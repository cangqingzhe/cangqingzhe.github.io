<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。  环境搭建​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境https:&#x2F;&#x2F;gi">
<meta property="og:type" content="article">
<meta property="og:title" content="shiro rce漏洞分析">
<meta property="og:url" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="1在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。  环境搭建​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境https:&#x2F;&#x2F;gi">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221552395.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221658967.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129131100239.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129132011123.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129122749329.png">
<meta property="og:image" content="https://wiki.jikexueyuan.com/project/shiro/images/14.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143520958.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143926553.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129144850395.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129134331085.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129153131427.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130114316497.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130155604254.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161156440.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161341690.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130162453138.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163400707.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163533846.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163606923.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165013406.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165132350.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170513136.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170719001.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171245277.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171552207.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171453470.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171804561.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171919629.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172056694.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172145175.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172223454.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130173904974.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174140275.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174259064.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174337766.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174508646.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180331183.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180538186.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180951079.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164200537.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164541425.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170537270.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170614952.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170630060.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170639745.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170725328.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170959832.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180626070.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180604356.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180705142.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094802148.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094838261.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202100922001.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104733807.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104854538.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105111202.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105408945.png">
<meta property="og:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105609290.png">
<meta property="article:published_time" content="2020-11-28T14:07:45.000Z">
<meta property="article:modified_time" content="2020-12-24T02:04:49.271Z">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="代码审计">
<meta property="article:tag" content="漏洞分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png">

<link rel="canonical" href="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>shiro rce漏洞分析 | 藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          shiro rce漏洞分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 22:07:45" itemprop="dateCreated datePublished" datetime="2020-11-28T22:07:45+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:04:49" itemprop="dateModified" datetime="2020-12-24T10:04:49+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境<code>https://github.com/potats0/ShiroDemo</code>，下载好项目以后使用IDEA导入pom.xml文件，由于我这里使用的MAVEN是阿里云镜像，我使用shiro-core为1.2.4时提示我找不到包，因此我这里使用的是1.2.2版本。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png" alt="image-20201128221450755"></p>
<p>​    需要的包导入后，找到App.java文件，通过调试来运行。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221552395.png" alt="image-20201128221552395"></p>
<p>​    运行成功后界面如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221658967.png" alt="image-20201128221658967"></p>
<h3 id="Shiro基本知识"><a href="#Shiro基本知识" class="headerlink" title="Shiro基本知识"></a>Shiro基本知识</h3><p>​    我们知道，shiro是一款用来进行权限认证和权限管理的框架，可以帮我们完成认证、授权、加密、会话管理、与Web集成、缓存等功能。</p>
<p>​    下面我结合着这个漏洞环境的代码带大家一起学习一下shiro的基本知识。</p>
<p>​    在这个项目的源码文件中，主要包含了4个文件，APP.java内容为启动springboot的内容，这里不做解释了，看下其他文件的内容，首先是MainRealm.java，在介绍这个文件的内容前，我们先了解几个基本的概念。</p>
<p>​    我们知道，shiro框架的一个主要的功能是用来做身份认证的，在shiro中，主要通过principals （身份）和 credentials（证明）一起来验证用户的身份。</p>
<h4 id="principals"><a href="#principals" class="headerlink" title="principals"></a><strong>principals</strong></h4><p>​    指用户身份的标识，可以是用户的用户名，手机号等等，但需要确保其唯一性。</p>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a><strong>credentials</strong></h4><p>​    凭证，一般来说就是密码。</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><strong>Realm</strong></h4><p>​    域，shiro会从Realm中获取安全数据（用户，角色，权限），当SecurityManager要身份认证，需要从Realm中来确定用户身份以及用户可以访问的权限。</p>
<p>​    在shiro中，SecurityManager负责身份认证的逻辑，它会委托给Authenticator进行身份认证，Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p>
<p><strong>AuthorizingRealm</strong></p>
<p>​    在shiro中，默认提供了一些Realm，他们的继承关系如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="img"> </p>
<p>​    CachingRealm是带缓存的Realm，里面包含了多个CacheManager属性，具体的缓存在其子类中进行实现。</p>
<p>​    AuthenticatingRealm是带认证的Realm,该类实现了认证的基本逻辑和缓存逻辑。</p>
<p>​    AuthorizingRealm主要用来鉴权和获取授权信息的Realm,该类实现了Authorizer，所以可以做鉴权。也实现了PermissionResolverAware，RolePermissionResolverAware因此可以对用户的访问权限做判断。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129131100239.png" alt="image-20201129131100239"></p>
<p>​    在shiro认证过程中，依赖AuthenticatingRealm的getAuthenticationInfo方法，getAuthenticationInfo会调用我们自定义的doGetAuthenticationInfo方法获取认证的结果。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129132011123.png" alt="image-20201129132011123"></p>
<p>​    在登录的时候需要将数据封装到<code>Shiro</code>的一个<code>token</code>中，执行shiro的<code>login()</code>方法，<code>Shiro</code>就会自动的调用<code>doGetAuthenticationInfo(AuthenticationToken token)</code>方法获取身份认证信息，在本次环境中，首先通过token.getPrincipal()方法获取username信息，通过authenticationToken.getCredentials()获取密码信息，对用户的用户名和密码进行判断，如果用户用户名为admin,密码为vulhub，认证成功则返回SimpleAuthenticationInfo对象,mainrealm.java的代码如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129122749329.png" alt="image-20201129122749329"></p>
<h4 id="shiro拦截器"><a href="#shiro拦截器" class="headerlink" title="shiro拦截器"></a><strong>shiro拦截器</strong></h4><p>​    在shiro中使用了与 Servlet 一样的 Filter 接口进行扩展，shiro拦截器的基础类及其继承关系如下：</p>
<p><img src="https://wiki.jikexueyuan.com/project/shiro/images/14.png" alt="img"></p>
<p>​    ShiroFilter是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，除了上面的基础拦截器类外，shiro还提供了一些比较常用的默认拦截器。</p>
<p>​    FormAuthenticationFilter登录拦截器，它主要有两个作用，一个是拦截登录表单提交的路径，创建登录认证所需要的Token令牌，并进入登录认证流程。另一个作用是拦截要求登录后才可以访问的路径，如果已经登录则直接进入到要访问路径，如果未登录则访问被拒绝并跳转到登录页。登录拦截器常用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createToken创建认证令牌，令牌内存储了登录认证时所需的数据。</span><br><span class="line">onLoginSuccess设置登录成功后的行为。</span><br><span class="line">onAccessDenied设置被拒绝后的行为</span><br><span class="line">setLoginUrl设置登录地址</span><br><span class="line">getUsername获取登录名，表单name值必须是username。</span><br><span class="line">getPassword获取密码，表单name值必须是password。</span><br></pre></td></tr></table></figure>

<p>​    UserFilter用户拦截器，用户已经登录认证 或 已经记住我 的都可以通过。</p>
<p>​    AnonymousFilter无需认证即可通过。</p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a><strong>拦截器链</strong></h4><p>​    Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理。当Filter执行的过程中，首先执行shiro的拦截器链，再经过Servlet容器的拦截器链。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143520958.png" alt="image-20201129143520958"></p>
<p>​    在shiro中提供了PathMatchingFilterChainResolver来判断请求的url和拦截器的规则是否匹配。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143926553.png" alt="image-20201129143926553"></p>
<p>​    DefaultFilterChainManager中维护者一个拦截器链，我们可以通过DefaultFilterChainManager中的方法添加拦截器。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129144850395.png" alt="image-20201129144850395"></p>
<h4 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a><strong>ShiroFilterFactoryBean</strong></h4><p>​    通过ShiroFilterFactoryBean类可以方便的配置拦截器的各种基本属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setSecurityManager:注入一个SecurityManager类，SecurityManager负责管理整个shiro核心验证功能。</span><br><span class="line">setLoginUrl：配置登录页路径。</span><br><span class="line">setSuccessUrl：配置登录成功页路径。</span><br><span class="line">setUnauthorizedUrl：配置没有权限跳转的页面。</span><br><span class="line">setFilterChainDefinitionMap：设置拦截规则。拦截规则是通过一个Map进行导入的。</span><br><span class="line">setFilters：用于注入自己实现的拦截器类。</span><br></pre></td></tr></table></figure>

<p>​    拦截规则是通过MAP来进行设置的，基本形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(&quot;&lt;拦截路径&gt;&quot;, &quot;&lt;拦截器名称&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>​    拦截器路径是一个从根路径开始的url，并支持通配符。拦截器名称既可以是shiro内置拦截器的名称比如anon(无需认证的拦截器)、authc（需要认证的拦截器）、user (已经登录成功或使用记住我的拦截器)，perms[role_name] - 需要权限验证的路径使用perms拦截器。中括号内为权限名称列表。</p>
<hr>
<p>​    接下来我们看一下shiroConfig.java，这个类是shiro的配置类，在这个类的shiroFilterFactoryBean中，通过setSecurityManager来设置securityManager，在securityManager中，设置了Realm为我们自己定义的mainRealm，RememberMeManager为cookieRememberMeManager，也就是cookie的”记住我”功能。通过setLoginUrl方法来设置未登录时需要认证的地址也就是登录地址。setUnauthorizedUrl方法来设置无权访问时跳转的地址。通过创建LinkedHashMap，设置map.put(“/doLogin”, “anon”)来设置不需要登录就能访问的地址。通过map.put(“/xxx/**”, “user”);来设置用户登录后才能访问的地址。最后通过setFilterChainDefinitionMap将这个map设置到FilterChain中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129134331085.png" alt="image-20201129134331085"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><strong>Subject</strong></h4><p>​    Shiro中认证授权组件Subject，为我们提供了当前用户、角色和授权的相关信息，可以进行登录，退出，权限验证，获取用户信息，session。</p>
<p>​    通过SecurityUtils.getSubject获取subject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject &#x3D; SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>​    subject包含如下主要接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;    &#x2F;&#x2F;登陆</span><br><span class="line">void logout(Subject subject);        &#x2F;&#x2F;退出登陆</span><br><span class="line">Subject createSubject(SubjectContext context);    &#x2F;&#x2F;获取subject</span><br><span class="line">Session session &#x3D; subject.getSession(); &#x2F;&#x2F;获取session对象</span><br><span class="line">String currentUser &#x3D; subject.getPrincipal().toString(); &#x2F;&#x2F;获取登录名</span><br></pre></td></tr></table></figure>

<p>​    了解了这些知识，我们看下UserController.java是如何实现的，通过SecurityUtils.getSubject方法获取subject对象，通过login来进行登录，传入的参数为UsernamePasswordToken对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129153131427.png" alt="image-20201129153131427"></p>
<p>​    这里，shiro的基础知识我们大概了解了一些了，下面我们再看一下漏洞。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    因为之前已经有人分析过shiro的反序列化漏洞了，并且在文章中给出了存在反序列化漏洞的方法，在DefaultSerializer类的deserialize方法中，因此我们可以直接找到这个方法并打上断点 。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130114316497.png" alt="image-20201130114316497"></p>
<p>​    在这个函数中调用了ObjectInputStream类的readObject方法来进行反序列化操作，下面是整个过程的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">deserialize:75, DefaultSerializer (org.apache.shiro.io)</span><br><span class="line">deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:846, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:93, FormContentFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:202, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:526, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:92, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:74, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:367, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:860, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1591, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>

<p>​    下面我们分析一下这个漏洞的调用过程，再调用的过程中，我们可以看到拦截器的调用链，已经将shiroFilter写入到tomcat拦截器之前。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130155604254.png" alt="image-20201130155604254"></p>
<p>​    下面依次调用对应的拦截器，OrderedCharacterEncodingFilter–&gt;OrderedFormContentFilter–&gt;OrderedRequestContextFilter–&gt;ShiroFilterFactoryBean–&gt;WsFilter。</p>
<p>​    首先调用OrderedCharacterEncodingFilter设置编码</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161156440.png" alt="image-20201130161156440"></p>
<p>​    调用OrderedFormContentFilter获取参数，这里参数为空，因此会调用else中的代码。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161341690.png" alt="image-20201130161341690"></p>
<p>​    调用OrderedRequestContextFilter完成requestContext的初始化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130162453138.png" alt="image-20201130162453138"></p>
<p>​    下来就是shiorFilter的调用链，再shior拦截器中调用了createSubject来创建subject对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163400707.png" alt="image-20201130163400707"></p>
<p>​    跟进createSubject方法，调用了buildWebSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163533846.png" alt="image-20201130163533846"></p>
<p>​    在 buildWebSubject中调用了其父类的buildSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163606923.png" alt="image-20201130163606923"></p>
<p>​    跟进父类的buildSubject方法，调用了DefaultSecurityManager的createSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165013406.png" alt="image-20201130165013406"></p>
<p>​    继续跟进，我们需要关注resolvePrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165132350.png" alt="image-20201130165132350"></p>
<p>​    跟进resolvePrincipals方法，判断RememberMeManager是否为空，不为空则调用getRememberedPrincipals。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170513136.png" alt="image-20201130170513136"></p>
<p>​    跟进getRememberedPrincipals方法，首先调用了getRememberedSerializedIdentity。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170719001.png" alt="image-20201130170719001"></p>
<p>​    跟进getRememberedSerializedIdentity方法，在该方法中，通过this.getCookie().readValue(request, response);获取了cookie的内容，并且判断是否为deleteMe，若为DeleteMe则返回null,否则将继续执行，对获取的cookie的内容进行base64解码并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171245277.png" alt="image-20201130171245277"></p>
<p>​        返回后会判断获取的cookie的内容是否为空，如果不为空，则调用convertBytesToPrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171552207.png" alt="image-20201130171552207"></p>
<p>​    在convertBytesToPrincipals调用了decrypt对cookie的内容进行解密。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171453470.png" alt="image-20201130171453470"></p>
<p>​    在decrypt中，调用cipherService.decrypt进行解密，同时传入了this.getDecryptionCipherKey()的内容。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171804561.png" alt="image-20201130171804561"></p>
<p>​    我们看一下getDecryptionCipherKey中的key是如何来的，返回了当前对象的decryptionCipherKey属性。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171919629.png" alt="image-20201130171919629"></p>
<p>​    decryptionCipherKey是在setDecryptionCipherKey中设置的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172056694.png" alt="image-20201130172056694"></p>
<p>​    在setCipherKey中调用了setDecryptionCipherKey进行设置、</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172145175.png" alt="image-20201130172145175"></p>
<p>​    setCipherKey中的参数来自于DEFAULT_CIPHER_KEY_BYTES，而这个值是kPH+bIxk5D2deZiIxcaaaA== base64解密后的内容，所以这个key的内容在我们当前的环境下是写死的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172223454.png" alt="image-20201130172223454"></p>
<p>​    继续跟进解密算法，可以看到使用的解密方式是AES方式。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130173904974.png" alt="image-20201130173904974"></p>
<p>​    将解密后的结果返回后，再转换为字节数组的形式并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174140275.png" alt="image-20201130174140275"></p>
<p>​    将返回的bytes作为参数传递到deserialize方法中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174259064.png" alt="image-20201130174259064"></p>
<p>​    继续跟踪下面的调用</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174337766.png" alt="image-20201130174337766"></p>
<p>​    最终我们可以看到，将我们通过cookie传入的内容转换为ObjectInputStream,并调用了readObject进行反序列化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174508646.png" alt="image-20201130174508646"></p>
<p>​    通过上面的分析，我相信我们已经对于shiro反序列化漏洞的基本原理有了大致的了解，这个漏洞要想正常的利用，至关重要的一点是找到解密cookie中传入payload的key，在这个环境中，key是写死的，实际上这个key也可以自己在shiorconfig类中配置加密的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180331183.png" alt="image-20201130180331183"></p>
<p>​    当我们更换key后，再去利用这个漏洞，由于key不正确无法解密导致无法继续利用。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180538186.png" alt="image-20201130180538186"></p>
<p>​    既然重新生成key这么简单，为什么还是有人使用默认的key或者网上公布的其他key？我们看一下这个key解密后的结果就知道了，由于这些key解密后都是一些乱码，不太容易编辑，所以可能很多人会去使用网上别人生成好的key，所以在漏洞利用的过程中有人想到了爆破key的方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180951079.png" alt="image-20201130180951079"></p>
<p>​    那如果想自己生成key,怎样生成才能满足要求呢,只要使用任意一个16位，24位，32位的字符串base64编码后都是可以作为key的。</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>​        我们尝试切换shiro为高版本，看一下shiro是如何修复反序列化漏洞的，我切换到1.2.7版本的shiro，我们可以看到在该版本中，key默认并不是写死的，而是由cipherService.generateNewKey().getEncoded()来生成的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164200537.png" alt="image-20201201164200537"></p>
<p>​    生成key的代码如下</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164541425.png" alt="image-20201201164541425"></p>
<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><h4 id="如何识别shiro"><a href="#如何识别shiro" class="headerlink" title="如何识别shiro?"></a><strong>如何识别shiro?</strong></h4><p>​        要检测一个shiro是否存在反序列化漏洞，首先需要对shiro这个框架做一个识别，目前大部分的方法都是通过rememberMe=deleteMe;来识别的，但是并不是我们请求的所有地址都会返回rememberMe=deleteMe,但是在实战中我们可能需要批量去检测shiro框架，我们该如何识别？</p>
<p>​        通过之前的分析我们知道，无论我们访问哪个url，都会经过shiro的拦截器，而在shiro的拦截器中会获取cookie中rememberMe的内容并进行解密，并且通过之前的分析，我们知道解密是由convertBytesToPrincipals（）完成的，如果我们传入的rememberMe不能正常的反序列化，就会抛出异常，调用onRememberedPrincipalFailure方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170537270.png" alt="image-20201201170537270"></p>
<p>​    该方法经过几层调用最终调用了this.getCookie().removeFrom(request, response);方法</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170614952.png" alt="image-20201201170614952"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170630060.png" alt="image-20201201170630060"></p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170639745.png" alt="image-20201201170639745"></strong></p>
<p>​    在removeFrom中，会在返回包header加上rememberMe=deleteMe，因此无论我们访问任何使用了shiro框架的路由，只需要在请求头中的cookie中加入rememberMe=xxx，如果目标使用了shiro，则会返回rememberMe=deleteMe，也就是说我们可以通过一个包来识别是否使用了shiro框架。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170725328.png" alt="image-20201201170725328"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170959832.png" alt="image-20201201170959832"></p>
<p>​    了解了这些，我们可以写一个简单的python脚本来批量识别shiro，这里注意我将重定向设置为false，否则我们在请求时会跟进302跳转，但跳转后的结果里可能没有rememberMe=deleteMe。<br><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180626070.png" alt="image-20201201180626070"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180604356.png" alt="image-20201201180604356"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def shiroScan(url):</span><br><span class="line"></span><br><span class="line">    header&#x3D;&#123;</span><br><span class="line">        &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.66 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#39;Accept&#39;:&#39;image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;*,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">        &#39;Accept-Encoding&#39;:&#39;gzip, deflate&#39;,</span><br><span class="line">        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q&#x3D;0.9&#39;,</span><br><span class="line">        &#39;Cookie&#39;:&#39;rememberMe&#x3D;1&#39;,</span><br><span class="line">        &#39;Connection&#39;:&#39;close&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    proxies &#x3D; &#123; &quot;http&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8088&quot;, &quot;https&quot;: &quot;https:&#x2F;&#x2F;127.0.0.1:8088&quot;&#125;</span><br><span class="line">    resp&#x3D;requests.get(url&#x3D;url,headers&#x3D;header,proxies&#x3D;proxies,verify&#x3D;False,allow_redirects&#x3D;False)</span><br><span class="line">    for name, regex in resp.headers.items():</span><br><span class="line">        if &quot;rememberMe&#x3D;deleteMe&quot; in regex:</span><br><span class="line">            print(url+ &quot; is Shiro!!!&quot;)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    with open(&#39;domain.txt&#39;,&#39;r&#39;) as f:</span><br><span class="line">        lines&#x3D;f.readlines()</span><br><span class="line">        for i in lines:</span><br><span class="line">            domain&#x3D;i.strip(&#39;\n&#39;)</span><br><span class="line">            shiroScan(domain)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180705142.png" alt="image-20201201180705142"></p>
<h4 id="如何判断key是否正确？"><a href="#如何判断key是否正确？" class="headerlink" title="如何判断key是否正确？"></a><strong>如何判断key是否正确？</strong></h4><p>​    通过上面的测试我们知道当我们使用的加密key正确可以正常进行反序列化操作，即使key正确，但生成的内容无法正常反序列化，则还是会返回rememberMe=deleteMe，因为反序列化的操作是在convertBytesToPrincipals方法完成的，如果反序列化的过程中出现异常，还是会设置rememberMe=deleteMe这个请求头，因此我们测试key是否正确，需要找到一个可以不依赖第三方组件的java中默认存在且和jdk版本无关的类来进行反序列化。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094802148.png" alt="image-20201202094802148"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094838261.png" alt="image-20201202094838261"></p>
<p>​        我尝试使用URLDNS来进行判断，虽然可以正常发起DNS请求，但 由于执行过程中的类型转换错误，因此还是会返回rememberMe=deleteMe。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202100922001.png" alt="image-20201202100922001"></p>
<p>​        我们正常的登录，看看正常登录过程中的反序列化的类是什么类型</p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104733807.png" alt="image-20201202104733807"></strong></p>
<p>​        使用这个rememberMe的内容利用，看shiro再进行反序列化的过程中反序列化的是哪个类？</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104854538.png" alt="image-20201202104854538"></p>
<p>​        跟进后发现是反序列化了SimplePrincipalCollection类，所以我们只要创建一个SimplePrincipalCollection对应的对象进行序列化就可以了，当传入的序列化内容可以正常被解析，就不会出现rememberMe=deleteMe，因此可以通过这个特性来判断我们的key是否正确。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105111202.png" alt="image-20201202105111202"></p>
<p>​        我们查看一下ShiroExploit这个工具，看看他是怎么实现的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105408945.png" alt="image-20201202105408945"></p>
<p>​    这个工具在检测key是否正确的过程中调用了ysoserial的ShiroCheck，可我去查看ysoserial的github项目，发现并没有这个选项，也就是这个是作者自己扩展编写的。我们反编译ShiroExploit自带的ysoserial，他的实现也非常简单，就是创建一个SimplePrincipalCollection对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105609290.png" alt="image-20201202105609290"></p>
<h4 id="如何检测利用链？"><a href="#如何检测利用链？" class="headerlink" title="如何检测利用链？"></a>如何检测利用链？</h4><p>​        在JAVA的反序列化漏洞中，仅仅找到readObject反序列化并不一定能造成RCE，还有一点比较重要的是需要找到利用链，这个要具体展开讲需要依赖的知识点有点多，我之后会单独写一篇文章来讲解。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag"># 代码审计</a>
              <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag"># 漏洞分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/" rel="prev" title="关于sqlserver注入另类技巧的学习">
      <i class="fa fa-chevron-left"></i> 关于sqlserver注入另类技巧的学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/" rel="next" title="JAVA反射机制学习">
      JAVA反射机制学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shiro基本知识"><span class="nav-number">2.</span> <span class="nav-text">Shiro基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#principals"><span class="nav-number">2.1.</span> <span class="nav-text">principals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#credentials"><span class="nav-number">2.2.</span> <span class="nav-text">credentials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Realm"><span class="nav-number">2.3.</span> <span class="nav-text">Realm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shiro拦截器"><span class="nav-number">2.4.</span> <span class="nav-text">shiro拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拦截器链"><span class="nav-number">2.5.</span> <span class="nav-text">拦截器链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ShiroFilterFactoryBean"><span class="nav-number">2.6.</span> <span class="nav-text">ShiroFilterFactoryBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subject"><span class="nav-number">2.7.</span> <span class="nav-text">Subject</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#漏洞分析"><span class="nav-number">3.</span> <span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#漏洞修复"><span class="nav-number">4.</span> <span class="nav-text">漏洞修复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#漏洞检测"><span class="nav-number">5.</span> <span class="nav-text">漏洞检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何识别shiro"><span class="nav-number">5.1.</span> <span class="nav-text">如何识别shiro?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何判断key是否正确？"><span class="nav-number">5.2.</span> <span class="nav-text">如何判断key是否正确？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何检测利用链？"><span class="nav-number">5.3.</span> <span class="nav-text">如何检测利用链？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
