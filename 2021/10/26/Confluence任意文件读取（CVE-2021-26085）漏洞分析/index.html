<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Confluence文件读取漏洞分析 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Confluence文件读取漏洞分析"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Confluence文件读取漏洞分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/10/26/Confluence任意文件读取（CVE-2021-26085）漏洞分析/" rel="bookmark">
        <time class="entry-date published" datetime="2021-10-26T03:44:50.000Z">
          2021-10-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前段时间<code>Confluence</code>发布了<code>CVE-2021-26085</code>补丁，刚好之前分析过<code>Confluence</code>的漏洞，免去了搭建漏洞分析环境的麻烦，因此分析下这个漏洞。</p>
<span id="more"></span> 

<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="漏洞点定位"><a href="#漏洞点定位" class="headerlink" title="漏洞点定位"></a>漏洞点定位</h3><p>​    这个漏洞爆出来已经有一段时间了，所以已经有公开的POC了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/s/123cfx/_/;/WEB-INF/web.xml</span><br></pre></td></tr></table></figure>

<p>​    首先大致测了一下，除了<code>123cfx</code>部分可以修改为其他内容，其他的部分修改或者删除后都会导致无法读取,<code>/s/</code>这部分比较特殊，所以猜测可能是由于以<code>/s/</code>开始会被当作静态文件处理。在<code>web.xml</code>中找<code>/s/</code>部分的<code>Filter</code>或者<code>Servlet</code>。</p>
<p>​    在<code>/WEB-INF/web.xml</code>中对<code>/s/</code>对应的<code>servlet</code>做了配置,所以理论上来讲可以在<code>ConfluenceNoOpServlet#service</code>方法打断点查看执行流程。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>noop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atlassian.confluence.servlet.ConfluenceNoOpServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>noop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    但是当执行<code>payload</code>后并没断下来，将url改为<code>/s/12xxxx</code>则执行到了<code>ConfluenceNoOpServlet</code>,所以在Tomcat程序<code>Filter</code>到<code>Servlet</code>的必经之路<code>ApplicationFilterChain#internalDoFilter</code>方法<code>this.servlet.service(request, response);</code>打断点，发现当我们执行<code>payload</code>时最后是由<code>DefaultServlet</code>来处理的，而<code>DefaultServlet</code>按理说是只处理根目录的请求，为什么我们的<code>payload</code>会被<code>DefaultServlet</code>处理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    设置<code>servlet</code>的代码在<code>ApplicationFilterChain#setServlet</code>中，再次运行测试，发现程序会两次进入<code>setServlet</code>方法，第一次是<code>ConfluenceNoOpServlet</code>，第二次是<code>DefaultServlet</code>。所以猜测是当程序在<code>Filter</code>中对请求做了转发，查看调用链，果然在<code>UrlRewriteFilter</code>中做了处理。</p>
<p><img src="/2021/10/26/Confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88CVE-2021-26085%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211026154941243.png" alt="image-20211026154941243"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.tuckey.web.filters.urlrewrite.UrlRewriteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="UrlRewriteFilter入门"><a href="#UrlRewriteFilter入门" class="headerlink" title="UrlRewriteFilter入门"></a>UrlRewriteFilter入门</h3><p>​    这里使用了<code>UrlRewriteFilter</code>组件，所以我们有必要先对这个组件简单了解。</p>
<blockquote>
<p>UrlRewriteFilter是一个改写URL的Java Web过滤器，可见将动态URL静态化。适用于任何Java Web服务器（Resin，Jetty，JBoss,Tomcat，Orion等）。与其功能类似的还有Apache的mod_rewrite。</p>
<p>将动态URL转化为伪静态URL的好处主要有三个：</p>
<ul>
<li>便于搜索引擎收录。</li>
<li>屏蔽url结构和参数信息，更安全。</li>
<li>可以将冗杂的URL改写得简而美。</li>
</ul>
</blockquote>
<p>​    一般在<code>web.xml</code>中配置后还需要配置一个<code>urlrewriter.xml</code>,在<code>Confluence</code>中，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">urlrewrite</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//tuckey.org//DTD UrlRewrite 4.0//EN&quot;</span> <span class="meta-string">&quot;http://tuckey.org/res/dtds/urlrewrite4.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlrewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class-rule</span> <span class="attr">class</span>=<span class="string">&#x27;com.atlassian.confluence.servlet.rewrite.ConfluenceResourceDownloadRewriteRule&#x27;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">from</span>&gt;</span>/images/icons/attachments/file.gif<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">to</span> <span class="attr">type</span>=<span class="string">&quot;permanent-redirect&quot;</span>&gt;</span>%&#123;context-path&#125;/images/icons/contenttypes/attachment_16.png<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">urlrewrite</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    这个<rule>标签中的内容比较好理解，大概是当访问呢<code>images/icons/attachments/file.gif</code>会被重定向到<code>%&#123;context-path&#125;/images/icons/contenttypes/attachment_16.png</code>中，但<code>&lt;class-rule &gt;</code>中配置的类是如何工作的？</rule></p>
<p>​    查了官网的文档，当我们要扩展基本规则时，可以继承<code>RewriteRule</code>类并实现<code>matches</code>方法。</p>
<p><img src="/2021/10/26/Confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88CVE-2021-26085%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211026163332297.png" alt="image-20211026163332297"></p>
<h3 id="UrlRewriteFilter解析流程分析"><a href="#UrlRewriteFilter解析流程分析" class="headerlink" title="UrlRewriteFilter解析流程分析"></a>UrlRewriteFilter解析流程分析</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    初始化<code>init</code>主要完成<code>urlrewriter.xml</code>的解析，这里会从<code>FilterConfig</code>中保存的配置中首先解析一些属性，这里需要注意，当没有配置<code>modRewriteConf</code>属性时，则会判断<code>modRewriteStyleConf</code>的值，这个值默认为False，所以会将<code>confPath</code>属性设置为<code>/WEB-INF/urlrewrite.xml</code>，再往下会判断<code>modRewriteConfText</code>属性是否在<code>FilterConfig</code>中配置，如果没有则通过<code>loadUrlRewriter</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> modRewriteStyleConf = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">		String confPathStr = filterConfig.getInitParameter(<span class="string">&quot;confPath&quot;</span>);</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">//判断是否在Filter中配置了modRewriteConf,如果没有则modRewriteStyleConf的值为默认值false。</span></span><br><span class="line">                String modRewriteConf = filterConfig.getInitParameter(<span class="string">&quot;modRewriteConf&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isBlank(modRewriteConf)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.modRewriteStyleConf = <span class="string">&quot;true&quot;</span>.equals(StringUtils.trim(modRewriteConf).toLowerCase());</span><br><span class="line">                &#125;</span><br><span class="line">    	<span class="comment">//由于modRewriteStyleConf为False，默认加载/WEB-INF/urlrewrite.xml</span></span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isBlank(confPathStr)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.confPath = StringUtils.trim(confPathStr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.confPath = <span class="keyword">this</span>.modRewriteStyleConf ? <span class="string">&quot;/WEB-INF/.htaccess&quot;</span> : <span class="string">&quot;/WEB-INF/urlrewrite.xml&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//没有在Filter中配置modRewriteConfText，则通过loadUrlRewriter加载配置。</span></span><br><span class="line">                String modRewriteConfText = filterConfig.getInitParameter(<span class="string">&quot;modRewriteConfText&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isBlank(modRewriteConfText)) &#123;</span><br><span class="line">                    ModRewriteConfLoader loader = <span class="keyword">new</span> ModRewriteConfLoader();</span><br><span class="line">                    Conf conf = <span class="keyword">new</span> Conf();</span><br><span class="line">                    loader.process(modRewriteConfText, conf);</span><br><span class="line">                    conf.initialise();</span><br><span class="line">                    <span class="keyword">this</span>.checkConf(conf);</span><br><span class="line">                    <span class="keyword">this</span>.confLoadedFromFile = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.loadUrlRewriter(filterConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>loadUrlRewriter</code>中主要通过调用<code>loadUrlRewriterLocal</code>完成实际的加载逻辑。</p>
<ul>
<li>通过<code>confPath</code>作为路径加载内容到<code>inputStream</code></li>
<li>将资源路径转换为<code>URL</code>并保存到<code>confUrlStr</code>中</li>
<li>通过文件内容，URL,<code>modRewriteStyleConf</code>等属性构建Conf对象</li>
<li><code>checkConf</code>检查<code>Conf</code>对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUrlRewriterLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       InputStream inputStream = <span class="keyword">this</span>.context.getResourceAsStream(<span class="keyword">this</span>.confPath);</span><br><span class="line">       <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">           inputStream = ClassLoader.getSystemResourceAsStream(<span class="keyword">this</span>.confPath);</span><br><span class="line">       &#125;</span><br><span class="line">       URL confUrl = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           confUrl = <span class="keyword">this</span>.context.getResource(<span class="keyword">this</span>.confPath);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MalformedURLException var5) &#123;</span><br><span class="line">           log.debug(var5);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String confUrlStr = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (confUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           confUrlStr = confUrl.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;unable to find urlrewrite conf file at &quot;</span> + <span class="keyword">this</span>.confPath);</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.urlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;unloading existing conf&quot;</span>);</span><br><span class="line">               <span class="keyword">this</span>.urlRewriter = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Conf conf = <span class="keyword">new</span> Conf(<span class="keyword">this</span>.context, inputStream, <span class="keyword">this</span>.confPath, confUrlStr, <span class="keyword">this</span>.modRewriteStyleConf);</span><br><span class="line">           <span class="keyword">this</span>.checkConf(conf);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    首先看下<code>Conf</code>对象创建的过程，前面的是一些属性赋值的操作，在下面的<code>If</code>语句中判断<code>modRewriteStyleConf</code>的值用不同的解析方式，这个也可以理解<code>.htaccess</code>和<code>urlrewrite.xml</code>本来就应该用不同的方式解析，由于我们这里是使用<code>urlrewrite.xml</code>配置，因此会通过<code>loadDom</code>加载XML内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Conf</span><span class="params">(ServletContext context, InputStream inputStream, String fileName, String systemId, <span class="keyword">boolean</span> modRewriteStyleConf)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">if</span> (modRewriteStyleConf) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadModRewriteStyle(inputStream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadDom(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.docProcessed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.initialise();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadedDate = <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>loadDom</code>主要通过<code>Dom</code>方式解析XML内容，解析完成后通过<code>processConfDoc</code>处理解析后的内容,这里会根据标签的不同做不同的处理，由于我们这里只用了<code>rule</code>和<code>rule-class</code>标签，所以其他部分的代码先忽略。</p>
<ul>
<li>标签为<code>rule</code>时则创建<code>NormalRule</code>对象 ，并将属性封装到这个对象中。</li>
<li>标签为<code>class-rule</code>创建<code>ClassRule</code>对象，并将<code>class</code>和<code>method</code>属性设置到这个对象中。</li>
<li>通过标签构造完对象后都会通过<code>addRule</code>将创建好的对象放到<code>Conf.rules</code>属性中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfDoc</span><span class="params">(Document doc)</span> </span>&#123;</span><br><span class="line">        Element rootElement = doc.getDocumentElement();</span><br><span class="line">...</span><br><span class="line">        NodeList rootElementList = rootElement.getChildNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootElementList.getLength(); ++i) &#123;</span><br><span class="line">            Node node = rootElementList.item(i);</span><br><span class="line">            Element ruleElement;</span><br><span class="line">            Node toNode;</span><br><span class="line">            <span class="keyword">if</span> (node.getNodeType() == <span class="number">1</span> &amp;&amp; ((Element)node).getTagName().equals(<span class="string">&quot;rule&quot;</span>)) &#123;</span><br><span class="line">                ruleElement = (Element)node;</span><br><span class="line">                NormalRule rule = <span class="keyword">new</span> NormalRule();</span><br><span class="line">                <span class="keyword">this</span>.processRuleBasics(ruleElement, rule);</span><br><span class="line">                procesConditions(ruleElement, rule);</span><br><span class="line">                processRuns(ruleElement, rule);</span><br><span class="line">                toNode = ruleElement.getElementsByTagName(<span class="string">&quot;to&quot;</span>).item(<span class="number">0</span>);</span><br><span class="line">                rule.setTo(getNodeValue(toNode));</span><br><span class="line">                rule.setToType(getAttrValue(toNode, <span class="string">&quot;type&quot;</span>));</span><br><span class="line">                rule.setToContextStr(getAttrValue(toNode, <span class="string">&quot;context&quot;</span>));</span><br><span class="line">                rule.setToLast(getAttrValue(toNode, <span class="string">&quot;last&quot;</span>));</span><br><span class="line">                rule.setQueryStringAppend(getAttrValue(toNode, <span class="string">&quot;qsappend&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equalsIgnoreCase(getAttrValue(toNode, <span class="string">&quot;encode&quot;</span>))) &#123;</span><br><span class="line">                    rule.setEncodeToUrl(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                processSetAttributes(ruleElement, rule);</span><br><span class="line">                <span class="keyword">this</span>.addRule(rule);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getNodeType() == <span class="number">1</span> &amp;&amp; ((Element)node).getTagName().equals(<span class="string">&quot;class-rule&quot;</span>)) &#123;</span><br><span class="line">                ruleElement = (Element)node;</span><br><span class="line">                ClassRule classRule = <span class="keyword">new</span> ClassRule();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equalsIgnoreCase(getAttrValue(ruleElement, <span class="string">&quot;enabled&quot;</span>))) &#123;</span><br><span class="line">                    classRule.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equalsIgnoreCase(getAttrValue(ruleElement, <span class="string">&quot;last&quot;</span>))) &#123;</span><br><span class="line">                    classRule.setLast(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                classRule.setClassStr(getAttrValue(ruleElement, <span class="string">&quot;class&quot;</span>));</span><br><span class="line">                classRule.setMethodStr(getAttrValue(ruleElement, <span class="string">&quot;method&quot;</span>));</span><br><span class="line">                <span class="keyword">this</span>.addRule(classRule);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.docProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    最后我们再看下<code>checkConf</code>方法，这个方法通过<code>checkConfLocal</code>完成具体的检测,主要是通过<code>Conf</code>对象的一些属性检测是否加载成功，如果加载成功则通过Conf构建<code>UrlRewriter</code>对象并赋值给<code>this.urlRewriter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConfLocal</span><span class="params">(Conf conf)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">this</span>.confLastLoaded = conf;</span><br><span class="line">    <span class="keyword">if</span> (conf.isOk() &amp;&amp; conf.isEngineEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.urlRewriter = <span class="keyword">new</span> UrlRewriter(conf);</span><br><span class="line">        log.info(<span class="string">&quot;loaded (conf ok)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!conf.isOk()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Conf failed to load&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conf.isEngineEnabled()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Engine explicitly disabled in conf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.urlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;unloading existing conf&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.urlRewriter = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拦截器处理过程"><a href="#拦截器处理过程" class="headerlink" title="拦截器处理过程"></a>拦截器处理过程</h4><p>​    拦截器的处理主要在<code>UrlRewriteFilter#doFilter</code>中，具体操作如下：</p>
<ul>
<li>获取<code>urlRewriter</code>对象并封装到<code>urlRewriteWrappedResponse</code>中</li>
<li>判断<code>servername</code>是否为<code>localhost</code>，一般都不是所以先不看这里的处理逻辑</li>
<li><code>urlRewriter</code>不为Null,执行<code>processRequest</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       UrlRewriter urlRewriter = <span class="keyword">this</span>.getUrlRewriter(request, response, chain);</span><br><span class="line">       HttpServletRequest hsRequest = (HttpServletRequest)request;</span><br><span class="line">       HttpServletResponse hsResponse = (HttpServletResponse)response;</span><br><span class="line">       UrlRewriteWrappedResponse urlRewriteWrappedResponse = <span class="keyword">new</span> UrlRewriteWrappedResponse(hsResponse, hsRequest, urlRewriter);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.statusEnabled &amp;&amp; <span class="keyword">this</span>.statusServerNameMatcher.isMatch(request.getServerName())) &#123;</span><br><span class="line">           String uri = hsRequest.getRequestURI();</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;checking for status path on &quot;</span> + uri);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String contextPath = hsRequest.getContextPath();</span><br><span class="line">           <span class="keyword">if</span> (uri != <span class="keyword">null</span> &amp;&amp; uri.startsWith(contextPath + <span class="keyword">this</span>.statusPath)) &#123;</span><br><span class="line">               <span class="keyword">this</span>.showStatus(hsRequest, urlRewriteWrappedResponse);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> requestRewritten = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (urlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">           requestRewritten = urlRewriter.processRequest(hsRequest, urlRewriteWrappedResponse, chain);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;urlRewriter engine not loaded ignoring request (could be a conf file problem)&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!requestRewritten) &#123;</span><br><span class="line">           chain.doFilter(hsRequest, urlRewriteWrappedResponse);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>processRequest</code>首先获取<code>RuleChain</code>,并执行<code>doRules</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest hsRequest, HttpServletResponse hsResponse, FilterChain parentChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RuleChain chain = <span class="keyword">this</span>.getNewChain(hsRequest, parentChain);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chain.doRules(hsRequest, hsResponse);</span><br><span class="line">        <span class="keyword">return</span> chain.isResponseHandled();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>getNewChain</code>主要是从<code>conf</code>中获取<code>rules</code>，如果不为空，则将<code>rules</code>封装到<code>RuleChain</code>对象中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> RuleChain <span class="title">getNewChain</span><span class="params">(HttpServletRequest hsRequest, FilterChain parentChain)</span> </span>&#123;</span><br><span class="line">      String originalUrl = <span class="keyword">this</span>.getPathWithinApplication(hsRequest);</span><br><span class="line">...</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.isOk()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;configuration is not ok.  not rewriting request.&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              List rules = <span class="keyword">this</span>.conf.getRules();</span><br><span class="line">              <span class="keyword">if</span> (rules.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                  log.debug(<span class="string">&quot;there are no rules setup.  not rewriting request.&quot;</span>);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> RuleChain(<span class="keyword">this</span>, originalUrl, parentChain);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RuleChain</span><span class="params">(UrlRewriter urlRewriter, String originalUrl, FilterChain parentChain)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.finalToUrl = originalUrl;</span><br><span class="line">      <span class="keyword">this</span>.urlRewriter = urlRewriter;</span><br><span class="line">      <span class="keyword">this</span>.rules = urlRewriter.getConf().getRules();</span><br><span class="line">      <span class="keyword">this</span>.parentChain = parentChain;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面分析比较重要的<code>doRules</code>方法，<code>process</code>主要是完成根据规则匹配URL，并重写<code>URL</code>。<code>handleRewrite</code>根据重写的URL发起请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRules</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.process(request, response);</span><br><span class="line">        <span class="keyword">this</span>.handleRewrite(request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleExcep(request, response, var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException var5) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(var5.getCause() <span class="keyword">instanceof</span> InvocationTargetException)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.handleExcep(request, response, (InvocationTargetException)var5.getCause());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面分析这两个方法的操作过程</p>
<h5 id="process"><a href="#process" class="headerlink" title="process"></a>process</h5><ul>
<li>循环调用<code>ruleChains</code>中的<code>matches</code>方法，匹配成功则将结果赋值给<code>RewrittenUrl</code>对象，并将<code>rewrittenUrl</code>对象赋值给<code>finalRewrittenRequest</code>。将<code>rewrittenUrl</code>的URL保存到<code>finalToUrl</code>中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.ruleIdxToRun &lt; <span class="keyword">this</span>.rules.size()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doRuleProcessing((HttpServletRequest)request, (HttpServletResponse)response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRuleProcessing</span><span class="params">(HttpServletRequest hsRequest, HttpServletResponse hsResponse)</span> <span class="keyword">throws</span> IOException, ServletException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentIdx = <span class="keyword">this</span>.ruleIdxToRun++;</span><br><span class="line">    Rule rule = (Rule)<span class="keyword">this</span>.rules.get(currentIdx);</span><br><span class="line">    RewrittenUrl rewrittenUrl = rule.matches(<span class="keyword">this</span>.finalToUrl, hsRequest, hsResponse, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rule.isFilter()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dontProcessAnyMoreRules();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rewrittenUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;got a rewritten url&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.finalRewrittenRequest = rewrittenUrl;</span><br><span class="line">        <span class="keyword">this</span>.finalToUrl = rewrittenUrl.getTarget();</span><br><span class="line">        <span class="keyword">if</span> (rule.isLast()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;rule is last&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.dontProcessAnyMoreRules();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面到了我们分析这次漏洞的重点<code>ClassRule</code>的<code>matches</code>方法，主要是通过反射调用<code>ConfluenceResourceDownloadRewriteRule#matches</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public RewrittenUrl matches(String url, HttpServletRequest hsRequest, HttpServletResponse hsResponse) throws ServletException, IOException &#123;</span><br><span class="line">        if (!this.initialised) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object[] args = new Object[]&#123;hsRequest, hsResponse&#125;;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(&quot;running &quot; + this.classStr + &quot;.&quot; + this.methodStr + &quot;(HttpServletRequest, HttpServletResponse)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.matchesMethod == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object returnedObj;</span><br><span class="line">                try &#123;</span><br><span class="line">                    returnedObj = this.matchesMethod.invoke(this.localRule, (Object[])args);</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    这里我解释下<code>matchesMethod</code>为什么是<code>ConfluenceResourceDownloadRewriteRule#matches</code>，在初始化方法中，会通过反射获取<code>method</code>对象并赋值给<code>matchesMethod</code>，<code>methodStr</code>默认为<code>matches</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> String methodStr = <span class="string">&quot;matches&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialise</span><span class="params">(ServletContext context)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ruleClass = Class.forName(<span class="keyword">this</span>.classStr);</span><br><span class="line">        ...</span><br><span class="line">               <span class="keyword">this</span>.matchesMethod = ruleClass.getMethod(<span class="keyword">this</span>.methodStr, methodParameterTypes);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ConfluenceResourceDownloadRewriteRule#matches</code>设置两个正则匹配,也就是说满足这两个任意一个正则，URL才会被重写并转发。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NO_CACHE_PATTERN = Pattern.compile(<span class="string">&quot;^/s/(.*)/NOCACHE(.*)/_/((?i)(?!WEB-INF)(?!META-INF).*)&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern CACHE_PATTERN = Pattern.compile(<span class="string">&quot;^/s/(.*)/_/((?i)(?!WEB-INF)(?!META-INF).*)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RewriteMatch <span class="title">matches</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    String url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//路径规范化，将../和./规范化</span></span><br><span class="line">        url = <span class="keyword">this</span>.getNormalisedPathFrom(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException var8) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matcher noCacheMatcher = NO_CACHE_PATTERN.matcher(url);</span><br><span class="line">    Matcher cacheMatcher = CACHE_PATTERN.matcher(url);</span><br><span class="line">    String rewrittenContextUrl;</span><br><span class="line">    String rewrittenUrl;</span><br><span class="line">    <span class="comment">//首先匹配noCacheMatcher正则，匹配成功则改写URL并设置到DisableCacheRewriteMatch</span></span><br><span class="line">    <span class="keyword">if</span> (noCacheMatcher.matches()) &#123;</span><br><span class="line">        rewrittenContextUrl = <span class="string">&quot;/&quot;</span> + <span class="keyword">this</span>.rewritePathMappings(noCacheMatcher.group(<span class="number">3</span>));</span><br><span class="line">        rewrittenUrl = request.getContextPath() + rewrittenContextUrl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DisableCacheRewriteMatch(rewrittenUrl, rewrittenContextUrl);</span><br><span class="line">    <span class="comment">//匹配cacheMatcher正则匹配成功改写URL并设置到CachedRewriteMatch中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cacheMatcher.matches()) &#123;</span><br><span class="line">        rewrittenContextUrl = <span class="string">&quot;/&quot;</span> + <span class="keyword">this</span>.rewritePathMappings(cacheMatcher.group(<span class="number">2</span>));</span><br><span class="line">        rewrittenUrl = request.getContextPath() + rewrittenContextUrl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CachedRewriteMatch(rewrittenUrl, rewrittenContextUrl, cacheMatcher.group(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     执行我们的<code>payload</code>后当然会进入<code>cacheMatcher</code>的匹配，会获取<code>/;/WEB-INF/web.xml</code>设置给<code>rewrittenContextUrl</code>，将<code>rewrittenContextUrl</code>和<code>request.getContextPath() </code>拼接得到<code>rewrittenUrl</code>,在<code>Confluence</code>中<code>request.getContextPath()</code>为空，所以<code>rewrittenContextUrl</code>=<code>rewrittenUrl</code>，下面将这些属性赋值到<code>CachedRewriteMatch</code>属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CachedRewriteMatch</span><span class="params">(String rewrittenUrl, String rewrittenContextUrl, String staticHash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rewrittenUrl = rewrittenUrl;</span><br><span class="line">    <span class="keyword">this</span>.rewrittenContextUrl = rewrittenContextUrl;</span><br><span class="line">    <span class="keyword">this</span>.staticHash = staticHash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="handleRewrite"><a href="#handleRewrite" class="headerlink" title="handleRewrite"></a>handleRewrite</h5><p>​    下面我们分析<code>handleRewrite</code>方法</p>
<ul>
<li>判断<code>overiddenRequestParameters</code>和<code>overiddenMethod</code>是否为空，为空则对<code>request</code>包装</li>
<li><code>finalRewrittenRequest</code>中保存了<code>rewrittenUrl</code>，所以这里会进入IF语句，执行<code>doRewrite</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRewrite</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.rewriteHandled) &#123;</span><br><span class="line">           <span class="keyword">this</span>.rewriteHandled = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (response <span class="keyword">instanceof</span> UrlRewriteWrappedResponse &amp;&amp; request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">               HashMap overiddenRequestParameters = ((UrlRewriteWrappedResponse)response).getOverridenRequestParameters();</span><br><span class="line">               String overiddenMethod = ((UrlRewriteWrappedResponse)response).getOverridenMethod();</span><br><span class="line">               <span class="keyword">if</span> (overiddenRequestParameters != <span class="keyword">null</span> || overiddenMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   request = <span class="keyword">new</span> UrlRewriteWrappedRequest((HttpServletRequest)request, overiddenRequestParameters, overiddenMethod);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.finalRewrittenRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.responseHandled = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">this</span>.requestRewritten = <span class="keyword">this</span>.finalRewrittenRequest.doRewrite((HttpServletRequest)request, (HttpServletResponse)response, <span class="keyword">this</span>.parentChain);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.requestRewritten) &#123;</span><br><span class="line">               <span class="keyword">this</span>.responseHandled = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">this</span>.parentChain.doFilter((ServletRequest)request, response);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面分析<code>doRewrite</code>方法， 执行<code>CachedRewriteMatch.execute</code>方法，这里可以看到将请求转发到<code>/;/WEB-INF/web.xml</code>中处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doRewrite</span><span class="params">(HttpServletRequest hsRequest, HttpServletResponse hsResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.rewriteMatch.execute(hsRequest, hsResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      ResourceDownloadUtils.addPublicCachingHeaders(request, response);</span><br><span class="line">      request.setAttribute(<span class="string">&quot;_statichash&quot;</span>, <span class="keyword">this</span>.staticHash);</span><br><span class="line">      request.getRequestDispatcher(<span class="keyword">this</span>.rewrittenContextUrl).forward(request, response);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​    上面我们已经分析了我们的请求如何被<code>UrlRewriteFilter</code>处理并转发，但是我还有一些问题？</p>
<h3 id="为什么不能直接访问-WEB-INF-web-xml触发漏洞？"><a href="#为什么不能直接访问-WEB-INF-web-xml触发漏洞？" class="headerlink" title="为什么不能直接访问;/WEB-INF/web.xml触发漏洞？"></a>为什么不能直接访问<code>;/WEB-INF/web.xml</code>触发漏洞？</h3><p>​    当我直接访问<code>/;/WEB-INF/web.xml</code>则返回404,但在目标通过<code>Forward</code>转发到这个请求却可以读取文件，这是为什么？</p>
<h4 id="直接访问过程"><a href="#直接访问过程" class="headerlink" title="直接访问过程"></a>直接访问过程</h4><p>​    在<code>StandardContextValve</code>中会判断当前的路径是否以<code>/WEB-INF/</code>或<code>/META-INF/</code>开始，如果是则返回<code>404</code>，不会执行后面的请求。那么有同学可能就要问了，我请求的地址明明是<code>/;WEB-INF/</code>,为什么到这里就变成了<code>/WEB-INF/</code>,<strong>是在哪一步对请求的路径做了处理呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardContextValve</span> <span class="keyword">extends</span> <span class="title">ValveBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(StandardContextValve.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StandardContextValve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">        <span class="keyword">if</span> (!requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>) &amp;&amp; !requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>)) &#123;</span><br><span class="line">            Wrapper wrapper = request.getWrapper();</span><br><span class="line">            <span class="keyword">if</span> (wrapper != <span class="keyword">null</span> &amp;&amp; !wrapper.isUnavailable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    response.sendAcknowledgement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.container.getLogger().error(sm.getString(<span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), var6);</span><br><span class="line">                    request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, var6);</span><br><span class="line">                    response.sendError(<span class="number">500</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">                    request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.sendError(<span class="number">404</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在<code>CoyoteAdapter#postParseRequest</code>中，<strong>会对传入的路径进行URL解码和规范化,并判断路径是否为<code>web-inf</code>,所以正常请求无法访问<code>WEB-INF</code>下的内容。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MessageBytes decodedURI = req.decodedURI();</span><br><span class="line">       <span class="keyword">if</span> (undecodedURI.getType() == <span class="number">2</span>) &#123;</span><br><span class="line">           decodedURI.duplicate(undecodedURI);</span><br><span class="line">           <span class="keyword">this</span>.parsePathParameters(req, request);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               req.getURLDecoder().convert(decodedURI, <span class="keyword">false</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException var19) &#123;</span><br><span class="line">               response.sendError(<span class="number">400</span>, <span class="string">&quot;Invalid URI: &quot;</span> + var19.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!normalize(req.decodedURI())) &#123;</span><br><span class="line">               response.sendError(<span class="number">400</span>, <span class="string">&quot;Invalid URI&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.convertURI(decodedURI, request);</span><br><span class="line">           <span class="keyword">if</span> (!checkNormalize(req.decodedURI())) &#123;</span><br><span class="line">               response.sendError(<span class="number">400</span>, <span class="string">&quot;Invalid URI&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           decodedURI.toChars();</span><br><span class="line">           CharChunk uriCC = decodedURI.getCharChunk();</span><br><span class="line">           <span class="keyword">int</span> semicolon = uriCC.indexOf(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">           <span class="keyword">if</span> (semicolon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(), semicolon);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="转发访问过程"><a href="#转发访问过程" class="headerlink" title="转发访问过程"></a>转发访问过程</h4><p>​    上面我们分析了正常请求下无法访问<code>WEB-INF</code>下文件的原因，那么我们再思考一下，为什么转发过去的URL就可以访问<code>web-inf</code>下的内容呢？<strong>首先我们可以猜测一下，是否是因为转发过的请求不会再经过<code>StandardContextValve</code>的处理导致的？</strong></p>
<p>​    答案是肯定的,<code>StandardContextValve</code>只会在我们请求时处理一次，转发的请求不会再经过<code>StandardContextValve</code>的处理，这也是转发请求可以绕过限制访问<code>WEB-INF</code>下的内容的原因。</p>
<h3 id="为什么转发请求会被DefaultServlet处理？"><a href="#为什么转发请求会被DefaultServlet处理？" class="headerlink" title="为什么转发请求会被DefaultServlet处理？"></a>为什么转发请求会被<code>DefaultServlet</code>处理？</h3><p>​    我们分析过转发请求的地址时，转发的地址是<code>/;/WEB-INF/web.xml</code>，而<code>DefaultServlet</code>匹配的地址应该是<code>/</code>,为什么这个请求会被<code>DefaultServlet</code>进行处理？</p>
<p>​    在<code>CachedRewriteMatch#execute</code>中，通过<code>request.getRequestDispatcher(this.rewrittenContextUrl).forward(request, response);</code>完成转发操作，而执行<code>request.getRequestDispatcher(this.rewrittenContextUrl)</code>后<code>wrapper.instance</code>已经被赋值为<code>DefaultServlet</code>。</p>
<p><img src="/2021/10/26/Confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88CVE-2021-26085%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211028133701792.png" alt="image-20211028133701792"></p>
<p>在<code>ApplicationContext#getRequestDispatcher</code>中首先对路径规范化，这个过程会将我们的<code>/;/</code>去掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;applicationContext.requestDispatcher.iae&quot;</span>, <span class="keyword">new</span> Object[]&#123;path&#125;));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = path.indexOf(<span class="number">63</span>);</span><br><span class="line">            String uri;</span><br><span class="line">            String queryString;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                uri = path.substring(<span class="number">0</span>, pos);</span><br><span class="line">                queryString = path.substring(pos + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                uri = path;</span><br><span class="line">                queryString = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//路径规范化</span></span><br><span class="line">            String uriNoParams = stripPathParams(uri);</span><br><span class="line">            String normalizedUri = RequestUtil.normalize(uriNoParams);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">this</span>.service.getMapper().map(<span class="keyword">this</span>.context, uriMB, mappingData);</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>​    在<code>map</code>方法中获取<code>Wrapper</code>保存到<code>mappingData</code>中。在<code>Mapper#internalMapWrapper</code>中将获取<code>Wrapper</code>,首先会根据路径匹配获取<code>Wrapper</code>，如果没有匹配到则默认由<code>DefautlWrapper</code>处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Context context, MessageBytes uri, MappingData mappingData)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">this</span>.internalMapWrapper(contextVersion, uricc, mappingData);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">internalMapWrapper</span><span class="params">(Mapper.ContextVersion contextVersion, CharChunk path, MappingData mappingData)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//如果没匹配到则默认交给DefaultWrapper处理</span></span><br><span class="line">  <span class="keyword">if</span> (mappingData.wrapper == <span class="keyword">null</span> &amp;&amp; !checkJspWelcomeFiles) &#123;</span><br><span class="line">               <span class="keyword">if</span> (contextVersion.defaultWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mappingData.wrapper = (Wrapper)contextVersion.defaultWrapper.object;</span><br><span class="line">                   mappingData.requestPath.setChars(path.getBuffer(), path.getStart(), path.getLength());</span><br><span class="line">                   mappingData.wrapperPath.setChars(path.getBuffer(), path.getStart(), path.getLength());</span><br><span class="line">                   mappingData.matchType = MappingMatch.DEFAULT;</span><br><span class="line">               &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么DefaultServlet会读取web-xml中的内容？"><a href="#为什么DefaultServlet会读取web-xml中的内容？" class="headerlink" title="为什么DefaultServlet会读取web.xml中的内容？"></a>为什么<code>DefaultServlet</code>会读取<code>web.xml</code>中的内容？</h3><p>​    在<code>DefaultServlet#service</code>会根据请求的类型调用不同的方法， 由于我们使用的<code>GET</code>请求，所以会调用<code>doGet</code>处理请求，而<code>doGet</code>又通过<code>serveResource</code>完成具体的处理操作,这里为了能让大家看的比较清晰，我对代码做了很多简化，大致可以看出根据我们传入的路径加载资源，通过<code>copy</code>将读取的内容输出到<code>response</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serveResource</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="keyword">boolean</span> content, String inputEncoding)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">     String path = <span class="keyword">this</span>.getRelativePath(request, <span class="keyword">true</span>);</span><br><span class="line">     WebResource resource = <span class="keyword">this</span>.resources.getResource(path);</span><br><span class="line">     InputStream source = resource.getInputStream();</span><br><span class="line">     ServletOutputStream ostream = <span class="keyword">null</span>;</span><br><span class="line">    ostream = response.getOutputStream();</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(ostream, charset);</span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(osw);</span><br><span class="line">    <span class="keyword">this</span>.copy((InputStream)source, (PrintWriter)pw, (String)inputEncoding);</span><br><span class="line">    pw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​    <strong>修复版本：</strong></p>
<ul>
<li>7.4.10</li>
<li>7.12.3</li>
<li>7.13.0</li>
<li>7.14.0  </li>
</ul>
<p>对比修复版本的补丁，主要在<code>ConfluenceResourceDownloadRewriteRule</code>中，在<code>matches</code>之前，首先循环对URL解码，并将<code>;</code>替换为<code>%3b</code><strong>，那么为什么把<code>;</code> URL编码后可以修复漏洞呢？</strong></p>
<p><img src="/2021/10/26/Confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88CVE-2021-26085%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211028151632760.png" alt="image-20211028151632760"></p>
<p>​    是因为在<code>ApplicationContext#getRequestDispatcher</code>中路径规范化操作在解码操作之前，所以可以正确修复漏洞。</p>
<p><img src="/2021/10/26/Confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%88CVE-2021-26085%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211028152503946.png" alt="image-20211028152503946"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/漏洞分析/">漏洞分析</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>